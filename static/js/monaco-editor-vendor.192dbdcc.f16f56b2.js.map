{"version":3,"file":"static/js/monaco-editor-vendor.192dbdcc.f16f56b2.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","../node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/viewEventHandler.js","../node_modules/monaco-editor/esm/vs/editor/common/viewEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLinesViewportData.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/minimapTokensColorTracker.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/overviewZoneManager.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewContext.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelDecorations.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLayout.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjection.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModelEventDispatcher.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        return {\n            changes: changes,\n            eol: eol,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine) {\n        this.visibleColumn = visibleColumn;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../base/common/lifecycle.js';\nexport class TokenizationRegistry {\n    constructor() {\n        this._map = new Map();\n        this._factories = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._colorMap = null;\n    }\n    fire(languages) {\n        this._onDidChange.fire({\n            changedLanguages: languages,\n            changedColorMap: false\n        });\n    }\n    register(language, support) {\n        this._map.set(language, support);\n        this.fire([language]);\n        return toDisposable(() => {\n            if (this._map.get(language) !== support) {\n                return;\n            }\n            this._map.delete(language);\n            this.fire([language]);\n        });\n    }\n    registerFactory(languageId, factory) {\n        var _a;\n        (_a = this._factories.get(languageId)) === null || _a === void 0 ? void 0 : _a.dispose();\n        const myData = new TokenizationSupportFactoryData(this, languageId, factory);\n        this._factories.set(languageId, myData);\n        return toDisposable(() => {\n            const v = this._factories.get(languageId);\n            if (!v || v !== myData) {\n                return;\n            }\n            this._factories.delete(languageId);\n            v.dispose();\n        });\n    }\n    getOrCreate(languageId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // check first if the support is already set\n            const tokenizationSupport = this.get(languageId);\n            if (tokenizationSupport) {\n                return tokenizationSupport;\n            }\n            const factory = this._factories.get(languageId);\n            if (!factory || factory.isResolved) {\n                // no factory or factory.resolve already finished\n                return null;\n            }\n            yield factory.resolve();\n            return this.get(languageId);\n        });\n    }\n    get(language) {\n        return (this._map.get(language) || null);\n    }\n    isResolved(languageId) {\n        const tokenizationSupport = this.get(languageId);\n        if (tokenizationSupport) {\n            return true;\n        }\n        const factory = this._factories.get(languageId);\n        if (!factory || factory.isResolved) {\n            return true;\n        }\n        return false;\n    }\n    setColorMap(colorMap) {\n        this._colorMap = colorMap;\n        this._onDidChange.fire({\n            changedLanguages: Array.from(this._map.keys()),\n            changedColorMap: true\n        });\n    }\n    getColorMap() {\n        return this._colorMap;\n    }\n    getDefaultBackground() {\n        if (this._colorMap && this._colorMap.length > 2 /* DefaultBackground */) {\n            return this._colorMap[2 /* DefaultBackground */];\n        }\n        return null;\n    }\n}\nclass TokenizationSupportFactoryData extends Disposable {\n    constructor(_registry, _languageId, _factory) {\n        super();\n        this._registry = _registry;\n        this._languageId = _languageId;\n        this._factory = _factory;\n        this._isDisposed = false;\n        this._resolvePromise = null;\n        this._isResolved = false;\n    }\n    get isResolved() {\n        return this._isResolved;\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    resolve() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._resolvePromise) {\n                this._resolvePromise = this._create();\n            }\n            return this._resolvePromise;\n        });\n    }\n    _create() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const value = yield Promise.resolve(this._factory.createTokenizationSupport());\n            this._isResolved = true;\n            if (value && !this._isDisposed) {\n                this._register(this._registry.register(this._languageId, value));\n            }\n        });\n    }\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../languages.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\n        | (0 /* None */ << 10 /* FONT_STYLE_OFFSET */)\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../languages.js';\nexport class LineTokens {\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this._languageIdCodec = decoder;\n    }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this._languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n    }\n}\nLineTokens.defaultTokenMetadata = ((0 /* None */ << 10 /* FONT_STYLE_OFFSET */)\n    | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\n    | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    static create(startLineNumber, tokens) {\n        return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._endLineNumber;\n    }\n    toString() {\n        return this._tokens.toString(this._startLineNumber);\n    }\n    _updateEndLineNumber() {\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    isEmpty() {\n        return this._tokens.isEmpty();\n    }\n    getLineTokens(lineNumber) {\n        if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n            return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n        }\n        return null;\n    }\n    getRange() {\n        const deltaRange = this._tokens.getRange();\n        if (!deltaRange) {\n            return deltaRange;\n        }\n        return new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n    removeTokens(range) {\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        this._updateEndLineNumber();\n    }\n    split(range) {\n        // split tokens to two:\n        // a) all the tokens before `range`\n        // b) all the tokens after `range`\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n    }\n    applyEdit(range, text) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n        this._updateEndLineNumber();\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            // Nothing to delete\n            return;\n        }\n        const firstLineIndex = range.startLineNumber - this._startLineNumber;\n        const lastLineIndex = range.endLineNumber - this._startLineNumber;\n        if (lastLineIndex < 0) {\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\n            this._startLineNumber -= deletedLinesCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion occurs entirely after this block, so there is nothing to do\n            return;\n        }\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion completely encompasses this block\n            this._startLineNumber = 0;\n            this._tokens.clear();\n            return;\n        }\n        if (firstLineIndex < 0) {\n            const deletedBefore = -firstLineIndex;\n            this._startLineNumber -= deletedBefore;\n            this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n        }\n        else {\n            this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n        }\n    }\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - this._startLineNumber;\n        if (lineIndex < 0) {\n            // this insertion occurs before this block, so we only need to adjust line numbers\n            this._startLineNumber += eolCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\n            // this insertion occurs after this block, so there is nothing to do\n            return;\n        }\n        this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n}\nclass SparseMultilineTokensStorage {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._tokenCount = tokens.length / 4;\n    }\n    toString(startLineNumber) {\n        const pieces = [];\n        for (let i = 0; i < this._tokenCount; i++) {\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n        }\n        return `[${pieces.join(',')}]`;\n    }\n    getMaxDeltaLine() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return -1;\n        }\n        return this._getDeltaLine(tokenCount - 1);\n    }\n    getRange() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return null;\n        }\n        const startChar = this._getStartCharacter(0);\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n        const endChar = this._getEndCharacter(tokenCount - 1);\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n    _getTokenCount() {\n        return this._tokenCount;\n    }\n    _getDeltaLine(tokenIndex) {\n        return this._tokens[4 * tokenIndex];\n    }\n    _getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    _getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    isEmpty() {\n        return (this._getTokenCount() === 0);\n    }\n    getLineTokens(deltaLine) {\n        let low = 0;\n        let high = this._getTokenCount() - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const midDeltaLine = this._getDeltaLine(mid);\n            if (midDeltaLine < deltaLine) {\n                low = mid + 1;\n            }\n            else if (midDeltaLine > deltaLine) {\n                high = mid - 1;\n            }\n            else {\n                let min = mid;\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n                    min--;\n                }\n                let max = mid;\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n                    max++;\n                }\n                return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n            }\n        }\n        if (this._getDeltaLine(low) === deltaLine) {\n            return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n        }\n        return null;\n    }\n    clear() {\n        this._tokenCount = 0;\n    }\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        let firstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                hasDeletedTokens = true;\n            }\n            else {\n                if (newTokenCount === 0) {\n                    firstDeltaLine = tokenDeltaLine;\n                }\n                if (hasDeletedTokens) {\n                    // must move the token to the left\n                    const destOffset = 4 * newTokenCount;\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n                    tokens[destOffset + 1] = tokenStartCharacter;\n                    tokens[destOffset + 2] = tokenEndCharacter;\n                    tokens[destOffset + 3] = tokenMetadata;\n                }\n                newTokenCount++;\n            }\n        }\n        this._tokenCount = newTokenCount;\n        return firstDeltaLine;\n    }\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const aTokens = [];\n        const bTokens = [];\n        let destTokens = aTokens;\n        let destOffset = 0;\n        let destFirstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                    // this token is touching the range\n                    continue;\n                }\n                else {\n                    // this token is after the range\n                    if (destTokens !== bTokens) {\n                        // this token is the first token after the range\n                        destTokens = bTokens;\n                        destOffset = 0;\n                        destFirstDeltaLine = tokenDeltaLine;\n                    }\n                }\n            }\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n            destTokens[destOffset++] = tokenStartCharacter;\n            destTokens[destOffset++] = tokenEndCharacter;\n            destTokens[destOffset++] = tokenMetadata;\n        }\n        return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n        // This is a bit complex, here are the cases I used to think about this:\n        //\n        // 1. The token starts before the deletion range\n        // 1a. The token is completely before the deletion range\n        //               -----------\n        //                          xxxxxxxxxxx\n        // 1b. The token starts before, the deletion range ends after the token\n        //               -----------\n        //                      xxxxxxxxxxx\n        // 1c. The token starts before, the deletion range ends precisely with the token\n        //               ---------------\n        //                      xxxxxxxx\n        // 1d. The token starts before, the deletion range is inside the token\n        //               ---------------\n        //                    xxxxx\n        //\n        // 2. The token starts at the same position with the deletion range\n        // 2a. The token starts at the same position, and ends inside the deletion range\n        //               -------\n        //               xxxxxxxxxxx\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\n        //               ----------\n        //               xxxxxxxxxx\n        // 2c. The token starts at the same position, and ends after the deletion range\n        //               -------------\n        //               xxxxxxx\n        //\n        // 3. The token starts inside the deletion range\n        // 3a. The token is inside the deletion range\n        //                -------\n        //             xxxxxxxxxxxxx\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n        //                ----------\n        //             xxxxxxxxxxxxx\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\n        //                ------------\n        //             xxxxxxxxxxx\n        //\n        // 4. The token starts after the deletion range\n        //                  -----------\n        //          xxxxxxxx\n        //\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            let tokenDeltaLine = tokens[srcOffset];\n            let tokenStartCharacter = tokens[srcOffset + 1];\n            let tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n                // 1a. The token is completely before the deletion range\n                // => nothing to do\n                newTokenCount++;\n                continue;\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n                // 1b, 1c, 1d\n                // => the token survives, but it needs to shrink\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 1d. The token starts before, the deletion range is inside the token\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 1b. The token starts before, the deletion range ends after the token\n                    // 1c. The token starts before, the deletion range ends precisely with the token\n                    // => the token shrinks its ending to the deletion start\n                    tokenEndCharacter = startCharacter;\n                }\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n                // 2a, 2b, 2c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 2c. The token starts at the same position, and ends after the deletion range\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 2a. The token starts at the same position, and ends inside the deletion range\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n                // 3a, 3b, 3c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\n                    // => the token moves left and shrinks\n                    if (tokenDeltaLine === startDeltaLine) {\n                        // the deletion started on the same line as the token\n                        // => the token moves left and shrinks\n                        tokenStartCharacter = startCharacter;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                    else {\n                        // the deletion started on a line above the token\n                        // => the token moves to the beginning of the line\n                        tokenStartCharacter = 0;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                }\n                else {\n                    // 3a. The token is inside the deletion range\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine > endDeltaLine) {\n                // 4. (partial) The token starts after the deletion range, on a line below...\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\n                    // early stop, there is no need to walk all the tokens and do nothing...\n                    newTokenCount = tokenCount;\n                    break;\n                }\n                tokenDeltaLine -= deletedLineCount;\n            }\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\n                }\n                tokenDeltaLine -= deletedLineCount;\n                tokenStartCharacter -= (endCharacter - startCharacter);\n                tokenEndCharacter -= (endCharacter - startCharacter);\n            }\n            else {\n                throw new Error(`Not possible!`);\n            }\n            const destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n            newTokenCount++;\n        }\n        this._tokenCount = newTokenCount;\n    }\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        // Here are the cases I used to think about this:\n        //\n        // 1. The token is completely before the insertion point\n        //            -----------   |\n        // 2. The token ends precisely at the insertion point\n        //            -----------|\n        // 3. The token contains the insertion point\n        //            -----|------\n        // 4. The token starts precisely at the insertion point\n        //            |-----------\n        // 5. The token is completely after the insertion point\n        //            |   -----------\n        //\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\n            && firstLineLength === 1\n            && ((firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */)\n                || (firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */)\n                || (firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */)));\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        for (let i = 0; i < tokenCount; i++) {\n            const offset = 4 * i;\n            let tokenDeltaLine = tokens[offset];\n            let tokenStartCharacter = tokens[offset + 1];\n            let tokenEndCharacter = tokens[offset + 2];\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n                // 1. The token is completely before the insertion point\n                // => nothing to do\n                continue;\n            }\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n                // 2. The token ends precisely at the insertion point\n                // => expand the end character only if inserting precisely one character that is a word character\n                if (isInsertingPreciselyOneWordCharacter) {\n                    tokenEndCharacter += 1;\n                }\n                else {\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n                // 3. The token contains the insertion point\n                if (eolCount === 0) {\n                    // => just expand the end character\n                    tokenEndCharacter += firstLineLength;\n                }\n                else {\n                    // => cut off the token\n                    tokenEndCharacter = character;\n                }\n            }\n            else {\n                // 4. or 5.\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n                    // 4. The token starts precisely at the insertion point\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n                    // => otherwise behave as in case 5.\n                    if (isInsertingPreciselyOneWordCharacter) {\n                        continue;\n                    }\n                }\n                // => the token must move and keep its size constant\n                if (tokenDeltaLine === deltaLine) {\n                    tokenDeltaLine += eolCount;\n                    // this token is on the line where the insertion is taking place\n                    if (eolCount === 0) {\n                        tokenStartCharacter += firstLineLength;\n                        tokenEndCharacter += firstLineLength;\n                    }\n                    else {\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\n                    }\n                }\n                else {\n                    tokenDeltaLine += eolCount;\n                }\n            }\n            tokens[offset] = tokenDeltaLine;\n            tokens[offset + 1] = tokenStartCharacter;\n            tokens[offset + 2] = tokenEndCharacter;\n        }\n    }\n}\nexport class SparseLineTokens {\n    constructor(tokens) {\n        this._tokens = tokens;\n    }\n    getCount() {\n        return this._tokens.length / 4;\n    }\n    getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    getMetadata(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 3];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* SEMANTIC_USE_ITALIC */) ? 1024 /* ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* SEMANTIC_USE_BOLD */) ? 2048 /* BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */) ? 4096 /* UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* SEMANTIC_USE_STRIKETHROUGH */) ? 8192 /* STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* SEMANTIC_USE_FOREGROUND */) ? 8372224 /* FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* SEMANTIC_USE_BACKGROUND */) ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../base/common/lifecycle.js';\nexport class ViewEventHandler extends Disposable {\n    constructor() {\n        super();\n        this._shouldRender = true;\n    }\n    shouldRender() {\n        return this._shouldRender;\n    }\n    forceShouldRender() {\n        this._shouldRender = true;\n    }\n    setShouldRender() {\n        this._shouldRender = true;\n    }\n    onDidRender() {\n        this._shouldRender = false;\n    }\n    // --- begin event handlers\n    onCompositionStart(e) {\n        return false;\n    }\n    onCompositionEnd(e) {\n        return false;\n    }\n    onConfigurationChanged(e) {\n        return false;\n    }\n    onCursorStateChanged(e) {\n        return false;\n    }\n    onDecorationsChanged(e) {\n        return false;\n    }\n    onFlushed(e) {\n        return false;\n    }\n    onFocusChanged(e) {\n        return false;\n    }\n    onLanguageConfigurationChanged(e) {\n        return false;\n    }\n    onLineMappingChanged(e) {\n        return false;\n    }\n    onLinesChanged(e) {\n        return false;\n    }\n    onLinesDeleted(e) {\n        return false;\n    }\n    onLinesInserted(e) {\n        return false;\n    }\n    onRevealRangeRequest(e) {\n        return false;\n    }\n    onScrollChanged(e) {\n        return false;\n    }\n    onThemeChanged(e) {\n        return false;\n    }\n    onTokensChanged(e) {\n        return false;\n    }\n    onTokensColorsChanged(e) {\n        return false;\n    }\n    onZonesChanged(e) {\n        return false;\n    }\n    // --- end event handlers\n    handleEvents(events) {\n        let shouldRender = false;\n        for (let i = 0, len = events.length; i < len; i++) {\n            const e = events[i];\n            switch (e.type) {\n                case 0 /* ViewCompositionStart */:\n                    if (this.onCompositionStart(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 1 /* ViewCompositionEnd */:\n                    if (this.onCompositionEnd(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 2 /* ViewConfigurationChanged */:\n                    if (this.onConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 3 /* ViewCursorStateChanged */:\n                    if (this.onCursorStateChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 4 /* ViewDecorationsChanged */:\n                    if (this.onDecorationsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 5 /* ViewFlushed */:\n                    if (this.onFlushed(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 6 /* ViewFocusChanged */:\n                    if (this.onFocusChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 7 /* ViewLanguageConfigurationChanged */:\n                    if (this.onLanguageConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 8 /* ViewLineMappingChanged */:\n                    if (this.onLineMappingChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 9 /* ViewLinesChanged */:\n                    if (this.onLinesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 10 /* ViewLinesDeleted */:\n                    if (this.onLinesDeleted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 11 /* ViewLinesInserted */:\n                    if (this.onLinesInserted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 12 /* ViewRevealRangeRequest */:\n                    if (this.onRevealRangeRequest(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 13 /* ViewScrollChanged */:\n                    if (this.onScrollChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 15 /* ViewTokensChanged */:\n                    if (this.onTokensChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 14 /* ViewThemeChanged */:\n                    if (this.onThemeChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 16 /* ViewTokensColorsChanged */:\n                    if (this.onTokensColorsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 17 /* ViewZonesChanged */:\n                    if (this.onZonesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                default:\n                    console.info('View received unknown event: ');\n                    console.info(e);\n            }\n        }\n        if (shouldRender) {\n            this._shouldRender = true;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ViewCompositionStartEvent {\n    constructor() {\n        this.type = 0 /* ViewCompositionStart */;\n    }\n}\nexport class ViewCompositionEndEvent {\n    constructor() {\n        this.type = 1 /* ViewCompositionEnd */;\n    }\n}\nexport class ViewConfigurationChangedEvent {\n    constructor(source) {\n        this.type = 2 /* ViewConfigurationChanged */;\n        this._source = source;\n    }\n    hasChanged(id) {\n        return this._source.hasChanged(id);\n    }\n}\nexport class ViewCursorStateChangedEvent {\n    constructor(selections, modelSelections) {\n        this.type = 3 /* ViewCursorStateChanged */;\n        this.selections = selections;\n        this.modelSelections = modelSelections;\n    }\n}\nexport class ViewDecorationsChangedEvent {\n    constructor(source) {\n        this.type = 4 /* ViewDecorationsChanged */;\n        if (source) {\n            this.affectsMinimap = source.affectsMinimap;\n            this.affectsOverviewRuler = source.affectsOverviewRuler;\n        }\n        else {\n            this.affectsMinimap = true;\n            this.affectsOverviewRuler = true;\n        }\n    }\n}\nexport class ViewFlushedEvent {\n    constructor() {\n        this.type = 5 /* ViewFlushed */;\n        // Nothing to do\n    }\n}\nexport class ViewFocusChangedEvent {\n    constructor(isFocused) {\n        this.type = 6 /* ViewFocusChanged */;\n        this.isFocused = isFocused;\n    }\n}\nexport class ViewLanguageConfigurationEvent {\n    constructor() {\n        this.type = 7 /* ViewLanguageConfigurationChanged */;\n    }\n}\nexport class ViewLineMappingChangedEvent {\n    constructor() {\n        this.type = 8 /* ViewLineMappingChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewLinesChangedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 9 /* ViewLinesChanged */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewLinesDeletedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 10 /* ViewLinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewLinesInsertedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 11 /* ViewLinesInserted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewRevealRangeRequestEvent {\n    constructor(\n    /**\n     * Source of the call that caused the event.\n     */\n    source, \n    /**\n     * Reduce the revealing to a minimum (e.g. avoid scrolling if the bounding box is visible and near the viewport edge).\n     */\n    minimalReveal, \n    /**\n     * Range to be reavealed.\n     */\n    range, \n    /**\n     * Selections to be revealed.\n     */\n    selections, \n    /**\n     * The vertical reveal strategy.\n     */\n    verticalType, \n    /**\n     * If true: there should be a horizontal & vertical revealing.\n     * If false: there should be just a vertical revealing.\n     */\n    revealHorizontal, \n    /**\n     * The scroll type.\n     */\n    scrollType) {\n        this.source = source;\n        this.minimalReveal = minimalReveal;\n        this.range = range;\n        this.selections = selections;\n        this.verticalType = verticalType;\n        this.revealHorizontal = revealHorizontal;\n        this.scrollType = scrollType;\n        this.type = 12 /* ViewRevealRangeRequest */;\n    }\n}\nexport class ViewScrollChangedEvent {\n    constructor(source) {\n        this.type = 13 /* ViewScrollChanged */;\n        this.scrollWidth = source.scrollWidth;\n        this.scrollLeft = source.scrollLeft;\n        this.scrollHeight = source.scrollHeight;\n        this.scrollTop = source.scrollTop;\n        this.scrollWidthChanged = source.scrollWidthChanged;\n        this.scrollLeftChanged = source.scrollLeftChanged;\n        this.scrollHeightChanged = source.scrollHeightChanged;\n        this.scrollTopChanged = source.scrollTopChanged;\n    }\n}\nexport class ViewThemeChangedEvent {\n    constructor(theme) {\n        this.theme = theme;\n        this.type = 14 /* ViewThemeChanged */;\n    }\n}\nexport class ViewTokensChangedEvent {\n    constructor(ranges) {\n        this.type = 15 /* ViewTokensChanged */;\n        this.ranges = ranges;\n    }\n}\nexport class ViewTokensColorsChangedEvent {\n    constructor() {\n        this.type = 16 /* ViewTokensColorsChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.type = 17 /* ViewZonesChanged */;\n        // Nothing to do\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n    constructor(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n        this._lineDecorationBrand = undefined;\n    }\n    static _equals(a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    }\n    static equalsArr(a, b) {\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static extractWrapped(arr, startOffset, endOffset) {\n        if (arr.length === 0) {\n            return arr;\n        }\n        const startColumn = startOffset + 1;\n        const endColumn = endOffset + 1;\n        const lineLength = endOffset - startOffset;\n        const r = [];\n        let rLength = 0;\n        for (const dec of arr) {\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n                continue;\n            }\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n        return r;\n    }\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            const range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === 0 /* Regular */ || d.type === 3 /* RegularAffectingLetterSpacing */)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    }\n    static _typeCompare(a, b) {\n        const ORDER = [2, 0, 1, 3];\n        return ORDER[a] - ORDER[b];\n    }\n    static compare(a, b) {\n        if (a.startColumn !== b.startColumn) {\n            return a.startColumn - b.startColumn;\n        }\n        if (a.endColumn !== b.endColumn) {\n            return a.endColumn - b.endColumn;\n        }\n        const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n        if (typeCmp !== 0) {\n            return typeCmp;\n        }\n        if (a.className !== b.className) {\n            return a.className < b.className ? -1 : 1;\n        }\n        return 0;\n    }\n}\nexport class DecorationSegment {\n    constructor(startOffset, endOffset, className, metadata) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n        this.metadata = metadata;\n    }\n}\nclass Stack {\n    constructor() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.metadata = [];\n        this.count = 0;\n    }\n    static _metadata(metadata) {\n        let result = 0;\n        for (let i = 0, len = metadata.length; i < len; i++) {\n            result |= metadata[i];\n        }\n        return result;\n    }\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            let i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.metadata.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    }\n    insert(stopOffset, className, metadata) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n            this.metadata.push(metadata);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (let i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    this.metadata.splice(i, 0, metadata);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    }\n}\nexport class LineDecorationsNormalizer {\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    static normalize(lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        const stack = new Stack();\n        let nextStartOffset = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            let startColumn = d.startColumn;\n            let endColumn = d.endColumn;\n            const className = d.className;\n            const metadata = (d.type === 1 /* Before */\n                ? 2 /* PSEUDO_BEFORE */\n                : d.type === 2 /* After */\n                    ? 4 /* PSEUDO_AFTER */\n                    : 0);\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            const currentStartOffset = startColumn - 1;\n            const currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className, metadata);\n        }\n        stack.consumeLowerThan(1073741824 /* MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nclass LinePart {\n    constructor(endIndex, type, metadata) {\n        this._linePartBrand = undefined;\n        this.endIndex = endIndex;\n        this.type = type;\n        this.metadata = metadata;\n    }\n    isWhitespace() {\n        return (this.metadata & 1 /* IS_WHITESPACE_MASK */ ? true : false);\n    }\n    isPseudoAfter() {\n        return (this.metadata & 4 /* PSEUDO_AFTER_MASK */ ? true : false);\n    }\n}\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* Trailing */\n                        : 0 /* None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\nexport class DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._absoluteOffsets = new Uint32Array(this.length);\n    }\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;\n    }\n    setColumnInfo(column, partIndex, charIndex, partAbsoluteOffset) {\n        const partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._absoluteOffsets[column - 1] = partAbsoluteOffset + charIndex;\n    }\n    getAbsoluteOffset(column) {\n        if (this._absoluteOffsets.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._absoluteOffsets[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendASCIIString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* Before */ || lineDecoration.type === 2 /* After */) {\n                    sb.appendASCIIString(`<span class=\"`);\n                    sb.appendASCIIString(lineDecoration.className);\n                    sb.appendASCIIString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* Before */) {\n                        containsForeignElements |= 1 /* Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* After */) {\n                        containsForeignElements |= 2 /* After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendASCIIString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendASCIIString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    const sb = createStringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* All */ ||\n        input.renderWhitespace === 1 /* Boundary */ ||\n        (input.renderWhitespace === 2 /* Selection */ && !!input.selectionsOnLine) ||\n        input.renderWhitespace === 3 /* Trailing */) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* Before */;\n            }\n            else if (lineDecoration.type === 1 /* Before */) {\n                containsForeignElements |= 1 /* Before */;\n            }\n            else if (lineDecoration.type === 2 /* After */) {\n                containsForeignElements |= 2 /* After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0);\n    }\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            result[resultLen++] = new LinePart(len, type, 0);\n            break;\n        }\n        result[resultLen++] = new LinePart(endIndex, type, 0);\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const piecesCount = Math.ceil(diff / 50 /* LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\n                    isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* IS_WHITESPACE */);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* Space */ && (prevCharCode !== 32 /* Space */ && prevCharCode !== 9 /* Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* IS_WHITESPACE */);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0;\n    let partDisplacement = 0;\n    let prevPartContentCnt = 0;\n    let partAbsoluteOffset = 0;\n    if (containsRTL) {\n        sb.appendASCIIString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendASCIIString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        partAbsoluteOffset += prevPartContentCnt;\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendASCIIString('<span class=\"');\n        sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCII(34 /* DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partContentCnt = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partContentCnt += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendASCIIString(' style=\"width:');\n                sb.appendASCIIString(String(spaceWidth * partContentCnt));\n                sb.appendASCIIString('px\"');\n            }\n            sb.appendASCII(62 /* GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let charWidth;\n                if (charCode === 9 /* Tab */) {\n                    charWidth = (tabSize - (visibleColumn % tabSize)) | 0;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.write1(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.write1(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    charWidth = 1;\n                    sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\n                }\n                charOffsetInPart += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n            prevPartContentCnt = partContentCnt;\n        }\n        else {\n            let partContentCnt = 0;\n            sb.appendASCII(62 /* GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.write1(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* Space */:\n                        sb.write1(0xA0); // &nbsp;\n                        break;\n                    case 60 /* LessThan */:\n                        sb.appendASCIIString('&lt;');\n                        break;\n                    case 62 /* GreaterThan */:\n                        sb.appendASCIIString('&gt;');\n                        break;\n                    case 38 /* Ampersand */:\n                        sb.appendASCIIString('&amp;');\n                        break;\n                    case 0 /* Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.write1(9216);\n                        }\n                        else {\n                            sb.appendASCIIString('&#00;');\n                        }\n                        break;\n                    case 65279 /* UTF8_BOM */:\n                    case 8232 /* LINE_SEPARATOR */:\n                    case 8233 /* PARAGRAPH_SEPARATOR */:\n                    case 133 /* NEXT_LINE */:\n                        sb.write1(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.write1(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.write1(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendASCIIString('[U+');\n                            sb.appendASCIIString(to4CharHex(charCode));\n                            sb.appendASCIIString(']');\n                            producedCharacters = 8;\n                        }\n                        else {\n                            sb.write1(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                partContentCnt += producedCharacters;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n            prevPartContentCnt = partContentCnt;\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, partAbsoluteOffset);\n        }\n        sb.appendASCIIString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n    }\n    if (isOverflowing) {\n        sb.appendASCIIString('<span>&hellip;</span>');\n    }\n    sb.appendASCIIString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\n/**\n * Contains all data needed to render at a specific viewport.\n */\nexport class ViewportData {\n    constructor(selections, partialData, whitespaceViewportData, model) {\n        this.selections = selections;\n        this.startLineNumber = partialData.startLineNumber | 0;\n        this.endLineNumber = partialData.endLineNumber | 0;\n        this.relativeVerticalOffset = partialData.relativeVerticalOffset;\n        this.bigNumbersDelta = partialData.bigNumbersDelta | 0;\n        this.whitespaceViewportData = whitespaceViewportData;\n        this._model = model;\n        this.visibleRange = new Range(partialData.startLineNumber, this._model.getLineMinColumn(partialData.startLineNumber), partialData.endLineNumber, this._model.getLineMaxColumn(partialData.endLineNumber));\n    }\n    getViewLineRenderingData(lineNumber) {\n        return this._model.getViewLineRenderingData(this.visibleRange, lineNumber);\n    }\n    getDecorationsInViewport() {\n        return this._model.getDecorationsInViewport(this.visibleRange);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../base/common/strings.js';\nimport { Range } from './core/range.js';\nexport class Viewport {\n    constructor(top, left, width, height) {\n        this._viewportBrand = undefined;\n        this.top = top | 0;\n        this.left = left | 0;\n        this.width = width | 0;\n        this.height = height | 0;\n    }\n}\nexport class MinimapLinesRenderingData {\n    constructor(tabSize, data) {\n        this.tabSize = tabSize;\n        this.data = data;\n    }\n}\nexport class ViewLineData {\n    constructor(content, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations) {\n        this._viewLineDataBrand = undefined;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.startVisibleColumn = startVisibleColumn;\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n    }\n}\nexport class ViewLineRenderingData {\n    constructor(minColumn, maxColumn, content, continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize, startVisibleColumn) {\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n        this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n    }\n    static isBasicASCII(lineContent, mightContainNonBasicASCII) {\n        if (mightContainNonBasicASCII) {\n            return strings.isBasicASCII(lineContent);\n        }\n        return true;\n    }\n    static containsRTL(lineContent, isBasicASCII, mightContainRTL) {\n        if (!isBasicASCII && mightContainRTL) {\n            return strings.containsRTL(lineContent);\n        }\n        return false;\n    }\n}\nexport class InlineDecoration {\n    constructor(range, inlineClassName, type) {\n        this.range = range;\n        this.inlineClassName = inlineClassName;\n        this.type = type;\n    }\n}\nexport class SingleLineInlineDecoration {\n    constructor(startOffset, endOffset, inlineClassName, inlineClassNameAffectsLetterSpacing) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.inlineClassName = inlineClassName;\n        this.inlineClassNameAffectsLetterSpacing = inlineClassNameAffectsLetterSpacing;\n    }\n    toInlineDecoration(lineNumber) {\n        return new InlineDecoration(new Range(lineNumber, this.startOffset + 1, lineNumber, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3 /* RegularAffectingLetterSpacing */ : 0 /* Regular */);\n    }\n}\nexport class ViewModelDecoration {\n    constructor(range, options) {\n        this._viewModelDecorationBrand = undefined;\n        this.range = range;\n        this.options = options;\n    }\n}\nexport class OverviewRulerDecorationsGroup {\n    constructor(color, zIndex, \n    /**\n     * Decorations are encoded in a number array using the following scheme:\n     *  - 3*i = lane\n     *  - 3*i+1 = startLineNumber\n     *  - 3*i+2 = endLineNumber\n     */\n    data) {\n        this.color = color;\n        this.zIndex = zIndex;\n        this.data = data;\n    }\n    static cmp(a, b) {\n        if (a.zIndex === b.zIndex) {\n            if (a.color < b.color) {\n                return -1;\n            }\n            if (a.color > b.color) {\n                return 1;\n            }\n            return 0;\n        }\n        return a.zIndex - b.zIndex;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, markAsSingleton } from '../../../base/common/lifecycle.js';\nimport { RGBA8 } from '../core/rgba.js';\nimport { TokenizationRegistry } from '../languages.js';\nexport class MinimapTokensColorTracker extends Disposable {\n    constructor() {\n        super();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._updateColorMap();\n        this._register(TokenizationRegistry.onDidChange(e => {\n            if (e.changedColorMap) {\n                this._updateColorMap();\n            }\n        }));\n    }\n    static getInstance() {\n        if (!this._INSTANCE) {\n            this._INSTANCE = markAsSingleton(new MinimapTokensColorTracker());\n        }\n        return this._INSTANCE;\n    }\n    _updateColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        if (!colorMap) {\n            this._colors = [RGBA8.Empty];\n            this._backgroundIsLight = true;\n            return;\n        }\n        this._colors = [RGBA8.Empty];\n        for (let colorId = 1; colorId < colorMap.length; colorId++) {\n            const source = colorMap[colorId].rgba;\n            // Use a VM friendly data-type\n            this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));\n        }\n        const backgroundLuminosity = colorMap[2 /* DefaultBackground */].getRelativeLuminance();\n        this._backgroundIsLight = backgroundLuminosity >= 0.5;\n        this._onDidChange.fire(undefined);\n    }\n    getColor(colorId) {\n        if (colorId < 1 || colorId >= this._colors.length) {\n            // background color (basically invisible)\n            colorId = 2 /* DefaultBackground */;\n        }\n        return this._colors[colorId];\n    }\n    backgroundIsLight() {\n        return this._backgroundIsLight;\n    }\n}\nMinimapTokensColorTracker._INSTANCE = null;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from '../modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(120 /* wordWrapBreakBeforeCharacters */), options.get(119 /* wordWrapBreakAfterCharacters */));\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n        const requests = [];\n        const injectedTexts = [];\n        const previousBreakingData = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n                const result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const injectedText = injectedTexts[i];\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = arrPool1;\n    const breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n    let injectionOptions;\n    let injectionOffsets;\n    if (injectedTexts && injectedTexts.length > 0) {\n        injectionOptions = injectedTexts.map(t => t.options);\n        injectionOffsets = injectedTexts.map(text => text.column - 1);\n    }\n    else {\n        injectionOptions = null;\n        injectionOffsets = null;\n    }\n    if (firstLineBreakColumn === -1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = [];\n    const breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\n    return (charCode !== 32 /* Space */\n        && ((prevCharCodeClass === 2 /* BREAK_AFTER */)\n            || (prevCharCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* BREAK_AFTER */)\n            || (charCodeClass === 1 /* BREAK_BEFORE */)\n            || (charCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* DeepIndent */ ? 2 : wrappingIndent === 2 /* Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ColorZone {\n    constructor(from, to, colorId) {\n        this._colorZoneBrand = undefined;\n        this.from = from | 0;\n        this.to = to | 0;\n        this.colorId = colorId | 0;\n    }\n    static compare(a, b) {\n        if (a.colorId === b.colorId) {\n            if (a.from === b.from) {\n                return a.to - b.to;\n            }\n            return a.from - b.from;\n        }\n        return a.colorId - b.colorId;\n    }\n}\n/**\n * A zone in the overview ruler\n */\nexport class OverviewRulerZone {\n    constructor(startLineNumber, endLineNumber, heightInLines, color) {\n        this._overviewRulerZoneBrand = undefined;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n        this.heightInLines = heightInLines;\n        this.color = color;\n        this._colorZone = null;\n    }\n    static compare(a, b) {\n        if (a.color === b.color) {\n            if (a.startLineNumber === b.startLineNumber) {\n                if (a.heightInLines === b.heightInLines) {\n                    return a.endLineNumber - b.endLineNumber;\n                }\n                return a.heightInLines - b.heightInLines;\n            }\n            return a.startLineNumber - b.startLineNumber;\n        }\n        return a.color < b.color ? -1 : 1;\n    }\n    setColorZone(colorZone) {\n        this._colorZone = colorZone;\n    }\n    getColorZones() {\n        return this._colorZone;\n    }\n}\nexport class OverviewZoneManager {\n    constructor(getVerticalOffsetForLine) {\n        this._getVerticalOffsetForLine = getVerticalOffsetForLine;\n        this._zones = [];\n        this._colorZonesInvalid = false;\n        this._lineHeight = 0;\n        this._domWidth = 0;\n        this._domHeight = 0;\n        this._outerHeight = 0;\n        this._pixelRatio = 1;\n        this._lastAssignedId = 0;\n        this._color2Id = Object.create(null);\n        this._id2Color = [];\n    }\n    getId2Color() {\n        return this._id2Color;\n    }\n    setZones(newZones) {\n        this._zones = newZones;\n        this._zones.sort(OverviewRulerZone.compare);\n    }\n    setLineHeight(lineHeight) {\n        if (this._lineHeight === lineHeight) {\n            return false;\n        }\n        this._lineHeight = lineHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    setPixelRatio(pixelRatio) {\n        this._pixelRatio = pixelRatio;\n        this._colorZonesInvalid = true;\n    }\n    getDOMWidth() {\n        return this._domWidth;\n    }\n    getCanvasWidth() {\n        return this._domWidth * this._pixelRatio;\n    }\n    setDOMWidth(width) {\n        if (this._domWidth === width) {\n            return false;\n        }\n        this._domWidth = width;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getDOMHeight() {\n        return this._domHeight;\n    }\n    getCanvasHeight() {\n        return this._domHeight * this._pixelRatio;\n    }\n    setDOMHeight(height) {\n        if (this._domHeight === height) {\n            return false;\n        }\n        this._domHeight = height;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getOuterHeight() {\n        return this._outerHeight;\n    }\n    setOuterHeight(outerHeight) {\n        if (this._outerHeight === outerHeight) {\n            return false;\n        }\n        this._outerHeight = outerHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    resolveColorZones() {\n        const colorZonesInvalid = this._colorZonesInvalid;\n        const lineHeight = Math.floor(this._lineHeight);\n        const totalHeight = Math.floor(this.getCanvasHeight());\n        const outerHeight = Math.floor(this._outerHeight);\n        const heightRatio = totalHeight / outerHeight;\n        const halfMinimumHeight = Math.floor(4 /* MINIMUM_HEIGHT */ * this._pixelRatio / 2);\n        const allColorZones = [];\n        for (let i = 0, len = this._zones.length; i < len; i++) {\n            const zone = this._zones[i];\n            if (!colorZonesInvalid) {\n                const colorZone = zone.getColorZones();\n                if (colorZone) {\n                    allColorZones.push(colorZone);\n                    continue;\n                }\n            }\n            const offset1 = this._getVerticalOffsetForLine(zone.startLineNumber);\n            const offset2 = (zone.heightInLines === 0\n                ? this._getVerticalOffsetForLine(zone.endLineNumber) + lineHeight\n                : offset1 + zone.heightInLines * lineHeight);\n            const y1 = Math.floor(heightRatio * offset1);\n            const y2 = Math.floor(heightRatio * offset2);\n            let ycenter = Math.floor((y1 + y2) / 2);\n            let halfHeight = (y2 - ycenter);\n            if (halfHeight < halfMinimumHeight) {\n                halfHeight = halfMinimumHeight;\n            }\n            if (ycenter - halfHeight < 0) {\n                ycenter = halfHeight;\n            }\n            if (ycenter + halfHeight > totalHeight) {\n                ycenter = totalHeight - halfHeight;\n            }\n            const color = zone.color;\n            let colorId = this._color2Id[color];\n            if (!colorId) {\n                colorId = (++this._lastAssignedId);\n                this._color2Id[color] = colorId;\n                this._id2Color[colorId] = color;\n            }\n            const colorZone = new ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId);\n            zone.setColorZone(colorZone);\n            allColorZones.push(colorZone);\n        }\n        this._colorZonesInvalid = false;\n        allColorZones.sort(ColorZone.compare);\n        return allColorZones;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorTheme } from '../editorTheme.js';\nexport class ViewContext {\n    constructor(configuration, theme, model) {\n        this.configuration = configuration;\n        this.theme = new EditorTheme(theme);\n        this.viewModel = model;\n        this.viewLayout = model.viewLayout;\n    }\n    addEventHandler(eventHandler) {\n        this.viewModel.addViewEventHandler(eventHandler);\n    }\n    removeEventHandler(eventHandler) {\n        this.viewModel.removeViewEventHandler(eventHandler);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { InlineDecoration, ViewModelDecoration } from '../viewModel.js';\nimport { filterValidationDecorations } from '../config/editorOptions.js';\nexport class ViewModelDecorations {\n    constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n        this.editorId = editorId;\n        this.model = model;\n        this.configuration = configuration;\n        this._linesCollection = linesCollection;\n        this._coordinatesConverter = coordinatesConverter;\n        this._decorationsCache = Object.create(null);\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    _clearCachedModelDecorationsResolver() {\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    dispose() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    reset() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onModelDecorationsChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onLineMappingChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    _getOrCreateViewModelDecoration(modelDecoration) {\n        const id = modelDecoration.id;\n        let r = this._decorationsCache[id];\n        if (!r) {\n            const modelRange = modelDecoration.range;\n            const options = modelDecoration.options;\n            let viewRange;\n            if (options.isWholeLine) {\n                const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1), 0 /* Left */);\n                const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)), 1 /* Right */);\n                viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n            }\n            else {\n                // For backwards compatibility reasons, we want injected text before any decoration.\n                // Thus, move decorations to the right.\n                viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange, 1 /* Right */);\n            }\n            r = new ViewModelDecoration(viewRange, options);\n            this._decorationsCache[id] = r;\n        }\n        return r;\n    }\n    getDecorationsViewportData(viewRange) {\n        let cacheIsValid = (this._cachedModelDecorationsResolver !== null);\n        cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));\n        if (!cacheIsValid) {\n            this._cachedModelDecorationsResolver = this._getDecorationsViewportData(viewRange);\n            this._cachedModelDecorationsResolverViewRange = viewRange;\n        }\n        return this._cachedModelDecorationsResolver;\n    }\n    _getDecorationsViewportData(viewportRange) {\n        const modelDecorations = this._linesCollection.getDecorationsInRange(viewportRange, this.editorId, filterValidationDecorations(this.configuration.options));\n        const startLineNumber = viewportRange.startLineNumber;\n        const endLineNumber = viewportRange.endLineNumber;\n        const decorationsInViewport = [];\n        let decorationsInViewportLen = 0;\n        const inlineDecorations = [];\n        for (let j = startLineNumber; j <= endLineNumber; j++) {\n            inlineDecorations[j - startLineNumber] = [];\n        }\n        for (let i = 0, len = modelDecorations.length; i < len; i++) {\n            const modelDecoration = modelDecorations[i];\n            const decorationOptions = modelDecoration.options;\n            if (!isModelDecorationVisible(this.model, modelDecoration)) {\n                continue;\n            }\n            const viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n            const viewRange = viewModelDecoration.range;\n            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n            if (decorationOptions.inlineClassName) {\n                const inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* RegularAffectingLetterSpacing */ : 0 /* Regular */);\n                const intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n                const intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n                for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n                    inlineDecorations[j - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.beforeContentClassName) {\n                if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* Before */);\n                    inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.afterContentClassName) {\n                if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* After */);\n                    inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n        }\n        return {\n            decorations: decorationsInViewport,\n            inlineDecorations: inlineDecorations\n        };\n    }\n}\nexport function isModelDecorationVisible(model, decoration) {\n    if (decoration.options.hideInCommentTokens && isModelDecorationInComment(model, decoration)) {\n        return false;\n    }\n    if (decoration.options.hideInStringTokens && isModelDecorationInString(model, decoration)) {\n        return false;\n    }\n    return true;\n}\nexport function isModelDecorationInComment(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 1 /* Comment */);\n}\nexport function isModelDecorationInString(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 2 /* String */);\n}\n/**\n * Calls the callback for every token that intersects the range.\n * If the callback returns `false`, iteration stops and `false` is returned.\n * Otherwise, `true` is returned.\n */\nfunction testTokensInRange(model, range, callback) {\n    for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n        const lineTokens = model.getLineTokens(lineNumber);\n        const isFirstLine = lineNumber === range.startLineNumber;\n        const isEndLine = lineNumber === range.endLineNumber;\n        let tokenIdx = isFirstLine ? lineTokens.findTokenIndexAtOffset(range.startColumn - 1) : 0;\n        while (tokenIdx < lineTokens.getCount()) {\n            if (isEndLine) {\n                const startOffset = lineTokens.getStartOffset(tokenIdx);\n                if (startOffset > range.endColumn - 1) {\n                    break;\n                }\n            }\n            const callbackResult = callback(lineTokens.getStandardTokenType(tokenIdx));\n            if (!callbackResult) {\n                return false;\n            }\n            tokenIdx++;\n        }\n    }\n    return true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    mustCommit() {\n        return this._hasPending;\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nexport class EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setLineHeight(lineHeight) {\n        this._checkPendingChanges();\n        this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount) {\n        this._checkPendingChanges();\n        this._lineCount = lineCount;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            const result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _checkPendingChanges() {\n        if (this._pendingChanges.mustCommit()) {\n            this._pendingChanges.commit(this);\n        }\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        this._checkPendingChanges();\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        this._checkPendingChanges();\n        const linesHeight = this._lineHeight * this._lineCount;\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber);\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        this._checkPendingChanges();\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        const lineHeight = this._lineHeight;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        this._checkPendingChanges();\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        const result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        this._checkPendingChanges();\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        this._checkPendingChanges();\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\nLinesLayout.INSTANCE_COUNT = 0;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Scrollable } from '../../../base/common/scrollable.js';\nimport { LinesLayout } from './linesLayout.js';\nimport { Viewport } from '../viewModel.js';\nimport { ContentSizeChangedEvent } from '../viewModelEventDispatcher.js';\nconst SMOOTH_SCROLLING_TIME = 125;\nclass EditorScrollDimensions {\n    constructor(width, contentWidth, height, contentHeight) {\n        width = width | 0;\n        contentWidth = contentWidth | 0;\n        height = height | 0;\n        contentHeight = contentHeight | 0;\n        if (width < 0) {\n            width = 0;\n        }\n        if (contentWidth < 0) {\n            contentWidth = 0;\n        }\n        if (height < 0) {\n            height = 0;\n        }\n        if (contentHeight < 0) {\n            contentHeight = 0;\n        }\n        this.width = width;\n        this.contentWidth = contentWidth;\n        this.scrollWidth = Math.max(width, contentWidth);\n        this.height = height;\n        this.contentHeight = contentHeight;\n        this.scrollHeight = Math.max(height, contentHeight);\n    }\n    equals(other) {\n        return (this.width === other.width\n            && this.contentWidth === other.contentWidth\n            && this.height === other.height\n            && this.contentHeight === other.contentHeight);\n    }\n}\nclass EditorScrollable extends Disposable {\n    constructor(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n        super();\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._dimensions = new EditorScrollDimensions(0, 0, 0, 0);\n        this._scrollable = this._register(new Scrollable({\n            forceIntegerValues: true,\n            smoothScrollDuration,\n            scheduleAtNextAnimationFrame\n        }));\n        this.onDidScroll = this._scrollable.onScroll;\n    }\n    getScrollable() {\n        return this._scrollable;\n    }\n    setSmoothScrollDuration(smoothScrollDuration) {\n        this._scrollable.setSmoothScrollDuration(smoothScrollDuration);\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    getScrollDimensions() {\n        return this._dimensions;\n    }\n    setScrollDimensions(dimensions) {\n        if (this._dimensions.equals(dimensions)) {\n            return;\n        }\n        const oldDimensions = this._dimensions;\n        this._dimensions = dimensions;\n        this._scrollable.setScrollDimensions({\n            width: dimensions.width,\n            scrollWidth: dimensions.scrollWidth,\n            height: dimensions.height,\n            scrollHeight: dimensions.scrollHeight\n        }, true);\n        const contentWidthChanged = (oldDimensions.contentWidth !== dimensions.contentWidth);\n        const contentHeightChanged = (oldDimensions.contentHeight !== dimensions.contentHeight);\n        if (contentWidthChanged || contentHeightChanged) {\n            this._onDidContentSizeChange.fire(new ContentSizeChangedEvent(oldDimensions.contentWidth, oldDimensions.contentHeight, dimensions.contentWidth, dimensions.contentHeight));\n        }\n    }\n    getFutureScrollPosition() {\n        return this._scrollable.getFutureScrollPosition();\n    }\n    getCurrentScrollPosition() {\n        return this._scrollable.getCurrentScrollPosition();\n    }\n    setScrollPositionNow(update) {\n        this._scrollable.setScrollPositionNow(update);\n    }\n    setScrollPositionSmooth(update) {\n        this._scrollable.setScrollPositionSmooth(update);\n    }\n}\nexport class ViewLayout extends Disposable {\n    constructor(configuration, lineCount, scheduleAtNextAnimationFrame) {\n        super();\n        this._configuration = configuration;\n        const options = this._configuration.options;\n        const layoutInfo = options.get(131 /* layoutInfo */);\n        const padding = options.get(75 /* padding */);\n        this._linesLayout = new LinesLayout(lineCount, options.get(59 /* lineHeight */), padding.top, padding.bottom);\n        this._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame));\n        this._configureSmoothScrollDuration();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(layoutInfo.contentWidth, 0, layoutInfo.height, 0));\n        this.onDidScroll = this._scrollable.onDidScroll;\n        this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;\n        this._updateHeight();\n    }\n    dispose() {\n        super.dispose();\n    }\n    getScrollable() {\n        return this._scrollable.getScrollable();\n    }\n    onHeightMaybeChanged() {\n        this._updateHeight();\n    }\n    _configureSmoothScrollDuration() {\n        this._scrollable.setSmoothScrollDuration(this._configuration.options.get(103 /* smoothScrolling */) ? SMOOTH_SCROLLING_TIME : 0);\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        const options = this._configuration.options;\n        if (e.hasChanged(59 /* lineHeight */)) {\n            this._linesLayout.setLineHeight(options.get(59 /* lineHeight */));\n        }\n        if (e.hasChanged(75 /* padding */)) {\n            const padding = options.get(75 /* padding */);\n            this._linesLayout.setPadding(padding.top, padding.bottom);\n        }\n        if (e.hasChanged(131 /* layoutInfo */)) {\n            const layoutInfo = options.get(131 /* layoutInfo */);\n            const width = layoutInfo.contentWidth;\n            const height = layoutInfo.height;\n            const scrollDimensions = this._scrollable.getScrollDimensions();\n            const contentWidth = scrollDimensions.contentWidth;\n            this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n        }\n        else {\n            this._updateHeight();\n        }\n        if (e.hasChanged(103 /* smoothScrolling */)) {\n            this._configureSmoothScrollDuration();\n        }\n    }\n    onFlushed(lineCount) {\n        this._linesLayout.onFlushed(lineCount);\n    }\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n    }\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n    }\n    // ---- end view event handlers\n    _getHorizontalScrollbarHeight(width, scrollWidth) {\n        const options = this._configuration.options;\n        const scrollbar = options.get(92 /* scrollbar */);\n        if (scrollbar.horizontal === 2 /* Hidden */) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        if (width >= scrollWidth) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        return scrollbar.horizontalScrollbarSize;\n    }\n    _getContentHeight(width, height, contentWidth) {\n        const options = this._configuration.options;\n        let result = this._linesLayout.getLinesTotalHeight();\n        if (options.get(94 /* scrollBeyondLastLine */)) {\n            result += Math.max(0, height - options.get(59 /* lineHeight */) - options.get(75 /* padding */).bottom);\n        }\n        else {\n            result += this._getHorizontalScrollbarHeight(width, contentWidth);\n        }\n        return result;\n    }\n    _updateHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const width = scrollDimensions.width;\n        const height = scrollDimensions.height;\n        const contentWidth = scrollDimensions.contentWidth;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n    }\n    // ---- Layouting logic\n    getCurrentViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    getFutureViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    _computeContentWidth(maxLineWidth) {\n        const options = this._configuration.options;\n        const wrappingInfo = options.get(132 /* wrappingInfo */);\n        const fontInfo = options.get(44 /* fontInfo */);\n        if (wrappingInfo.isViewportWrapping) {\n            const layoutInfo = options.get(131 /* layoutInfo */);\n            const minimap = options.get(65 /* minimap */);\n            if (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {\n                // This is a case where viewport wrapping is on, but the line extends above the viewport\n                if (minimap.enabled && minimap.side === 'right') {\n                    // We need to accomodate the scrollbar width\n                    return maxLineWidth + layoutInfo.verticalScrollbarWidth;\n                }\n            }\n            return maxLineWidth;\n        }\n        else {\n            const extraHorizontalSpace = options.get(93 /* scrollBeyondLastColumn */) * fontInfo.typicalHalfwidthCharacterWidth;\n            const whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n            return Math.max(maxLineWidth + extraHorizontalSpace, whitespaceMinWidth);\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        // const newScrollWidth = ;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(scrollDimensions.width, this._computeContentWidth(maxLineWidth), scrollDimensions.height, scrollDimensions.contentHeight));\n        // The height might depend on the fact that there is a horizontal scrollbar or not\n        this._updateHeight();\n    }\n    // ---- view state\n    saveState() {\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        const scrollTop = currentScrollPosition.scrollTop;\n        const firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n        const whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n        return {\n            scrollTop: scrollTop,\n            scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n            scrollLeft: currentScrollPosition.scrollLeft\n        };\n    }\n    // ----\n    changeWhitespace(callback) {\n        const hadAChange = this._linesLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this.onHeightMaybeChanged();\n        }\n        return hadAChange;\n    }\n    getVerticalOffsetForLineNumber(lineNumber) {\n        return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n    isAfterLines(verticalOffset) {\n        return this._linesLayout.isAfterLines(verticalOffset);\n    }\n    isInTopPadding(verticalOffset) {\n        return this._linesLayout.isInTopPadding(verticalOffset);\n    }\n    isInBottomPadding(verticalOffset) {\n        return this._linesLayout.isInBottomPadding(verticalOffset);\n    }\n    getLineNumberAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n    }\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n    }\n    getLinesViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getLinesViewportDataAtScrollTop(scrollTop) {\n        // do some minimal validations on scrollTop\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n            scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n        }\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n    }\n    getWhitespaceViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getWhitespaces() {\n        return this._linesLayout.getWhitespaces();\n    }\n    // ----\n    getContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentWidth;\n    }\n    getScrollWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollWidth;\n    }\n    getContentHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentHeight;\n    }\n    getScrollHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollHeight;\n    }\n    getCurrentScrollLeft() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollLeft;\n    }\n    getCurrentScrollTop() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollTop;\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    setScrollPosition(position, type) {\n        if (type === 1 /* Immediate */) {\n            this._scrollable.setScrollPositionNow(position);\n        }\n        else {\n            this._scrollable.setScrollPositionSmooth(position);\n        }\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        this._scrollable.setScrollPositionNow({\n            scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n            scrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from '../viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return IdentityModelLineProjection.INSTANCE;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    else {\n        return new ModelLineProjection(lineBreakData, isVisible);\n    }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection {\n    constructor(lineBreakData, isVisible) {\n        this._projectionData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getProjectionData() {\n        return this._projectionData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._projectionData.getOutputLineCount();\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n        let r;\n        if (this._projectionData.injectionOffsets !== null) {\n            const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));\n            const lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n            r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n        }\n        else {\n            r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffsetInInputWithInjections + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffsetInInputWithInjections + 1\n            });\n        }\n        if (outputLineIndex > 0) {\n            r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getLineLength(outputLineIndex);\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n    }\n    /**\n     * Try using {@link getViewLinesData} instead.\n    */\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        const arr = new Array();\n        this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n        return arr[0];\n    }\n    getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const injectionOffsets = lineBreakData.injectionOffsets;\n        const injectionOptions = lineBreakData.injectionOptions;\n        let inlineDecorationsPerOutputLine = null;\n        if (injectionOffsets) {\n            inlineDecorationsPerOutputLine = [];\n            let totalInjectedTextLengthBefore = 0;\n            let currentInjectedOffset = 0;\n            for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n                const inlineDecorations = new Array();\n                inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n                const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n                const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n                while (currentInjectedOffset < injectionOffsets.length) {\n                    const length = injectionOptions[currentInjectedOffset].content.length;\n                    const injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n                    const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n                    if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n                        // Injected text only starts in later wrapped lines.\n                        break;\n                    }\n                    if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n                        // Injected text ends after or in this line (but also starts in or before this line).\n                        const options = injectionOptions[currentInjectedOffset];\n                        if (options.inlineClassName) {\n                            const offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n                            const start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n                            const end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections);\n                            if (start !== end) {\n                                inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                            }\n                        }\n                    }\n                    if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n                        totalInjectedTextLengthBefore += length;\n                        currentInjectedOffset++;\n                    }\n                    else {\n                        // injected text breaks into next line, process it again\n                        break;\n                    }\n                }\n            }\n        }\n        let lineWithInjections;\n        if (injectionOffsets) {\n            lineWithInjections = model.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n                offset,\n                text: injectionOptions[idx].content,\n                tokenMetadata: LineTokens.defaultTokenMetadata\n            })));\n        }\n        else {\n            lineWithInjections = model.getLineTokens(modelLineNumber);\n        }\n        for (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n            const globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n        }\n    }\n    _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n        const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n        const tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n        let lineContent = tokens.getLineContent();\n        if (outputLineIndex > 0) {\n            lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n        const maxColumn = lineContent.length + 1;\n        const continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        this._assertVisible();\n        return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2 /* None */) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n        return r.toPosition(deltaLineNumber);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n        return deltaLineNumber + r.outputLineIndex;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n        const normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n        const result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n        return result;\n    }\n    getInjectedTextAt(outputLineIndex, outputColumn) {\n        return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n    _assertVisible() {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n    }\n}\n/**\n * This projection does not change the model line.\n*/\nclass IdentityModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        const lineTokens = model.getLineTokens(modelLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        return outputPosition;\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        return null;\n    }\n}\nIdentityModelLineProjection.INSTANCE = new IdentityModelLineProjection();\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return IdentityModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        throw new Error('Not supported');\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n}\nHiddenModelLineProjection.INSTANCE = new HiddenModelLineProjection();\nlet _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                if (viewLineInfo.isWrappedLineContinuation && this.getMinColumnOfViewLine(viewLineInfo) === 1) {\n                    // Don't add indent guides when the wrapped line continuation has no wrapping-indentation.\n                    resultPerViewLine.push([]);\n                }\n                else {\n                    let bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                    // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                    // model-columns must be converted to view-model columns.\n                    bracketGuides = bracketGuides.map(g => g.horizontalLine ?\n                        new IndentGuide(g.visibleColumn, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn).column)) : g);\n                    resultPerViewLine.push(bracketGuides);\n                }\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* BlockSubsequent */ : 2 /* BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* None */) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n            lineIndexChanged = true;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            return new Position(1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        let finalResult = [], finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n    get isWrappedLineContinuation() {\n        return this.modelLineWrappedLineIdx > 0;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._themeService = _themeService;\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStartLine = -1;\n        this._viewportStartLineTrackedRange = null;\n        this._viewportStartLineDelta = 0;\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(44 /* fontInfo */);\n            const wrappingStrategy = options.get(125 /* wrappingStrategy */);\n            const wrappingInfo = options.get(132 /* wrappingInfo */);\n            const wrappingIndent = options.get(124 /* wrappingIndent */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._register(this._themeService.onDidColorThemeChange((theme) => {\n            this._invalidateDecorationsColorCache();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1 /* NeverGrowsWhenTypingAtEdges */);\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    tokenizeViewport() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        for (const modelVisibleRange of modelVisibleRanges) {\n            this.model.tokenizeViewport(modelVisibleRange.startLineNumber, modelVisibleRange.endLineNumber);\n        }\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        // We might need to restore the current centered view range, so save it (if available)\n        let previousViewportStartModelPosition = null;\n        if (this._viewportStartLine !== -1) {\n            const previousViewportStartViewPosition = new Position(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));\n            previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n        }\n        let restorePreviousViewportStart = false;\n        const options = this._configuration.options;\n        const fontInfo = options.get(44 /* fontInfo */);\n        const wrappingStrategy = options.get(125 /* wrappingStrategy */);\n        const wrappingInfo = options.get(132 /* wrappingInfo */);\n        const wrappingIndent = options.get(124 /* wrappingIndent */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            if (this.viewLayout.getCurrentScrollTop() !== 0) {\n                // Never change the scroll position from 0 to something else...\n                restorePreviousViewportStart = true;\n            }\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(81 /* readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n            const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n            const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n            this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\n        }\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = e.changes;\n                const versionId = (e instanceof textModelEvents.ModelRawContentChangedEvent ? e.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            this._viewportStartLine = -1;\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {\n                const modelRange = this.model._getTrackedRange(this._viewportStartLineTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._tokenizeViewportSoon.schedule();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            if (e.tokenizationSupportChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges) {\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(ranges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(131 /* layoutInfo */);\n        const lineHeight = this._configuration.options.get(59 /* lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStartLine = startLineNumber;\n        const position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = this.viewLayout.getCurrentScrollTop();\n        this._viewportStartLineDelta = scrollTop - viewportStartLineTop;\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewLineRenderingData(visibleRange, lineNumber) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    _invalidateDecorationsColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts1 = decoration.options.overviewRuler;\n            if (opts1) {\n                opts1.invalidateCachedColor();\n            }\n            const opts2 = decoration.options.minimap;\n            if (opts2) {\n                opts2.invalidateCachedColor();\n            }\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(44 /* fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._cursor.setIsDoingComposition(true);\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._cursor.setIsDoingComposition(false);\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* Simple */, revealHorizontal, 0 /* Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            return callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable } from '../../base/common/lifecycle.js';\nexport class ViewModelEventDispatcher extends Disposable {\n    constructor() {\n        super();\n        this._onEvent = this._register(new Emitter());\n        this.onEvent = this._onEvent.event;\n        this._eventHandlers = [];\n        this._viewEventQueue = null;\n        this._isConsumingViewEventQueue = false;\n        this._collector = null;\n        this._collectorCnt = 0;\n        this._outgoingEvents = [];\n    }\n    emitOutgoingEvent(e) {\n        this._addOutgoingEvent(e);\n        this._emitOutgoingEvents();\n    }\n    _addOutgoingEvent(e) {\n        for (let i = 0, len = this._outgoingEvents.length; i < len; i++) {\n            if (this._outgoingEvents[i].kind === e.kind) {\n                this._outgoingEvents[i] = this._outgoingEvents[i].merge(e);\n                return;\n            }\n        }\n        // not merged\n        this._outgoingEvents.push(e);\n    }\n    _emitOutgoingEvents() {\n        while (this._outgoingEvents.length > 0) {\n            if (this._collector || this._isConsumingViewEventQueue) {\n                // right now collecting or emitting view events, so let's postpone emitting\n                return;\n            }\n            const event = this._outgoingEvents.shift();\n            if (event.isNoOp()) {\n                continue;\n            }\n            this._onEvent.fire(event);\n        }\n    }\n    addViewEventHandler(eventHandler) {\n        for (let i = 0, len = this._eventHandlers.length; i < len; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                console.warn('Detected duplicate listener in ViewEventDispatcher', eventHandler);\n            }\n        }\n        this._eventHandlers.push(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        for (let i = 0; i < this._eventHandlers.length; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                this._eventHandlers.splice(i, 1);\n                break;\n            }\n        }\n    }\n    beginEmitViewEvents() {\n        this._collectorCnt++;\n        if (this._collectorCnt === 1) {\n            this._collector = new ViewModelEventsCollector();\n        }\n        return this._collector;\n    }\n    endEmitViewEvents() {\n        this._collectorCnt--;\n        if (this._collectorCnt === 0) {\n            const outgoingEvents = this._collector.outgoingEvents;\n            const viewEvents = this._collector.viewEvents;\n            this._collector = null;\n            for (const outgoingEvent of outgoingEvents) {\n                this._addOutgoingEvent(outgoingEvent);\n            }\n            if (viewEvents.length > 0) {\n                this._emitMany(viewEvents);\n            }\n        }\n        this._emitOutgoingEvents();\n    }\n    emitSingleViewEvent(event) {\n        try {\n            const eventsCollector = this.beginEmitViewEvents();\n            eventsCollector.emitViewEvent(event);\n        }\n        finally {\n            this.endEmitViewEvents();\n        }\n    }\n    _emitMany(events) {\n        if (this._viewEventQueue) {\n            this._viewEventQueue = this._viewEventQueue.concat(events);\n        }\n        else {\n            this._viewEventQueue = events;\n        }\n        if (!this._isConsumingViewEventQueue) {\n            this._consumeViewEventQueue();\n        }\n    }\n    _consumeViewEventQueue() {\n        try {\n            this._isConsumingViewEventQueue = true;\n            this._doConsumeQueue();\n        }\n        finally {\n            this._isConsumingViewEventQueue = false;\n        }\n    }\n    _doConsumeQueue() {\n        while (this._viewEventQueue) {\n            // Empty event queue, as events might come in while sending these off\n            const events = this._viewEventQueue;\n            this._viewEventQueue = null;\n            // Use a clone of the event handlers list, as they might remove themselves\n            const eventHandlers = this._eventHandlers.slice(0);\n            for (const eventHandler of eventHandlers) {\n                eventHandler.handleEvents(events);\n            }\n        }\n    }\n}\nexport class ViewModelEventsCollector {\n    constructor() {\n        this.viewEvents = [];\n        this.outgoingEvents = [];\n    }\n    emitViewEvent(event) {\n        this.viewEvents.push(event);\n    }\n    emitOutgoingEvent(e) {\n        this.outgoingEvents.push(e);\n    }\n}\nexport class ContentSizeChangedEvent {\n    constructor(oldContentWidth, oldContentHeight, contentWidth, contentHeight) {\n        this.kind = 0 /* ContentSizeChanged */;\n        this._oldContentWidth = oldContentWidth;\n        this._oldContentHeight = oldContentHeight;\n        this.contentWidth = contentWidth;\n        this.contentHeight = contentHeight;\n        this.contentWidthChanged = (this._oldContentWidth !== this.contentWidth);\n        this.contentHeightChanged = (this._oldContentHeight !== this.contentHeight);\n    }\n    isNoOp() {\n        return (!this.contentWidthChanged && !this.contentHeightChanged);\n    }\n    merge(other) {\n        if (other.kind !== 0 /* ContentSizeChanged */) {\n            return this;\n        }\n        return new ContentSizeChangedEvent(this._oldContentWidth, this._oldContentHeight, other.contentWidth, other.contentHeight);\n    }\n}\nexport class FocusChangedEvent {\n    constructor(oldHasFocus, hasFocus) {\n        this.kind = 1 /* FocusChanged */;\n        this.oldHasFocus = oldHasFocus;\n        this.hasFocus = hasFocus;\n    }\n    isNoOp() {\n        return (this.oldHasFocus === this.hasFocus);\n    }\n    merge(other) {\n        if (other.kind !== 1 /* FocusChanged */) {\n            return this;\n        }\n        return new FocusChangedEvent(this.oldHasFocus, other.hasFocus);\n    }\n}\nexport class ScrollChangedEvent {\n    constructor(oldScrollWidth, oldScrollLeft, oldScrollHeight, oldScrollTop, scrollWidth, scrollLeft, scrollHeight, scrollTop) {\n        this.kind = 2 /* ScrollChanged */;\n        this._oldScrollWidth = oldScrollWidth;\n        this._oldScrollLeft = oldScrollLeft;\n        this._oldScrollHeight = oldScrollHeight;\n        this._oldScrollTop = oldScrollTop;\n        this.scrollWidth = scrollWidth;\n        this.scrollLeft = scrollLeft;\n        this.scrollHeight = scrollHeight;\n        this.scrollTop = scrollTop;\n        this.scrollWidthChanged = (this._oldScrollWidth !== this.scrollWidth);\n        this.scrollLeftChanged = (this._oldScrollLeft !== this.scrollLeft);\n        this.scrollHeightChanged = (this._oldScrollHeight !== this.scrollHeight);\n        this.scrollTopChanged = (this._oldScrollTop !== this.scrollTop);\n    }\n    isNoOp() {\n        return (!this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged);\n    }\n    merge(other) {\n        if (other.kind !== 2 /* ScrollChanged */) {\n            return this;\n        }\n        return new ScrollChangedEvent(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, other.scrollWidth, other.scrollLeft, other.scrollHeight, other.scrollTop);\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.kind = 3 /* ViewZonesChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    merge(other) {\n        return this;\n    }\n}\nexport class HiddenAreasChangedEvent {\n    constructor() {\n        this.kind = 4 /* HiddenAreasChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    merge(other) {\n        return this;\n    }\n}\nexport class CursorStateChangedEvent {\n    constructor(oldSelections, selections, oldModelVersionId, modelVersionId, source, reason, reachedMaxCursorCount) {\n        this.kind = 6 /* CursorStateChanged */;\n        this.oldSelections = oldSelections;\n        this.selections = selections;\n        this.oldModelVersionId = oldModelVersionId;\n        this.modelVersionId = modelVersionId;\n        this.source = source;\n        this.reason = reason;\n        this.reachedMaxCursorCount = reachedMaxCursorCount;\n    }\n    static _selectionsAreEqual(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!a[i].equalsSelection(b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isNoOp() {\n        return (CursorStateChangedEvent._selectionsAreEqual(this.oldSelections, this.selections)\n            && this.oldModelVersionId === this.modelVersionId);\n    }\n    merge(other) {\n        if (other.kind !== 6 /* CursorStateChanged */) {\n            return this;\n        }\n        return new CursorStateChangedEvent(this.oldSelections, other.selections, this.oldModelVersionId, other.modelVersionId, other.source, other.reason, this.reachedMaxCursorCount || other.reachedMaxCursorCount);\n    }\n}\nexport class ReadOnlyEditAttemptEvent {\n    constructor() {\n        this.kind = 5 /* ReadOnlyEditAttempt */;\n    }\n    isNoOp() {\n        return false;\n    }\n    merge(other) {\n        return this;\n    }\n}\n"],"names":["BracketInfo","range","nestingLevel","isInvalid","this","BracketPairWithMinIndentationInfo","openingBracketRange","closingBracketRange","minVisibleColumnIndentation","ModelRawFlush","changeType","LineInjectedText","ownerId","lineNumber","column","options","order","lineText","injectedTexts","length","result","lastOriginalOffset","injectedText","substring","content","decorations","decoration","before","push","startLineNumber","startColumn","after","endLineNumber","endColumn","sort","a","b","ModelRawLineChanged","detail","ModelRawLinesDeleted","fromLineNumber","toLineNumber","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","changes","versionId","isUndoing","isRedoing","resultingSelection","type","i","len","concat","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","rawContentChangedEvent","contentChangedEvent","other","merge","_mergeChangeEvents","eol","isFlush","HorizontalGuidesState","IndentGuide","visibleColumn","className","horizontalLine","IndentGuideHorizontalLine","top","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","done","then","apply","TokenizationRegistry","_map","Map","_factories","_onDidChange","Emitter","onDidChange","event","_colorMap","languages","fire","changedLanguages","changedColorMap","language","support","set","toDisposable","get","delete","languageId","factory","_a","dispose","myData","TokenizationSupportFactoryData","v","tokenizationSupport","isResolved","colorMap","Array","from","keys","_registry","_languageId","_factory","_isDisposed","_resolvePromise","_isResolved","_create","createTokenizationSupport","_register","register","Disposable","ContiguousMultilineTokens","tokens","_startLineNumber","_tokens","lineTokens","ContiguousMultilineTokensBuilder","last","appendLineTokens","EMPTY_LINE_TOKENS","Uint32Array","buffer","ContiguousTokensEditing","toChIndex","fromChIndex","toUint32Array","lineTextLength","tokensCount","dest","lastEnd","fromTokenIndex","LineTokens","fromTokenStartOffset","delta","tokenIndex","tokenEndOffset","tmp","subarray","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength","arr","ContiguousTokensStore","languageIdCodec","_lineTokens","_len","_languageIdCodec","topLevelLanguageId","lineIndex","rawLineTokens","getDefaultMetadata","encodeLanguageId","start","deleteCount","splice","insertIndex","insertCount","arrays","checkEquality","_massageTokens","_ensureLine","oldTokens","_equals","eolCount","firstLineLength","_acceptDeleteRange","_acceptInsertText","Position","firstLineIndex","deleteEnding","lastLineIndex","lastLineTokens","deleteBeginning","append","_deleteLines","position","insert","_insertLines","hasDifferentLanguageId","TokenMetadata","byteOffset","byteLength","_b","text","decoder","_lineTokensBrand","undefined","_tokensCount","_text","slicedEquals","sliceFromTokenIndex","sliceTokenCount","to","metadata","decodeLanguageId","offset","findIndexInTokensArray","startOffset","endOffset","deltaOffset","SliceLineTokens","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","tokenMetadata","lineContent","defaultMetadata","defaultTokenMetadata","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","findTokenIndexAtOffset","getCount","getStartOffset","getMetadata","getLanguageId","getLineContent","getForeground","getEndOffset","min","getClassName","getInlineStyle","getPresentation","SparseMultilineTokens","_endLineNumber","getMaxDeltaLine","toString","isEmpty","getLineTokens","deltaRange","getRange","Range","startLineIndex","endLineIndex","removeTokens","_updateEndLineNumber","split","bDeltaLine","countEOL","lastLineLength","acceptEdit","charCodeAt","firstCharCode","deletedLinesCount","tokenMaxDeltaLine","clear","deletedBefore","acceptDeleteRange","acceptInsertText","SparseMultilineTokensStorage","_tokenCount","pieces","_getDeltaLine","_getStartCharacter","_getEndCharacter","join","tokenCount","_getTokenCount","startChar","maxDeltaLine","endChar","deltaLine","midDeltaLine","max","SparseLineTokens","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","destOffset","aTokens","bTokens","destTokens","destFirstDeltaLine","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","Error","character","isInsertingPreciselyOneWordCharacter","tokenLength","SparseTokensStore","_pieces","_isComplete","isComplete","_range","_firstRange","_lastRange","plusRange","insertPosition","piece","index","_findFirstPieceWithLine","aLen","bLen","aIndex","resultLen","lastEndOffset","emitToken","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","bMask","aMask","aMergeIndex","ViewEventHandler","_shouldRender","events","shouldRender","onCompositionStart","onCompositionEnd","onConfigurationChanged","onCursorStateChanged","onDecorationsChanged","onFlushed","onFocusChanged","onLanguageConfigurationChanged","onLineMappingChanged","onLinesChanged","onLinesDeleted","onLinesInserted","onRevealRangeRequest","onScrollChanged","onTokensChanged","onThemeChanged","onTokensColorsChanged","onZonesChanged","console","info","ViewCompositionStartEvent","ViewCompositionEndEvent","ViewConfigurationChangedEvent","id","hasChanged","ViewCursorStateChangedEvent","selections","modelSelections","ViewDecorationsChangedEvent","affectsMinimap","affectsOverviewRuler","ViewFlushedEvent","ViewFocusChangedEvent","isFocused","ViewLanguageConfigurationEvent","ViewLineMappingChangedEvent","ViewLinesChangedEvent","ViewLinesDeletedEvent","ViewLinesInsertedEvent","ViewRevealRangeRequestEvent","minimalReveal","verticalType","revealHorizontal","scrollType","ViewScrollChangedEvent","scrollWidth","scrollLeft","scrollHeight","scrollTop","scrollWidthChanged","scrollLeftChanged","scrollHeightChanged","scrollTopChanged","ViewThemeChangedEvent","theme","ViewTokensChangedEvent","ranges","ViewTokensColorsChangedEvent","ViewZonesChangedEvent","LineDecoration","_lineDecorationBrand","lineLength","r","rLength","dec","lineDecorations","minLineColumn","maxLineColumn","d","inlineClassName","ORDER","typeCmp","_typeCompare","DecorationSegment","Stack","stopOffsets","classNames","count","maxStopOffset","nextStartOffset","_metadata","stopOffset","LineDecorationsNormalizer","stack","charCodeBefore","strings","currentStartOffset","currentEndOffset","consumeLowerThan","LinePart","endIndex","_linePartBrand","LineRange","startIndex","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","continuesWithWrappedLine","isBasicASCII","containsRTL","fauxIndentLength","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","abs","renderSpaceWidth","renderSpaceCharCode","otherSelections","equals","sameSelection","DomPosition","partIndex","charIndex","CharacterMapping","partCount","_data","_absoluteOffsets","partAbsoluteOffset","partData","charOffset","charOffsetToPartData","getPartIndex","getCharIndex","domPosition","partLength","partDataToCharOffset","searchEntry","midEntry","minEntry","maxEntry","minPartIndex","RenderLineOutput","characterMapping","containsForeignElements","_renderLineOutputBrand","renderViewLine","input","sb","appendASCIIString","beforeCount","afterCount","lineDecoration","setColumnInfo","fontIsMonospace","isOverflowing","parts","lastCharacterMappingDefined","charOffsetInPart","partDisplacement","prevPartContentCnt","tokensLen","part","partEndIndex","partType","partRendersWhitespace","isWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","isPseudoAfter","appendASCII","partContentCnt","_charIndex","_visibleColumn","charWidth","String","write1","space","charCode","producedCharacters","isControlCharacter","to4CharHex","_renderLine","transformAndRemoveOverflowing","lastLinePart","token","tokenEndIndex","extractControlCharacters","lastNonWhitespaceIndex","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokenType","tokensLength","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","generateWhitespace","lastCharCode","prevCharCode","_applyRenderWhitespace","_lineDecorations","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastTokenEndIndex","_applyInlineDecorations","onlyAtSpaces","lastSpaceOffset","currTokenStart","j","diff","piecesCount","ceil","pieceEndIndex","splitLargeTokens","ResolvedRenderLineInput","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","createStringBuilder","out","build","n","toUpperCase","padStart","ViewportData","partialData","whitespaceViewportData","model","relativeVerticalOffset","bigNumbersDelta","_model","visibleRange","getLineMinColumn","getLineMaxColumn","getViewLineRenderingData","getDecorationsInViewport","Viewport","left","width","height","_viewportBrand","MinimapLinesRenderingData","data","ViewLineData","minColumn","maxColumn","inlineDecorations","_viewLineDataBrand","ViewLineRenderingData","mightContainRTL","mightContainNonBasicASCII","InlineDecoration","SingleLineInlineDecoration","inlineClassNameAffectsLetterSpacing","ViewModelDecoration","_viewModelDecorationBrand","OverviewRulerDecorationsGroup","color","zIndex","MinimapTokensColorTracker","_updateColorMap","_colors","RGBA8","_backgroundIsLight","colorId","rgba","g","round","backgroundLuminosity","getRelativeLuminance","_INSTANCE","markAsSingleton","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","classifier","WrappingCharacterClassifier","fontInfo","wrappingColumn","wrappingIndent","requests","previousBreakingData","addRequest","previousLineBreakData","finalize","columnsForFullWidthChar","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","injectionOptions","createLineBreaks","createLineBreaksFromPreviousLineBreaks","arrPool1","arrPool2","BREAK_BEFORE","BREAK_AFTER","_asciiMap","_defaultValue","CharacterClassifier","firstLineBreakColumn","prevBreakingOffsets","breakOffsets","prevBreakingOffsetsVisibleColumn","breakOffsetsVisibleColumn","wrappedTextIndentLength","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","lastBreakingOffset","lastBreakingOffsetVisibleColumn","breakingColumn","prevLen","prevIndex","bestDistance","distance","prevBreakOffset","prevBreakOffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","_lineText","injectionOffsets","map","t","ModelLineProjectionData","tabCharacterWidth","numberOfAdditionalTabs","ColorZone","_colorZoneBrand","OverviewRulerZone","heightInLines","_overviewRulerZoneBrand","_colorZone","colorZone","OverviewZoneManager","getVerticalOffsetForLine","_getVerticalOffsetForLine","_zones","_colorZonesInvalid","_lineHeight","_domWidth","_domHeight","_outerHeight","_pixelRatio","_lastAssignedId","_color2Id","Object","create","_id2Color","newZones","compare","lineHeight","pixelRatio","outerHeight","colorZonesInvalid","totalHeight","getCanvasHeight","heightRatio","halfMinimumHeight","allColorZones","zone","getColorZones","offset1","offset2","y1","y2","ycenter","halfHeight","setColorZone","ViewContext","configuration","EditorTheme","viewModel","viewLayout","eventHandler","addViewEventHandler","removeViewEventHandler","ViewModelDecorations","editorId","linesCollection","coordinatesConverter","_linesCollection","_coordinatesConverter","_decorationsCache","_cachedModelDecorationsResolver","_cachedModelDecorationsResolverViewRange","_clearCachedModelDecorationsResolver","modelDecoration","viewRange","modelRange","isWholeLine","convertModelPositionToViewPosition","end","convertModelRangeToViewRange","cacheIsValid","equalsRange","_getDecorationsViewportData","viewportRange","modelDecorations","getDecorationsInRange","filterValidationDecorations","decorationsInViewport","decorationsInViewportLen","decorationOptions","isModelDecorationVisible","viewModelDecoration","_getOrCreateViewModelDecoration","inlineDecoration","intersectedStartLineNumber","intersectedEndLineNumber","beforeContentClassName","afterContentClassName","hideInCommentTokens","isModelDecorationInComment","hideInStringTokens","isModelDecorationInString","testTokensInRange","callback","isFirstLine","isEndLine","tokenIdx","getStandardTokenType","PendingChanges","_hasPending","_inserts","_changes","_removes","x","linesLayout","inserts","removes","_commitPendingChanges","EditorWhitespace","afterLineNumber","ordinal","minWidth","prefixSum","LinesLayout","lineCount","paddingTop","paddingBottom","_instanceId","INSTANCE_COUNT","_pendingChanges","_lastWhitespaceId","_arr","_prefixSumValidIndex","_minWidth","_lineCount","_paddingTop","_paddingBottom","_checkPendingChanges","hadAChange","insertWhitespace","heightInPx","changeOneWhitespace","newAfterLineNumber","newHeight","change","removeWhitespace","remove","commit","_insertWhitespace","_changeOneWhitespace","_findWhitespaceIndex","_removeWhitespace","toRemove","Set","add","toChange","applyRemoveAndChange","whitespaces","whitespace","has","mustCommit","findInsertionIndex","removeIndex","getWhitespacesAccumulatedHeight","getWhitespacesTotalHeight","lastWhitespaceBeforeLineNumber","_findLastWhitespaceBeforeLineNumber","firstWhitespaceAfterLineNumber","_findFirstWhitespaceAfterLineNumber","getWhitespaceAccumulatedHeightBeforeLineNumber","verticalOffset","getLinesTotalHeight","linesCount","minLineNumber","maxLineNumber","midLineNumber","midLineNumberVerticalOffset","getVerticalOffsetForLineNumber","verticalOffset1","verticalOffset2","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","getLineNumberAtOrAfterVerticalOffset","startLineNumberVerticalOffset","whitespaceIndex","getFirstWhitespaceIndexAfterLineNumber","whitespaceCount","getWhitespacesCount","getAfterLineNumberForWhitespaceIndex","getHeightForWhitespaceIndex","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","linesOffsets","verticalCenter","centeredLineNumber","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","minWhitespaceIndex","maxWhitespaceIndex","getVerticalOffsetForWhitespaceIndex","midWhitespaceIndex","midWhitespaceVerticalOffset","candidateIndex","getWhitespaceIndexAtOrAfterVerticallOffset","candidateTop","candidateHeight","getIdForWhitespaceIndex","slice","EditorScrollDimensions","contentWidth","contentHeight","EditorScrollable","smoothScrollDuration","scheduleAtNextAnimationFrame","_onDidContentSizeChange","onDidContentSizeChange","_dimensions","_scrollable","Scrollable","forceIntegerValues","onDidScroll","onScroll","setSmoothScrollDuration","scrollPosition","validateScrollPosition","dimensions","oldDimensions","setScrollDimensions","contentWidthChanged","contentHeightChanged","ContentSizeChangedEvent","getFutureScrollPosition","getCurrentScrollPosition","update","setScrollPositionNow","setScrollPositionSmooth","ViewLayout","_configuration","layoutInfo","padding","_linesLayout","bottom","_configureSmoothScrollDuration","_updateHeight","getScrollable","setLineHeight","setPadding","scrollDimensions","getScrollDimensions","_getContentHeight","scrollbar","horizontal","horizontalScrollbarSize","_getHorizontalScrollbarHeight","currentScrollPosition","maxLineWidth","wrappingInfo","isViewportWrapping","minimap","enabled","side","verticalScrollbarWidth","extraHorizontalSpace","whitespaceMinWidth","getWhitespaceMinWidth","_computeContentWidth","firstLineNumberInViewport","scrollTopWithoutViewZones","changeWhitespace","onHeightMaybeChanged","isAfterLines","isInTopPadding","isInBottomPadding","getWhitespaceAtVerticalOffset","visibleBox","getCurrentViewport","getLinesViewportData","getWhitespaceViewportData","getWhitespaces","deltaScrollLeft","deltaScrollTop","createModelLineProjection","lineBreakData","isVisible","IdentityModelLineProjection","INSTANCE","HiddenModelLineProjection","ModelLineProjection","_projectionData","_isVisible","getOutputLineCount","modelLineNumber","outputLineIndex","_assertVisible","startOffsetInInputWithInjections","endOffsetInInputWithInjections","idx","getValueInRange","spaces","getLineLength","_modelLineNumber","getMinOutputOffset","getMaxOutputOffset","getViewLinesData","outputLineIdx","globalStartIndex","needed","lineWithInjections","inlineDecorationsPerOutputLine","totalInjectedTextLengthBefore","currentInjectedOffset","lineStartOffsetInInputWithInjections","lineEndOffsetInInputWithInjections","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","withInserted","globalIndex","_getViewLineData","deltaStartIndex","sliceAndInflate","getViewLineCount","outputColumn","translateToInputOffset","deltaLineNumber","inputColumn","affinity","translateToOutputPosition","toPosition","outputPosition","baseViewLineNumber","normalizeOutputPosition","getInjectedText","_outputLineIndex","inflate","_fromOuputLineIndex","_toOutputLineIndex","getViewLineData","_inputColumn","_outputColumn","_globalStartIndex","_needed","_result","_deltaLineNumber","_spaces","_makeSpaces","ViewModelLinesFromProjectedModel","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","wrappingStrategy","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","hiddenAreasDecorationIds","deltaDecorations","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","modelLineProjections","linesContent","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineBreaksComputer","createLineBreaksComputer","injectedTextQueue","lineInjectedText","takeWhile","linesBreaks","values","hiddenAreas","areaId","getDecorationRange","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","isInHiddenArea","line","getVersionId","projectedModelLineLineCounts","ConstantTimePrefixSumComputer","decId","_ranges","newRanges","sortedRanges","currentRangeStart","currentRangeEnd","normalizeLineRanges","validateRange","oldRanges","hasDifference","newDecorations","ModelDecorationOptions","hasVisibleLine","lineChanged","setVisible","newOutputLineCount","setValue","setHiddenAreas","_modelColumn","newTabSize","equalFontInfo","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","onlyWrappingColumnChanged","getProjectionData","outputFromLineNumber","getPrefixSum","outputToLineNumber","removeValues","viewEvents","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","outputLineCount","insertValues","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","getTotalSum","viewLineNumber","viewLineCount","_toValidViewLineNumber","modelPosition","convertViewPositionToModelPosition","getViewLineMinColumn","modelMinPosition","modelMaxPosition","guides","getActiveIndentGuide","viewStartPosition","viewEndPosition","indent","getIndexOf","remainder","ViewLineInfo","viewLineInfo","modelLineWrappedLineIdx","minViewColumn","getModelColumnOfViewPosition","maxViewColumn","getViewLineMaxColumn","viewStartLineNumber","viewEndLineNumber","startViewLine","getViewLineInfo","endViewLine","lastVisibleModelPos","getModelStartPositionOfViewLine","viewLines","curModelLine","lastVisibleModelPos2","ViewLineInfoGroupedByModelRange","getModelEndPositionOfViewLine","activeViewPosition","modelActivePosition","resultPerViewLine","getViewLineInfosGroupedByModelRanges","group","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","isWrappedLineContinuation","getMinColumnOfViewLine","bracketGuides","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","getViewLineNumberOfModelPosition","viewLineEndIndex","option","getLinesIndentGuides","viewIndents","currIndex","blockAtIndex","getViewLineContent","getViewLineLength","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","viewColumn","expectedModelPosition","computedModelColumn","validatePosition","expectedModelRange","validViewStart","validateViewPosition","getStartPosition","validViewEnd","getEndPosition","validPosition","inputLineNumber","lineIndexChanged","getViewPositionOfModelPosition","modelColumn","filterOutValidation","res","finalResult","finalResultLen","prevDecId","getInjectedTextAt","normalizePosition","getLineIndentColumn","lines","_lines","viewPosition","convertViewRangeToModelRange","validateViewRange","modelPositionIsVisible","getModelLineViewLineCount","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","_versionId","_minLineNumber","_maxLineNumber","activePosition","fill","pos","_validPosition","_validRange","_viewPosition","_viewRange","ViewModel","languageConfigurationService","_themeService","_eventDispatcher","ViewModelEventDispatcher","onEvent","cursorConfig","CursorConfiguration","getOptions","_tokenizeViewportSoon","RunOnceScheduler","tokenizeViewport","_updateConfigurationViewLineCount","_updateConfigurationViewLineCountNow","_hasFocus","_viewportStartLine","_viewportStartLineTrackedRange","_viewportStartLineDelta","isTooLargeForTokenization","createCoordinatesConverter","_cursor","CursorsController","schedule","emitSingleViewEvent","emitOutgoingEvent","ScrollChangedEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","_decorations","_registerModelEvents","onDidChangeFast","eventsCollector","beginEmitViewEvents","_onConfigurationChanged","endEmitViewEvents","onDidColorThemeChange","_invalidateDecorationsColorCache","_setTrackedRange","setViewLineCount","linesViewportData","viewVisibleRange","modelVisibleRanges","_toModelVisibleRanges","modelVisibleRange","hasFocus","setHasFocus","FocusChangedEvent","previousViewportStartModelPosition","previousViewportStartViewPosition","restorePreviousViewportStart","setWrappingSettings","emitViewEvent","getCurrentScrollTop","reset","viewPositionTop","setScrollPosition","updateConfiguration","onDidChangeContentOrInjectedText","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","textModelEvents","lineIdx","filter","element","lineBreakQueue","ArrayQueue","onModelFlushed","linesDeletedEvent","onModelLinesDeleted","insertedLineBreaks","takeCount","linesInsertedEvent","onModelLinesInserted","changedLineBreakData","dequeue","onModelLineChanged","linesChangedEvent","acceptVersionId","setModelLineCount","getAttachedEditorCount","_getTrackedRange","onModelContentChanged","onDidChangeTokens","viewRanges","lenJ","tokenizationSupportChanged","onDidChangeLanguageConfiguration","onDidChangeLanguage","onDidChangeOptions","setTabSize","onDidChangeDecorations","onModelDecorationsChanged","linesAround","startViewLineNumber","endViewLineNumber","visibleViewRange","getCompletelyVisibleViewRange","getHiddenAreas","hiddenStartLineNumber","hiddenEndLineNumber","getLinesViewportDataAtScrollTop","compatViewState","saveState","firstViewLineNumber","getLineNumberAtVerticalOffset","firstPosition","firstPositionDeltaTop","state","_reduceRestoreStateCompatibility","viewportStartLineTop","getViewLinesIndentGuides","getViewLinesBracketGuides","getDecorationsViewportData","getTabSize","lineData","toInlineDecoration","getOverviewRulerDecorations","OverviewRulerDecorations","opts","overviewRuler","lane","getColor","accept","asArray","opts1","invalidateCachedColor","opts2","viewAnchorPosition","lineFeedCnt","modelAnchor","getEOL","resultOffset","getOffsetAt","getPositionAt","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","hasEmptyRange","hasNonEmptyRange","modelLineNumbers","prevModelLineNumber","PLAINTEXT_LANGUAGE_ID","fontFamily","_getColorMap","test","EDITOR_FONT_DEFAULTS","replace","mode","fontWeight","fontSize","_getHTMLToCopy","tokenizeLineToHTML","platform","Color","getPrimaryCursorState","getLastAddedCursorIndex","getCursorStates","reason","states","_withViewEventsCollector","setStates","getCursorColumnSelectData","getAutoClosedCharacters","columnSelectData","setCursorColumnSelectData","getPrevEditOperationType","setPrevEditOperationType","getSelection","getSelections","modelState","setSelections","restoreState","context","readOnly","ReadOnlyEditAttemptEvent","edits","cursorStateComputer","_executeCursorEdit","executeEdits","setIsDoingComposition","startComposition","endComposition","replacePrevCharCnt","replaceNextCharCnt","positionDelta","compositionType","pasteOnNewLine","multicursorText","paste","cut","command","executeCommand","commands","executeCommands","revealPrimary","getTopMostViewPosition","getBottomMostViewPosition","_asMap","prevGroup","prevData","prevLane","prevEndLineNumber","_onEvent","_eventHandlers","_viewEventQueue","_isConsumingViewEventQueue","_collector","_collectorCnt","_outgoingEvents","_addOutgoingEvent","_emitOutgoingEvents","kind","shift","isNoOp","warn","ViewModelEventsCollector","outgoingEvents","outgoingEvent","_emitMany","_consumeViewEventQueue","_doConsumeQueue","eventHandlers","handleEvents","oldContentWidth","oldContentHeight","_oldContentWidth","_oldContentHeight","oldHasFocus","_oldScrollWidth","_oldScrollLeft","_oldScrollHeight","_oldScrollTop","CursorStateChangedEvent","oldSelections","oldModelVersionId","modelVersionId","reachedMaxCursorCount","_selectionsAreEqual","equalsSelection"],"sourceRoot":""}