{"version":3,"file":"static/js/monaco-editor-vendor.4ec6fe68.912baec1.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/position.js","../node_modules/monaco-editor/esm/vs/editor/common/core/range.js","../node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js","../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursorCommon.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        asciiMap.fill(defaultValue);\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n    clear() {\n        this._asciiMap.fill(this._defaultValue);\n        this._map.clear();\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n    clear() {\n        return this._actual.clear();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'), true);\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nexport const deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'), false, nls.localize('deprecatedEditorIndentGuides', '\\'editorIndentGuide.background\\' is deprecated. Use \\'editorIndentGuide.background1\\' instead.'));\nexport const deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'), false, nls.localize('deprecatedEditorActiveIndentGuide', '\\'editorIndentGuide.activeBackground\\' is deprecated. Use \\'editorIndentGuide.activeBackground1\\' instead.'));\nexport const editorIndentGuide1 = registerColor('editorIndentGuide.background1', { dark: deprecatedEditorIndentGuides, light: deprecatedEditorIndentGuides, hcDark: deprecatedEditorIndentGuides, hcLight: deprecatedEditorIndentGuides }, nls.localize('editorIndentGuides1', 'Color of the editor indentation guides (1).'));\nexport const editorIndentGuide2 = registerColor('editorIndentGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides2', 'Color of the editor indentation guides (2).'));\nexport const editorIndentGuide3 = registerColor('editorIndentGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides3', 'Color of the editor indentation guides (3).'));\nexport const editorIndentGuide4 = registerColor('editorIndentGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides4', 'Color of the editor indentation guides (4).'));\nexport const editorIndentGuide5 = registerColor('editorIndentGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides5', 'Color of the editor indentation guides (5).'));\nexport const editorIndentGuide6 = registerColor('editorIndentGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides6', 'Color of the editor indentation guides (6).'));\nexport const editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', { dark: deprecatedEditorActiveIndentGuides, light: deprecatedEditorActiveIndentGuides, hcDark: deprecatedEditorActiveIndentGuides, hcLight: deprecatedEditorActiveIndentGuides }, nls.localize('editorActiveIndentGuide1', 'Color of the active editor indentation guides (1).'));\nexport const editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide2', 'Color of the active editor indentation guides (2).'));\nexport const editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide3', 'Color of the active editor indentation guides (3).'));\nexport const editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide4', 'Color of the active editor indentation guides (4).'));\nexport const editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide5', 'Color of the active editor indentation guides (5).'));\nexport const editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide6', 'Color of the active editor indentation guides (6).'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hcDark: deprecatedEditorActiveLineNumber, hcLight: deprecatedEditorActiveLineNumber }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\nexport const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hcDark: rulerRangeDefault, hcLight: rulerRangeDefault }, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', { dark: '#BD9B03', light: '#CEA33D', hcDark: '#ff0000', hcLight: '#CEA33D' }, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', { dark: '#bd9b0326', light: '#cea33d14', hcDark: '#00000000', hcLight: '#cea33d14' }, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRange(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = new LineRangeSet(lineRanges[0].slice());\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n        }\n        return result.ranges;\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    deltaLength(offset) {\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n    toOffsetRange() {\n        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n}\nexport class LineRangeSet {\n    constructor(\n    /**\n     * Sorted by start line number.\n     * No two line ranges are touching or intersecting.\n     */\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        // Idea: Find joinRange such that:\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            // First and last element are different - we need to replace the entire range\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n    subtractFrom(range) {\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return new LineRangeSet([range]);\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n        }\n        return new LineRangeSet(result);\n    }\n    toString() {\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return new LineRangeSet(result);\n    }\n    getWithDelta(value) {\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange {\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return new OffsetRange(start, endExclusive);\n    }\n    static ofLength(length) {\n        return new OffsetRange(0, length);\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    deltaStart(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive);\n    }\n    deltaEnd(offset) {\n        return new OffsetRange(this.start, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    equals(other) {\n        return this.start === other.start && this.endExclusive === other.endExclusive;\n    }\n    containsRange(other) {\n        return this.start <= other.start && other.endExclusive <= this.endExclusive;\n    }\n    contains(offset) {\n        return this.start <= offset && offset < this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return new OffsetRange(start, end);\n        }\n        return undefined;\n    }\n    slice(arr) {\n        return arr.slice(this.start, this.endExclusive);\n    }\n    /**\n     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n     * The range must not be empty.\n     */\n    clip(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n    }\n    /**\n     * Returns `r := value + k * length` such that `r` is contained in this range.\n     * The range must not be empty.\n     *\n     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n     */\n    clipCyclic(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        if (value < this.start) {\n            return this.endExclusive - ((this.start - value) % this.length);\n        }\n        if (value >= this.endExclusive) {\n            return this.start + ((value - this.start) % this.length);\n        }\n        return value;\n    }\n    forEach(f) {\n        for (let i = this.start; i < this.endExclusive; i++) {\n            f(i);\n        }\n    }\n}\nexport class OffsetRangeSet {\n    constructor() {\n        this._sortedRanges = [];\n    }\n    addRange(range) {\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            this._sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, this._sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n            this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    toString() {\n        return this._sortedRanges.map(r => r.toString()).join(', ');\n    }\n    /**\n     * Returns of there is a value that is contained in this instance and the given range.\n     */\n    intersectsStrict(other) {\n        // TODO use binary search\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n            i++;\n        }\n        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n    }\n    intersectWithRange(other) {\n        // TODO use binary search + slice\n        const result = new OffsetRangeSet();\n        for (const range of this._sortedRanges) {\n            const intersection = range.intersect(other);\n            if (intersection) {\n                result.addRange(intersection);\n            }\n        }\n        return result;\n    }\n    intersectWithRangeLength(other) {\n        return this.intersectWithRange(other).length;\n    }\n    get length() {\n        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\nRGBA8.Empty = new RGBA8(0, 0, 0, 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators) {\n        super(0 /* WordCharacterClass.Regular */);\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n}\nfunction once(computeFn) {\n    const cache = {}; // TODO@Alex unbounded cache\n    return (input) => {\n        if (!cache.hasOwnProperty(input)) {\n            cache[input] = computeFn(input);\n        }\n        return cache[input];\n    };\n}\nexport const getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        if (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n            // Avoid selecting text when recovering from markers\n            return Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n        }\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy } from '../../../base/common/arrays.js';\nimport { findLastMaxBy, findFirstMinBy } from '../../../base/common/arraysFind.js';\nimport { CursorState } from '../cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findFirstMinBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMaxBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CursorContext {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        this._cursorContextBrand = undefined;\n        this.model = model;\n        this.viewModel = viewModel;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealPrimary(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../core/cursorColumns.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Direction.Left */:\n                left = true;\n                break;\n            case 1 /* Direction.Right */:\n                left = false;\n                break;\n            case 2 /* Direction.Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* CharCode.Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* CharCode.Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 2 /* SelectionStartKind.Line */, 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(true, viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(true, selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(true, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        if (inSelectionMode) {\n            if (cursor.modelState.selectionStartKind === 1 /* SelectionStartKind.Word */) {\n                return this.word(viewModel, cursor, inSelectionMode, _position);\n            }\n            if (cursor.modelState.selectionStartKind === 2 /* SelectionStartKind.Line */) {\n                return this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n            }\n        }\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.description = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let i = 0;\n        let r;\n        do {\n            r = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n            const np = model.normalizePosition(new Position(r.lineNumber, r.column), 2 /* PositionAffinity.None */);\n            if (np.lineNumber > lineNumber) {\n                break;\n            }\n        } while (i++ < 10 && lineNumber + i < model.getLineCount());\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n            if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        let autoCloseConfig;\n        let shouldAutoCloseBefore;\n        const chIsQuote = isQuote(ch);\n        if (chIsQuote) {\n            autoCloseConfig = config.autoClosingQuotes;\n            shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n        }\n        else {\n            const pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n            if (pairIsForComments) {\n                autoCloseConfig = config.autoClosingComments;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n            }\n            else {\n                autoCloseConfig = config.autoClosingBrackets;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n            }\n        }\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './core/position.js';\nimport { Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { createScopedLineTokens } from './languages/supports.js';\nimport { CursorColumns } from './core/cursorColumns.js';\nimport { normalizeIndentation } from './core/indentation.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    static shouldRecreate(e) {\n        return (e.hasChanged(143 /* EditorOption.layoutInfo */)\n            || e.hasChanged(129 /* EditorOption.wordSeparators */)\n            || e.hasChanged(37 /* EditorOption.emptySelectionClipboard */)\n            || e.hasChanged(76 /* EditorOption.multiCursorMergeOverlapping */)\n            || e.hasChanged(78 /* EditorOption.multiCursorPaste */)\n            || e.hasChanged(79 /* EditorOption.multiCursorLimit */)\n            || e.hasChanged(6 /* EditorOption.autoClosingBrackets */)\n            || e.hasChanged(7 /* EditorOption.autoClosingComments */)\n            || e.hasChanged(11 /* EditorOption.autoClosingQuotes */)\n            || e.hasChanged(9 /* EditorOption.autoClosingDelete */)\n            || e.hasChanged(10 /* EditorOption.autoClosingOvertype */)\n            || e.hasChanged(14 /* EditorOption.autoSurround */)\n            || e.hasChanged(127 /* EditorOption.useTabStops */)\n            || e.hasChanged(50 /* EditorOption.fontInfo */)\n            || e.hasChanged(90 /* EditorOption.readOnly */));\n    }\n    constructor(languageId, modelOptions, configuration, languageConfigurationService) {\n        var _a;\n        this.languageConfigurationService = languageConfigurationService;\n        this._cursorMoveConfigurationBrand = undefined;\n        this._languageId = languageId;\n        const options = configuration.options;\n        const layoutInfo = options.get(143 /* EditorOption.layoutInfo */);\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        this.readOnly = options.get(90 /* EditorOption.readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(115 /* EditorOption.stickyTabStops */);\n        this.lineHeight = fontInfo.lineHeight;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(127 /* EditorOption.useTabStops */);\n        this.wordSeparators = options.get(129 /* EditorOption.wordSeparators */);\n        this.emptySelectionClipboard = options.get(37 /* EditorOption.emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(25 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(76 /* EditorOption.multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(78 /* EditorOption.multiCursorPaste */);\n        this.multiCursorLimit = options.get(79 /* EditorOption.multiCursorLimit */);\n        this.autoClosingBrackets = options.get(6 /* EditorOption.autoClosingBrackets */);\n        this.autoClosingComments = options.get(7 /* EditorOption.autoClosingComments */);\n        this.autoClosingQuotes = options.get(11 /* EditorOption.autoClosingQuotes */);\n        this.autoClosingDelete = options.get(9 /* EditorOption.autoClosingDelete */);\n        this.autoClosingOvertype = options.get(10 /* EditorOption.autoClosingOvertype */);\n        this.autoSurround = options.get(14 /* EditorOption.autoSurround */);\n        this.autoIndent = options.get(12 /* EditorOption.autoIndent */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: this._getShouldAutoClose(languageId, this.autoClosingQuotes, true),\n            comment: this._getShouldAutoClose(languageId, this.autoClosingComments, false),\n            bracket: this._getShouldAutoClose(languageId, this.autoClosingBrackets, false),\n        };\n        this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoClosingPairs();\n        const surroundingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getSurroundingPairs();\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n        const commentsConfiguration = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        this.blockCommentStartToken = (_a = commentsConfiguration === null || commentsConfiguration === void 0 ? void 0 : commentsConfiguration.blockCommentStartToken) !== null && _a !== void 0 ? _a : null;\n    }\n    get electricChars() {\n        var _a;\n        if (!this._electricChars) {\n            this._electricChars = {};\n            const electricChars = (_a = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || _a === void 0 ? void 0 : _a.getElectricCharacters();\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        const electricCharacterSupport = this.languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).electricCharacter;\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    normalizeIndentation(str) {\n        return normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    _getShouldAutoClose(languageId, autoCloseConfig, forQuotes) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return this._getLanguageDefinedShouldAutoClose(languageId, forQuotes);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    _getLanguageDefinedShouldAutoClose(languageId, forQuotes) {\n        const autoCloseBeforeSet = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoCloseBeforeSet(forQuotes);\n        return c => autoCloseBeforeSet.indexOf(c) !== -1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    visibleColumnFromColumn(model, position) {\n        return CursorColumns.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, this.tabSize);\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    columnFromVisibleColumn(model, lineNumber, visibleColumn) {\n        const result = CursorColumns.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, this.tabSize);\n        const minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n}\nexport class CursorState {\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selection = Selection.liftSelection(modelSelection);\n        const modelState = new SingleCursorState(Range.fromPositions(selection.getSelectionStart()), 0 /* SelectionStartKind.Simple */, 0, selection.getPosition(), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        const states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    constructor(modelState, viewState) {\n        this._cursorStateBrand = undefined;\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this.selectionStart = selectionStart;\n        this.selectionStartKind = selectionStartKind;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this._singleCursorStateBrand = undefined;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.selectionStartKind === other.selectionStartKind\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        if (selectionStart.isEmpty() || !position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n            return Selection.fromPositions(selectionStart.getStartPosition(), position);\n        }\n        else {\n            return Selection.fromPositions(selectionStart.getEndPosition(), position);\n        }\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this._editOperationResultBrand = undefined;\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n"],"names":["CharacterClassifier","_defaultValue","_classCallCheck","defaultValue","toUint8","this","_asciiMap","_createAsciiMap","_map","Map","_createClass","key","value","charCode","_value","set","get","fill","clear","asciiMap","Uint8Array","CharacterSet","_actual","CursorColumns","codePoint","visibleColumn","tabSize","nextRenderTabStop","strings","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","offset","nextGraphemeLength","_nextVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","indentSize","max","EditOperation","position","range","Range","lineNumber","forceMoveMarkers","editorLineHighlight","registerColor","dark","light","hcDark","hcLight","nls","editorLineHighlightBorder","contrastBorder","editorCursorForeground","activeContrastBorder","editorFindMatchHighlight","Color","black","white","editorCursorBackground","editorWhitespaces","editorLineNumbers","deprecatedEditorIndentGuides","deprecatedEditorActiveIndentGuides","editorIndentGuide1","editorIndentGuide2","editorIndentGuide3","editorIndentGuide4","editorIndentGuide5","editorIndentGuide6","editorActiveIndentGuide1","editorActiveIndentGuide2","editorActiveIndentGuide3","editorActiveIndentGuide4","editorActiveIndentGuide5","editorActiveIndentGuide6","deprecatedEditorActiveLineNumber","editorDimmedLineNumber","editorOverviewRulerBorder","lightgrey","editorOverviewRulerBackground","editorUnnecessaryCodeOpacity","editorBackground","fromHex","transparent","rulerRangeDefault","RGBA","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","editorWarningForeground","editorWarningBorder","overviewRulerInfo","editorInfoForeground","editorInfoBorder","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","registerThemingParticipant","theme","collector","background","getColor","lineHighlight","imeBackground","isTransparent","addRule","concat","countEOL","eolCount","firstLineLength","lastLineStart","i","len","chr","charCodeAt","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","spacesCnt","charAt","nextIndentTabStop","tabsCnt","floor","_normalizeIndentationFromWhitespace","LineRange","startLineNumber","endLineNumberExclusive","BugIndicatingError","other","b","isEmpty","Number","MAX_SAFE_INTEGER","f","push","OffsetRange","endLineNumber","lineRanges","LineRangeSet","slice","getUnion","ranges","lineRange","_normalizedRanges","arguments","undefined","joinRangeStartIdx","findFirstIdxMonotonousOrArrLen","r","joinRangeEndIdxExclusive","findLastIdxMonotonous","splice","joinRange","join","rangeThatStartsBeforeEnd","findLastMonotonous","i1","i2","current","next","lineRange1","lineRange2","map","toString","r1","r2","intersect","delta","start","endExclusive","end","arr","sortedRanges","j","OffsetRangeSet","_sortedRanges","_step","_iterator","_createForOfIteratorHelper","s","n","done","intersection","addRange","err","e","intersectWithRange","reduce","prev","cur","Position","newLineNumber","newColumn","deltaLineNumber","deltaColumn","with","equals","isBefore","isBeforeOrEqual","a","aLineNumber","bLineNumber","pos","obj","startColumn","endColumn","containsPosition","containsRange","strictContainsRange","plusRange","intersectRanges","equalsRange","getEndPosition","getStartPosition","collapseToStart","collapseToEnd","lineCount","otherRange","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","RGBA8","g","_rgba8Brand","_clamp","c","Empty","Selection","_Range","_inherits","_super","_createSuper","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_this","call","selectionsEqual","getDirection","direction","sel","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","platform","decodeUTF16LE","source","view","Uint16Array","buffer","resultLen","String","fromCharCode","compatDecodeUTF16LE","decode","StringBuilder","capacity","_capacity","_buffer","_completedStrings","_bufferLength","_flushBuffer","_buildBuffer","bufferString","remainingSpace","strLen","escapeNewLine","replace","TextChange","oldPosition","oldText","newPosition","newText","_writeStringSize","_writeString","dest","_readString","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","oldEnd","_acceptCurr","newEnd","_acceptPrev","_TextChangeCompressor","_splitCurr","_TextChangeCompressor2","_slicedToArray","e1","e2","_TextChangeCompressor3","_splitPrev","_TextChangeCompressor4","mergePrev","mergeCurr","_TextChangeCompressor5","oldLength","_TextChangeCompressor6","_TextChangeCompressor7","newLength","_TextChangeCompressor8","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","curr","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","independentColorPoolPerBracketType","WordCharacterClassifier","_CharacterClassifier","wordSeparators","getMapForWordSeparators","computeFn","cache","input","hasOwnProperty","once","USUAL_WORD_SEPARATORS","DEFAULT_WORD_REGEXP","allowInWords","sep","indexOf","RegExp","createWordRegExp","ensureValidWordDefinition","wordDefinition","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","LinkedList","getWordAtText","textOffset","config","Iterable","first","maxLen","t1","Date","now","prevRegexIndex","match","timeBudget","regexIndex","windowSize","thisMatch","_findRegexMatchEnclosingPosition","word","index","stopPos","exec","matchIndex","unshift","Cursor","context","_selTrackedRange","_trackSelection","_setState","SingleCursorState","_removeTrackedRange","_updateTrackedRange","model","_setTrackedRange","modelState","selection","CursorState","viewState","_getTrackedRange","fromRange","_validateViewState","viewModel","selectionStart","validateRange","selectionStartLeftoverVisibleColumns","validatePosition","leftoverVisibleColumns","selectionStartKind","coordinatesConverter","convertViewRangeToModelRange","convertViewPositionToModelPosition","viewSelectionStart","validateViewRange","viewPosition","validateViewPosition","viewSelectionStart1","convertModelPositionToViewPosition","viewSelectionStart2","cacheInput","cacheOutput","normalizePosition","sStartPosition","sEndPosition","validPosition","validSStartPosition","_validatePositionWithCache","validSEndPosition","fromPositions","CursorCollection","cursors","lastAddedCursorIndex","dispose","_step2","_iterator2","startTrackingSelection","_step3","_iterator3","stopTrackingSelection","_step4","_iterator4","ensureValidState","readSelectionFromMarkers","asCursorState","findFirstMinBy","compareBy","compare","findLastMaxBy","selections","setStates","fromModelSelections","states","setState","_setSecondaryStates","secondaryStates","secondaryCursorsLength","secondaryStatesLength","createCnt","_addSecondaryCursor","removeCnt","_removeSecondaryCursor","removeIndex","sortedCursors","sort","compareRangesUsingStarts","sortedCursorIndex","currentSelection","nextSelection","cursorConfig","multiCursorMergeOverlapping","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","equalsSelection","resultingRange","looserSelectionIsLTR","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingSelection","resultingState","fromModelSelection","_step5","_iterator5","sortedCursor","CursorContext","_cursorContextBrand","CursorsController","_Disposable","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","_cursors","_hasFocus","_isHandling","_compositionState","_columnSelectData","_autoClosedActions","_prevEditOperationType","_get","_getPrototypeOf","prototype","updateContext","eventsCollector","getCursorStates","hasFocus","getSelections","autoClosedAction","isValid","getPrimaryCursor","getLastAddedCursorIndex","getAll","reason","reachedMaxCursorCount","multiCursorLimit","oldState","CursorModelState","from","normalize","_validateAutoClosedActions","_emitStateChangedIfNecessary","columnSelectData","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","emitViewEvent","ViewRevealRangeRequestEvent","inSelectionMode","desiredSelections","state","revealPrimary","event","ModelInjectedTextChangedEvent","rawContentChangedEvent","versionId","hadFlushEvent","containsEvent","cursorState","isUndoing","isRedoing","selectionsFromMarkers","getTopMostViewPosition","getBottomMostViewPosition","primaryCursor","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","type","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","TypeWithAutoClosingCommand","enclosingRange","closeCharacterRange","_pushAutoClosedAction","shouldPushStackElementAfter","setSelections","newState","viewSelections","ViewCursorStateChangedEvent","some","newCursorState","oldSelections","oldModelVersionId","modelVersionId","emitOutgoingEvent","CursorStateChangedEvent","indices","m","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","cursorStateComputer","_this2","autoClosingIndices","_findAutoClosingPairs","_isTracked","pushEditOperations","undoEdits","_autoClosingIndices$i","openCharInnerIndex","closeCharInnerIndex","undoEdit","callback","cursorChangeReason","readOnly","stopTrackingSelections","onUnexpectedError","startTrackingSelections","getAllAutoClosedCharacters","CompositionState","_this3","compositionOutcome","deduceOutcome","_executeEdit","_executeEditOperation","TypeOperations","compositionEndWithInterceptors","getAutoClosedCharacters","_this4","charLength","typeWithInterceptors","typeWithoutInterceptors","replacePrevCharCnt","replaceNextCharCnt","positionDelta","_this5","compositionType","newSelections","getPosition","pasteOnNewLine","multicursorText","_this6","paste","_this7","DeleteOperations","cut","_this8","killSecondaryCursors","EditOperationResult","_this9","Disposable","cursor","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","decorationRange","getDecorationRange","enclosingRanges","autoClosedActions","autoClosedCharacters","getAutoClosedCharactersRanges","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","console","warn","filteredOperations","identifier","major","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","minor","cursorSelections","_loop","_i3","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","losingCursors","losingCursorIndex","_i4","_losingCursors","losingCursor","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","isAutoWhitespaceEdit","insertsAutoWhitespace","editOperationBuilder","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","loserMajor","CompositionLineState","startSelection","endSelection","textModel","_original","_capture","_deduceOutcome","getLineContent","original","commonPrefix","commonSuffix","deletedText","insertedText","CompositionOutcome","AtomicTabMoveOperations","lineLength","prevTabStopPosition","prevTabStopVisibleColumn","left","_AtomicTabMoveOperati","whitespaceVisibleColumn","_AtomicTabMoveOperati2","currentVisibleColumn","targetVisibleColumn","ColumnSelection","fromLineNumber","fromVisibleColumn","toLineNumber","toVisibleColumn","abs","reversed","isRTL","isLTR","columnFromVisibleColumn","visibleStartColumn","visibleEndColumn","maxColumn","viewStates","fromVisualColumn","toVisualColumn","prevColumnSelectData","columnSelect","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","isPaged","linesCount","pageSize","getLineCount","prevEditOperationType","deleteSelection","rightOfPosition","MoveOperations","right","ReplaceCommand","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","lineText","character","autoClosingPairCandidates","isQuote","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","close","found","lenJ","autoClosedCharacter","isAutoClosingPairDelete","autoClosingPairsOpenByEnd","_runAutoClosingPairDelete","deleteRange","getDeleteRange","useTabStops","lastIndentationColumn","prevIndentTabStop","toColumn","getPositionAfterDeleteLeft","newLine","lastCutRange","emptySelectionClipboard","CursorMove","CursorMoveCommands","useLogicalLine","fromModelState","translateDown","fromViewState","translateUp","_moveToLineStart","currentViewStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","firstNonBlankColumn","getLineFirstNonWhitespaceColumn","_moveToLineStartByModel","_moveToLineStartByView","moveToBeginningOfLine","sticky","_moveToLineEnd","viewStatePosition","viewModelMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_moveToLineEndByModel","_moveToLineEndByView","moveToEndOfLine","moveToBeginningOfBuffer","moveToEndOfBuffer","_position","_viewPosition","selectToLineNumber","selectToColumn","enteringLineNumber","move","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","WordOperations","hasSelection","line","unit","_moveHalfLineLeft","_moveLeft","_moveHalfLineRight","_moveRight","_moveUpByViewLines","_moveUpByModelLines","_moveDownByViewLines","_moveDownByModelLines","moveToPrevBlankLine","moveToNextBlankLine","_moveToViewMinColumn","_moveToViewFirstNonWhitespaceColumn","_moveToViewCenterColumn","_moveToViewMaxColumn","_moveToViewLastNonWhitespaceColumn","visibleViewRange","getCompletelyVisibleViewRange","visibleModelRange","modelLineNumber","_firstLineNumberInRange","modelColumn","_moveToModelPosition","_lastLineNumberInRange","round","findPositionInViewportIfOutside","newViewLineNumber","viewLineNumber","vertical","count","getLineMinColumn","noOfColumns","moveLeft","halfLine","moveRight","moveDown","moveUp","toViewColumn","toModelLineNumber","toModelColumn","viewColumn","_moveToViewPosition","getLineLastNonWhitespaceColumn","args","name","constraint","arg","types","cursorMoveArg","to","select","by","schema","RawDirection","Left","Right","Up","Down","PrevBlankLine","NextBlankLine","WrappedLineStart","WrappedLineFirstNonWhitespaceCharacter","WrappedLineColumnCenter","WrappedLineEnd","WrappedLineLastNonWhitespaceCharacter","ViewPortTop","ViewPortCenter","ViewPortBottom","ViewPortIfOutside","RawUnit","Line","WrappedLine","Character","HalfLine","parse","CursorPosition","_cursorPositionBrand","getLineIndentColumn","minColumn","atomicPosition","leftPosition","stickyTabStops","leftPositionAtomicSoftTabs","normalizedPos","clipPositionColumn","p","clipRange","rightPosition","rightPositionAtomicSoftTabs","allowMoveOnEdgeLine","normalizationAffinity","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","allowMoveOnLastLine","down","allowMoveOnFirstLine","up","_isBlankLine","lastLineNumber","lastColumn","ShiftCommand","isUnshift","autoIndent","languageConfigurationService","indentation","shiftIndent","unshiftIndent","typeSelection","ReplaceCommandThatPreservesSelection","multiCursorPaste","lines","distributedPaste","_distributePasteToCursors","_distributedPaste","_simplePaste","action","expectedIndentAction","getInheritIndentForLine","expectedEnterAction","getEnterAction","appendText","IndentAction","Indent","Outdent","typeText","test","tokenization","isCheapToTokenize","goodIndent","_goodIndentForLine","possibleTypeText","startsWith","_replaceJumpToNextIndent","lineMaxColumn","_compositionType","shouldPushStackElementBetween","getValueInRange","ReplaceCommandWithOffsetCursorState","keepPosition","ReplaceCommandWithoutChangingPosition","_typeCommand","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","indent","oldEndViewColumn","oldEndColumn","newLineContent","firstNonWhitespace","setEndPosition","afterEnter","ceil","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","autoClosingOvertype","has","chIsQuote","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","x","isBeforeClosingBrace","positions","candidates","candidate","candidateIsMatch","pair","lastChar","autoClosingPairsCloseByEnd","includes","endsWith","chIsAlreadyTyped","autoCloseConfig","shouldAutoCloseBefore","_findAutoClosingPairOpen","quote","blockCommentStartToken","autoClosingComments","comment","bracket","containedPair","_findContainedAutoClosingPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","_isBeforeClosingBrace","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","autoClosingPairClose","autoSurround","_shouldSurroundChar","surroundingPairs","_step6","isTypingAQuoteCharacter","_iterator6","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","closeCharacter","SurroundSelectionCommand","electricChars","electricAction","onElectricCharacter","matchOpenBracket","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","getTypingOperation","compositions","_step7","_iterator7","composition","_step8","hasDeletion","_iterator8","_step9","_iterator9","deletedSelectionStart","deletedSelectionEnd","_step10","_iterator10","CompositionSurroundSelectionCommand","_isAutoClosingOvertype","_getAutoClosingPairClose","_runAutoClosingOpenCharType","isDoingComposition","_enter","_isAutoIndentType","autoIndentFails","_runAutoIndentType","_runAutoClosingOvertype","_isSurroundSelectionType","_runSurroundSelectionType","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","opType","_ReplaceCommandWithOf","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","helper","insertedSelectionStart","insertedSelectionEnd","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","wordType","nextCharClass","_doFindPreviousWordOnLine","chIndex","chCode","chClass","_createWord","_findEndOfWord","_doFindNextWordOnLine","_findStartOfWord","wordNavigationType","prevWordOnLine","_findPreviousWordOnLine","rightRight","movedDown","nextWordOnLine","_findNextWordOnLine","lastNonWhitespace","whitespaceHeuristics","_deleteWordLeftWhitespace","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","leftIndex","_charAtIsWhitespace","rightIndex","touchesWord","createRangeWithPosition","deleteWordAndAdjacentWhitespace","expandedToTheRight","toPosition","_moveWordPartLeft","_findFirstNonWhitespaceChar","_deleteWordRightWhitespace","_moveWordPartRight","_wordSeparators","prevWord","_createWordAtPosition","nextWord","possiblePosition","WordPartOperations","_WordOperations","apply","enforceDefined","deleteWordLeft","_deleteWordPartLeft","deleteWordRight","_deleteWordPartRight","moveWordLeft","moveWordRight","filter","el","Boolean","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","CursorConfiguration","languageId","modelOptions","configuration","_a","_cursorMoveConfigurationBrand","_languageId","layoutInfo","fontInfo","lineHeight","typicalHalfwidthCharacterWidth","height","copyWithSyntaxHighlighting","_electricChars","_getShouldAutoClose","getLanguageConfiguration","getAutoClosingPairs","getSurroundingPairs","commentsConfiguration","comments","electricCharacter","getElectricCharacters","char","electricCharacterSupport","forQuotes","_getLanguageDefinedShouldAutoClose","autoCloseBeforeSet","getAutoCloseBeforeSet","hasChanged","_cursorStateBrand","PartialModelCursorState","PartialViewCursorState","modelSelection","getSelectionStart","modelSelections","_singleCursorStateBrand","_computeSelection","opts","_editOperationResultBrand"],"sourceRoot":""}