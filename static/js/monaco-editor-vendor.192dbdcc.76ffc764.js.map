{"version":3,"file":"static/js/monaco-editor-vendor.192dbdcc.76ffc764.js","mappings":"0OAIaA,GAAWC,EAAAA,EAAAA,IACpB,SAAAD,EAAYE,EAEZC,EAAcC,EAAgCC,IAAWC,EAAAA,EAAAA,GAAA,KAAAN,GACrDO,KAAKL,MAAQA,EACbK,KAAKJ,aAAeA,EACpBI,KAAKH,+BAAiCA,EACtCG,KAAKF,UAAYA,CACrB,IAiBSG,EAAiC,SAAAC,IAAAC,EAAAA,EAAAA,GAAAF,EAAAC,GAAA,IAAAE,GAAAC,EAAAA,EAAAA,GAAAJ,GAC1C,SAAAA,EAAYN,EAAOW,EAAqBC,EAIxCX,EAAcC,EAAgCW,EAI9CC,GAA6B,IAAAC,EAEsC,OAFtCX,EAAAA,EAAAA,GAAA,KAAAE,IACzBS,EAAAN,EAAAO,KAAA,KAAMhB,EAAOW,EAAqBC,EAAqBX,EAAcC,EAAgCW,IAChGC,4BAA8BA,EAA4BC,CACnE,CAAC,OAAAhB,EAAAA,EAAAA,GAAAO,EAAA,CAZyC,CAflB,WACxB,SAAAW,EAAYjB,EAAOW,EAAqBC,EAExCX,EAAcC,EAAgCW,IAAiBT,EAAAA,EAAAA,GAAA,KAAAa,GAC3DZ,KAAKL,MAAQA,EACbK,KAAKM,oBAAsBA,EAC3BN,KAAKO,oBAAsBA,EAC3BP,KAAKJ,aAAeA,EACpBI,KAAKH,+BAAiCA,EACtCG,KAAKQ,gBAAkBA,CAC3B,CAGC,OAHAd,EAAAA,EAAAA,GAAAkB,EAAA,EAAAC,IAAA,qBAAAC,IACD,WACI,OAAOd,KAAKQ,gBAAgBO,eAAeC,WAC/C,KAACJ,CAAA,CAbuB,G,8RCNfK,GAAavB,EAAAA,EAAAA,IACtB,SAAAuB,KAAclB,EAAAA,EAAAA,GAAA,KAAAkB,GACVjB,KAAKkB,WAAa,CACtB,IAMSC,EAAgB,WAoCzB,SAAAA,EAAYC,EAASC,EAAYC,EAAQC,EAASC,IAAOzB,EAAAA,EAAAA,GAAA,KAAAoB,GACrDnB,KAAKoB,QAAUA,EACfpB,KAAKqB,WAAaA,EAClBrB,KAAKsB,OAASA,EACdtB,KAAKuB,QAAUA,EACfvB,KAAKwB,MAAQA,CACjB,CAPC,OAOA9B,EAAAA,EAAAA,GAAAyB,EAAA,OAAAN,IAAA,oBAAAY,MAzCD,SAAyBC,EAAUC,GAC/B,IAAKA,GAA0C,IAAzBA,EAAcC,OAChC,OAAOF,EAEX,IAEwCG,EAFpCC,EAAS,GACTC,EAAqB,EAAEC,GAAAC,EAAAA,EAAAA,GACAN,GAAa,IAAxC,IAAAK,EAAAE,MAAAL,EAAAG,EAAAG,KAAAC,MAA0C,KAA/BC,EAAYR,EAAAJ,MACnBK,GAAUJ,EAASY,UAAUP,EAAoBM,EAAaf,OAAS,GACvES,EAAqBM,EAAaf,OAAS,EAC3CQ,GAAUO,EAAad,QAAQgB,OACnC,CAAC,OAAAC,GAAAR,EAAAS,EAAAD,EAAA,SAAAR,EAAAU,GAAA,CAED,OADAZ,GAAUJ,EAASY,UAAUP,EAEjC,GAAC,CAAAlB,IAAA,kBAAAY,MACD,SAAuBkB,GACnB,IACoCC,EAD9Bd,EAAS,GAAGe,GAAAZ,EAAAA,EAAAA,GACOU,GAAW,IAApC,IAAAE,EAAAX,MAAAU,EAAAC,EAAAV,KAAAC,MAAsC,KAA3BU,EAAUF,EAAAnB,MACbqB,EAAWvB,QAAQwB,QAAUD,EAAWvB,QAAQwB,OAAOR,QAAQX,OAAS,GACxEE,EAAOkB,KAAK,IAAI7B,EAAiB2B,EAAW1B,QAAS0B,EAAWnD,MAAMsD,gBAAiBH,EAAWnD,MAAMuD,YAAaJ,EAAWvB,QAAQwB,OAAQ,IAEhJD,EAAWvB,QAAQ4B,OAASL,EAAWvB,QAAQ4B,MAAMZ,QAAQX,OAAS,GACtEE,EAAOkB,KAAK,IAAI7B,EAAiB2B,EAAW1B,QAAS0B,EAAWnD,MAAMyD,cAAeN,EAAWnD,MAAM0D,UAAWP,EAAWvB,QAAQ4B,MAAO,GAEnJ,CAAC,OAAAX,GAAAK,EAAAJ,EAAAD,EAAA,SAAAK,EAAAH,GAAA,CAUD,OATAZ,EAAOwB,MAAK,SAACC,EAAGC,GACZ,OAAID,EAAElC,aAAemC,EAAEnC,WACfkC,EAAEjC,SAAWkC,EAAElC,OACRiC,EAAE/B,MAAQgC,EAAEhC,MAEhB+B,EAAEjC,OAASkC,EAAElC,OAEjBiC,EAAElC,WAAamC,EAAEnC,UAC5B,IACOS,CACX,KAACX,CAAA,CAnCwB,GAgDhBsC,GAAmB/D,EAAAA,EAAAA,IAC5B,SAAA+D,EAAYpC,EAAYqC,EAAQrB,IAActC,EAAAA,EAAAA,GAAA,KAAA0D,GAC1CzD,KAAKkB,WAAa,EAClBlB,KAAKqB,WAAaA,EAClBrB,KAAK0D,OAASA,EACd1D,KAAKqC,aAAeA,CACxB,IAMSsB,GAAoBjE,EAAAA,EAAAA,IAC7B,SAAAiE,EAAYC,EAAgBC,IAAc9D,EAAAA,EAAAA,GAAA,KAAA4D,GACtC3D,KAAKkB,WAAa,EAClBlB,KAAK4D,eAAiBA,EACtB5D,KAAK6D,aAAeA,CACxB,IAMSC,GAAqBpE,EAAAA,EAAAA,IAC9B,SAAAoE,EAAYF,EAAgBC,EAAcH,EAAQ/B,IAAe5B,EAAAA,EAAAA,GAAA,KAAA+D,GAC7D9D,KAAKkB,WAAa,EAClBlB,KAAK2B,cAAgBA,EACrB3B,KAAK4D,eAAiBA,EACtB5D,KAAK6D,aAAeA,EACpB7D,KAAK0D,OAASA,CAClB,IAMSK,GAAkBrE,EAAAA,EAAAA,IAC3B,SAAAqE,KAAchE,EAAAA,EAAAA,GAAA,KAAAgE,GACV/D,KAAKkB,WAAa,CACtB,IAMS8C,EAA2B,WACpC,SAAAA,EAAYC,EAASC,EAAWC,EAAWC,IAAWrE,EAAAA,EAAAA,GAAA,KAAAiE,GAClDhE,KAAKiE,QAAUA,EACfjE,KAAKkE,UAAYA,EACjBlE,KAAKmE,UAAYA,EACjBnE,KAAKoE,UAAYA,EACjBpE,KAAKqE,mBAAqB,IAC9B,CAgBC,OAhBA3E,EAAAA,EAAAA,GAAAsE,EAAA,EAAAnD,IAAA,gBAAAY,MACD,SAAc6C,GACV,IAAK,IAAIC,EAAI,EAAGC,EAAMxE,KAAKiE,QAAQrC,OAAQ2C,EAAIC,EAAKD,IAAK,CAErD,GADevE,KAAKiE,QAAQM,GACjBrD,aAAeoD,EACtB,OAAO,CAEf,CACA,OAAO,CACX,IAAC,EAAAzD,IAAA,QAAAY,MACD,SAAa8B,EAAGC,GAKZ,OAAO,IAAIQ,EAJK,GAAGS,OAAOlB,EAAEU,SAASQ,OAAOjB,EAAES,SAC5BT,EAAEU,UACDX,EAAEY,WAAaX,EAAEW,UACjBZ,EAAEa,WAAaZ,EAAEY,UAExC,KAACJ,CAAA,CAvBmC,GA6B3BU,GAA6BhF,EAAAA,EAAAA,IACtC,SAAAgF,EAAYT,IAASlE,EAAAA,EAAAA,GAAA,KAAA2E,GACjB1E,KAAKiE,QAAUA,CACnB,IAKSU,EAA+B,WACxC,SAAAA,EAAYC,EAAwBC,IAAqB9E,EAAAA,EAAAA,GAAA,KAAA4E,GACrD3E,KAAK4E,uBAAyBA,EAC9B5E,KAAK6E,oBAAsBA,CAC/B,CAuBC,OAvBAnF,EAAAA,EAAAA,GAAAiF,EAAA,EAAA9D,IAAA,QAAAY,MACD,SAAMqD,GACF,IAAMF,EAAyBZ,EAA4Be,MAAM/E,KAAK4E,uBAAwBE,EAAMF,wBAC9FC,EAAsBF,EAAgCK,mBAAmBhF,KAAK6E,oBAAqBC,EAAMD,qBAC/G,OAAO,IAAIF,EAAgCC,EAAwBC,EACvE,IAAC,EAAAhE,IAAA,qBAAAY,MACD,SAA0B8B,EAAGC,GACzB,IAAMS,EAAU,GAAGQ,OAAOlB,EAAEU,SAASQ,OAAOjB,EAAES,SACxCgB,EAAMzB,EAAEyB,IACRf,EAAYV,EAAEU,UACdC,EAAaZ,EAAEY,WAAaX,EAAEW,UAC9BC,EAAab,EAAEa,WAAaZ,EAAEY,UAC9Bc,EAAW3B,EAAE2B,SAAW1B,EAAE0B,QAEhC,MAAO,CACHjB,QAASA,EACTgB,IAAKA,EACLE,YAJgB5B,EAAE4B,aAAe3B,EAAE2B,YAKnCjB,UAAWA,EACXC,UAAWA,EACXC,UAAWA,EACXc,QAASA,EAEjB,KAACP,CAAA,CA3BuC,E,6GC/IjCS,E,uBACX,SAAWA,GACPA,EAAsBA,EAAgC,SAAI,GAAK,WAC/DA,EAAsBA,EAAwC,iBAAI,GAAK,mBACvEA,EAAsBA,EAA+B,QAAI,GAAK,SACjE,CAJD,CAIGA,IAA0BA,EAAwB,CAAC,IAC/C,IAAMC,GAAW3F,EAAAA,EAAAA,IACpB,SAAA2F,EAAYC,EAAehE,EAAQiE,EAKnCC,EAIAC,EAA4BC,GAOxB,IAPyD3F,EAAAA,EAAAA,GAAA,KAAAsF,GACzDrF,KAAKsF,cAAgBA,EACrBtF,KAAKsB,OAASA,EACdtB,KAAKuF,UAAYA,EACjBvF,KAAKwF,eAAiBA,EACtBxF,KAAKyF,2BAA6BA,EAClCzF,KAAK0F,gCAAkCA,GACf,IAAnBJ,MAAuC,IAAZhE,GAC5B,MAAM,IAAIqE,KAElB,IAESC,GAAyBlG,EAAAA,EAAAA,IAClC,SAAAkG,EAAYC,EAAKxC,IAAWtD,EAAAA,EAAAA,GAAA,KAAA6F,GACxB5F,KAAK6F,IAAMA,EACX7F,KAAKqD,UAAYA,CACrB,G,+JChCAyC,EAAwC,SAAUC,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAU7E,GAAS,IAAM8E,EAAKL,EAAUM,KAAK/E,GAAS,CAAE,MAAOgB,GAAK4D,EAAO5D,EAAI,CAAE,CAC1F,SAASgE,EAAShF,GAAS,IAAM8E,EAAKL,EAAiB,MAAEzE,GAAS,CAAE,MAAOgB,GAAK4D,EAAO5D,EAAI,CAAE,CAC7F,SAAS8D,EAAKzE,GAJlB,IAAeL,EAIaK,EAAOM,KAAOgE,EAAQtE,EAAOL,QAJ1CA,EAIyDK,EAAOL,MAJhDA,aAAiBwE,EAAIxE,EAAQ,IAAIwE,GAAE,SAAUG,GAAWA,EAAQ3E,EAAQ,KAIjBiF,KAAKJ,EAAWG,EAAW,CAC7GF,GAAML,EAAYA,EAAUS,MAAMZ,EAASC,GAAc,KAAKQ,OAClE,GACJ,EAGaI,EAAoB,WAC7B,SAAAA,KAAc7G,EAAAA,EAAAA,GAAA,KAAA6G,GACV5G,KAAK6G,sBAAwB,IAAIC,IACjC9G,KAAK+G,WAAa,IAAID,IACtB9G,KAAKgH,aAAe,IAAIC,EAAAA,GACxBjH,KAAKkH,YAAclH,KAAKgH,aAAaG,MACrCnH,KAAKoH,UAAY,IACrB,CA6EC,OA7EA1H,EAAAA,EAAAA,GAAAkH,EAAA,EAAA/F,IAAA,eAAAY,MACD,SAAa4F,GACTrH,KAAKgH,aAAaM,KAAK,CACnBC,iBAAkBF,EAClBG,iBAAiB,GAEzB,GAAC,CAAA3G,IAAA,WAAAY,MACD,SAASgG,EAAYC,GAAS,IAAAhH,EAAA,KAG1B,OAFAV,KAAK6G,sBAAsBc,IAAIF,EAAYC,GAC3C1H,KAAK4H,aAAa,CAACH,KACZI,EAAAA,EAAAA,KAAa,WACZnH,EAAKmG,sBAAsB/F,IAAI2G,KAAgBC,IAGnDhH,EAAKmG,sBAAsBiB,OAAOL,GAClC/G,EAAKkH,aAAa,CAACH,IACvB,GACJ,GAAC,CAAA5G,IAAA,MAAAY,MACD,SAAIgG,GACA,OAAOzH,KAAK6G,sBAAsB/F,IAAI2G,IAAe,IACzD,GAAC,CAAA5G,IAAA,kBAAAY,MACD,SAAgBgG,EAAYM,GAAS,IAC7BC,EAD6BC,EAAA,KAEU,QAA1CD,EAAKhI,KAAK+G,WAAWjG,IAAI2G,UAAgC,IAAPO,GAAyBA,EAAGE,UAC/E,IAAMC,EAAS,IAAIC,EAA+BpI,KAAMyH,EAAYM,GAEpE,OADA/H,KAAK+G,WAAWY,IAAIF,EAAYU,IACzBN,EAAAA,EAAAA,KAAa,WAChB,IAAMQ,EAAIJ,EAAKlB,WAAWjG,IAAI2G,GACzBY,GAAKA,IAAMF,IAGhBF,EAAKlB,WAAWe,OAAOL,GACvBY,EAAEH,UACN,GACJ,GAAC,CAAArH,IAAA,cAAAY,MACD,SAAYgG,GACR,OAAO3B,EAAU9F,UAAM,OAAQ,GAAMsI,EAAAA,EAAAA,KAAAC,MAAE,SAAAC,IAAA,IAAAC,EAAAV,EAAA,OAAAO,EAAAA,EAAAA,KAAAI,MAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAnC,MAAA,OAEa,KAA1CiC,EAAsBzI,KAAKc,IAAI2G,IACZ,CAAFkB,EAAAnC,KAAA,eAAAmC,EAAAE,OAAA,SACZJ,GAAmB,OAEiB,IAAzCV,EAAU/H,KAAK+G,WAAWjG,IAAI2G,MACpBM,EAAQe,WAAU,CAAAH,EAAAnC,KAAA,eAAAmC,EAAAE,OAAA,SAEvB,MAAI,OAEf,OAFeF,EAAAnC,KAAA,EAETuB,EAAQ3B,UAAS,cAAAuC,EAAAE,OAAA,SAChB7I,KAAKc,IAAI2G,IAAW,wBAAAkB,EAAAI,OAAA,GAAAP,EAAA,SAEnC,GAAC,CAAA3H,IAAA,aAAAY,MACD,SAAWgG,GAEP,GAD4BzH,KAAKc,IAAI2G,GAEjC,OAAO,EAEX,IAAMM,EAAU/H,KAAK+G,WAAWjG,IAAI2G,GACpC,QAAKM,IAAWA,EAAQe,WAI5B,GAAC,CAAAjI,IAAA,cAAAY,MACD,SAAYuH,GACRhJ,KAAKoH,UAAY4B,EACjBhJ,KAAKgH,aAAaM,KAAK,CACnBC,iBAAkB0B,MAAMC,KAAKlJ,KAAK6G,sBAAsBsC,QACxD3B,iBAAiB,GAEzB,GAAC,CAAA3G,IAAA,cAAAY,MACD,WACI,OAAOzB,KAAKoH,SAChB,GAAC,CAAAvG,IAAA,uBAAAY,MACD,WACI,OAAIzB,KAAKoH,WAAapH,KAAKoH,UAAUxF,OAAS,EACnC5B,KAAKoH,UAAU,GAEnB,IACX,KAACR,CAAA,CApF4B,GAsF3BwB,EAA8B,SAAAgB,IAAAjJ,EAAAA,EAAAA,GAAAiI,EAAAgB,GAAA,IAAAhJ,GAAAC,EAAAA,EAAAA,GAAA+H,GAIhC,SAAAA,EAAYiB,EAAWC,EAAaC,GAAU,IAAAC,EAOjB,OAPiBzJ,EAAAA,EAAAA,GAAA,KAAAqI,IAC1CoB,EAAApJ,EAAAO,KAAA,OACK0I,UAAYA,EACjBG,EAAKF,YAAcA,EACnBE,EAAKD,SAAWA,EAChBC,EAAKC,aAAc,EACnBD,EAAKE,gBAAkB,KACvBF,EAAKG,aAAc,EAAMH,CAC7B,CAqBC,OArBA9J,EAAAA,EAAAA,GAAA0I,EAAA,EAAAvH,IAAA,aAAAC,IAXD,WACI,OAAOd,KAAK2J,WAChB,GAAC,CAAA9I,IAAA,UAAAY,MAUD,WACIzB,KAAKyJ,aAAc,GACnBG,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,GAAAzB,EAAA0B,WAAA,gBAAAnJ,KAAA,KACJ,GAAC,CAAAE,IAAA,UAAAY,MACD,WACI,OAAOqE,EAAU9F,UAAM,OAAQ,GAAMsI,EAAAA,EAAAA,KAAAC,MAAE,SAAAwB,IAAA,OAAAzB,EAAAA,EAAAA,KAAAI,MAAA,SAAAsB,GAAA,cAAAA,EAAApB,KAAAoB,EAAAxD,MAAA,OAGlC,OAFIxG,KAAK0J,kBACN1J,KAAK0J,gBAAkB1J,KAAKiK,WAC/BD,EAAAnB,OAAA,SACM7I,KAAK0J,iBAAe,wBAAAM,EAAAjB,OAAA,GAAAgB,EAAA,SAEnC,GAAC,CAAAlJ,IAAA,UAAAY,MACD,WACI,OAAOqE,EAAU9F,UAAM,OAAQ,GAAMsI,EAAAA,EAAAA,KAAAC,MAAE,SAAA2B,IAAA,IAAAzI,EAAA,OAAA6G,EAAAA,EAAAA,KAAAI,MAAA,SAAAyB,GAAA,cAAAA,EAAAvB,KAAAuB,EAAA3D,MAAA,OACrB,OADqB2D,EAAA3D,KAAA,EACfxG,KAAKuJ,SAASd,oBAAmB,OAA/ChH,EAAK0I,EAAAC,KACXpK,KAAK2J,aAAc,EACflI,IAAUzB,KAAKyJ,aACfzJ,KAAKqK,UAAUrK,KAAKqJ,UAAUiB,SAAStK,KAAKsJ,YAAa7H,IAC5D,wBAAA0I,EAAApB,OAAA,GAAAmB,EAAA,SAET,KAAC9B,CAAA,CAjC+B,CAASmC,EAAAA,G,kFClGhCC,EAAyB,WAalC,SAAAA,EAAYvH,EAAiBwH,IAAQ1K,EAAAA,EAAAA,GAAA,KAAAyK,GACjCxK,KAAK0K,iBAAmBzH,EACxBjD,KAAK2K,QAAUF,CACnB,CASC,OARD/K,EAAAA,EAAAA,GAAA8K,EAAA,EAAA3J,IAAA,kBAAAC,IAbA,WACI,OAAOd,KAAK0K,gBAChB,GACA,CAAA7J,IAAA,gBAAAC,IAGA,WACI,OAAOd,KAAK0K,iBAAmB1K,KAAK2K,QAAQ/I,OAAS,CACzD,GAAC,CAAAf,IAAA,gBAAAY,MAQD,SAAcJ,GACV,OAAOrB,KAAK2K,QAAQtJ,EAAarB,KAAK0K,iBAC1C,GAAC,CAAA7J,IAAA,mBAAAY,MACD,SAAiBmJ,GACb5K,KAAK2K,QAAQ3H,KAAK4H,EACtB,KAACJ,CAAA,CAzBiC,GCFzBK,EAAgC,WACzC,SAAAA,KAAc9K,EAAAA,EAAAA,GAAA,KAAA8K,GACV7K,KAAK2K,QAAU,EACnB,CAcC,OAdAjL,EAAAA,EAAAA,GAAAmL,EAAA,EAAAhK,IAAA,MAAAY,MACD,SAAIJ,EAAYuJ,GACZ,GAAI5K,KAAK2K,QAAQ/I,OAAS,EAAG,CACzB,IAAMkJ,EAAO9K,KAAK2K,QAAQ3K,KAAK2K,QAAQ/I,OAAS,GAChD,GAAIkJ,EAAK1H,cAAgB,IAAM/B,EAG3B,YADAyJ,EAAKC,iBAAiBH,EAG9B,CACA5K,KAAK2K,QAAQ3H,KAAK,IAAIwH,EAA0BnJ,EAAY,CAACuJ,IACjE,GAAC,CAAA/J,IAAA,WAAAY,MACD,WACI,OAAOzB,KAAK2K,OAChB,KAACE,CAAA,CAjBwC,E,kHCIhCG,EAAqB,IAAIC,YAAY,GAAIC,OACzCC,EAAuB,oBAAAA,KAAApL,EAAAA,EAAAA,GAAA,KAAAoL,EAAA,CA6G/B,OA7G+BzL,EAAAA,EAAAA,GAAAyL,EAAA,OAAAtK,IAAA,kBAAAY,MAChC,SAAuBmJ,EAAYQ,GAC/B,OAAmB,OAAfR,GAAuBA,IAAeI,EAC/BJ,EAEJO,EAAwBrD,OAAO8C,EAAY,EAAGQ,EACzD,GAAC,CAAAvK,IAAA,eAAAY,MACD,SAAoBmJ,EAAYS,GAC5B,GAAmB,OAAfT,GAAuBA,IAAeI,EACtC,OAAOJ,EAEX,IAAMH,EAASa,EAAcV,GACvBW,EAAiBd,EAAOA,EAAO7I,OAAS,GAC9C,OAAOuJ,EAAwBrD,OAAO8C,EAAYS,EAAaE,EACnE,GAAC,CAAA1K,IAAA,SAAAY,MACD,SAAcmJ,EAAYS,EAAaD,GACnC,GAAmB,OAAfR,GAAuBA,IAAeI,GAAqBK,IAAgBD,EAC3E,OAAOR,EAEX,IAAMH,EAASa,EAAcV,GACvBY,EAAef,EAAO7I,SAAW,EAEvC,GAAoB,IAAhByJ,GAAqBZ,EAAOA,EAAO7I,OAAS,KAAOwJ,EACnD,OAAOJ,EAEX,IAWIS,EACAC,EAZEC,EAAiBC,EAAAA,EAAWC,uBAAuBpB,EAAQY,GAC3DS,EAAwBH,EAAiB,EAAIlB,EAAQkB,EAAiB,GAAM,GAAK,EAEvF,GAAIP,EADuBX,EAAOkB,GAAkB,GAChB,CAGhC,IADA,IAAMI,EAASX,EAAYC,EAClB9G,EAAIoH,EAAgBpH,EAAIiH,EAAajH,IAC1CkG,EAAOlG,GAAK,IAAMwH,EAEtB,OAAOnB,CACX,CAGIkB,IAAyBT,GACzBZ,EAAOkB,GAAkB,GAAKN,EAC9BI,EAASE,EAAiB,GAAM,EAChCD,EAAUL,IAGVI,EAAQE,GAAkB,EAC1BD,EAAUI,GAGd,IADA,IAAMC,EAASX,EAAYC,EAClBW,EAAaL,EAAiB,EAAGK,EAAaR,EAAaQ,IAAc,CAC9E,IAAMC,EAAiBxB,EAAOuB,GAAc,GAAKD,EAC7CE,EAAiBP,IACjBjB,EAAOgB,KAAUQ,EACjBxB,EAAOgB,KAAUhB,EAA2B,GAAnBuB,GAAc,IACvCN,EAAUO,EAElB,CACA,GAAIR,IAAShB,EAAO7I,OAEhB,OAAOgJ,EAEX,IAAMsB,EAAM,IAAIjB,YAAYQ,GAE5B,OADAS,EAAIvE,IAAI8C,EAAO0B,SAAS,EAAGV,GAAO,GAC3BS,EAAIhB,MACf,GAAC,CAAArK,IAAA,SAAAY,MACD,SAAcmJ,EAAYwB,GACtB,GAAIA,IAAiBpB,EACjB,OAAOJ,EAEX,GAAIA,IAAeI,EACf,OAAOoB,EAEX,GAAmB,OAAfxB,EACA,OAAOA,EAEX,GAAqB,OAAjBwB,EAEA,OAAO,KAEX,IAAMC,EAAWf,EAAcV,GACzB0B,EAAchB,EAAcc,GAC5BG,EAAoBD,EAAY1K,SAAW,EAC3CE,EAAS,IAAImJ,YAAYoB,EAASzK,OAAS0K,EAAY1K,QAC7DE,EAAO6F,IAAI0E,EAAU,GAGrB,IAFA,IAAIZ,EAAOY,EAASzK,OACdmK,EAAQM,EAASA,EAASzK,OAAS,GAChC2C,EAAI,EAAGA,EAAIgI,EAAkBhI,IAClCzC,EAAO2J,KAAUa,EAAa/H,GAAK,GAAMwH,EACzCjK,EAAO2J,KAAUa,EAAuB,GAAV/H,GAAK,IAEvC,OAAOzC,EAAOoJ,MAClB,GAAC,CAAArK,IAAA,SAAAY,MACD,SAAcmJ,EAAY4B,EAASC,GAC/B,GAAmB,OAAf7B,GAAuBA,IAAeI,EAEtC,OAAOJ,EAEX,IAAMH,EAASa,EAAcV,GACvBY,EAAef,EAAO7I,SAAW,EACnC+J,EAAiBC,EAAAA,EAAWC,uBAAuBpB,EAAQ+B,GAC3Db,EAAiB,IACYlB,EAAQkB,EAAiB,GAAM,KAC/Ba,GACzBb,KAGR,IAAK,IAAIK,EAAaL,EAAgBK,EAAaR,EAAaQ,IAC5DvB,EAAOuB,GAAc,IAAMS,EAE/B,OAAO7B,CACX,KAACO,CAAA,CA7G+B,GA+G7B,SAASG,EAAcoB,GAC1B,OAAIA,aAAezB,YACRyB,EAGA,IAAIzB,YAAYyB,EAE/B,C,eChHaC,EAAqB,WAC9B,SAAAA,EAAYC,IAAiB7M,EAAAA,EAAAA,GAAA,KAAA4M,GACzB3M,KAAK6M,YAAc,GACnB7M,KAAK8M,KAAO,EACZ9M,KAAK+M,iBAAmBH,CAC5B,CAkGC,OAlGAlN,EAAAA,EAAAA,GAAAiN,EAAA,EAAA9L,IAAA,QAAAY,MACD,WACIzB,KAAK6M,YAAc,GACnB7M,KAAK8M,KAAO,CAChB,GAAC,CAAAjM,IAAA,YAAAC,IACD,WACI,OAAOd,KAAK6M,YAAYjL,OAAS,CACrC,GAAC,CAAAf,IAAA,YAAAY,MACD,SAAUuL,EAAoBC,EAAWvL,GACrC,IAAIwL,EAAgB,KAIpB,GAHID,EAAYjN,KAAK8M,OACjBI,EAAgBlN,KAAK6M,YAAYI,IAEf,OAAlBC,GAA0BA,IAAkBlC,EAC5C,OAAO,IAAIY,EAAAA,EAAWN,EAAc4B,GAAgBxL,EAAU1B,KAAK+M,kBAEvE,IAAMnC,EAAa,IAAIK,YAAY,GAGnC,OAFAL,EAAW,GAAKlJ,EAASE,OACzBgJ,EAAW,GAAKuC,EAAmBnN,KAAK+M,iBAAiBK,iBAAiBJ,IACnE,IAAIpB,EAAAA,EAAWhB,EAAYlJ,EAAU1B,KAAK+M,iBACrD,GAAC,CAAAlM,IAAA,cAAAY,MA0BD,SAAYwL,GACR,KAAOA,GAAajN,KAAK8M,MACrB9M,KAAK6M,YAAY7M,KAAK8M,MAAQ,KAC9B9M,KAAK8M,MAEb,GAAC,CAAAjM,IAAA,eAAAY,MACD,SAAa4L,EAAOC,GACI,IAAhBA,IAGAD,EAAQC,EAActN,KAAK8M,OAC3BQ,EAActN,KAAK8M,KAAOO,GAE9BrN,KAAK6M,YAAYU,OAAOF,EAAOC,GAC/BtN,KAAK8M,MAAQQ,EACjB,GAAC,CAAAzM,IAAA,eAAAY,MACD,SAAa+L,EAAaC,GACtB,GAAoB,IAAhBA,EAAJ,CAIA,IADA,IAAM7C,EAAa,GACVrG,EAAI,EAAGA,EAAIkJ,EAAalJ,IAC7BqG,EAAWrG,GAAK,KAEpBvE,KAAK6M,YAAca,EAAAA,GAAmB1N,KAAK6M,YAAaW,EAAa5C,GACrE5K,KAAK8M,MAAQW,CANb,CAOJ,GAAC,CAAA5M,IAAA,YAAAY,MACD,SAAUuL,EAAoBC,EAAW1B,EAAgBZ,EAASgD,GAC9D,IAAMlD,EAASkC,EAAsBiB,eAAe5N,KAAK+M,iBAAiBK,iBAAiBJ,GAAqBzB,EAAgBZ,GAChI3K,KAAK6N,YAAYZ,GACjB,IAAMa,EAAY9N,KAAK6M,YAAYI,GAEnC,OADAjN,KAAK6M,YAAYI,GAAaxC,IAC1BkD,IACQhB,EAAsBoB,QAAQD,EAAWrD,EAGzD,GAAC,CAAA5J,IAAA,aAAAY,MAkBD,SAAW9B,EAAOqO,EAAUC,GACxBjO,KAAKkO,mBAAmBvO,GACxBK,KAAKmO,kBAAkB,IAAIC,EAAAA,EAASzO,EAAMsD,gBAAiBtD,EAAMuD,aAAc8K,EAAUC,EAC7F,GAAC,CAAApN,IAAA,qBAAAY,MACD,SAAmB9B,GACf,IAAM0O,EAAiB1O,EAAMsD,gBAAkB,EAC/C,KAAIoL,GAAkBrO,KAAK8M,MAG3B,GAAInN,EAAMsD,kBAAoBtD,EAAMyD,cAApC,CAQApD,KAAK6M,YAAYwB,GAAkBlD,EAAwBmD,aAAatO,KAAK6M,YAAYwB,GAAiB1O,EAAMuD,YAAc,GAC9H,IAAMqL,EAAgB5O,EAAMyD,cAAgB,EACxCoL,EAAiB,KACjBD,EAAgBvO,KAAK8M,OACrB0B,EAAiBrD,EAAwBsD,gBAAgBzO,KAAK6M,YAAY0B,GAAgB5O,EAAM0D,UAAY,IAGhHrD,KAAK6M,YAAYwB,GAAkBlD,EAAwBuD,OAAO1O,KAAK6M,YAAYwB,GAAiBG,GAEpGxO,KAAK2O,aAAahP,EAAMsD,gBAAiBtD,EAAMyD,cAAgBzD,EAAMsD,gBAVrE,KAPA,CACI,GAAItD,EAAMuD,cAAgBvD,EAAM0D,UAE5B,OAEJrD,KAAK6M,YAAYwB,GAAkBlD,EAAwBrD,OAAO9H,KAAK6M,YAAYwB,GAAiB1O,EAAMuD,YAAc,EAAGvD,EAAM0D,UAAY,EAEjJ,CAWJ,GAAC,CAAAxC,IAAA,oBAAAY,MACD,SAAkBmN,EAAUZ,EAAUC,GAClC,GAAiB,IAAbD,GAAsC,IAApBC,EAAtB,CAIA,IAAMhB,EAAY2B,EAASvN,WAAa,EACpC4L,GAAajN,KAAK8M,OAGL,IAAbkB,GAKJhO,KAAK6M,YAAYI,GAAa9B,EAAwBmD,aAAatO,KAAK6M,YAAYI,GAAY2B,EAAStN,OAAS,GAClHtB,KAAK6M,YAAYI,GAAa9B,EAAwB0D,OAAO7O,KAAK6M,YAAYI,GAAY2B,EAAStN,OAAS,EAAG2M,GAC/GjO,KAAK8O,aAAaF,EAASvN,WAAY2M,IALnChO,KAAK6M,YAAYI,GAAa9B,EAAwB0D,OAAO7O,KAAK6M,YAAYI,GAAY2B,EAAStN,OAAS,EAAG2M,GAPnH,CAaJ,GACA,CAAApN,IAAA,qBAAAY,MACA,SAAmBgJ,EAAQsE,GACvB,GAAsB,IAAlBtE,EAAO7I,OACP,MAAO,CAAEqC,QAAS,IAGtB,IADA,IAAM+K,EAAS,GACNzK,EAAI,EAAGC,EAAMiG,EAAO7I,OAAQ2C,EAAIC,EAAKD,IAAK,CAK/C,IAJA,IAAM0K,EAAUxE,EAAOlG,GACnB2K,EAAuB,EACvBC,EAAuB,EACvBC,GAAY,EACP/N,EAAa4N,EAAQhM,gBAAiB5B,GAAc4N,EAAQ7L,cAAe/B,IAAc,CAC9F,GAAI+N,EACApP,KAAKqP,UAAUN,EAAUO,gBAAiBjO,EAAa,EAAG0N,EAAUQ,cAAclO,GAAa4N,EAAQO,cAAcnO,IAAa,GAClI8N,EAAuB9N,OAGDrB,KAAKqP,UAAUN,EAAUO,gBAAiBjO,EAAa,EAAG0N,EAAUQ,cAAclO,GAAa4N,EAAQO,cAAcnO,IAAa,KAEpJ+N,GAAY,EACZF,EAAuB7N,EACvB8N,EAAuB9N,EAGnC,CACI+N,GACAJ,EAAOhM,KAAK,CAAEY,eAAgBsL,EAAsBrL,aAAcsL,GAE1E,CACA,MAAO,CAAElL,QAAS+K,EACtB,IAAC,EAAAnO,IAAA,iBAAAY,MA3JD,SAAsBuL,EAAoBzB,EAAgBZ,GACtD,IAAMF,EAASE,EAAUW,EAAcX,GAAW,KAClD,GAAuB,IAAnBY,EAAsB,CACtB,IAAIkE,GAAyB,EAI7B,GAHIhF,GAAUA,EAAO7I,OAAS,IAC1B6N,EAA0BC,EAAAA,EAAcJ,cAAc7E,EAAO,MAAQuC,IAEpEyC,EACD,OAAOzE,CAEf,CACA,IAAKP,GAA4B,IAAlBA,EAAO7I,OAAc,CAChC,IAAM6I,EAAS,IAAIQ,YAAY,GAG/B,OAFAR,EAAO,GAAKc,EACZd,EAAO,GAAK0C,EAAmBH,GACxBvC,EAAOS,MAClB,CAGA,OADAT,EAAOA,EAAO7I,OAAS,GAAK2J,EACF,IAAtBd,EAAOkF,YAAoBlF,EAAOmF,aAAenF,EAAOS,OAAO0E,WAExDnF,EAAOS,OAEXT,CACX,GAAC,CAAA5J,IAAA,UAAAY,MAsCD,SAAeuG,EAAI6H,GACf,IAAK7H,IAAO6H,EACR,OAAQ7H,IAAO6H,EAEnB,IAAMtM,EAAI+H,EAActD,GAClBxE,EAAI8H,EAAcuE,GACxB,GAAItM,EAAE3B,SAAW4B,EAAE5B,OACf,OAAO,EAEX,IAAK,IAAI2C,EAAI,EAAGC,EAAMjB,EAAE3B,OAAQ2C,EAAIC,EAAKD,IACrC,GAAIhB,EAAEgB,KAAOf,EAAEe,GACX,OAAO,EAGf,OAAO,CACX,KAACoI,CAAA,CAvG6B,GAuLlC,SAASQ,EAAmBH,GACxB,OACO,MADEA,GAAsB,EAIxB,GAAqC,GAErC,QAAuD,CAClE,C,6FCtMapB,EAAU,WAQnB,SAAAA,EAAYnB,EAAQqF,EAAMC,IAAShQ,EAAAA,EAAAA,GAAA,KAAA6L,GAC/B5L,KAAKgQ,sBAAmBC,EACxBjQ,KAAK2K,QAAUF,EACfzK,KAAKkQ,aAAgBlQ,KAAK2K,QAAQ/I,SAAW,EAC7C5B,KAAKmQ,MAAQL,EACb9P,KAAK+M,iBAAmBgD,CAC5B,CA6GC,OA7GArQ,EAAAA,EAAAA,GAAAkM,EAAA,EAAA/K,IAAA,SAAAY,MACD,SAAOqD,GACH,OAAIA,aAAiB8G,GACV5L,KAAKoQ,aAAatL,EAAO,EAAG9E,KAAKkQ,aAGhD,GAAC,CAAArP,IAAA,eAAAY,MACD,SAAaqD,EAAOuL,EAAqBC,GACrC,GAAItQ,KAAKmQ,QAAUrL,EAAMqL,MACrB,OAAO,EAEX,GAAInQ,KAAKkQ,eAAiBpL,EAAMoL,aAC5B,OAAO,EAIX,IAFA,IAAMhH,EAAQmH,GAAuB,EAC/BE,EAAKrH,GAAQoH,GAAmB,GAC7B/L,EAAI2E,EAAM3E,EAAIgM,EAAIhM,IACvB,GAAIvE,KAAK2K,QAAQpG,KAAOO,EAAM6F,QAAQpG,GAClC,OAAO,EAGf,OAAO,CACX,GAAC,CAAA1D,IAAA,iBAAAY,MACD,WACI,OAAOzB,KAAKmQ,KAChB,GAAC,CAAAtP,IAAA,WAAAY,MACD,WACI,OAAOzB,KAAKkQ,YAChB,GAAC,CAAArP,IAAA,iBAAAY,MACD,SAAeuK,GACX,OAAIA,EAAa,EACNhM,KAAK2K,QAASqB,EAAa,GAAM,GAErC,CACX,GAAC,CAAAnL,IAAA,cAAAY,MACD,SAAYuK,GAER,OADiBhM,KAAK2K,QAA4B,GAAnBqB,GAAc,GAEjD,GAAC,CAAAnL,IAAA,gBAAAY,MACD,SAAcuK,GACV,IAAMwE,EAAWxQ,KAAK2K,QAA4B,GAAnBqB,GAAc,IACvCvE,EAAaiI,EAAAA,EAAcJ,cAAckB,GAC/C,OAAOxQ,KAAK+M,iBAAiB0D,iBAAiBhJ,EAClD,GAAC,CAAA5G,IAAA,uBAAAY,MACD,SAAqBuK,GACjB,IAAMwE,EAAWxQ,KAAK2K,QAA4B,GAAnBqB,GAAc,IAC7C,OAAO0D,EAAAA,EAAcgB,aAAaF,EACtC,GAAC,CAAA3P,IAAA,gBAAAY,MACD,SAAcuK,GACV,IAAMwE,EAAWxQ,KAAK2K,QAA4B,GAAnBqB,GAAc,IAC7C,OAAO0D,EAAAA,EAAciB,cAAcH,EACvC,GAAC,CAAA3P,IAAA,eAAAY,MACD,SAAauK,GACT,IAAMwE,EAAWxQ,KAAK2K,QAA4B,GAAnBqB,GAAc,IAC7C,OAAO0D,EAAAA,EAAckB,yBAAyBJ,EAClD,GAAC,CAAA3P,IAAA,iBAAAY,MACD,SAAeuK,EAAYhD,GACvB,IAAMwH,EAAWxQ,KAAK2K,QAA4B,GAAnBqB,GAAc,IAC7C,OAAO0D,EAAAA,EAAcmB,2BAA2BL,EAAUxH,EAC9D,GAAC,CAAAnI,IAAA,kBAAAY,MACD,SAAgBuK,GACZ,IAAMwE,EAAWxQ,KAAK2K,QAA4B,GAAnBqB,GAAc,IAC7C,OAAO0D,EAAAA,EAAcoB,4BAA4BN,EACrD,GAAC,CAAA3P,IAAA,eAAAY,MACD,SAAauK,GACT,OAAOhM,KAAK2K,QAAQqB,GAAc,EACtC,GACA,CAAAnL,IAAA,yBAAAY,MAKA,SAAuBsP,GACnB,OAAOnF,EAAWC,uBAAuB7L,KAAK2K,QAASoG,EAC3D,GAAC,CAAAlQ,IAAA,UAAAY,MACD,WACI,OAAOzB,IACX,GAAC,CAAAa,IAAA,kBAAAY,MACD,SAAgBuP,EAAaC,EAAWC,GACpC,OAAO,IAAIC,EAAgBnR,KAAMgR,EAAaC,EAAWC,EAC7D,GAAC,CAAArQ,IAAA,eAAAY,MAkCD,SAAa2P,GACT,GAA4B,IAAxBA,EAAaxP,OACb,OAAO5B,KAOX,IALA,IAAIqR,EAAuB,EACvBC,EAAqB,EACrBxB,EAAO,GACLyB,EAAY,IAAItI,MAClBuI,EAAoB,IACX,CACT,IAAMC,EAA6BJ,EAAuBrR,KAAKkQ,aAAelQ,KAAK2K,QAAQ0G,GAAwB,IAAM,EACnHK,EAAkBJ,EAAqBF,EAAaxP,OAASwP,EAAaE,GAAsB,KACtG,IAAoC,IAAhCG,IAA0D,OAApBC,GAA4BD,GAA8BC,EAAgBX,QAAS,CAEzHjB,GAAQ9P,KAAKmQ,MAAM7N,UAAUkP,EAAmBC,GAChD,IAAMjB,EAAWxQ,KAAK2K,QAAsC,GAA7B0G,GAAwB,IACvDE,EAAUvO,KAAK8M,EAAKlO,OAAQ4O,GAC5Ba,IACAG,EAAoBC,CACxB,KACK,KAAIC,EAaL,MAZA,GAAIA,EAAgBX,OAASS,EAAmB,CAE5C1B,GAAQ9P,KAAKmQ,MAAM7N,UAAUkP,EAAmBE,EAAgBX,QAChE,IAAMP,EAAWxQ,KAAK2K,QAAsC,GAA7B0G,GAAwB,IACvDE,EAAUvO,KAAK8M,EAAKlO,OAAQ4O,GAC5BgB,EAAoBE,EAAgBX,MACxC,CACAjB,GAAQ4B,EAAgB5B,KACxByB,EAAUvO,KAAK8M,EAAKlO,OAAQ8P,EAAgBC,eAC5CL,GAIJ,CACJ,CACA,OAAO,IAAI1F,EAAW,IAAIX,YAAYsG,GAAYzB,EAAM9P,KAAK+M,iBACjE,IAAC,EAAAlM,IAAA,cAAAY,MApKD,SAAmBmQ,EAAa7B,GAC5B,IAAM8B,EAAkBjG,EAAWkG,qBAC7BrH,EAAS,IAAIQ,YAAY,GAG/B,OAFAR,EAAO,GAAKmH,EAAYhQ,OACxB6I,EAAO,GAAKoH,EACL,IAAIjG,EAAWnB,EAAQmH,EAAa7B,EAC/C,GAAC,CAAAlP,IAAA,qBAAAY,MAwFD,SAA0BgJ,EAAQc,GAG9B,IAFA,IACMwG,GADctH,EAAO7I,SAAW,GACF,EAC3BoK,EAAa,EAAGA,EAAa+F,EAAgB/F,IAClDvB,EAAOuB,GAAc,GAAKvB,EAAQuB,EAAa,GAAM,GAEzDvB,EAAOsH,GAAkB,GAAKxG,CAClC,GAAC,CAAA1K,IAAA,yBAAAY,MACD,SAA8BgJ,EAAQuH,GAClC,GAAIvH,EAAO7I,QAAU,EACjB,OAAO,EAIX,IAFA,IAAIqQ,EAAM,EACNC,GAAQzH,EAAO7I,SAAW,GAAK,EAC5BqQ,EAAMC,GAAM,CACf,IAAMC,EAAMF,EAAMG,KAAKC,OAAOH,EAAOD,GAAO,GACtChB,EAAYxG,EAAQ0H,GAAO,GACjC,GAAIlB,IAAce,EACd,OAAOG,EAAM,EAERlB,EAAYe,EACjBC,EAAME,EAAM,EAEPlB,EAAYe,IACjBE,EAAOC,EAEf,CACA,OAAOF,CACX,KAACrG,CAAA,CA3HkB,GAuKvBA,EAAWkG,qBAAuB,SAE4D,IACxFX,EAAe,WACjB,SAAAA,EAAYmB,EAAQtB,EAAaC,EAAWC,IAAanR,EAAAA,EAAAA,GAAA,KAAAoR,GACrDnR,KAAKuS,QAAUD,EACftS,KAAKwS,aAAexB,EACpBhR,KAAKyS,WAAaxB,EAClBjR,KAAK0S,aAAexB,EACpBlR,KAAK2S,iBAAmBL,EAAOM,uBAAuB5B,GACtDhR,KAAKkQ,aAAe,EACpB,IAAK,IAAI3L,EAAIvE,KAAK2S,iBAAkBnO,EAAM8N,EAAOO,WAAYtO,EAAIC,EAAKD,IAAK,CAEvE,GADyB+N,EAAOQ,eAAevO,IACvB0M,EACpB,MAEJjR,KAAKkQ,cACT,CACJ,CAwCC,OAxCAxQ,EAAAA,EAAAA,GAAAyR,EAAA,EAAAtQ,IAAA,cAAAY,MACD,SAAYuK,GACR,OAAOhM,KAAKuS,QAAQQ,YAAY/S,KAAK2S,iBAAmB3G,EAC5D,GAAC,CAAAnL,IAAA,gBAAAY,MACD,SAAcuK,GACV,OAAOhM,KAAKuS,QAAQjD,cAActP,KAAK2S,iBAAmB3G,EAC9D,GAAC,CAAAnL,IAAA,iBAAAY,MACD,WACI,OAAOzB,KAAKuS,QAAQS,iBAAiB1Q,UAAUtC,KAAKwS,aAAcxS,KAAKyS,WAC3E,GAAC,CAAA5R,IAAA,SAAAY,MACD,SAAOqD,GACH,OAAIA,aAAiBqM,IACTnR,KAAKwS,eAAiB1N,EAAM0N,cAC7BxS,KAAKyS,aAAe3N,EAAM2N,YAC1BzS,KAAK0S,eAAiB5N,EAAM4N,cAC5B1S,KAAKuS,QAAQnC,aAAatL,EAAMyN,QAASvS,KAAK2S,iBAAkB3S,KAAKkQ,cAGpF,GAAC,CAAArP,IAAA,WAAAY,MACD,WACI,OAAOzB,KAAKkQ,YAChB,GAAC,CAAArP,IAAA,gBAAAY,MACD,SAAcuK,GACV,OAAOhM,KAAKuS,QAAQ5B,cAAc3Q,KAAK2S,iBAAmB3G,EAC9D,GAAC,CAAAnL,IAAA,eAAAY,MACD,SAAauK,GACT,IAAMC,EAAiBjM,KAAKuS,QAAQU,aAAajT,KAAK2S,iBAAmB3G,GACzE,OAAOoG,KAAKc,IAAIlT,KAAKyS,WAAYxG,GAAkBjM,KAAKwS,aAAexS,KAAK0S,YAChF,GAAC,CAAA7R,IAAA,eAAAY,MACD,SAAauK,GACT,OAAOhM,KAAKuS,QAAQY,aAAanT,KAAK2S,iBAAmB3G,EAC7D,GAAC,CAAAnL,IAAA,iBAAAY,MACD,SAAeuK,EAAYhD,GACvB,OAAOhJ,KAAKuS,QAAQa,eAAepT,KAAK2S,iBAAmB3G,EAAYhD,EAC3E,GAAC,CAAAnI,IAAA,kBAAAY,MACD,SAAgBuK,GACZ,OAAOhM,KAAKuS,QAAQc,gBAAgBrT,KAAK2S,iBAAmB3G,EAChE,GAAC,CAAAnL,IAAA,yBAAAY,MACD,SAAuBsP,GACnB,OAAO/Q,KAAKuS,QAAQK,uBAAuB7B,EAAS/Q,KAAKwS,aAAexS,KAAK0S,cAAgB1S,KAAK2S,gBACtG,KAACxB,CAAA,CAvDgB,E,6HCrKRmC,EAAqB,WAgB9B,SAAAA,EAAYrQ,EAAiBwH,IAAQ1K,EAAAA,EAAAA,GAAA,KAAAuT,GACjCtT,KAAK0K,iBAAmBzH,EACxBjD,KAAK2K,QAAUF,EACfzK,KAAKuT,eAAiBvT,KAAK0K,iBAAmB1K,KAAK2K,QAAQ6I,iBAC/D,CAjBC,OAiBA9T,EAAAA,EAAAA,GAAA4T,EAAA,EAAAzS,IAAA,kBAAAC,IAbD,WACI,OAAOd,KAAK0K,gBAChB,GACA,CAAA7J,IAAA,gBAAAC,IAGA,WACI,OAAOd,KAAKuT,cAChB,GAAC,CAAA1S,IAAA,WAAAY,MAMD,WACI,OAAOzB,KAAK2K,QAAQ8I,SAASzT,KAAK0K,iBACtC,GAAC,CAAA7J,IAAA,uBAAAY,MACD,WACIzB,KAAKuT,eAAiBvT,KAAK0K,iBAAmB1K,KAAK2K,QAAQ6I,iBAC/D,GAAC,CAAA3S,IAAA,UAAAY,MACD,WACI,OAAOzB,KAAK2K,QAAQ+I,SACxB,GAAC,CAAA7S,IAAA,gBAAAY,MACD,SAAcJ,GACV,OAAIrB,KAAK0K,kBAAoBrJ,GAAcA,GAAcrB,KAAKuT,eACnDvT,KAAK2K,QAAQ6E,cAAcnO,EAAarB,KAAK0K,kBAEjD,IACX,GAAC,CAAA7J,IAAA,WAAAY,MACD,WACI,IAAMkS,EAAa3T,KAAK2K,QAAQiJ,WAChC,OAAKD,EAGE,IAAIE,EAAAA,EAAM7T,KAAK0K,iBAAmBiJ,EAAW1Q,gBAAiB0Q,EAAWzQ,YAAalD,KAAK0K,iBAAmBiJ,EAAWvQ,cAAeuQ,EAAWtQ,WAF/IsQ,CAGf,GAAC,CAAA9S,IAAA,eAAAY,MACD,SAAa9B,GACT,IAAMmU,EAAiBnU,EAAMsD,gBAAkBjD,KAAK0K,iBAC9CqJ,EAAepU,EAAMyD,cAAgBpD,KAAK0K,iBAChD1K,KAAK0K,kBAAoB1K,KAAK2K,QAAQqJ,aAAaF,EAAgBnU,EAAMuD,YAAc,EAAG6Q,EAAcpU,EAAM0D,UAAY,GAC1HrD,KAAKiU,sBACT,GAAC,CAAApT,IAAA,QAAAY,MACD,SAAM9B,GAIF,IAAMmU,EAAiBnU,EAAMsD,gBAAkBjD,KAAK0K,iBAC9CqJ,EAAepU,EAAMyD,cAAgBpD,KAAK0K,iBAChDwJ,EAA2BlU,KAAK2K,QAAQwJ,MAAML,EAAgBnU,EAAMuD,YAAc,EAAG6Q,EAAcpU,EAAM0D,UAAY,GAAE+Q,GAAAC,EAAAA,EAAAA,GAAAH,EAAA,GAAhH3Q,EAAC6Q,EAAA,GAAE5Q,EAAC4Q,EAAA,GAAEE,EAAUF,EAAA,GACvB,MAAO,CAAC,IAAId,EAAsBtT,KAAK0K,iBAAkBnH,GAAI,IAAI+P,EAAsBtT,KAAK0K,iBAAmB4J,EAAY9Q,GAC/H,GAAC,CAAA3C,IAAA,YAAAY,MACD,SAAU9B,EAAOmQ,GACb,IAAAyE,GAAoDC,EAAAA,EAAAA,GAAS1E,GAAK2E,GAAAJ,EAAAA,EAAAA,GAAAE,EAAA,GAA3DvG,EAAQyG,EAAA,GAAExG,EAAewG,EAAA,GAAEC,EAAcD,EAAA,GAChDzU,KAAK2U,WAAWhV,EAAOqO,EAAUC,EAAiByG,EAAgB5E,EAAKlO,OAAS,EAAIkO,EAAK8E,WAAW,GAAK,EAC7G,GAAC,CAAA/T,IAAA,aAAAY,MACD,SAAW9B,EAAOqO,EAAUC,EAAiByG,EAAgBG,GACzD7U,KAAKkO,mBAAmBvO,GACxBK,KAAKmO,kBAAkB,IAAIC,EAAAA,EAASzO,EAAMsD,gBAAiBtD,EAAMuD,aAAc8K,EAAUC,EAAiByG,EAAgBG,GAC1H7U,KAAKiU,sBACT,GAAC,CAAApT,IAAA,qBAAAY,MACD,SAAmB9B,GACf,GAAIA,EAAMsD,kBAAoBtD,EAAMyD,eAAiBzD,EAAMuD,cAAgBvD,EAAM0D,UAAjF,CAIA,IAAMgL,EAAiB1O,EAAMsD,gBAAkBjD,KAAK0K,iBAC9C6D,EAAgB5O,EAAMyD,cAAgBpD,KAAK0K,iBACjD,GAAI6D,EAAgB,EAApB,CAEI,IAAMuG,EAAoBvG,EAAgBF,EAC1CrO,KAAK0K,kBAAoBoK,CAE7B,KALA,CAMA,IAAMC,EAAoB/U,KAAK2K,QAAQ6I,kBACvC,KAAInF,GAAkB0G,EAAoB,GAA1C,CAIA,GAAI1G,EAAiB,GAAKE,GAAiBwG,EAAoB,EAI3D,OAFA/U,KAAK0K,iBAAmB,OACxB1K,KAAK2K,QAAQqK,QAGjB,GAAI3G,EAAiB,EAAG,CACpB,IAAM4G,GAAiB5G,EACvBrO,KAAK0K,kBAAoBuK,EACzBjV,KAAK2K,QAAQuK,kBAAkBvV,EAAMuD,YAAc,EAAG,EAAG,EAAGqL,EAAe5O,EAAM0D,UAAY,EACjG,MAEIrD,KAAK2K,QAAQuK,kBAAkB,EAAG7G,EAAgB1O,EAAMuD,YAAc,EAAGqL,EAAe5O,EAAM0D,UAAY,EAb9G,CALA,CARA,CA4BJ,GAAC,CAAAxC,IAAA,oBAAAY,MACD,SAAkBmN,EAAUZ,EAAUC,EAAiByG,EAAgBG,GACnE,GAAiB,IAAb7G,GAAsC,IAApBC,EAAtB,CAIA,IAAMhB,EAAY2B,EAASvN,WAAarB,KAAK0K,iBAC7C,GAAIuC,EAAY,EAEZjN,KAAK0K,kBAAoBsD,OAIzBf,GADsBjN,KAAK2K,QAAQ6I,kBACF,GAIrCxT,KAAK2K,QAAQwK,iBAAiBlI,EAAW2B,EAAStN,OAAS,EAAG0M,EAAUC,EAAiByG,EAAgBG,EAZzG,CAaJ,IAAC,EAAAhU,IAAA,SAAAY,MApHD,SAAcwB,EAAiBwH,GAC3B,OAAO,IAAI6I,EAAsBrQ,EAAiB,IAAImS,EAA6B3K,GACvF,KAAC6I,CAAA,CAH6B,GAuH5B8B,EAA4B,WAC9B,SAAAA,EAAY3K,IAAQ1K,EAAAA,EAAAA,GAAA,KAAAqV,GAChBpV,KAAK2K,QAAUF,EACfzK,KAAKqV,YAAc5K,EAAO7I,OAAS,CACvC,CA4WC,OA5WAlC,EAAAA,EAAAA,GAAA0V,EAAA,EAAAvU,IAAA,WAAAY,MACD,SAASwB,GAEL,IADA,IAAMqS,EAAS,GACN/Q,EAAI,EAAGA,EAAIvE,KAAKqV,YAAa9Q,IAClC+Q,EAAOtS,KAAK,IAADyB,OAAKzE,KAAKuV,cAAchR,GAAKtB,EAAe,KAAAwB,OAAIzE,KAAKwV,mBAAmBjR,GAAE,KAAAE,OAAIzE,KAAKyV,iBAAiBlR,GAAE,MAErH,MAAO,IAAPE,OAAW6Q,EAAOI,KAAK,KAAI,IAC/B,GAAC,CAAA7U,IAAA,kBAAAY,MACD,WACI,IAAMkU,EAAa3V,KAAK4V,iBACxB,OAAmB,IAAfD,GACQ,EAEL3V,KAAKuV,cAAcI,EAAa,EAC3C,GAAC,CAAA9U,IAAA,WAAAY,MACD,WACI,IAAMkU,EAAa3V,KAAK4V,iBACxB,GAAmB,IAAfD,EACA,OAAO,KAEX,IAAME,EAAY7V,KAAKwV,mBAAmB,GACpCM,EAAe9V,KAAKuV,cAAcI,EAAa,GAC/CI,EAAU/V,KAAKyV,iBAAiBE,EAAa,GACnD,OAAO,IAAI9B,EAAAA,EAAM,EAAGgC,EAAY,EAAGC,EAAcC,EAAU,EAC/D,GAAC,CAAAlV,IAAA,iBAAAY,MACD,WACI,OAAOzB,KAAKqV,WAChB,GAAC,CAAAxU,IAAA,gBAAAY,MACD,SAAcuK,GACV,OAAOhM,KAAK2K,QAAQ,EAAIqB,EAC5B,GAAC,CAAAnL,IAAA,qBAAAY,MACD,SAAmBuK,GACf,OAAOhM,KAAK2K,QAAQ,EAAIqB,EAAa,EACzC,GAAC,CAAAnL,IAAA,mBAAAY,MACD,SAAiBuK,GACb,OAAOhM,KAAK2K,QAAQ,EAAIqB,EAAa,EACzC,GAAC,CAAAnL,IAAA,UAAAY,MACD,WACI,OAAkC,IAA1BzB,KAAK4V,gBACjB,GAAC,CAAA/U,IAAA,gBAAAY,MACD,SAAcuU,GAGV,IAFA,IAAI/D,EAAM,EACNC,EAAOlS,KAAK4V,iBAAmB,EAC5B3D,EAAMC,GAAM,CACf,IAAMC,EAAMF,EAAMG,KAAKC,OAAOH,EAAOD,GAAO,GACtCgE,EAAejW,KAAKuV,cAAcpD,GACxC,GAAI8D,EAAeD,EACf/D,EAAME,EAAM,MAEX,MAAI8D,EAAeD,GAGnB,CAED,IADA,IAAI9C,EAAMf,EACHe,EAAMjB,GAAOjS,KAAKuV,cAAcrC,EAAM,KAAO8C,GAChD9C,IAGJ,IADA,IAAIgD,EAAM/D,EACH+D,EAAMhE,GAAQlS,KAAKuV,cAAcW,EAAM,KAAOF,GACjDE,IAEJ,OAAO,IAAIC,EAAiBnW,KAAK2K,QAAQwB,SAAS,EAAI+G,EAAK,EAAIgD,EAAM,GACzE,CAZIhE,EAAOC,EAAM,CAYjB,CACJ,CACA,OAAInS,KAAKuV,cAActD,KAAS+D,EACrB,IAAIG,EAAiBnW,KAAK2K,QAAQwB,SAAS,EAAI8F,EAAK,EAAIA,EAAM,IAElE,IACX,GAAC,CAAApR,IAAA,QAAAY,MACD,WACIzB,KAAKqV,YAAc,CACvB,GAAC,CAAAxU,IAAA,eAAAY,MACD,SAAa2U,EAAgBP,EAAWQ,EAAcN,GAMlD,IALA,IAAMtL,EAASzK,KAAK2K,QACdgL,EAAa3V,KAAKqV,YACpBiB,EAAgB,EAChBC,GAAmB,EACnBC,EAAiB,EACZjS,EAAI,EAAGA,EAAIoR,EAAYpR,IAAK,CACjC,IAAMkS,EAAY,EAAIlS,EAChBmS,EAAiBjM,EAAOgM,GACxBE,EAAsBlM,EAAOgM,EAAY,GACzCG,EAAoBnM,EAAOgM,EAAY,GACvC9E,EAAgBlH,EAAOgM,EAAY,GACzC,IAAKC,EAAiBN,GAAmBM,IAAmBN,GAAkBQ,GAAqBf,KAC3Fa,EAAiBL,GAAiBK,IAAmBL,GAAgBM,GAAuBZ,GAChGQ,GAAmB,MAElB,CAID,GAHsB,IAAlBD,IACAE,EAAiBE,GAEjBH,EAAkB,CAElB,IAAMM,EAAa,EAAIP,EACvB7L,EAAOoM,GAAcH,EAAiBF,EACtC/L,EAAOoM,EAAa,GAAKF,EACzBlM,EAAOoM,EAAa,GAAKD,EACzBnM,EAAOoM,EAAa,GAAKlF,CAC7B,CACA2E,GACJ,CACJ,CAEA,OADAtW,KAAKqV,YAAciB,EACZE,CACX,GAAC,CAAA3V,IAAA,QAAAY,MACD,SAAM2U,EAAgBP,EAAWQ,EAAcN,GAQ3C,IAPA,IAAMtL,EAASzK,KAAK2K,QACdgL,EAAa3V,KAAKqV,YAClByB,EAAU,GACVC,EAAU,GACZC,EAAaF,EACbD,EAAa,EACbI,EAAqB,EAChB1S,EAAI,EAAGA,EAAIoR,EAAYpR,IAAK,CACjC,IAAMkS,EAAY,EAAIlS,EAChBmS,EAAiBjM,EAAOgM,GACxBE,EAAsBlM,EAAOgM,EAAY,GACzCG,EAAoBnM,EAAOgM,EAAY,GACvC9E,EAAgBlH,EAAOgM,EAAY,GACzC,GAAKC,EAAiBN,GAAmBM,IAAmBN,GAAkBQ,GAAqBf,EAAa,CAC5G,GAAKa,EAAiBL,GAAiBK,IAAmBL,GAAgBM,GAAuBZ,EAE7F,SAIIiB,IAAeD,IAEfC,EAAaD,EACbF,EAAa,EACbI,EAAqBP,EAGjC,CACAM,EAAWH,KAAgBH,EAAiBO,EAC5CD,EAAWH,KAAgBF,EAC3BK,EAAWH,KAAgBD,EAC3BI,EAAWH,KAAgBlF,CAC/B,CACA,MAAO,CAAC,IAAIyD,EAA6B,IAAInK,YAAY6L,IAAW,IAAI1B,EAA6B,IAAInK,YAAY8L,IAAWE,EACpI,GAAC,CAAApW,IAAA,oBAAAY,MACD,SAAkByV,EAAmCd,EAAgBe,EAAgBd,EAAce,GAgD/F,IALA,IAAM3M,EAASzK,KAAK2K,QACdgL,EAAa3V,KAAKqV,YAClBgC,EAAoBhB,EAAeD,EACrCE,EAAgB,EAChBC,GAAmB,EACdhS,EAAI,EAAGA,EAAIoR,EAAYpR,IAAK,CACjC,IAAMkS,EAAY,EAAIlS,EAClBmS,EAAiBjM,EAAOgM,GACxBE,EAAsBlM,EAAOgM,EAAY,GACzCG,EAAoBnM,EAAOgM,EAAY,GACrC9E,EAAgBlH,EAAOgM,EAAY,GACzC,GAAIC,EAAiBN,GAAmBM,IAAmBN,GAAkBQ,GAAqBO,EAG9Fb,QAHJ,CAMK,GAAII,IAAmBN,GAAkBO,EAAsBQ,EAG5DT,IAAmBL,GAAgBO,EAAoBQ,EAGvDR,GAAsBQ,EAAeD,EAMrCP,EAAoBO,OAGvB,GAAIT,IAAmBN,GAAkBO,IAAwBQ,EAAgB,CAElF,KAAIT,IAAmBL,GAAgBO,EAAoBQ,GAKtD,CAIDb,GAAmB,EACnB,QACJ,CARIK,GAAsBQ,EAAeD,CAS7C,MACK,GAAIT,EAAiBL,GAAiBK,IAAmBL,GAAgBM,EAAsBS,EAAe,CAE/G,KAAIV,IAAmBL,GAAgBO,EAAoBQ,GAOtD,CAIDb,GAAmB,EACnB,QACJ,CAVIG,EAAiBN,EAEjBQ,GADAD,EAAsBQ,IACqBP,EAAoBQ,EASvE,MACK,GAAIV,EAAiBL,EAAc,CAEpC,GAAyB,IAArBgB,IAA2Bd,EAAkB,CAE7CD,EAAgBX,EAChB,KACJ,CACAe,GAAkBW,CACtB,KACK,MAAIX,IAAmBL,GAAgBM,GAAuBS,GAW/D,MAAM,IAAIzR,MAAM,iBATZuR,GAAwD,IAAnBR,IACrCC,GAAuBO,EACvBN,GAAqBM,GAEzBR,GAAkBW,EAClBV,GAAwBS,EAAeD,EACvCP,GAAsBQ,EAAeD,CAIzC,CACA,IAAMN,EAAa,EAAIP,EACvB7L,EAAOoM,GAAcH,EACrBjM,EAAOoM,EAAa,GAAKF,EACzBlM,EAAOoM,EAAa,GAAKD,EACzBnM,EAAOoM,EAAa,GAAKlF,EACzB2E,GANA,CAOJ,CACAtW,KAAKqV,YAAciB,CACvB,GAAC,CAAAzV,IAAA,mBAAAY,MACD,SAAiBuU,EAAWsB,EAAWtJ,EAAUC,EAAiByG,EAAgBG,GAqB9E,IAPA,IAAM0C,EAAqD,IAAbvJ,GACnB,IAApBC,IACE4G,GAAiB,IAA4BA,GAAiB,IAC3DA,GAAiB,IAAuBA,GAAiB,IACzDA,GAAiB,IAAuBA,GAAiB,KAC/DpK,EAASzK,KAAK2K,QACdgL,EAAa3V,KAAKqV,YACf9Q,EAAI,EAAGA,EAAIoR,EAAYpR,IAAK,CACjC,IAAMwM,EAAS,EAAIxM,EACfmS,EAAiBjM,EAAOsG,GACxB4F,EAAsBlM,EAAOsG,EAAS,GACtC6F,EAAoBnM,EAAOsG,EAAS,GACxC,KAAI2F,EAAiBV,GAAcU,IAAmBV,GAAaY,EAAoBU,GAAvF,CAKK,GAAIZ,IAAmBV,GAAaY,IAAsBU,EAAW,CAGtE,IAAIC,EAIA,SAHAX,GAAqB,CAK7B,MACK,GAAIF,IAAmBV,GAAaW,EAAsBW,GAAaA,EAAYV,EAEnE,IAAb5I,EAEA4I,GAAqB3I,EAIrB2I,EAAoBU,MAGvB,CAED,GAAIZ,IAAmBV,GAAaW,IAAwBW,GAIpDC,EACA,SAIR,GAAIb,IAAmBV,EAGnB,GAFAU,GAAkB1I,EAED,IAAbA,EACA2I,GAAuB1I,EACvB2I,GAAqB3I,MAEpB,CACD,IAAMuJ,EAAcZ,EAAoBD,EAExCC,GADAD,EAAsBjC,GAAkBiC,EAAsBW,IACpBE,CAC9C,MAGAd,GAAkB1I,CAE1B,CACAvD,EAAOsG,GAAU2F,EACjBjM,EAAOsG,EAAS,GAAK4F,EACrBlM,EAAOsG,EAAS,GAAK6F,CAHrB,CAIJ,CACJ,KAACxB,CAAA,CAhX6B,GAkXrBe,EAAgB,WACzB,SAAAA,EAAY1L,IAAQ1K,EAAAA,EAAAA,GAAA,KAAAoW,GAChBnW,KAAK2K,QAAUF,CACnB,CAYC,OAZA/K,EAAAA,EAAAA,GAAAyW,EAAA,EAAAtV,IAAA,WAAAY,MACD,WACI,OAAOzB,KAAK2K,QAAQ/I,OAAS,CACjC,GAAC,CAAAf,IAAA,oBAAAY,MACD,SAAkBuK,GACd,OAAOhM,KAAK2K,QAAQ,EAAIqB,EAAa,EACzC,GAAC,CAAAnL,IAAA,kBAAAY,MACD,SAAgBuK,GACZ,OAAOhM,KAAK2K,QAAQ,EAAIqB,EAAa,EACzC,GAAC,CAAAnL,IAAA,cAAAY,MACD,SAAYuK,GACR,OAAOhM,KAAK2K,QAAQ,EAAIqB,EAAa,EACzC,KAACmK,CAAA,CAfwB,E,8HC1ehBsB,EAAiB,WAC1B,SAAAA,EAAY7K,IAAiB7M,EAAAA,EAAAA,GAAA,KAAA0X,GACzBzX,KAAK0X,QAAU,GACf1X,KAAK2X,aAAc,EACnB3X,KAAK+M,iBAAmBH,CAC5B,CA6KC,OA7KAlN,EAAAA,EAAAA,GAAA+X,EAAA,EAAA5W,IAAA,QAAAY,MACD,WACIzB,KAAK0X,QAAU,GACf1X,KAAK2X,aAAc,CACvB,GAAC,CAAA9W,IAAA,UAAAY,MACD,WACI,OAAgC,IAAxBzB,KAAK0X,QAAQ9V,MACzB,GAAC,CAAAf,IAAA,MAAAY,MACD,SAAI6T,EAAQsC,GACR5X,KAAK0X,QAAUpC,GAAU,GACzBtV,KAAK2X,YAAcC,CACvB,GAAC,CAAA/W,IAAA,aAAAY,MACD,SAAWoW,EAAQvC,GAEf,IAAI3V,EAAQkY,EACZ,GAAIvC,EAAO1T,OAAS,EAAG,CACnB,IAAMkW,EAAcxC,EAAO,GAAG1B,WACxBmE,EAAazC,EAAOA,EAAO1T,OAAS,GAAGgS,WAC7C,IAAKkE,IAAgBC,EACjB,OAAOF,EAEXlY,EAAQkY,EAAOG,UAAUF,GAAaE,UAAUD,EACpD,CAEA,IADA,IAAIE,EAAiB,KACZ1T,EAAI,EAAGC,EAAMxE,KAAK0X,QAAQ9V,OAAQ2C,EAAIC,EAAKD,IAAK,CACrD,IAAM2T,EAAQlY,KAAK0X,QAAQnT,GAC3B,KAAI2T,EAAM9U,cAAgBzD,EAAMsD,iBAAhC,CAIA,GAAIiV,EAAMjV,gBAAkBtD,EAAMyD,cAAe,CAG7C6U,EAAiBA,GAAkB,CAAEE,MAAO5T,GAC5C,KACJ,CAGA,GADA2T,EAAMlE,aAAarU,GACfuY,EAAMxE,UAEN1T,KAAK0X,QAAQnK,OAAOhJ,EAAG,GACvBA,IACAC,SAGJ,KAAI0T,EAAM9U,cAAgBzD,EAAMsD,iBAIhC,GAAIiV,EAAMjV,gBAAkBtD,EAAMyD,cAE9B6U,EAAiBA,GAAkB,CAAEE,MAAO5T,OAFhD,CAMA,IAAA6T,EAAeF,EAAM/D,MAAMxU,GAAM0Y,GAAAhE,EAAAA,EAAAA,GAAA+D,EAAA,GAA1B7U,EAAC8U,EAAA,GAAE7U,EAAC6U,EAAA,GACP9U,EAAEmQ,UAEFuE,EAAiBA,GAAkB,CAAEE,MAAO5T,GAG5Cf,EAAEkQ,YAIN1T,KAAK0X,QAAQnK,OAAOhJ,EAAG,EAAGhB,EAAGC,GAC7Be,IACAC,IACAyT,EAAiBA,GAAkB,CAAEE,MAAO5T,GAf5C,CAxBA,CAwCJ,CAOA,OANA0T,EAAiBA,GAAkB,CAAEE,MAAOnY,KAAK0X,QAAQ9V,QACrD0T,EAAO1T,OAAS,IAChB5B,KAAK0X,QAAUhK,EAAAA,GAAmB1N,KAAK0X,QAASO,EAAeE,MAAO7C,IAInE3V,CACX,GAAC,CAAAkB,IAAA,aAAAY,MACD,WACI,OAAOzB,KAAK2X,WAChB,GAAC,CAAA9W,IAAA,kBAAAY,MACD,SAAgBJ,EAAYyV,GACxB,GAAwC,IAApCA,EAAQ9D,iBAAiBpR,OAEzB,OAAOkV,EAEX,IAAMxB,EAAStV,KAAK0X,QACpB,GAAsB,IAAlBpC,EAAO1T,OACP,OAAOkV,EAEX,IACMC,EAAUzB,EADGmC,EAAkBa,wBAAwBhD,EAAQjU,IAClCmO,cAAcnO,GACjD,IAAK0V,EACD,OAAOD,EAgBX,IAdA,IAAMyB,EAAOzB,EAAQjE,WACf2F,EAAOzB,EAAQlE,WACjB4F,EAAS,EACP3W,EAAS,GACX4W,EAAY,EACZC,EAAgB,EACdC,EAAY,SAAC3H,EAAWT,GACtBS,IAAc0H,IAGlBA,EAAgB1H,EAChBnP,EAAO4W,KAAezH,EACtBnP,EAAO4W,KAAelI,EAC1B,EACSqI,EAAS,EAAGA,EAASL,EAAMK,IAAU,CAY1C,IAXA,IAAMC,EAAkB/B,EAAQgC,kBAAkBF,GAC5CG,EAAgBjC,EAAQkC,gBAAgBJ,GACxCK,EAAYnC,EAAQhE,YAAY8F,GAChCM,IAAuB,EAAZD,EAA0D,KAAwC,IAC/F,EAAZA,EAAwD,KAAsC,IAClF,EAAZA,EAA6D,KAA2C,IAC5F,EAAZA,EAAiE,MAAgD,IACrG,GAAZA,EAA+D,SAAgD,IACnG,GAAZA,EAA+D,WAAkD,MAAQ,EAC3HE,GAAUD,IAAW,EAEpBV,EAASF,GAAQzB,EAAQ7D,aAAawF,IAAWK,GACpDF,EAAU9B,EAAQ7D,aAAawF,GAAS3B,EAAQ/D,YAAY0F,IAC5DA,IAOJ,IAJIA,EAASF,GAAQzB,EAAQhE,eAAe2F,GAAUK,GAClDF,EAAUE,EAAiBhC,EAAQ/D,YAAY0F,IAG5CA,EAASF,GAAQzB,EAAQ7D,aAAawF,GAAUO,GACnDJ,EAAU9B,EAAQ7D,aAAawF,GAAU3B,EAAQ/D,YAAY0F,GAAUW,EAAUF,EAAYC,GAC7FV,IAEJ,GAAIA,EAASF,EACTK,EAAUI,EAAgBlC,EAAQ/D,YAAY0F,GAAUW,EAAUF,EAAYC,GAC1ErC,EAAQ7D,aAAawF,KAAYO,GAEjCP,QAGH,CACD,IAAMY,EAAcjH,KAAKc,IAAId,KAAK8D,IAAI,EAAGuC,EAAS,GAAIF,EAAO,GAE7DK,EAAUI,EAAgBlC,EAAQ/D,YAAYsG,GAAeD,EAAUF,EAAYC,EACvF,CACJ,CAEA,KAAOV,EAASF,GACZK,EAAU9B,EAAQ7D,aAAawF,GAAS3B,EAAQ/D,YAAY0F,IAC5DA,IAEJ,OAAO,IAAI7M,EAAAA,EAAW,IAAIX,YAAYnJ,GAASgV,EAAQ9D,iBAAkBhT,KAAK+M,iBAClF,GAAC,CAAAlM,IAAA,aAAAY,MAqBD,SAAW9B,EAAOqO,EAAUC,EAAiByG,EAAgBG,GAAe,IACxChT,EADwCG,GAAAC,EAAAA,EAAAA,GACpDjC,KAAK0X,SAAO,IAAhC,IAAA1V,EAAAE,MAAAL,EAAAG,EAAAG,KAAAC,MAAkC,CAAlBP,EAAAJ,MACNkT,WAAWhV,EAAOqO,EAAUC,EAAiByG,EAAgBG,EACvE,CAAC,OAAArS,GAAAR,EAAAS,EAAAD,EAAA,SAAAR,EAAAU,GAAA,CACL,IAAC,EAAA7B,IAAA,0BAAAY,MAxBD,SAA+B6T,EAAQjU,GAGnC,IAFA,IAAI4Q,EAAM,EACNC,EAAOoD,EAAO1T,OAAS,EACpBqQ,EAAMC,GAAM,CACf,IAAIC,EAAMF,EAAMG,KAAKC,OAAOH,EAAOD,GAAO,GAC1C,GAAIqD,EAAOnD,GAAK/O,cAAgB/B,EAC5B4Q,EAAME,EAAM,MAEX,MAAImD,EAAOnD,GAAKlP,gBAAkB5B,GAGlC,CACD,KAAO8Q,EAAMF,GAAOqD,EAAOnD,EAAM,GAAGlP,iBAAmB5B,GAAcA,GAAciU,EAAOnD,EAAM,GAAG/O,eAC/F+O,IAEJ,OAAOA,CACX,CAPID,EAAOC,EAAM,CAOjB,CACJ,CACA,OAAOF,CACX,KAACwF,CAAA,CAlLyB,E,uGCJjB6B,EAAgB,SAAAlQ,IAAAjJ,EAAAA,EAAAA,GAAAmZ,EAAAlQ,GAAA,IAAAhJ,GAAAC,EAAAA,EAAAA,GAAAiZ,GACzB,SAAAA,IAAc,IAAA5Y,EAEgB,OAFhBX,EAAAA,EAAAA,GAAA,KAAAuZ,IACV5Y,EAAAN,EAAAO,KAAA,OACK4Y,eAAgB,EAAK7Y,CAC9B,CA4KC,OA5KAhB,EAAAA,EAAAA,GAAA4Z,EAAA,EAAAzY,IAAA,eAAAY,MACD,WACI,OAAOzB,KAAKuZ,aAChB,GAAC,CAAA1Y,IAAA,oBAAAY,MACD,WACIzB,KAAKuZ,eAAgB,CACzB,GAAC,CAAA1Y,IAAA,kBAAAY,MACD,WACIzB,KAAKuZ,eAAgB,CACzB,GAAC,CAAA1Y,IAAA,cAAAY,MACD,WACIzB,KAAKuZ,eAAgB,CACzB,GACA,CAAA1Y,IAAA,qBAAAY,MACA,SAAmBgB,GACf,OAAO,CACX,GAAC,CAAA5B,IAAA,mBAAAY,MACD,SAAiBgB,GACb,OAAO,CACX,GAAC,CAAA5B,IAAA,yBAAAY,MACD,SAAuBgB,GACnB,OAAO,CACX,GAAC,CAAA5B,IAAA,uBAAAY,MACD,SAAqBgB,GACjB,OAAO,CACX,GAAC,CAAA5B,IAAA,uBAAAY,MACD,SAAqBgB,GACjB,OAAO,CACX,GAAC,CAAA5B,IAAA,YAAAY,MACD,SAAUgB,GACN,OAAO,CACX,GAAC,CAAA5B,IAAA,iBAAAY,MACD,SAAegB,GACX,OAAO,CACX,GAAC,CAAA5B,IAAA,iCAAAY,MACD,SAA+BgB,GAC3B,OAAO,CACX,GAAC,CAAA5B,IAAA,uBAAAY,MACD,SAAqBgB,GACjB,OAAO,CACX,GAAC,CAAA5B,IAAA,iBAAAY,MACD,SAAegB,GACX,OAAO,CACX,GAAC,CAAA5B,IAAA,iBAAAY,MACD,SAAegB,GACX,OAAO,CACX,GAAC,CAAA5B,IAAA,kBAAAY,MACD,SAAgBgB,GACZ,OAAO,CACX,GAAC,CAAA5B,IAAA,uBAAAY,MACD,SAAqBgB,GACjB,OAAO,CACX,GAAC,CAAA5B,IAAA,kBAAAY,MACD,SAAgBgB,GACZ,OAAO,CACX,GAAC,CAAA5B,IAAA,iBAAAY,MACD,SAAegB,GACX,OAAO,CACX,GAAC,CAAA5B,IAAA,kBAAAY,MACD,SAAgBgB,GACZ,OAAO,CACX,GAAC,CAAA5B,IAAA,wBAAAY,MACD,SAAsBgB,GAClB,OAAO,CACX,GAAC,CAAA5B,IAAA,iBAAAY,MACD,SAAegB,GACX,OAAO,CACX,GACA,CAAA5B,IAAA,eAAAY,MACA,SAAa+X,GAET,IADA,IAAIC,GAAe,EACVlV,EAAI,EAAGC,EAAMgV,EAAO5X,OAAQ2C,EAAIC,EAAKD,IAAK,CAC/C,IAAM9B,EAAI+W,EAAOjV,GACjB,OAAQ9B,EAAE6B,MACN,KAAK,EACGtE,KAAK0Z,mBAAmBjX,KACxBgX,GAAe,GAEnB,MACJ,KAAK,EACGzZ,KAAK2Z,iBAAiBlX,KACtBgX,GAAe,GAEnB,MACJ,KAAK,EACGzZ,KAAK4Z,uBAAuBnX,KAC5BgX,GAAe,GAEnB,MACJ,KAAK,EACGzZ,KAAK6Z,qBAAqBpX,KAC1BgX,GAAe,GAEnB,MACJ,KAAK,EACGzZ,KAAK8Z,qBAAqBrX,KAC1BgX,GAAe,GAEnB,MACJ,KAAK,EACGzZ,KAAK+Z,UAAUtX,KACfgX,GAAe,GAEnB,MACJ,KAAK,EACGzZ,KAAKga,eAAevX,KACpBgX,GAAe,GAEnB,MACJ,KAAK,EACGzZ,KAAKia,+BAA+BxX,KACpCgX,GAAe,GAEnB,MACJ,KAAK,EACGzZ,KAAKka,qBAAqBzX,KAC1BgX,GAAe,GAEnB,MACJ,KAAK,EACGzZ,KAAKma,eAAe1X,KACpBgX,GAAe,GAEnB,MACJ,KAAK,GACGzZ,KAAKoa,eAAe3X,KACpBgX,GAAe,GAEnB,MACJ,KAAK,GACGzZ,KAAKqa,gBAAgB5X,KACrBgX,GAAe,GAEnB,MACJ,KAAK,GACGzZ,KAAKsa,qBAAqB7X,KAC1BgX,GAAe,GAEnB,MACJ,KAAK,GACGzZ,KAAKua,gBAAgB9X,KACrBgX,GAAe,GAEnB,MACJ,KAAK,GACGzZ,KAAKwa,gBAAgB/X,KACrBgX,GAAe,GAEnB,MACJ,KAAK,GACGzZ,KAAKya,eAAehY,KACpBgX,GAAe,GAEnB,MACJ,KAAK,GACGzZ,KAAK0a,sBAAsBjY,KAC3BgX,GAAe,GAEnB,MACJ,KAAK,GACGzZ,KAAK2a,eAAelY,KACpBgX,GAAe,GAEnB,MACJ,QACImB,QAAQC,KAAK,iCACbD,QAAQC,KAAKpY,GAEzB,CACIgX,IACAzZ,KAAKuZ,eAAgB,EAE7B,KAACD,CAAA,CAhLwB,C,SAAS/O,G,2eCDzBuQ,GAAyBpb,EAAAA,EAAAA,IAClC,SAAAob,KAAc/a,EAAAA,EAAAA,GAAA,KAAA+a,GACV9a,KAAKsE,KAAO,CAChB,IAESyW,GAAuBrb,EAAAA,EAAAA,IAChC,SAAAqb,KAAchb,EAAAA,EAAAA,GAAA,KAAAgb,GACV/a,KAAKsE,KAAO,CAChB,IAES0W,EAA6B,WACtC,SAAAA,EAAY1I,IAAQvS,EAAAA,EAAAA,GAAA,KAAAib,GAChBhb,KAAKsE,KAAO,EACZtE,KAAKuS,QAAUD,CACnB,CAGC,OAHA5S,EAAAA,EAAAA,GAAAsb,EAAA,EAAAna,IAAA,aAAAY,MACD,SAAWwZ,GACP,OAAOjb,KAAKuS,QAAQ2I,WAAWD,EACnC,KAACD,CAAA,CAPqC,GAS7BG,GAA2Bzb,EAAAA,EAAAA,IACpC,SAAAyb,EAAYC,EAAYC,EAAiBC,IAAQvb,EAAAA,EAAAA,GAAA,KAAAob,GAC7Cnb,KAAKob,WAAaA,EAClBpb,KAAKqb,gBAAkBA,EACvBrb,KAAKsb,OAASA,EACdtb,KAAKsE,KAAO,CAChB,IAESiX,GAA2B7b,EAAAA,EAAAA,IACpC,SAAA6b,EAAYjJ,IAAQvS,EAAAA,EAAAA,GAAA,KAAAwb,GAChBvb,KAAKsE,KAAO,EACRgO,GACAtS,KAAKwb,eAAiBlJ,EAAOkJ,eAC7Bxb,KAAKyb,qBAAuBnJ,EAAOmJ,qBACnCzb,KAAK0b,mBAAqBpJ,EAAOoJ,qBAGjC1b,KAAKwb,gBAAiB,EACtBxb,KAAKyb,sBAAuB,EAC5Bzb,KAAK0b,oBAAqB,EAElC,IAESC,GAAgBjc,EAAAA,EAAAA,IACzB,SAAAic,KAAc5b,EAAAA,EAAAA,GAAA,KAAA4b,GACV3b,KAAKsE,KAAO,CAEhB,IAESsX,GAAqBlc,EAAAA,EAAAA,IAC9B,SAAAkc,EAAYC,IAAW9b,EAAAA,EAAAA,GAAA,KAAA6b,GACnB5b,KAAKsE,KAAO,EACZtE,KAAK6b,UAAYA,CACrB,IAESC,GAA8Bpc,EAAAA,EAAAA,IACvC,SAAAoc,KAAc/b,EAAAA,EAAAA,GAAA,KAAA+b,GACV9b,KAAKsE,KAAO,CAChB,IAESyX,GAA2Brc,EAAAA,EAAAA,IACpC,SAAAqc,KAAchc,EAAAA,EAAAA,GAAA,KAAAgc,GACV/b,KAAKsE,KAAO,CAEhB,IAES0X,GAAqBtc,EAAAA,EAAAA,IAC9B,SAAAsc,EAIApY,EAIAqY,IAAOlc,EAAAA,EAAAA,GAAA,KAAAic,GACHhc,KAAK4D,eAAiBA,EACtB5D,KAAKic,MAAQA,EACbjc,KAAKsE,KAAO,CAChB,IAES4X,GAAqBxc,EAAAA,EAAAA,IAC9B,SAAAwc,EAAYtY,EAAgBC,IAAc9D,EAAAA,EAAAA,GAAA,KAAAmc,GACtClc,KAAKsE,KAAO,GACZtE,KAAK4D,eAAiBA,EACtB5D,KAAK6D,aAAeA,CACxB,IAESsY,GAAsBzc,EAAAA,EAAAA,IAC/B,SAAAyc,EAAYvY,EAAgBC,IAAc9D,EAAAA,EAAAA,GAAA,KAAAoc,GACtCnc,KAAKsE,KAAO,GACZtE,KAAK4D,eAAiBA,EACtB5D,KAAK6D,aAAeA,CACxB,IAESuY,GAA2B1c,EAAAA,EAAAA,IACpC,SAAA0c,EAIA9J,EAIA+J,EAIA1c,EAIAyb,EAIAkB,EAKAC,EAIAC,IAAYzc,EAAAA,EAAAA,GAAA,KAAAqc,GACRpc,KAAKsS,OAASA,EACdtS,KAAKqc,cAAgBA,EACrBrc,KAAKL,MAAQA,EACbK,KAAKob,WAAaA,EAClBpb,KAAKsc,aAAeA,EACpBtc,KAAKuc,iBAAmBA,EACxBvc,KAAKwc,WAAaA,EAClBxc,KAAKsE,KAAO,EAChB,IAESmY,GAAsB/c,EAAAA,EAAAA,IAC/B,SAAA+c,EAAYnK,IAAQvS,EAAAA,EAAAA,GAAA,KAAA0c,GAChBzc,KAAKsE,KAAO,GACZtE,KAAK0c,YAAcpK,EAAOoK,YAC1B1c,KAAK2c,WAAarK,EAAOqK,WACzB3c,KAAK4c,aAAetK,EAAOsK,aAC3B5c,KAAK6c,UAAYvK,EAAOuK,UACxB7c,KAAK8c,mBAAqBxK,EAAOwK,mBACjC9c,KAAK+c,kBAAoBzK,EAAOyK,kBAChC/c,KAAKgd,oBAAsB1K,EAAO0K,oBAClChd,KAAKid,iBAAmB3K,EAAO2K,gBACnC,IAESC,GAAqBxd,EAAAA,EAAAA,IAC9B,SAAAwd,EAAYC,IAAOpd,EAAAA,EAAAA,GAAA,KAAAmd,GACfld,KAAKmd,MAAQA,EACbnd,KAAKsE,KAAO,EAChB,IAES8Y,GAAsB1d,EAAAA,EAAAA,IAC/B,SAAA0d,EAAYpO,IAAQjP,EAAAA,EAAAA,GAAA,KAAAqd,GAChBpd,KAAKsE,KAAO,GACZtE,KAAKgP,OAASA,CAClB,IAESqO,GAA4B3d,EAAAA,EAAAA,IACrC,SAAA2d,KAActd,EAAAA,EAAAA,GAAA,KAAAsd,GACVrd,KAAKsE,KAAO,EAEhB,IAESgZ,GAAqB5d,EAAAA,EAAAA,IAC9B,SAAA4d,KAAcvd,EAAAA,EAAAA,GAAA,KAAAud,GACVtd,KAAKsE,KAAO,EAEhB,G,gICzKSiZ,EAAc,WACvB,SAAAA,EAAYra,EAAaG,EAAWkC,EAAWjB,IAAMvE,EAAAA,EAAAA,GAAA,KAAAwd,GACjDvd,KAAKkD,YAAcA,EACnBlD,KAAKqD,UAAYA,EACjBrD,KAAKuF,UAAYA,EACjBvF,KAAKsE,KAAOA,EACZtE,KAAKwd,0BAAuBvN,CAChC,CA+EC,OA/EAvQ,EAAAA,EAAAA,GAAA6d,EAAA,OAAA1c,IAAA,UAAAY,MACD,SAAe8B,EAAGC,GACd,OAAQD,EAAEL,cAAgBM,EAAEN,aACrBK,EAAEF,YAAcG,EAAEH,WAClBE,EAAEgC,YAAc/B,EAAE+B,WAClBhC,EAAEe,OAASd,EAAEc,IACxB,GAAC,CAAAzD,IAAA,YAAAY,MACD,SAAiB8B,EAAGC,GAChB,IAAM+U,EAAOhV,EAAE3B,OAEf,GAAI2W,IADS/U,EAAE5B,OAEX,OAAO,EAEX,IAAK,IAAI2C,EAAI,EAAGA,EAAIgU,EAAMhU,IACtB,IAAKgZ,EAAexP,QAAQxK,EAAEgB,GAAIf,EAAEe,IAChC,OAAO,EAGf,OAAO,CACX,GAAC,CAAA1D,IAAA,iBAAAY,MACD,SAAsBiL,EAAKsE,EAAaC,GACpC,GAAmB,IAAfvE,EAAI9K,OACJ,OAAO8K,EAEX,IAKqB7K,EALfqB,EAAc8N,EAAc,EAC5B3N,EAAY4N,EAAY,EACxBwM,EAAaxM,EAAYD,EACzB0M,EAAI,GACNC,EAAU,EAAE3b,GAAAC,EAAAA,EAAAA,GACEyK,GAAG,IAArB,IAAA1K,EAAAE,MAAAL,EAAAG,EAAAG,KAAAC,MAAuB,KAAZwb,EAAG/b,EAAAJ,MACNmc,EAAIva,WAAaH,GAAe0a,EAAI1a,aAAeG,IAGvDqa,EAAEC,KAAa,IAAIJ,EAAenL,KAAK8D,IAAI,EAAG0H,EAAI1a,YAAcA,EAAc,GAAIkP,KAAKc,IAAIuK,EAAa,EAAGG,EAAIva,UAAYH,EAAc,GAAI0a,EAAIrY,UAAWqY,EAAItZ,MACpK,CAAC,OAAA9B,GAAAR,EAAAS,EAAAD,EAAA,SAAAR,EAAAU,GAAA,CACD,OAAOgb,CACX,GAAC,CAAA7c,IAAA,SAAAY,MACD,SAAcoc,EAAiBxc,EAAYyc,EAAeC,GACtD,GAA+B,IAA3BF,EAAgBjc,OAChB,MAAO,GAIX,IAFA,IAAME,EAAS,GACX4W,EAAY,EACPnU,EAAI,EAAGC,EAAMqZ,EAAgBjc,OAAQ2C,EAAIC,EAAKD,IAAK,CACxD,IAAMyZ,EAAIH,EAAgBtZ,GACpB5E,EAAQqe,EAAEre,MAChB,KAAIA,EAAMyD,cAAgB/B,GAAc1B,EAAMsD,gBAAkB5B,MAI5D1B,EAAM+T,WAAyB,IAAXsK,EAAE1Z,MAA4D,IAAX0Z,EAAE1Z,MAA7E,CAIA,IAAMpB,EAAevD,EAAMsD,kBAAoB5B,EAAa1B,EAAMuD,YAAc4a,EAC1Eza,EAAa1D,EAAMyD,gBAAkB/B,EAAa1B,EAAM0D,UAAY0a,EAC1Ejc,EAAO4W,KAAe,IAAI6E,EAAera,EAAaG,EAAW2a,EAAEC,gBAAiBD,EAAE1Z,KAHtF,CAIJ,CACA,OAAOxC,CACX,GAAC,CAAAjB,IAAA,eAAAY,MACD,SAAoB8B,EAAGC,GACnB,IAAM0a,EAAQ,CAAC,EAAG,EAAG,EAAG,GACxB,OAAOA,EAAM3a,GAAK2a,EAAM1a,EAC5B,GAAC,CAAA3C,IAAA,UAAAY,MACD,SAAe8B,EAAGC,GACd,GAAID,EAAEL,cAAgBM,EAAEN,YACpB,OAAOK,EAAEL,YAAcM,EAAEN,YAE7B,GAAIK,EAAEF,YAAcG,EAAEH,UAClB,OAAOE,EAAEF,UAAYG,EAAEH,UAE3B,IAAM8a,EAAUZ,EAAea,aAAa7a,EAAEe,KAAMd,EAAEc,MACtD,OAAgB,IAAZ6Z,EACOA,EAEP5a,EAAEgC,YAAc/B,EAAE+B,UACXhC,EAAEgC,UAAY/B,EAAE+B,WAAa,EAAI,EAErC,CACX,KAACgY,CAAA,CAtFsB,GAwFdc,GAAiB3e,EAAAA,EAAAA,IAC1B,SAAA2e,EAAYrN,EAAaC,EAAW1L,EAAWiL,IAAUzQ,EAAAA,EAAAA,GAAA,KAAAse,GACrDre,KAAKgR,YAAcA,EACnBhR,KAAKiR,UAAYA,EACjBjR,KAAKuF,UAAYA,EACjBvF,KAAKwQ,SAAWA,CACpB,IAEE8N,EAAK,WACP,SAAAA,KAAcve,EAAAA,EAAAA,GAAA,KAAAue,GACVte,KAAKue,YAAc,GACnBve,KAAKwe,WAAa,GAClBxe,KAAKwQ,SAAW,GAChBxQ,KAAKic,MAAQ,CACjB,CAOC,OAPAvc,EAAAA,EAAAA,GAAA4e,EAAA,EAAAzd,IAAA,mBAAAY,MAQD,SAAiBgd,EAAeC,EAAiB5c,GAC7C,KAAO9B,KAAKic,MAAQ,GAAKjc,KAAKue,YAAY,GAAKE,GAAe,CAG1D,IAFA,IAAIla,EAAI,EAEDA,EAAI,EAAIvE,KAAKic,OAASjc,KAAKue,YAAYha,KAAOvE,KAAKue,YAAYha,EAAI,IACtEA,IAGJzC,EAAOkB,KAAK,IAAIqb,EAAkBK,EAAiB1e,KAAKue,YAAYha,GAAIvE,KAAKwe,WAAW9I,KAAK,KAAM4I,EAAMK,UAAU3e,KAAKwQ,YACxHkO,EAAkB1e,KAAKue,YAAYha,GAAK,EAExCvE,KAAKue,YAAYhR,OAAO,EAAGhJ,EAAI,GAC/BvE,KAAKwe,WAAWjR,OAAO,EAAGhJ,EAAI,GAC9BvE,KAAKwQ,SAASjD,OAAO,EAAGhJ,EAAI,GAC5BvE,KAAKic,OAAU1X,EAAI,CACvB,CAKA,OAJIvE,KAAKic,MAAQ,GAAKyC,EAAkBD,IACpC3c,EAAOkB,KAAK,IAAIqb,EAAkBK,EAAiBD,EAAgB,EAAGze,KAAKwe,WAAW9I,KAAK,KAAM4I,EAAMK,UAAU3e,KAAKwQ,YACtHkO,EAAkBD,GAEfC,CACX,GAAC,CAAA7d,IAAA,SAAAY,MACD,SAAOmd,EAAYrZ,EAAWiL,GAC1B,GAAmB,IAAfxQ,KAAKic,OAAejc,KAAKue,YAAYve,KAAKic,MAAQ,IAAM2C,EAExD5e,KAAKue,YAAYvb,KAAK4b,GACtB5e,KAAKwe,WAAWxb,KAAKuC,GACrBvF,KAAKwQ,SAASxN,KAAKwN,QAInB,IAAK,IAAIjM,EAAI,EAAGA,EAAIvE,KAAKic,MAAO1X,IAC5B,GAAIvE,KAAKue,YAAYha,IAAMqa,EAAY,CACnC5e,KAAKue,YAAYhR,OAAOhJ,EAAG,EAAGqa,GAC9B5e,KAAKwe,WAAWjR,OAAOhJ,EAAG,EAAGgB,GAC7BvF,KAAKwQ,SAASjD,OAAOhJ,EAAG,EAAGiM,GAC3B,KACJ,CAGRxQ,KAAKic,OAET,IAAC,EAAApb,IAAA,YAAAY,MAjDD,SAAiB+O,GAEb,IADA,IAAI1O,EAAS,EACJyC,EAAI,EAAGC,EAAMgM,EAAS5O,OAAQ2C,EAAIC,EAAKD,IAC5CzC,GAAU0O,EAASjM,GAEvB,OAAOzC,CACX,KAACwc,CAAA,CAbM,GA0DEO,EAAyB,oBAAAA,KAAA9e,EAAAA,EAAAA,GAAA,KAAA8e,EAAA,CA4CjC,OA5CiCnf,EAAAA,EAAAA,GAAAmf,EAAA,OAAAhe,IAAA,YAAAY,MAIlC,SAAiBmQ,EAAaiM,GAC1B,GAA+B,IAA3BA,EAAgBjc,OAChB,MAAO,GAKX,IAHA,IAAME,EAAS,GACTgd,EAAQ,IAAIR,EACdI,EAAkB,EACbna,EAAI,EAAGC,EAAMqZ,EAAgBjc,OAAQ2C,EAAIC,EAAKD,IAAK,CACxD,IAAMyZ,EAAIH,EAAgBtZ,GACtBrB,EAAc8a,EAAE9a,YAChBG,EAAY2a,EAAE3a,UACZkC,EAAYyY,EAAEzY,UACdiL,EAAuB,IAAXwN,EAAE1Z,KACd,EACW,IAAX0Z,EAAE1Z,KACE,EACA,EAEV,GAAIpB,EAAc,EAAG,CACjB,IAAM6b,EAAiBnN,EAAYgD,WAAW1R,EAAc,GACxD8b,EAAAA,GAAwBD,IACxB7b,GAER,CACA,GAAIG,EAAY,EAAG,CACf,IAAM0b,EAAiBnN,EAAYgD,WAAWvR,EAAY,GACtD2b,EAAAA,GAAwBD,IACxB1b,GAER,CACA,IAAM4b,EAAqB/b,EAAc,EACnCgc,EAAmB7b,EAAY,EACrCqb,EAAkBI,EAAMK,iBAAiBF,EAAoBP,EAAiB5c,GAC1D,IAAhBgd,EAAM7C,QACNyC,EAAkBO,GAEtBH,EAAMjQ,OAAOqQ,EAAkB3Z,EAAWiL,EAC9C,CAEA,OADAsO,EAAMK,iBAAiB,WAAmDT,EAAiB5c,GACpFA,CACX,KAAC+c,CAAA,CA5CiC,E,0OC3JzBO,EAAQ,WACjB,SAAAA,EAIAC,EAAU/a,EAAMkM,EAAU8O,IAAavf,EAAAA,EAAAA,GAAA,KAAAqf,GACnCpf,KAAKqf,SAAWA,EAChBrf,KAAKsE,KAAOA,EACZtE,KAAKwQ,SAAWA,EAChBxQ,KAAKsf,YAAcA,EACnBtf,KAAKuf,oBAAiBtP,CAC1B,CAMC,OANAvQ,EAAAA,EAAAA,GAAA0f,EAAA,EAAAve,IAAA,eAAAY,MACD,WACI,SAAwB,EAAhBzB,KAAKwQ,SACjB,GAAC,CAAA3P,IAAA,gBAAAY,MACD,WACI,SAAwB,EAAhBzB,KAAKwQ,SACjB,KAAC4O,CAAA,CAjBgB,GCKRI,EAAS,WAClB,SAAAA,EAAYC,EAAYJ,IAAUtf,EAAAA,EAAAA,GAAA,KAAAyf,GAC9Bxf,KAAKgR,YAAcyO,EACnBzf,KAAKiR,UAAYoO,CACrB,CAIC,OAJA3f,EAAAA,EAAAA,GAAA8f,EAAA,EAAA3e,IAAA,SAAAY,MACD,SAAOie,GACH,OAAO1f,KAAKgR,cAAgB0O,EAAe1O,aACpChR,KAAKiR,YAAcyO,EAAezO,SAC7C,KAACuO,CAAA,CARiB,GAUTG,EAAe,WACxB,SAAAA,EAAYC,EAA2BC,EAAgCjO,EAAakO,EAA0BC,EAAcT,EAAaU,EAAkBpV,EAAYiT,EAAiBoC,EAASC,EAAoBC,EAAYC,EAAaC,EAAeC,EAAwBC,EAAkBC,EAAyBC,EAAeC,IAAkB3gB,EAAAA,EAAAA,GAAA,KAAA4f,GAC7V3f,KAAK4f,0BAA4BA,EACjC5f,KAAK6f,+BAAiCA,EACtC7f,KAAK4R,YAAcA,EACnB5R,KAAK8f,yBAA2BA,EAChC9f,KAAK+f,aAAeA,EACpB/f,KAAKsf,YAAcA,EACnBtf,KAAKggB,iBAAmBA,EACxBhgB,KAAK4K,WAAaA,EAClB5K,KAAK6d,gBAAkBA,EAAgBva,KAAKia,EAAAA,GAAeoD,SAC3D3gB,KAAKigB,QAAUA,EACfjgB,KAAKkgB,mBAAqBA,EAC1BlgB,KAAKmgB,WAAaA,EAClBngB,KAAKsgB,uBAAyBA,EAC9BtgB,KAAKugB,iBAAyC,QAArBA,EACnB,EACqB,aAArBA,EACI,EACqB,cAArBA,EACI,EACqB,aAArBA,EACI,EACA,EAClBvgB,KAAKwgB,wBAA0BA,EAC/BxgB,KAAKygB,cAAgBA,EACrBzgB,KAAK0gB,iBAAmBA,GAAoBA,EAAiBpd,MAAK,SAACC,EAAGC,GAAC,OAAKD,EAAEyN,YAAcxN,EAAEwN,aAAe,EAAI,CAAC,IAC7FoB,KAAKwO,IAAIP,EAAgBF,GAC3B/N,KAAKwO,IAAIR,EAAcD,IAEtCngB,KAAK6gB,iBAAmBR,EACxBrgB,KAAK8gB,oBAAsB,QAG3B9gB,KAAK6gB,iBAAmBT,EACxBpgB,KAAK8gB,oBAAsB,IAEnC,CAsCC,OAtCAphB,EAAAA,EAAAA,GAAAigB,EAAA,EAAA9e,IAAA,gBAAAY,MACD,SAAcsf,GACV,GAA8B,OAA1B/gB,KAAK0gB,iBACL,OAA2B,OAApBK,EAEX,GAAwB,OAApBA,EACA,OAAO,EAEX,GAAIA,EAAgBnf,SAAW5B,KAAK0gB,iBAAiB9e,OACjD,OAAO,EAEX,IAAK,IAAI2C,EAAI,EAAGA,EAAIvE,KAAK0gB,iBAAiB9e,OAAQ2C,IAC9C,IAAKvE,KAAK0gB,iBAAiBnc,GAAGyc,OAAOD,EAAgBxc,IACjD,OAAO,EAGf,OAAO,CACX,GAAC,CAAA1D,IAAA,SAAAY,MACD,SAAOqD,GACH,OAAQ9E,KAAK4f,4BAA8B9a,EAAM8a,2BAC1C5f,KAAK6f,iCAAmC/a,EAAM+a,gCAC9C7f,KAAK4R,cAAgB9M,EAAM8M,aAC3B5R,KAAK8f,2BAA6Bhb,EAAMgb,0BACxC9f,KAAK+f,eAAiBjb,EAAMib,cAC5B/f,KAAKsf,cAAgBxa,EAAMwa,aAC3Btf,KAAKggB,mBAAqBlb,EAAMkb,kBAChChgB,KAAKigB,UAAYnb,EAAMmb,SACvBjgB,KAAKkgB,qBAAuBpb,EAAMob,oBAClClgB,KAAKmgB,aAAerb,EAAMqb,YAC1BngB,KAAK6gB,mBAAqB/b,EAAM+b,kBAChC7gB,KAAK8gB,sBAAwBhc,EAAMgc,qBACnC9gB,KAAKsgB,yBAA2Bxb,EAAMwb,wBACtCtgB,KAAKugB,mBAAqBzb,EAAMyb,kBAChCvgB,KAAKwgB,0BAA4B1b,EAAM0b,yBACvCxgB,KAAKygB,gBAAkB3b,EAAM2b,eAC7BlD,EAAAA,GAAe0D,UAAUjhB,KAAK6d,gBAAiB/Y,EAAM+Y,kBACrD7d,KAAK4K,WAAWoW,OAAOlc,EAAM8F,aAC7B5K,KAAKkhB,cAAcpc,EAAM4b,iBACpC,KAACf,CAAA,CA3EuB,GA6EfwB,GAAWzhB,EAAAA,EAAAA,IACpB,SAAAyhB,EAAYC,EAAWC,IAAWthB,EAAAA,EAAAA,GAAA,KAAAohB,GAC9BnhB,KAAKohB,UAAYA,EACjBphB,KAAKqhB,UAAYA,CACrB,IAKSC,EAAgB,WAOzB,SAAAA,EAAY1f,EAAQ2f,IAAWxhB,EAAAA,EAAAA,GAAA,KAAAuhB,GAC3BthB,KAAK4B,OAASA,EACd5B,KAAKwhB,MAAQ,IAAIvW,YAAYjL,KAAK4B,QAClC5B,KAAKyhB,kBAAoB,IAAIxW,YAAYjL,KAAK4B,OAClD,CALC,OAKAlC,EAAAA,EAAAA,GAAA4hB,EAAA,EAAAzgB,IAAA,gBAAAY,MACD,SAAcH,EAAQ8f,EAAWC,EAAWK,GACxC,IAAMC,GAAaP,GAAa,GACzBC,GAAa,KAA0D,EAC9ErhB,KAAKwhB,MAAMlgB,EAAS,GAAKqgB,EACzB3hB,KAAKyhB,kBAAkBngB,EAAS,GAAKogB,CACzC,GAAC,CAAA7gB,IAAA,sBAAAY,MACD,SAAoBH,GAChB,OAAsC,IAAlCtB,KAAKyhB,kBAAkB7f,OAEhB,EAEJ5B,KAAKyhB,kBAAkBngB,EAAS,EAC3C,GAAC,CAAAT,IAAA,uBAAAY,MACD,SAAqBmgB,GACjB,OAAoB,IAAhB5hB,KAAK4B,OACE,EAEPggB,EAAa,EACN5hB,KAAKwhB,MAAM,GAElBI,GAAc5hB,KAAK4B,OACZ5B,KAAKwhB,MAAMxhB,KAAK4B,OAAS,GAE7B5B,KAAKwhB,MAAMI,EACtB,GAAC,CAAA/gB,IAAA,iBAAAY,MACD,SAAeH,GACX,IAAMqgB,EAAW3hB,KAAK6hB,qBAAqBvgB,EAAS,GAC9C8f,EAAYE,EAAiBQ,aAAaH,GAC1CN,EAAYC,EAAiBS,aAAaJ,GAChD,OAAO,IAAIR,EAAYC,EAAWC,EACtC,GAAC,CAAAxgB,IAAA,YAAAY,MACD,SAAUugB,EAAaC,GAEnB,OADmBjiB,KAAKkiB,qBAAqBF,EAAYZ,UAAWa,EAAYD,EAAYX,WACxE,CACxB,GAAC,CAAAxgB,IAAA,uBAAAY,MACD,SAAqB2f,EAAWa,EAAYZ,GACxC,GAAoB,IAAhBrhB,KAAK4B,OACL,OAAO,EAMX,IAJA,IAAMugB,GAAgBf,GAAa,GAC5BC,GAAa,KAA0D,EAC1EnO,EAAM,EACNgD,EAAMlW,KAAK4B,OAAS,EACjBsR,EAAM,EAAIgD,GAAK,CAClB,IAAM/D,EAAQe,EAAMgD,IAAS,EACvBkM,EAAWpiB,KAAKwhB,MAAMrP,GAC5B,GAAIiQ,IAAaD,EACb,OAAOhQ,EAEFiQ,EAAWD,EAChBjM,EAAM/D,EAGNe,EAAMf,CAEd,CACA,GAAIe,IAAQgD,EACR,OAAOhD,EAEX,IAAMmP,EAAWriB,KAAKwhB,MAAMtO,GACtBoP,EAAWtiB,KAAKwhB,MAAMtL,GAC5B,GAAImM,IAAaF,EACb,OAAOjP,EAEX,GAAIoP,IAAaH,EACb,OAAOjM,EAEX,IAAMqM,EAAejB,EAAiBQ,aAAaO,GAanD,OAFyBhB,EAVJC,EAAiBS,aAAaM,KAG/CE,IAFiBjB,EAAiBQ,aAAaQ,GAIhCL,EAGAX,EAAiBS,aAAaO,IAGTjB,EAE7BnO,EAEJgD,CACX,IAAC,EAAArV,IAAA,eAAAY,MA/FD,SAAoBkgB,GAChB,OAAmB,WAAXA,KAA2E,EACvF,GAAC,CAAA9gB,IAAA,eAAAY,MACD,SAAoBkgB,GAChB,OAAmB,MAAXA,KAAsE,CAClF,KAACL,CAAA,CANwB,GAkGhBkB,GAAgB9iB,EAAAA,EAAAA,IACzB,SAAA8iB,EAAYC,EAAkBnD,EAAaoD,IAAyB3iB,EAAAA,EAAAA,GAAA,KAAAyiB,GAChExiB,KAAK2iB,4BAAyB1S,EAC9BjQ,KAAKyiB,iBAAmBA,EACxBziB,KAAKsf,YAAcA,EACnBtf,KAAK0iB,wBAA0BA,CACnC,IAEG,SAASE,EAAeC,EAAOC,GAClC,GAAiC,IAA7BD,EAAMjR,YAAYhQ,OAAc,CAChC,GAAIihB,EAAMhF,gBAAgBjc,OAAS,EAAG,CAElCkhB,EAAGC,aAAa,UAChB,IAGkDlhB,EAH9CmhB,EAAc,EACdC,EAAa,EACbP,EAA0B,EAAgC1gB,GAAAC,EAAAA,EAAAA,GACjC4gB,EAAMhF,iBAAe,IAAlD,IAAA7b,EAAAE,MAAAL,EAAAG,EAAAG,KAAAC,MAAoD,KAAzC8gB,EAAcrhB,EAAAJ,MACO,IAAxByhB,EAAe5e,MAAwE,IAAxB4e,EAAe5e,OAC9Ewe,EAAGC,aAAa,iBAChBD,EAAGC,aAAaG,EAAe3d,WAC/Bud,EAAGC,aAAa,aACY,IAAxBG,EAAe5e,OACfoe,GAA2B,EAC3BM,KAEwB,IAAxBE,EAAe5e,OACfoe,GAA2B,EAC3BO,KAGZ,CAAC,OAAAzgB,GAAAR,EAAAS,EAAAD,EAAA,SAAAR,EAAAU,GAAA,CACDogB,EAAGC,aAAa,WAChB,IAAMN,EAAmB,IAAInB,EAAiB,EAAG0B,EAAcC,GAE/D,OADAR,EAAiBU,cAAc,EAAGH,EAAa,EAAG,GAC3C,IAAIR,EAAiBC,GAAkB,EAAOC,EACzD,CAGA,OADAI,EAAGC,aAAa,8BACT,IAAIP,EAAiB,IAAIlB,EAAiB,EAAG,IAAI,EAAO,EACnE,CACA,OA2cJ,SAAqBuB,EAAOC,GACxB,IAAMM,EAAkBP,EAAMO,gBACxBvD,EAAiCgD,EAAMhD,+BACvC6C,EAA0BG,EAAMH,wBAChC9Q,EAAciR,EAAMjR,YACpBpN,EAAMqe,EAAMre,IACZ6e,EAAgBR,EAAMQ,cACtBC,EAAuBT,EAAMS,qBAC7BC,EAAQV,EAAMU,MACdvD,EAAmB6C,EAAM7C,iBACzBC,EAAU4C,EAAM5C,QAChBC,EAAqB2C,EAAM3C,mBAC3BZ,EAAcuD,EAAMvD,YACpBa,EAAa0C,EAAM1C,WACnBW,EAAsB+B,EAAM/B,oBAC5BP,EAAmBsC,EAAMtC,iBACzBC,EAA0BqC,EAAMrC,wBAChCiC,EAAmB,IAAInB,EAAiB9c,EAAM,EAAG+e,EAAM3hB,QACzD4hB,GAA8B,EAC9BnC,EAAY,EACZ/b,EAAgB4a,EAChBuD,EAAmB,EACnBC,EAAuB,EACvBC,EAAmB,EACnBrE,EACAwD,EAAGC,aAAa,oBAGhBD,EAAGC,aAAa,UAEpB,IAAK,IAAI3B,EAAY,EAAGwC,EAAYL,EAAM3hB,OAAQwf,EAAYwC,EAAWxC,IAAa,CAClF,IAAMyC,EAAON,EAAMnC,GACb0C,EAAeD,EAAKxE,SACpB0E,EAAWF,EAAKvf,KAChB0f,EAAkBH,EAAKvE,YACvB2E,EAA8C,IAArB1D,GAAsDsD,EAAKK,eACpFC,EAAiCF,IAA0Bb,IAAiC,SAAbW,IAA4CrB,GAC3H0B,EAAgC/C,IAAcyC,GAAgBD,EAAKQ,gBASzE,GARAZ,EAAmB,EACnBX,EAAGC,aAAa,UACZiB,GACAlB,EAAGC,aAAa,iCAEpBD,EAAGC,aAAa,WAChBD,EAAGC,aAAaoB,EAAiC,OAASJ,GAC1DjB,EAAGwB,oBAAoB,IACnBL,EAAuB,CAKnB,IAJJ,IAAIM,EAAY,EAERC,EAAanD,EACboD,EAAiBnf,EACdkf,EAAaV,EAAcU,IAAc,CAC5C,IACME,EAA+F,GAArE,IADf9S,EAAYgD,WAAW4P,GACgBvE,EAAWwE,EAAiBxE,EAAY,GAChGsE,GAAaG,EACTF,GAAcxE,IACdyE,GAAkBC,EAE1B,CAQJ,IANIP,IACArB,EAAGC,aAAa,kBAChBD,EAAGC,aAAa4B,OAAOxE,EAAaoE,IACpCzB,EAAGC,aAAa,QAEpBD,EAAGwB,oBAAoB,IAChBjD,EAAYyC,EAAczC,IAAa,CAC1CoB,EAAiBU,cAAc9B,EAAY,EAAGD,EAAYuC,EAAkBF,EAAkBC,GAC9FC,EAAmB,EACnB,IACIiB,OAAkB,EAClBF,OAAS,EACb,GAAiB,IAHA9S,EAAYgD,WAAWyM,GAGD,CAEnCqD,EADAE,EAAsB3E,EAAW3a,EAAgB2a,EAAY,GAExDJ,GAAkC6E,EAAY,EAC/C5B,EAAG+B,eAAe,MAGlB/B,EAAG+B,eAAe,OAEtB,IAAK,IAAIC,EAAQ,EAAGA,GAASJ,EAAWI,IACpChC,EAAG+B,eAAe,IAE1B,MAEID,EAAqB,EACrBF,EAAY,EACZ5B,EAAG+B,eAAe/D,GAClBgC,EAAG+B,eAAe,MAEtBpB,GAAoBmB,EACpBlB,GAAwBgB,EACpBrD,GAAarB,IACb1a,GAAiBof,EAEzB,CACJ,MAGI,IADA5B,EAAGwB,oBAAoB,IAChBjD,EAAYyC,EAAczC,IAAa,CAC1CoB,EAAiBU,cAAc9B,EAAY,EAAGD,EAAYuC,EAAkBF,EAAkBC,GAC9FC,EAAmB,EACnB,IAAMoB,EAAWnT,EAAYgD,WAAWyM,GACpCuD,EAAqB,EACrBF,EAAY,EAChB,OAAQK,GACJ,KAAK,EAEDL,EADAE,EAAsB3E,EAAW3a,EAAgB2a,EAEjD,IAAK,IAAI6E,EAAQ,EAAGA,GAASF,EAAoBE,IAC7ChC,EAAG+B,eAAe,KAEtB,MACJ,KAAK,GACD/B,EAAG+B,eAAe,KAClB,MACJ,KAAK,GACD/B,EAAGC,aAAa,QAChB,MACJ,KAAK,GACDD,EAAGC,aAAa,QAChB,MACJ,KAAK,GACDD,EAAGC,aAAa,SAChB,MACJ,KAAK,EACGvC,EAEAsC,EAAG+B,eAAe,MAGlB/B,EAAGC,aAAa,SAEpB,MACJ,KAAK,MACL,KAAK,KACL,KAAK,KACL,KAAK,IACDD,EAAG+B,eAAe,OAClB,MACJ,QACQ7F,EAAAA,GAA6B+F,IAC7BL,IAGAlE,GAA2BuE,EAAW,GACtCjC,EAAG+B,eAAe,KAAOE,GAEpBvE,GAAwC,MAAbuE,EAEhCjC,EAAG+B,eAAe,MAEbrE,GAA2BwE,EAAmBD,IACnDjC,EAAGC,aAAa,OAChBD,EAAGC,aAAakC,EAAWF,IAC3BjC,EAAGC,aAAa,KAEhB2B,EADAE,EAAqB,GAIrB9B,EAAG+B,eAAeE,GAG9BtB,GAAoBmB,EACpBlB,GAAwBgB,EACpBrD,GAAarB,IACb1a,GAAiBof,EAEzB,CAEAN,EACAT,IAGAA,EAAmB,EAEnBtC,GAAa7c,IAAQgf,GAA+BK,EAAKQ,kBACzDb,GAA8B,EAC9Bf,EAAiBU,cAAc9B,EAAY,EAAGD,EAAWqC,EAAkBC,IAE/EZ,EAAGC,aAAa,UACpB,CACKS,GAGDf,EAAiBU,cAAc3e,EAAM,EAAG+e,EAAM3hB,OAAS,EAAG6hB,EAAkBC,GAE5EL,IACAP,EAAGC,aAAa,8BAChBD,EAAGC,aAAamC,EAAAA,GAAa,WAAY,kBASjD,SAAoC/iB,GAChC,GAAIA,EAAI,KACJ,OAAO+iB,EAAAA,GAAa,iBAAkB,YAAa/iB,GAEvD,GAAIA,EAAI,QACJ,MAAO,GAAPsC,QAAWtC,EAAI,MAAMgjB,QAAQ,GAAE,OAEnC,MAAO,GAAP1gB,QAAWtC,EAAI,KAAO,MAAMgjB,QAAQ,GAAE,MAC1C,CAjBoEC,CAA2B9B,KACvFR,EAAGC,aAAa,YAGpB,OADAD,EAAGC,aAAa,WACT,IAAIP,EAAiBC,EAAkBnD,EAAaoD,EAC/D,CA9oBW2C,CAoCX,SAAgCxC,GAC5B,IACIQ,EACAC,EACA9e,EAHEoN,EAAciR,EAAMjR,aAIY,IAAlCiR,EAAMvC,wBAAiCuC,EAAMvC,uBAAyB1O,EAAYhQ,QAClFyhB,GAAgB,EAChBC,EAAuB1R,EAAYhQ,OAASihB,EAAMvC,uBAClD9b,EAAMqe,EAAMvC,yBAGZ+C,GAAgB,EAChBC,EAAuB,EACvB9e,EAAMoN,EAAYhQ,QAEtB,IAAI6I,EAuCR,SAAuCmH,EAAa0T,EAAiB7a,EAAQuV,EAAkBxb,GAC3F,IAAM1C,EAAS,GACX4W,EAAY,EAEZsH,EAAmB,IACnBle,EAAO4W,KAAe,IAAI0G,EAASY,EAAkB,GAAI,GAAG,IAGhE,IADA,IAAIhP,EAAcgP,EACThU,EAAa,EAAG4X,EAAYnZ,EAAOoI,WAAY7G,EAAa4X,EAAW5X,IAAc,CAC1F,IAAMqT,EAAW5U,EAAOwI,aAAajH,GACrC,KAAIqT,GAAYW,GAAhB,CAIA,IAAM1b,EAAOmG,EAAO0I,aAAanH,GACjC,GAAIqT,GAAY7a,EAAK,CACjB,IAAM+gB,IAAoBD,GAAkBtG,EAAAA,GAAoBpN,EAAYtP,UAAU0O,EAAaxM,IACnG1C,EAAO4W,KAAe,IAAI0G,EAAS5a,EAAKF,EAAM,EAAGihB,GACjD,KACJ,CACA,IAAMA,IAAoBD,GAAkBtG,EAAAA,GAAoBpN,EAAYtP,UAAU0O,EAAaqO,IACnGvd,EAAO4W,KAAe,IAAI0G,EAASC,EAAU/a,EAAM,EAAGihB,GACtDvU,EAAcqO,CATd,CAUJ,CACA,OAAOvd,CACX,CAhEiB0jB,CAA8B5T,EAAaiR,EAAMvD,YAAauD,EAAMjY,WAAYiY,EAAM7C,iBAAkBxb,GACjHqe,EAAMrC,0BAA4BqC,EAAM9C,eAGxCtV,EA4JR,SAAkCmH,EAAanH,GAC3C,IAG0B7H,EAHpBd,EAAS,GACX2jB,EAAe,IAAIrG,EAAS,EAAG,GAAI,GAAG,GACtCwC,EAAa,EAAE/e,GAAAZ,EAAAA,EAAAA,GACCwI,GAAM,IAA1B,IAAA5H,EAAAX,MAAAU,EAAAC,EAAAV,KAAAC,MAA4B,CAExB,IAFwB,IAAjBsjB,EAAK9iB,EAAAnB,MACNkkB,EAAgBD,EAAMrG,SACrBuC,EAAa+D,EAAe/D,IAAc,CAEzCoD,EADapT,EAAYgD,WAAWgN,MAEhCA,EAAa6D,EAAapG,WAE1BoG,EAAe,IAAIrG,EAASwC,EAAY8D,EAAMphB,KAAMohB,EAAMlV,SAAUkV,EAAMpG,aAC1Exd,EAAOkB,KAAKyiB,IAEhBA,EAAe,IAAIrG,EAASwC,EAAa,EAAG,aAAc8D,EAAMlV,UAAU,GAC1E1O,EAAOkB,KAAKyiB,GAEpB,CACI7D,EAAa6D,EAAapG,WAE1BoG,EAAe,IAAIrG,EAASuG,EAAeD,EAAMphB,KAAMohB,EAAMlV,SAAUkV,EAAMpG,aAC7Exd,EAAOkB,KAAKyiB,GAEpB,CAAC,OAAAjjB,GAAAK,EAAAJ,EAAAD,EAAA,SAAAK,EAAAH,GAAA,CACD,OAAOZ,CACX,CArLiB8jB,CAAyBhU,EAAanH,KAEpB,IAA3BoY,EAAMtC,kBACqB,IAA3BsC,EAAMtC,kBACsB,IAA3BsC,EAAMtC,kBAA6DsC,EAAMnC,kBAC9C,IAA3BmC,EAAMtC,mBAA2DsC,EAAM/C,4BACxErV,EAqLR,SAAgCoY,EAAOjR,EAAapN,EAAKiG,GACrD,IAkBIob,EAlBE/F,EAA2B+C,EAAM/C,yBACjCE,EAAmB6C,EAAM7C,iBACzBC,EAAU4C,EAAM5C,QAChBC,EAAqB2C,EAAM3C,mBAC3BN,EAA4BiD,EAAMjD,0BAClCxE,EAAayH,EAAMnC,iBACnBoF,EAA2C,IAA3BjD,EAAMtC,iBACtBwF,EAA2C,IAA3BlD,EAAMtC,iBACtByF,EAAqCnD,EAAMhC,mBAAqBgC,EAAM1C,WACtEre,EAAS,GACX4W,EAAY,EACZ1M,EAAa,EACbia,EAAYxb,EAAOuB,GAAY1H,KAC/BihB,EAAmB9a,EAAOuB,GAAYsT,YACtCqG,EAAgBlb,EAAOuB,GAAYqT,SACjC6G,EAAezb,EAAO7I,OACxBukB,GAA0B,EAC1BC,EAA0BpH,EAAAA,GAAgCpN,IAE7B,IAA7BwU,GACAD,GAA0B,EAC1BC,EAA0B5hB,EAC1BqhB,EAAyBrhB,GAGzBqhB,EAAyB7G,EAAAA,GAA+BpN,GAM5D,IAJA,IAAIyU,GAAkB,EAClBC,EAAwB,EACxBC,EAAmBnL,GAAcA,EAAWkL,GAC5CE,EAAYtG,EAAqBD,EAC5BoB,EAAYrB,EAAkBqB,EAAY7c,EAAK6c,IAAa,CACjE,IAAMoF,EAAS7U,EAAYgD,WAAWyM,GAClCkF,GAAoBlF,GAAakF,EAAiBtV,YAClDqV,IACAC,EAAmBnL,GAAcA,EAAWkL,IAEhD,IAAII,OAAc,EAClB,GAAIrF,EAAY+E,GAA2B/E,EAAYwE,EAEnDa,GAAiB,OAEhB,GAAe,IAAXD,EAELC,GAAiB,OAEhB,GAAe,KAAXD,EAEL,GAAIX,EAEA,GAAIO,EACAK,GAAiB,MAEhB,CACD,IAAMC,EAActF,EAAY,EAAI7c,EAAMoN,EAAYgD,WAAWyM,EAAY,GAAK,EAClFqF,EAAiC,KAAfC,GAAyD,IAAfA,CAChE,MAGAD,GAAiB,OAIrBA,GAAiB,EAqBrB,GAlBIA,GAAkBtL,IAClBsL,IAAmBH,GAAoBA,EAAiBvV,aAAeqQ,GAAakF,EAAiBtV,UAAYoQ,GAGjHqF,GAAkBX,IAClBW,EAAiBP,GAA2B9E,EAAYwE,GAExDa,GAAkBnB,GAOdlE,GAAa+E,GAA2B/E,GAAawE,IACrDa,GAAiB,GAGrBL,GAEA,IAAKK,IAAoB9G,GAA6B4G,GAAavG,EAAU,CAEzE,GAAI+F,EAEA,IADA,IACSzhB,GADamU,EAAY,EAAI5W,EAAO4W,EAAY,GAAG2G,SAAWW,GAC3C,EAAGzb,GAAK8c,EAAW9c,IAC3CzC,EAAO4W,KAAe,IAAI0G,EAAS7a,EAAG,OAAQ,GAAwC,QAI1FzC,EAAO4W,KAAe,IAAI0G,EAASiC,EAAW,OAAQ,GAAwC,GAElGmF,GAAwBvG,CAC5B,OAIIoB,IAAcsE,GAAkBe,GAAkBrF,EAAYrB,KAC9Dle,EAAO4W,KAAe,IAAI0G,EAASiC,EAAW4E,EAAW,EAAGV,GAC5DiB,GAAwBvG,GAahC,IAVe,IAAXwG,EACAD,EAAYvG,EAEPjB,EAAAA,GAA6ByH,GAClCD,GAAa,EAGbA,IAEJH,EAAkBK,EACXrF,IAAcsE,KACjB3Z,EACiBka,GACbD,EAAYxb,EAAOuB,GAAY1H,KAC/BihB,EAAmB9a,EAAOuB,GAAYsT,YACtCqG,EAAgBlb,EAAOuB,GAAYqT,QAM/C,CACA,IAAIuH,GAAqB,EACzB,GAAIP,EAEA,GAAIvG,GAA4BgG,EAAc,CAC1C,IAAMe,EAAgBriB,EAAM,EAAIoN,EAAYgD,WAAWpQ,EAAM,GAAK,EAC5DsiB,EAAgBtiB,EAAM,EAAIoN,EAAYgD,WAAWpQ,EAAM,GAAK,EAClB,KAAjBqiB,GAA8D,KAAjBC,GAA6D,IAAjBA,IAEpHF,GAAqB,EAE7B,MAEIA,GAAqB,EAG7B,GAAIA,EACA,GAAIZ,EAEA,IADA,IACSzhB,GADamU,EAAY,EAAI5W,EAAO4W,EAAY,GAAG2G,SAAWW,GAC3C,EAAGzb,GAAKC,EAAKD,IACrCzC,EAAO4W,KAAe,IAAI0G,EAAS7a,EAAG,OAAQ,GAAwC,QAI1FzC,EAAO4W,KAAe,IAAI0G,EAAS5a,EAAK,OAAQ,GAAwC,QAI5F1C,EAAO4W,KAAe,IAAI0G,EAAS5a,EAAKyhB,EAAW,EAAGV,GAE1D,OAAOzjB,CACX,CArViBilB,CAAuBlE,EAAOjR,EAAapN,EAAKiG,IAE7D,IAAIiY,EAA0B,EAC9B,GAAIG,EAAMhF,gBAAgBjc,OAAS,EAAG,CAClC,IAAK,IAAI2C,EAAI,EAAGC,EAAMqe,EAAMhF,gBAAgBjc,OAAQ2C,EAAIC,EAAKD,IAAK,CAC9D,IAAM2e,EAAiBL,EAAMhF,gBAAgBtZ,GACjB,IAAxB2e,EAAe5e,MAIc,IAAxB4e,EAAe5e,KAFpBoe,GAA2B,EAKE,IAAxBQ,EAAe5e,OACpBoe,GAA2B,EAEnC,CACAjY,EAyUR,SAAiCmH,EAAapN,EAAKiG,EAAQuc,GACvDA,EAAiB1jB,KAAKia,EAAAA,GAAeoD,SAOrC,IANA,IAAM9C,EAAkBgB,EAAAA,EAA0BoI,UAAUrV,EAAaoV,GACnEE,EAAqBrJ,EAAgBjc,OACvCulB,EAAsB,EACpBrlB,EAAS,GACX4W,EAAY,EACZ0O,EAAqB,EAChBpb,EAAa,EAAGxH,EAAMiG,EAAO7I,OAAQoK,EAAaxH,EAAKwH,IAAc,CAM1E,IALA,IAAM0Z,EAAQjb,EAAOuB,GACf2Z,EAAgBD,EAAMrG,SACtB4G,EAAYP,EAAMphB,KAClBqN,EAAgB+T,EAAMlV,SACtB+U,EAAmBG,EAAMpG,YACxB6H,EAAsBD,GAAsBrJ,EAAgBsJ,GAAqBnW,YAAc2U,GAAe,CACjH,IAAMzC,EAAiBrF,EAAgBsJ,GAKvC,GAJIjE,EAAelS,YAAcoW,IAC7BA,EAAqBlE,EAAelS,YACpClP,EAAO4W,KAAe,IAAI0G,EAASgI,EAAoBnB,EAAWtU,EAAe4T,MAEjFrC,EAAejS,UAAY,GAAK0U,GAM/B,CAEDyB,EAAqBzB,EACrB7jB,EAAO4W,KAAe,IAAI0G,EAASgI,EAAoBnB,EAAY,IAAM/C,EAAe3d,UAAWoM,EAAgBuR,EAAe1S,SAAU+U,GAC5I,KACJ,CATI6B,EAAqBlE,EAAejS,UAAY,EAChDnP,EAAO4W,KAAe,IAAI0G,EAASgI,EAAoBnB,EAAY,IAAM/C,EAAe3d,UAAWoM,EAAgBuR,EAAe1S,SAAU+U,GAC5I4B,GAQR,CACIxB,EAAgByB,IAChBA,EAAqBzB,EACrB7jB,EAAO4W,KAAe,IAAI0G,EAASgI,EAAoBnB,EAAWtU,EAAe4T,GAEzF,CACA,IAAM8B,EAAoB5c,EAAOA,EAAO7I,OAAS,GAAGyd,SACpD,GAAI8H,EAAsBD,GAAsBrJ,EAAgBsJ,GAAqBnW,cAAgBqW,EACjG,KAAOF,EAAsBD,GAAsBrJ,EAAgBsJ,GAAqBnW,cAAgBqW,GAAmB,CACvH,IAAMnE,EAAiBrF,EAAgBsJ,GACvCrlB,EAAO4W,KAAe,IAAI0G,EAASgI,EAAoBlE,EAAe3d,UAAW2d,EAAe1S,UAAU,GAC1G2W,GACJ,CAEJ,OAAOrlB,CACX,CAxXiBwlB,CAAwB1V,EAAapN,EAAKiG,EAAQoY,EAAMhF,gBACrE,CACKgF,EAAMvD,cAEP7U,EAuCR,SAA0BmH,EAAanH,EAAQ8c,GAC3C,IAAIF,EAAoB,EAClBvlB,EAAS,GACX4W,EAAY,EAChB,GAAI6O,EAEA,IAAK,IAAIhjB,EAAI,EAAGC,EAAMiG,EAAO7I,OAAQ2C,EAAIC,EAAKD,IAAK,CAC/C,IAAMmhB,EAAQjb,EAAOlG,GACfohB,EAAgBD,EAAMrG,SAC5B,GAAIgI,EAAoB,GAA+B1B,EAAe,CAMlE,IALA,IAAMM,EAAYP,EAAMphB,KAClBqN,EAAgB+T,EAAMlV,SACtB+U,EAAmBG,EAAMpG,YAC3BkI,GAAmB,EACnBC,EAAiBJ,EACZK,EAAIL,EAAmBK,EAAI/B,EAAe+B,IACb,KAA9B9V,EAAYgD,WAAW8S,KACvBF,EAAkBE,IAEG,IAArBF,GAA0BE,EAAID,GAAkB,KAEhD3lB,EAAO4W,KAAe,IAAI0G,EAASoI,EAAkB,EAAGvB,EAAWtU,EAAe4T,GAClFkC,EAAiBD,EAAkB,EACnCA,GAAmB,GAGvBC,IAAmB9B,IACnB7jB,EAAO4W,KAAe,IAAI0G,EAASuG,EAAeM,EAAWtU,EAAe4T,GAEpF,MAEIzjB,EAAO4W,KAAegN,EAE1B2B,EAAoB1B,CACxB,MAIA,IAAK,IAAIphB,EAAI,EAAGC,EAAMiG,EAAO7I,OAAQ2C,EAAIC,EAAKD,IAAK,CAC/C,IAAMmhB,EAAQjb,EAAOlG,GACfohB,EAAgBD,EAAMrG,SACtBsI,EAAQhC,EAAgB0B,EAC9B,GAAIM,EAAO,GAA8B,CAKrC,IAJA,IAAM1B,EAAYP,EAAMphB,KAClBqN,EAAgB+T,EAAMlV,SACtB+U,EAAmBG,EAAMpG,YACzBsI,EAAcxV,KAAKyV,KAAKF,EAAO,IAC5BD,EAAI,EAAGA,EAAIE,EAAaF,IAAK,CAClC,IAAMI,EAAgBT,EAAyB,GAAJK,EAC3C5lB,EAAO4W,KAAe,IAAI0G,EAAS0I,EAAe7B,EAAWtU,EAAe4T,EAChF,CACAzjB,EAAO4W,KAAe,IAAI0G,EAASuG,EAAeM,EAAWtU,EAAe4T,EAChF,MAEIzjB,EAAO4W,KAAegN,EAE1B2B,EAAoB1B,CACxB,CAEJ,OAAO7jB,CACX,CAnGiBimB,CAAiBnW,EAAanH,GAASoY,EAAM9C,cAAgB8C,EAAMpC,gBAEhF,OAAO,IAAIuH,EAAwBnF,EAAMjD,0BAA2BiD,EAAMhD,+BAAgCjO,EAAapN,EAAK6e,EAAeC,EAAsB7Y,EAAQiY,EAAyBG,EAAM7C,iBAAkB6C,EAAM5C,QAAS4C,EAAM3C,mBAAoB2C,EAAMvD,YAAauD,EAAM1C,WAAY0C,EAAM/B,oBAAqB+B,EAAMtC,iBAAkBsC,EAAMrC,wBACrW,CArFuByH,CAAuBpF,GAAQC,EACtD,CACO,IAAMoF,GAAiBxoB,EAAAA,EAAAA,IAC1B,SAAAwoB,EAAYzF,EAAkB0F,EAAM7I,EAAaoD,IAAyB3iB,EAAAA,EAAAA,GAAA,KAAAmoB,GACtEloB,KAAKyiB,iBAAmBA,EACxBziB,KAAKmoB,KAAOA,EACZnoB,KAAKsf,YAAcA,EACnBtf,KAAK0iB,wBAA0BA,CACnC,IAEG,SAAS0F,EAAgBvF,GAC5B,IAAMC,EAAK,IAAIuF,EAAAA,GAAc,KACvBC,EAAM1F,EAAeC,EAAOC,GAClC,OAAO,IAAIoF,EAAkBI,EAAI7F,iBAAkBK,EAAGyF,QAASD,EAAIhJ,YAAagJ,EAAI5F,wBACxF,CAAC,IACKsF,GAAuBtoB,EAAAA,EAAAA,IACzB,SAAAsoB,EAAY5E,EAAiBvD,EAAgCjO,EAAapN,EAAK6e,EAAeC,EAAsBC,EAAOb,EAAyB1C,EAAkBC,EAASC,EAAoBZ,EAAaa,EAAYW,EAAqBP,EAAkBC,IAAyBzgB,EAAAA,EAAAA,GAAA,KAAAioB,GACxRhoB,KAAKojB,gBAAkBA,EACvBpjB,KAAK6f,+BAAiCA,EACtC7f,KAAK4R,YAAcA,EACnB5R,KAAKwE,IAAMA,EACXxE,KAAKqjB,cAAgBA,EACrBrjB,KAAKsjB,qBAAuBA,EAC5BtjB,KAAKujB,MAAQA,EACbvjB,KAAK0iB,wBAA0BA,EAC/B1iB,KAAKggB,iBAAmBA,EACxBhgB,KAAKigB,QAAUA,EACfjgB,KAAKkgB,mBAAqBA,EAC1BlgB,KAAKsf,YAAcA,EACnBtf,KAAKmgB,WAAaA,EAClBngB,KAAK8gB,oBAAsBA,EAC3B9gB,KAAKugB,iBAAmBA,EACxBvgB,KAAKwgB,wBAA0BA,CAEnC,IAoJJ,SAASwE,EAAmBD,GACxB,OAAIA,EAAW,GACU,IAAbA,EAEK,MAAbA,IAICA,GAAY,MAAUA,GAAY,MAC/BA,GAAY,MAAUA,GAAY,MAClCA,GAAY,MAAUA,GAAY,MACtB,OAAbA,EAiBX,CA6bA,SAASE,EAAW9iB,GAChB,OAAOA,EAAEsR,SAAS,IAAI+U,cAAcC,SAAS,EAAG,IACpD,C,6FC53BaC,EAAY,WACrB,SAAAA,EAAYtN,EAAYuN,EAAaC,EAAwBC,IAAO9oB,EAAAA,EAAAA,GAAA,KAAA2oB,GAChE1oB,KAAKob,WAAaA,EAClBpb,KAAKiD,gBAAgD,EAA9B0lB,EAAY1lB,gBACnCjD,KAAKoD,cAA4C,EAA5BulB,EAAYvlB,cACjCpD,KAAK8oB,uBAAyBH,EAAYG,uBAC1C9oB,KAAK+oB,gBAAgD,EAA9BJ,EAAYI,gBACnC/oB,KAAK4oB,uBAAyBA,EAC9B5oB,KAAKgpB,OAASH,EACd7oB,KAAKipB,aAAe,IAAIpV,EAAAA,EAAM8U,EAAY1lB,gBAAiBjD,KAAKgpB,OAAOE,iBAAiBP,EAAY1lB,iBAAkB0lB,EAAYvlB,cAAepD,KAAKgpB,OAAOG,iBAAiBR,EAAYvlB,eAC9L,CAMC,OANA1D,EAAAA,EAAAA,GAAAgpB,EAAA,EAAA7nB,IAAA,2BAAAY,MACD,SAAyBJ,GACrB,OAAOrB,KAAKgpB,OAAOI,iCAAiCppB,KAAKipB,aAAc5nB,EAC3E,GAAC,CAAAR,IAAA,2BAAAY,MACD,WACI,OAAOzB,KAAKgpB,OAAOK,yBAAyBrpB,KAAKipB,aACrD,KAACP,CAAA,CAhBoB,E,4RCDZY,GAAQ5pB,EAAAA,EAAAA,IACjB,SAAA4pB,EAAYzjB,EAAK0jB,EAAMC,EAAOC,IAAQ1pB,EAAAA,EAAAA,GAAA,KAAAupB,GAClCtpB,KAAK0pB,oBAAiBzZ,EACtBjQ,KAAK6F,IAAY,EAANA,EACX7F,KAAKupB,KAAc,EAAPA,EACZvpB,KAAKwpB,MAAgB,EAARA,EACbxpB,KAAKypB,OAAkB,EAATA,CAClB,IAESE,GAAyBjqB,EAAAA,EAAAA,IAClC,SAAAiqB,EAAY1J,EAAS2J,IAAM7pB,EAAAA,EAAAA,GAAA,KAAA4pB,GACvB3pB,KAAKigB,QAAUA,EACfjgB,KAAK4pB,KAAOA,CAChB,IAESC,GAAYnqB,EAAAA,EAAAA,IACrB,SAAAmqB,EAAYtnB,EAASud,EAA0BgK,EAAWC,EAAW7J,EAAoBzV,EAAQuf,IAAmBjqB,EAAAA,EAAAA,GAAA,KAAA8pB,GAChH7pB,KAAKiqB,wBAAqBha,EAC1BjQ,KAAKuC,QAAUA,EACfvC,KAAK8f,yBAA2BA,EAChC9f,KAAK8pB,UAAYA,EACjB9pB,KAAK+pB,UAAYA,EACjB/pB,KAAKkgB,mBAAqBA,EAC1BlgB,KAAKyK,OAASA,EACdzK,KAAKgqB,kBAAoBA,CAC7B,IAESE,EAAqB,WAC9B,SAAAA,EAAYJ,EAAWC,EAAWxnB,EAASud,EAA0BqK,EAAiBC,EAA2B3f,EAAQuf,EAAmB/J,EAASC,IAAoBngB,EAAAA,EAAAA,GAAA,KAAAmqB,GACrKlqB,KAAK8pB,UAAYA,EACjB9pB,KAAK+pB,UAAYA,EACjB/pB,KAAKuC,QAAUA,EACfvC,KAAK8f,yBAA2BA,EAChC9f,KAAK+f,aAAemK,EAAsBnK,aAAaxd,EAAS6nB,GAChEpqB,KAAKsf,YAAc4K,EAAsB5K,YAAY/c,EAASvC,KAAK+f,aAAcoK,GACjFnqB,KAAKyK,OAASA,EACdzK,KAAKgqB,kBAAoBA,EACzBhqB,KAAKigB,QAAUA,EACfjgB,KAAKkgB,mBAAqBA,CAC9B,CAYC,OAZAxgB,EAAAA,EAAAA,GAAAwqB,EAAA,OAAArpB,IAAA,eAAAY,MACD,SAAoBmQ,EAAawY,GAC7B,OAAIA,GACOpL,EAAAA,GAAqBpN,EAGpC,GAAC,CAAA/Q,IAAA,cAAAY,MACD,SAAmBmQ,EAAamO,EAAcoK,GAC1C,QAAKpK,IAAgBoK,IACVnL,EAAAA,GAAoBpN,EAGnC,KAACsY,CAAA,CAxB6B,GA0BrBG,GAAgB3qB,EAAAA,EAAAA,IACzB,SAAA2qB,EAAY1qB,EAAOse,EAAiB3Z,IAAMvE,EAAAA,EAAAA,GAAA,KAAAsqB,GACtCrqB,KAAKL,MAAQA,EACbK,KAAKie,gBAAkBA,EACvBje,KAAKsE,KAAOA,CAChB,IAESgmB,EAA0B,WACnC,SAAAA,EAAYtZ,EAAaC,EAAWgN,EAAiBsM,IAAqCxqB,EAAAA,EAAAA,GAAA,KAAAuqB,GACtFtqB,KAAKgR,YAAcA,EACnBhR,KAAKiR,UAAYA,EACjBjR,KAAKie,gBAAkBA,EACvBje,KAAKuqB,oCAAsCA,CAC/C,CAGC,OAHA7qB,EAAAA,EAAAA,GAAA4qB,EAAA,EAAAzpB,IAAA,qBAAAY,MACD,SAAmBJ,GACf,OAAO,IAAIgpB,EAAiB,IAAIxW,EAAAA,EAAMxS,EAAYrB,KAAKgR,YAAc,EAAG3P,EAAYrB,KAAKiR,UAAY,GAAIjR,KAAKie,gBAAiBje,KAAKuqB,oCAAsC,EAA6D,EAC3O,KAACD,CAAA,CATkC,GAW1BE,GAAmB9qB,EAAAA,EAAAA,IAC5B,SAAA8qB,EAAY7qB,EAAO4B,IAASxB,EAAAA,EAAAA,GAAA,KAAAyqB,GACxBxqB,KAAKyqB,+BAA4Bxa,EACjCjQ,KAAKL,MAAQA,EACbK,KAAKuB,QAAUA,CACnB,IAESmpB,EAA6B,WACtC,SAAAA,EAAYC,EAAOC,EAOnBhB,IAAM7pB,EAAAA,EAAAA,GAAA,KAAA2qB,GACF1qB,KAAK2qB,MAAQA,EACb3qB,KAAK4qB,OAASA,EACd5qB,KAAK4pB,KAAOA,CAChB,CAoBC,OApBAlqB,EAAAA,EAAAA,GAAAgrB,EAAA,OAAA7pB,IAAA,0BAAAY,MACD,SAA+B8B,EAAGC,GAC9B,OAAID,EAAEqnB,SAAWpnB,EAAEonB,OACXrnB,EAAEonB,MAAQnnB,EAAEmnB,OACJ,EAERpnB,EAAEonB,MAAQnnB,EAAEmnB,MACL,EAEJ,EAEJpnB,EAAEqnB,OAASpnB,EAAEonB,MACxB,GAAC,CAAA/pB,IAAA,SAAAY,MACD,SAAc8B,EAAGC,GACb,OAAQD,EAAEonB,QAAUnnB,EAAEmnB,OACfpnB,EAAEqnB,SAAWpnB,EAAEonB,QACfld,EAAAA,GAAcnK,EAAEqmB,KAAMpmB,EAAEomB,KACnC,GAAC,CAAA/oB,IAAA,YAAAY,MACD,SAAiB8B,EAAGC,GAChB,OAAOkK,EAAAA,GAAcnK,EAAGC,EAAGknB,EAA8B1J,OAC7D,KAAC0J,CAAA,CAhCqC,E,oJC7E7BG,EAAyB,SAAAzhB,IAAAjJ,EAAAA,EAAAA,GAAA0qB,EAAAzhB,GAAA,IAAAhJ,GAAAC,EAAAA,EAAAA,GAAAwqB,GAOlC,SAAAA,IAAc,IAAAnqB,EASN,OATMX,EAAAA,EAAAA,GAAA,KAAA8qB,IACVnqB,EAAAN,EAAAO,KAAA,OACKqG,aAAe,IAAIC,EAAAA,GACxBvG,EAAKwG,YAAcxG,EAAKsG,aAAaG,MACrCzG,EAAKoqB,kBACLpqB,EAAK2J,UAAUzD,EAAAA,GAAqBM,aAAY,SAAAzE,GACxCA,EAAE+E,iBACF9G,EAAKoqB,iBAEb,KAAIpqB,CACR,CAXC,OAWAhB,EAAAA,EAAAA,GAAAmrB,EAAA,EAAAhqB,IAAA,kBAAAY,MACD,WACI,IAAMuH,EAAWpC,EAAAA,GAAqBmkB,cACtC,IAAK/hB,EAGD,OAFAhJ,KAAKgrB,QAAU,CAACC,EAAAA,EAAMC,YACtBlrB,KAAKmrB,oBAAqB,GAG9BnrB,KAAKgrB,QAAU,CAACC,EAAAA,EAAMC,OACtB,IAAK,IAAIE,EAAU,EAAGA,EAAUpiB,EAASpH,OAAQwpB,IAAW,CACxD,IAAM9Y,EAAStJ,EAASoiB,GAASC,KAEjCrrB,KAAKgrB,QAAQI,GAAW,IAAIH,EAAAA,EAAM3Y,EAAOoL,EAAGpL,EAAOgZ,EAAGhZ,EAAO9O,EAAG4O,KAAKmZ,MAAiB,IAAXjZ,EAAO/O,GACtF,CACA,IAAMioB,EAAuBxiB,EAAS,GAAmCyiB,uBACzEzrB,KAAKmrB,mBAAqBK,GAAwB,GAClDxrB,KAAKgH,aAAaM,UAAK2I,EAC3B,GAAC,CAAApP,IAAA,WAAAY,MACD,SAAS2pB,GAKL,OAJIA,EAAU,GAAKA,GAAWprB,KAAKgrB,QAAQppB,UAEvCwpB,EAAU,GAEPprB,KAAKgrB,QAAQI,EACxB,GAAC,CAAAvqB,IAAA,oBAAAY,MACD,WACI,OAAOzB,KAAKmrB,kBAChB,IAAC,EAAAtqB,IAAA,cAAAY,MA3CD,WAII,OAHKzB,KAAK0rB,YACN1rB,KAAK0rB,WAAYC,EAAAA,EAAAA,IAAgB,IAAId,IAElC7qB,KAAK0rB,SAChB,KAACb,CAAA,CANiC,CAAStgB,EAAAA,IA8C/CsgB,EAA0Ba,UAAY,I,oJC9CzBE,EAAkC,WAI3C,SAAAA,EAAYC,EAAkBC,IAAiB/rB,EAAAA,EAAAA,GAAA,KAAA6rB,GAC3C5rB,KAAK+rB,WAAa,IAAIC,EAA4BH,EAAkBC,EACxE,CAHC,OAGApsB,EAAAA,EAAAA,GAAAksB,EAAA,EAAA/qB,IAAA,2BAAAY,MACD,SAAyBwqB,EAAUhM,EAASiM,EAAgBC,EAAgBC,GAAW,IAAA1rB,EAAA,KAC7E2rB,EAAW,GACX1qB,EAAgB,GAChB2qB,EAAuB,GAC7B,MAAO,CACHC,WAAY,SAAC7qB,EAAUW,EAAcmqB,GACjCH,EAASrpB,KAAKtB,GACdC,EAAcqB,KAAKX,GACnBiqB,EAAqBtpB,KAAKwpB,EAC9B,EACAC,SAAU,WAGN,IAFA,IAAMC,EAA0BT,EAASU,+BAAiCV,EAASW,+BAC7E9qB,EAAS,GACNyC,EAAI,EAAGC,EAAM6nB,EAASzqB,OAAQ2C,EAAIC,EAAKD,IAAK,CACjD,IAAMlC,EAAeV,EAAc4C,GAC7BioB,EAAwBF,EAAqB/nB,IAC/CioB,GAA0BA,EAAsBK,kBAAqBxqB,EAIrEP,EAAOyC,GAAKuoB,EAAiBpsB,EAAKqrB,WAAYM,EAAS9nB,GAAIlC,EAAc4d,EAASiM,EAAgBQ,EAAyBP,EAAgBC,GAH3ItqB,EAAOyC,GAAKwoB,EAAuCrsB,EAAKqrB,WAAYS,EAAuBH,EAAS9nB,GAAI0b,EAASiM,EAAgBQ,EAAyBP,EAAgBC,EAKlL,CAGA,OAFAY,EAASprB,OAAS,EAClBqrB,EAASrrB,OAAS,EACXE,CACX,EAER,IAAC,EAAAjB,IAAA,SAAAY,MAlCD,SAAcF,GACV,OAAO,IAAIqqB,EAAmCrqB,EAAQT,IAAI,KAAuDS,EAAQT,IAAI,KACjI,KAAC8qB,CAAA,CAH0C,GAqCzCI,EAA2B,SAAAkB,IAAA/sB,EAAAA,EAAAA,GAAA6rB,EAAAkB,GAAA,IAAA9sB,GAAAC,EAAAA,EAAAA,GAAA2rB,GAC7B,SAAAA,EAAYmB,EAAcC,GAAa,IAAAnlB,GAAAlI,EAAAA,EAAAA,GAAA,KAAAisB,GACnC/jB,EAAA7H,EAAAO,KAAA,KAAM,GACN,IAAK,IAAI4D,EAAI,EAAGA,EAAI4oB,EAAavrB,OAAQ2C,IACrC0D,EAAKN,IAAIwlB,EAAavY,WAAWrQ,GAAI,GAEzC,IAAK,IAAIA,EAAI,EAAGA,EAAI6oB,EAAYxrB,OAAQ2C,IACpC0D,EAAKN,IAAIylB,EAAYxY,WAAWrQ,GAAI,GACvC,OAAA0D,CACL,CAiBC,OAjBAvI,EAAAA,EAAAA,GAAAssB,EAAA,EAAAnrB,IAAA,MAAAY,MACD,SAAIsjB,GACA,OAAIA,GAAY,GAAKA,EAAW,IACrB/kB,KAAKqtB,UAAUtI,GAOjBA,GAAY,OAAUA,GAAY,OAC/BA,GAAY,OAAUA,GAAY,OAClCA,GAAY,OAAUA,GAAY,MAC/B,EAEH/kB,KAAKstB,KAAKxsB,IAAIikB,IAAa/kB,KAAKutB,aAEhD,KAACvB,CAAA,CA1B4B,CAASwB,EAAAA,GA4BtCR,EAAW,GACXC,EAAW,GACf,SAASF,EAAuChB,EAAYO,EAAsB5qB,EAAUue,EAASwN,EAAsBf,EAAyBP,EAAgBC,GAChK,IAA8B,IAA1BqB,EACA,OAAO,KAEX,IAAMjpB,EAAM9C,EAASE,OACrB,GAAI4C,GAAO,EACP,OAAO,KAEX,IAAMkpB,EAA2B,YAAdtB,EACbuB,EAAsBrB,EAAqBsB,aAC3CC,EAAmCvB,EAAqBwB,0BACxDC,EAA0BC,EAA+BtsB,EAAUue,EAASwN,EAAsBf,EAAyBP,GAC3H8B,EAAyBR,EAAuBM,EAChDG,EAAkBlB,EAClBmB,EAA+BlB,EACjCmB,EAAuB,EACvBC,EAAqB,EACrBC,EAAkC,EAClCC,EAAiBd,EACfe,EAAUb,EAAoB/rB,OAChC6sB,EAAY,EAChB,GAAIA,GAAa,EAEb,IADA,IAAIC,EAAetc,KAAKwO,IAAIiN,EAAiCY,GAAaF,GACnEE,EAAY,EAAID,GAAS,CAC5B,IAAMG,EAAWvc,KAAKwO,IAAIiN,EAAiCY,EAAY,GAAKF,GAC5E,GAAII,GAAYD,EACZ,MAEJA,EAAeC,EACfF,GACJ,CAEJ,KAAOA,EAAYD,GAAS,CAExB,IAAII,EAAkBH,EAAY,EAAI,EAAId,EAAoBc,GAC1DI,EAA+BJ,EAAY,EAAI,EAAIZ,EAAiCY,GACpFJ,EAAqBO,IACrBA,EAAkBP,EAClBQ,EAA+BP,GAEnC,IAAIQ,EAAc,EACdC,EAA2B,EAC3BC,EAAoB,EACpBC,EAAiC,EAErC,GAAIJ,GAAgCN,EAAgB,CAKhD,IAJA,IAAIjpB,EAAgBupB,EAChB/H,EAAmC,IAApB8H,EAAwB,EAAwBltB,EAASkT,WAAWga,EAAkB,GACrGM,EAAwC,IAApBN,EAAwB,EAA8B7C,EAAWjrB,IAAIgmB,GACzFqI,GAAiB,EACZ5qB,EAAIqqB,EAAiBrqB,EAAIC,EAAKD,IAAK,CACxC,IAAM6qB,EAAkB7qB,EAClBwgB,EAAWrjB,EAASkT,WAAWrQ,GACjC8qB,OAAa,EACb3K,OAAS,EAiBb,GAhBI1F,EAAAA,GAAwB+F,IAExBxgB,IACA8qB,EAAgB,EAChB3K,EAAY,IAGZ2K,EAAgBtD,EAAWjrB,IAAIikB,GAC/BL,EAAY4K,EAAiBvK,EAAUzf,EAAe2a,EAASyM,IAE/D0C,EAAkBf,GAAsBkB,EAASzI,EAAcoI,EAAmBnK,EAAUsK,EAAe3B,KAC3GoB,EAAcM,EACdL,EAA2BzpB,IAE/BA,GAAiBof,GAEG6J,EAAgB,CAE5Ba,EAAkBf,GAClBW,EAAoBI,EACpBH,EAAiC3pB,EAAgBof,IAIjDsK,EAAoBzqB,EAAI,EACxB0qB,EAAiC3pB,GAEjCA,EAAgBypB,EAA2Bd,IAE3Ca,EAAc,GAElBK,GAAiB,EACjB,KACJ,CACArI,EAAe/B,EACfmK,EAAoBG,CACxB,CACA,GAAIF,EAAgB,CAEZf,EAAuB,IAEvBF,EAAgBE,GAAwBT,EAAoBA,EAAoB/rB,OAAS,GACzFusB,EAA6BC,GAAwBP,EAAiCF,EAAoB/rB,OAAS,GACnHwsB,KAEJ,KACJ,CACJ,CACA,GAAoB,IAAhBU,EAAmB,CAMnB,IAJA,IAAIxpB,EAAgBupB,EAChB9J,EAAWrjB,EAASkT,WAAWga,GAC/BS,EAAgBtD,EAAWjrB,IAAIikB,GAC/ByK,GAAmB,EACdjrB,EAAIqqB,EAAkB,EAAGrqB,GAAK8pB,EAAoB9pB,IAAK,CAC5D,IAAM6qB,EAAkB7qB,EAAI,EACtBuiB,EAAeplB,EAASkT,WAAWrQ,GACzC,GAAqB,IAAjBuiB,EAAuC,CAEvC0I,GAAmB,EACnB,KACJ,CACA,IAAIN,OAAiB,EACjBO,OAAa,EAWjB,GAVIzQ,EAAAA,GAAuB8H,IAEvBviB,IACA2qB,EAAoB,EACpBO,EAAgB,IAGhBP,EAAoBnD,EAAWjrB,IAAIgmB,GACnC2I,EAAiBzQ,EAAAA,GAA6B8H,GAAgB4F,EAA0B,GAExFpnB,GAAiBipB,EAAgB,CAKjC,GAJ0B,IAAtBS,IACAA,EAAoBI,EACpBH,EAAiC3pB,GAEjCA,GAAiBipB,EAAiBN,EAElC,MAEJ,GAAIsB,EAASzI,EAAcoI,EAAmBnK,EAAUsK,EAAe3B,GAAY,CAC/EoB,EAAcM,EACdL,EAA2BzpB,EAC3B,KACJ,CACJ,CACAA,GAAiBmqB,EACjB1K,EAAW+B,EACXuI,EAAgBH,CACpB,CACA,GAAoB,IAAhBJ,EAAmB,CACnB,IAAMY,GAA2BzB,GAA0BgB,EAAiCF,GAC5F,GAAIW,IAA4BzP,EAAS,CACrC,IAAM0P,GAA8BjuB,EAASkT,WAAWoa,GASpDU,IAPA1Q,EAAAA,GAAwB2Q,IAEZ,EAGAL,EAAiBK,GAA6BV,EAAgChP,EAASyM,IAE5D,IAEvCoC,EAAc,EAEtB,CACJ,CACA,GAAIU,EAAkB,CAElBf,IACA,QACJ,CACJ,CAMA,GALoB,IAAhBK,IAEAA,EAAcE,EACdD,EAA2BE,GAE3BH,GAAeT,EAAoB,CAEnC,IAAMtJ,GAAWrjB,EAASkT,WAAWyZ,GACjCrP,EAAAA,GAAwB+F,KAExB+J,EAAcT,EAAqB,EACnCU,EAA2BT,EAAkC,IAG7DQ,EAAcT,EAAqB,EACnCU,EAA2BT,EAAkCgB,EAAiBvK,GAAUuJ,EAAiCrO,EAASyM,GAE1I,CAOA,IANA2B,EAAqBS,EACrBZ,EAAgBE,GAAwBU,EACxCR,EAAkCS,EAClCZ,EAA6BC,GAAwBW,EACrDX,IACAG,EAAiBQ,EAA2Bd,EACrCQ,EAAY,GAAMA,EAAYD,GAAWX,EAAiCY,GAAaM,GAC1FN,IAGJ,IADA,IAAIC,GAAetc,KAAKwO,IAAIiN,EAAiCY,GAAaF,GACnEE,EAAY,EAAID,GAAS,CAC5B,IAAMG,GAAWvc,KAAKwO,IAAIiN,EAAiCY,EAAY,GAAKF,GAC5E,GAAII,IAAYD,GACZ,MAEJA,GAAeC,GACfF,GACJ,CACJ,CACA,OAA6B,IAAzBL,EACO,MAGXF,EAAgBtsB,OAASwsB,EACzBD,EAA6BvsB,OAASwsB,EACtCpB,EAAWV,EAAqBsB,aAChCX,EAAWX,EAAqBwB,0BAChCxB,EAAqBsB,aAAeM,EACpC5B,EAAqBwB,0BAA4BK,EACjD7B,EAAqByB,wBAA0BA,EACxCzB,EACX,CACA,SAASQ,EAAiBf,EAAY6D,EAAWjuB,EAAese,EAASwN,EAAsBf,EAAyBP,EAAgBC,GACpI,IACIS,EACAgD,EAFEnuB,EAAWP,EAAAA,GAAiB2uB,kBAAkBF,EAAWjuB,GAW/D,GARIA,GAAiBA,EAAcC,OAAS,GACxCirB,EAAmBlrB,EAAcouB,KAAI,SAAAC,GAAC,OAAIA,EAAEzuB,OAAO,IACnDsuB,EAAmBluB,EAAcouB,KAAI,SAAAjgB,GAAI,OAAIA,EAAKxO,OAAS,CAAC,MAG5DurB,EAAmB,KACnBgD,EAAmB,OAEO,IAA1BpC,EACA,OAAKZ,EAKE,IAAIoD,EAAAA,GAAwBJ,EAAkBhD,EAAkB,CAACnrB,EAASE,QAAS,GAAI,GAJnF,KAMf,IAAM4C,EAAM9C,EAASE,OACrB,GAAI4C,GAAO,EACP,OAAKqoB,EAKE,IAAIoD,EAAAA,GAAwBJ,EAAkBhD,EAAkB,CAACnrB,EAASE,QAAS,GAAI,GAJnF,KAMf,IAAM8rB,EAA2B,YAAdtB,EACb2B,EAA0BC,EAA+BtsB,EAAUue,EAASwN,EAAsBf,EAAyBP,GAC3H8B,EAAyBR,EAAuBM,EAChDG,EAAkB,GAClBC,EAA+B,GACjCC,EAAuB,EACvBU,EAAc,EACdC,EAA2B,EAC3BR,EAAiBd,EACjB3G,EAAeplB,EAASkT,WAAW,GACnCsa,EAAoBnD,EAAWjrB,IAAIgmB,GACnCxhB,EAAgBgqB,EAAiBxI,EAAc,EAAG7G,EAASyM,GAC3D1b,EAAc,EACdgO,EAAAA,GAAwB8H,KAExBxhB,GAAiB,EACjBwhB,EAAeplB,EAASkT,WAAW,GACnCsa,EAAoBnD,EAAWjrB,IAAIgmB,GACnC9V,KAEJ,IAAK,IAAIzM,EAAIyM,EAAazM,EAAIC,EAAKD,IAAK,CACpC,IAAM6qB,EAAkB7qB,EAClBwgB,EAAWrjB,EAASkT,WAAWrQ,GACjC8qB,OAAa,EACb3K,OAAS,EACT1F,EAAAA,GAAwB+F,IAExBxgB,IACA8qB,EAAgB,EAChB3K,EAAY,IAGZ2K,EAAgBtD,EAAWjrB,IAAIikB,GAC/BL,EAAY4K,EAAiBvK,EAAUzf,EAAe2a,EAASyM,IAE/D6C,EAASzI,EAAcoI,EAAmBnK,EAAUsK,EAAe3B,KACnEoB,EAAcM,EACdL,EAA2BzpB,IAE/BA,GAAiBof,GAEG6J,KAEI,IAAhBO,GAAqBxpB,EAAgBypB,EAA2Bd,KAEhEa,EAAcM,EACdL,EAA2BzpB,EAAgBof,GAE/CwJ,EAAgBE,GAAwBU,EACxCX,EAA6BC,GAAwBW,EACrDX,IACAG,EAAiBQ,EAA2Bd,EAC5Ca,EAAc,GAElBhI,EAAe/B,EACfmK,EAAoBG,CACxB,CACA,OAA6B,IAAzBjB,GAAgCzsB,GAA0C,IAAzBA,EAAcC,QAInEssB,EAAgBE,GAAwB5pB,EACxC2pB,EAA6BC,GAAwB9oB,EAC9C,IAAI2qB,EAAAA,GAAwBJ,EAAkBhD,EAAkBqB,EAAiBC,EAA8BJ,IAL3G,IAMf,CACA,SAASuB,EAAiBvK,EAAUzf,EAAe2a,EAASyM,GACxD,OAAiB,IAAb3H,EACQ9E,EAAW3a,EAAgB2a,EAEnCjB,EAAAA,GAA6B+F,IAG7BA,EAAW,GAFJ2H,EAMJ,CACX,CACA,SAASwD,EAAkB5qB,EAAe2a,GACtC,OAAQA,EAAW3a,EAAgB2a,CACvC,CAKA,SAASsP,EAASzI,EAAcoI,EAAmBnK,EAAUsK,EAAe3B,GACxE,OAAqB,KAAb3I,IACuB,IAAtBmK,GAA8E,IAAlBG,GACnC,IAAtBH,GAA+E,IAAlBG,IAC5D3B,GAAmC,IAAtBwB,GAAoF,IAAlBG,IAC/E3B,GAA+B,IAAlB2B,GAAoF,IAAtBH,EAC5F,CACA,SAASlB,EAA+BtsB,EAAUue,EAASwN,EAAsBf,EAAyBP,GACtG,IAAI4B,EAA0B,EAC9B,GAAuB,IAAnB5B,EAAgD,CAChD,IAAM/F,EAA0BpH,EAAAA,GAAgCtd,GAChE,IAAiC,IAA7B0kB,EAAgC,CAEhC,IAAK,IAAI7hB,EAAI,EAAGA,EAAI6hB,EAAyB7hB,IAAK,CAE9CwpB,GAD8C,IAA3BrsB,EAASkT,WAAWrQ,GAA8B2rB,EAAkBnC,EAAyB9N,GAAW,CAE/H,CAGA,IADA,IAAMkQ,EAA6C,IAAnBhE,EAAuD,EAAuB,IAAnBA,EAAmD,EAAI,EACzI5nB,EAAI,EAAGA,EAAI4rB,EAAwB5rB,IAAK,CAE7CwpB,GADkBmC,EAAkBnC,EAAyB9N,EAEjE,CAEI8N,EAA0BrB,EAA0Be,IACpDM,EAA0B,EAElC,CACJ,CACA,OAAOA,CACX,C,2GCrbaqC,EAAS,WAClB,SAAAA,EAAYlnB,EAAMqH,EAAI6a,IAASrrB,EAAAA,EAAAA,GAAA,KAAAqwB,GAC3BpwB,KAAKqwB,qBAAkBpgB,EACvBjQ,KAAKkJ,KAAc,EAAPA,EACZlJ,KAAKuQ,GAAU,EAALA,EACVvQ,KAAKorB,QAAoB,EAAVA,CACnB,CASC,OATA1rB,EAAAA,EAAAA,GAAA0wB,EAAA,OAAAvvB,IAAA,UAAAY,MACD,SAAe8B,EAAGC,GACd,OAAID,EAAE6nB,UAAY5nB,EAAE4nB,QACZ7nB,EAAE2F,OAAS1F,EAAE0F,KACN3F,EAAEgN,GAAK/M,EAAE+M,GAEbhN,EAAE2F,KAAO1F,EAAE0F,KAEf3F,EAAE6nB,QAAU5nB,EAAE4nB,OACzB,KAACgF,CAAA,CAfiB,GAoBTE,EAAiB,WAC1B,SAAAA,EAAYrtB,EAAiBG,EAAemtB,EAAe5F,IAAO5qB,EAAAA,EAAAA,GAAA,KAAAuwB,GAC9DtwB,KAAKwwB,6BAA0BvgB,EAC/BjQ,KAAKiD,gBAAkBA,EACvBjD,KAAKoD,cAAgBA,EACrBpD,KAAKuwB,cAAgBA,EACrBvwB,KAAK2qB,MAAQA,EACb3qB,KAAKywB,WAAa,IACtB,CAYC,OAZA/wB,EAAAA,EAAAA,GAAA4wB,EAAA,EAAAzvB,IAAA,eAAAY,MAaD,SAAaivB,GACT1wB,KAAKywB,WAAaC,CACtB,GAAC,CAAA7vB,IAAA,gBAAAY,MACD,WACI,OAAOzB,KAAKywB,UAChB,IAAC,EAAA5vB,IAAA,UAAAY,MAjBD,SAAe8B,EAAGC,GACd,OAAID,EAAEonB,QAAUnnB,EAAEmnB,MACVpnB,EAAEN,kBAAoBO,EAAEP,gBACpBM,EAAEgtB,gBAAkB/sB,EAAE+sB,cACfhtB,EAAEH,cAAgBI,EAAEJ,cAExBG,EAAEgtB,cAAgB/sB,EAAE+sB,cAExBhtB,EAAEN,gBAAkBO,EAAEP,gBAE1BM,EAAEonB,MAAQnnB,EAAEmnB,OAAS,EAAI,CACpC,KAAC2F,CAAA,CApByB,GA4BjBK,EAAmB,WAC5B,SAAAA,EAAYC,IAA0B7wB,EAAAA,EAAAA,GAAA,KAAA4wB,GAClC3wB,KAAK6wB,0BAA4BD,EACjC5wB,KAAK8wB,OAAS,GACd9wB,KAAK+wB,oBAAqB,EAC1B/wB,KAAKgxB,YAAc,EACnBhxB,KAAKixB,UAAY,EACjBjxB,KAAKkxB,WAAa,EAClBlxB,KAAKmxB,aAAe,EACpBnxB,KAAKoxB,YAAc,EACnBpxB,KAAKqxB,gBAAkB,EACvBrxB,KAAKsxB,UAAYC,OAAOC,OAAO,MAC/BxxB,KAAKyxB,UAAY,EACrB,CA2GC,OA3GA/xB,EAAAA,EAAAA,GAAAixB,EAAA,EAAA9vB,IAAA,cAAAY,MACD,WACI,OAAOzB,KAAKyxB,SAChB,GAAC,CAAA5wB,IAAA,WAAAY,MACD,SAASiwB,GACL1xB,KAAK8wB,OAASY,EACd1xB,KAAK8wB,OAAOxtB,KAAKgtB,EAAkB3P,QACvC,GAAC,CAAA9f,IAAA,gBAAAY,MACD,SAAckwB,GACV,OAAI3xB,KAAKgxB,cAAgBW,IAGzB3xB,KAAKgxB,YAAcW,EACnB3xB,KAAK+wB,oBAAqB,GACnB,EACX,GAAC,CAAAlwB,IAAA,gBAAAY,MACD,SAAcmwB,GACV5xB,KAAKoxB,YAAcQ,EACnB5xB,KAAK+wB,oBAAqB,CAC9B,GAAC,CAAAlwB,IAAA,cAAAY,MACD,WACI,OAAOzB,KAAKixB,SAChB,GAAC,CAAApwB,IAAA,iBAAAY,MACD,WACI,OAAOzB,KAAKixB,UAAYjxB,KAAKoxB,WACjC,GAAC,CAAAvwB,IAAA,cAAAY,MACD,SAAY+nB,GACR,OAAIxpB,KAAKixB,YAAczH,IAGvBxpB,KAAKixB,UAAYzH,EACjBxpB,KAAK+wB,oBAAqB,GACnB,EACX,GAAC,CAAAlwB,IAAA,eAAAY,MACD,WACI,OAAOzB,KAAKkxB,UAChB,GAAC,CAAArwB,IAAA,kBAAAY,MACD,WACI,OAAOzB,KAAKkxB,WAAalxB,KAAKoxB,WAClC,GAAC,CAAAvwB,IAAA,eAAAY,MACD,SAAagoB,GACT,OAAIzpB,KAAKkxB,aAAezH,IAGxBzpB,KAAKkxB,WAAazH,EAClBzpB,KAAK+wB,oBAAqB,GACnB,EACX,GAAC,CAAAlwB,IAAA,iBAAAY,MACD,WACI,OAAOzB,KAAKmxB,YAChB,GAAC,CAAAtwB,IAAA,iBAAAY,MACD,SAAeowB,GACX,OAAI7xB,KAAKmxB,eAAiBU,IAG1B7xB,KAAKmxB,aAAeU,EACpB7xB,KAAK+wB,oBAAqB,GACnB,EACX,GAAC,CAAAlwB,IAAA,oBAAAY,MACD,WAQI,IAPA,IAAMqwB,EAAoB9xB,KAAK+wB,mBACzBY,EAAavf,KAAKC,MAAMrS,KAAKgxB,aAC7Be,EAAc3f,KAAKC,MAAMrS,KAAKgyB,mBAE9BC,EAAcF,EADA3f,KAAKC,MAAMrS,KAAKmxB,cAE9Be,EAAoB9f,KAAKC,MAAM,EAAmCrS,KAAKoxB,YAAc,GACrFe,EAAgB,GACb5tB,EAAI,EAAGC,EAAMxE,KAAK8wB,OAAOlvB,OAAQ2C,EAAIC,EAAKD,IAAK,CACpD,IAAM6tB,EAAOpyB,KAAK8wB,OAAOvsB,GACzB,IAAKutB,EAAmB,CACpB,IAAMpB,EAAY0B,EAAKC,gBACvB,GAAI3B,EAAW,CACXyB,EAAcnvB,KAAK0tB,GACnB,QACJ,CACJ,CACA,IAAM4B,EAAUtyB,KAAK6wB,0BAA0BuB,EAAKnvB,iBAC9CsvB,EAAkC,IAAvBH,EAAK7B,cAChBvwB,KAAK6wB,0BAA0BuB,EAAKhvB,eAAiBuuB,EACrDW,EAAUF,EAAK7B,cAAgBoB,EAC/Ba,EAAKpgB,KAAKC,MAAM4f,EAAcK,GAC9BG,EAAKrgB,KAAKC,MAAM4f,EAAcM,GAChCG,EAAUtgB,KAAKC,OAAOmgB,EAAKC,GAAM,GACjCE,EAAcF,EAAKC,EACnBC,EAAaT,IACbS,EAAaT,GAEbQ,EAAUC,EAAa,IACvBD,EAAUC,GAEVD,EAAUC,EAAaZ,IACvBW,EAAUX,EAAcY,GAE5B,IAAMhI,EAAQyH,EAAKzH,MACfS,EAAUprB,KAAKsxB,UAAU3G,GACxBS,IACDA,IAAaprB,KAAKqxB,gBAClBrxB,KAAKsxB,UAAU3G,GAASS,EACxBprB,KAAKyxB,UAAUrG,GAAWT,GAE9B,IAAM+F,EAAY,IAAIN,EAAUsC,EAAUC,EAAYD,EAAUC,EAAYvH,GAC5EgH,EAAKQ,aAAalC,GAClByB,EAAcnvB,KAAK0tB,EACvB,CAGA,OAFA1wB,KAAK+wB,oBAAqB,EAC1BoB,EAAc7uB,KAAK8sB,EAAUzP,SACtBwR,CACX,KAACxB,CAAA,CAxH2B,E,6FC/CnBkC,EAAW,WACpB,SAAAA,EAAYC,EAAe3V,EAAO0L,IAAO9oB,EAAAA,EAAAA,GAAA,KAAA8yB,GACrC7yB,KAAK8yB,cAAgBA,EACrB9yB,KAAKmd,MAAQ,IAAI4V,EAAAA,EAAY5V,GAC7Bnd,KAAKgzB,UAAYnK,EACjB7oB,KAAKizB,WAAapK,EAAMoK,UAC5B,CAMC,OANAvzB,EAAAA,EAAAA,GAAAmzB,EAAA,EAAAhyB,IAAA,kBAAAY,MACD,SAAgByxB,GACZlzB,KAAKgzB,UAAUG,oBAAoBD,EACvC,GAAC,CAAAryB,IAAA,qBAAAY,MACD,SAAmByxB,GACflzB,KAAKgzB,UAAUI,uBAAuBF,EAC1C,KAACL,CAAA,CAZmB,E,uMCGXQ,EAAoB,WAC7B,SAAAA,EAAYC,EAAUzK,EAAOiK,EAAeS,EAAiBC,IAAsBzzB,EAAAA,EAAAA,GAAA,KAAAszB,GAC/ErzB,KAAKszB,SAAWA,EAChBtzB,KAAK6oB,MAAQA,EACb7oB,KAAK8yB,cAAgBA,EACrB9yB,KAAKyzB,iBAAmBF,EACxBvzB,KAAK0zB,sBAAwBF,EAC7BxzB,KAAK2zB,kBAAoBpC,OAAOC,OAAO,MACvCxxB,KAAK4zB,gCAAkC,KACvC5zB,KAAK6zB,yCAA2C,IACpD,CAuGC,OAvGAn0B,EAAAA,EAAAA,GAAA2zB,EAAA,EAAAxyB,IAAA,uCAAAY,MACD,WACIzB,KAAK4zB,gCAAkC,KACvC5zB,KAAK6zB,yCAA2C,IACpD,GAAC,CAAAhzB,IAAA,UAAAY,MACD,WACIzB,KAAK2zB,kBAAoBpC,OAAOC,OAAO,MACvCxxB,KAAK8zB,sCACT,GAAC,CAAAjzB,IAAA,QAAAY,MACD,WACIzB,KAAK2zB,kBAAoBpC,OAAOC,OAAO,MACvCxxB,KAAK8zB,sCACT,GAAC,CAAAjzB,IAAA,4BAAAY,MACD,WACIzB,KAAK2zB,kBAAoBpC,OAAOC,OAAO,MACvCxxB,KAAK8zB,sCACT,GAAC,CAAAjzB,IAAA,uBAAAY,MACD,WACIzB,KAAK2zB,kBAAoBpC,OAAOC,OAAO,MACvCxxB,KAAK8zB,sCACT,GAAC,CAAAjzB,IAAA,kCAAAY,MACD,SAAgCsyB,GAC5B,IAAM9Y,EAAK8Y,EAAgB9Y,GACvByC,EAAI1d,KAAK2zB,kBAAkB1Y,GAC/B,IAAKyC,EAAG,CACJ,IAEIsW,EAFEC,EAAaF,EAAgBp0B,MAC7B4B,EAAUwyB,EAAgBxyB,QAEhC,GAAIA,EAAQ2yB,YAAa,CACrB,IAAM7mB,EAAQrN,KAAK0zB,sBAAsBS,mCAAmC,IAAI/lB,EAAAA,EAAS6lB,EAAWhxB,gBAAiB,GAAI,GAA+B,GAAO,GACzJmxB,EAAMp0B,KAAK0zB,sBAAsBS,mCAAmC,IAAI/lB,EAAAA,EAAS6lB,EAAW7wB,cAAepD,KAAK6oB,MAAMM,iBAAiB8K,EAAW7wB,gBAAiB,GACzK4wB,EAAY,IAAIngB,EAAAA,EAAMxG,EAAMhM,WAAYgM,EAAM/L,OAAQ8yB,EAAI/yB,WAAY+yB,EAAI9yB,OAC9E,MAII0yB,EAAYh0B,KAAK0zB,sBAAsBW,6BAA6BJ,EAAY,GAEpFvW,EAAI,IAAI8M,EAAAA,GAAoBwJ,EAAWzyB,GACvCvB,KAAK2zB,kBAAkB1Y,GAAMyC,CACjC,CACA,OAAOA,CACX,GAAC,CAAA7c,IAAA,+BAAAY,MACD,SAA6B9B,GACzB,OAAOK,KAAKs0B,uBAAuB30B,GAAO,GAAM,GAAOgD,WAC3D,GAAC,CAAA9B,IAAA,6BAAAY,MACD,SAA2BuyB,GACvB,IAAIO,EAAyD,OAAzCv0B,KAAK4zB,gCAMzB,OALAW,EAAeA,GAAiBP,EAAUQ,YAAYx0B,KAAK6zB,6CAEvD7zB,KAAK4zB,gCAAkC5zB,KAAKs0B,uBAAuBN,GAAW,GAAO,GACrFh0B,KAAK6zB,yCAA2CG,GAE7Ch0B,KAAK4zB,+BAChB,GAAC,CAAA/yB,IAAA,6BAAAY,MACD,SAA2BJ,GAA2E,IAA/DozB,EAAsBC,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,IAAAA,UAAA,GAAUC,EAAqBD,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,IAAAA,UAAA,GAClF/0B,EAAQ,IAAIkU,EAAAA,EAAMxS,EAAYrB,KAAKyzB,iBAAiBmB,qBAAqBvzB,GAAaA,EAAYrB,KAAKyzB,iBAAiBoB,qBAAqBxzB,IACnJ,OAAOrB,KAAKs0B,uBAAuB30B,EAAO80B,EAAwBE,GAAuB3K,kBAAkB,EAC/G,GAAC,CAAAnpB,IAAA,yBAAAY,MACD,SAAuBuyB,EAAWS,EAAwBE,GAOtD,IANA,IAAMG,EAAmB90B,KAAKyzB,iBAAiBsB,sBAAsBf,EAAWh0B,KAAKszB,UAAU0B,EAAAA,EAAAA,IAA4Bh1B,KAAK8yB,cAAcvxB,SAAUkzB,EAAwBE,GAC1K1xB,EAAkB+wB,EAAU/wB,gBAC5BG,EAAgB4wB,EAAU5wB,cAC1B6xB,EAAwB,GAC1BC,EAA2B,EACzBlL,EAAoB,GACjBtC,EAAIzkB,EAAiBykB,GAAKtkB,EAAeskB,IAC9CsC,EAAkBtC,EAAIzkB,GAAmB,GAE7C,IAAK,IAAIsB,EAAI,EAAGC,EAAMswB,EAAiBlzB,OAAQ2C,EAAIC,EAAKD,IAAK,CACzD,IAAMwvB,EAAkBe,EAAiBvwB,GACnC4wB,EAAoBpB,EAAgBxyB,QAC1C,GAAK6zB,EAAyBp1B,KAAK6oB,MAAOkL,GAA1C,CAGA,IAAMsB,EAAsBr1B,KAAKs1B,gCAAgCvB,GAC3DC,EAAYqB,EAAoB11B,MAEtC,GADAs1B,EAAsBC,KAA8BG,EAChDF,EAAkBlX,gBAIlB,IAHA,IAAMsX,EAAmB,IAAIlL,EAAAA,GAAiB2J,EAAWmB,EAAkBlX,gBAAiBkX,EAAkB5K,oCAAsC,EAA6D,GAC3MiL,EAA6BpjB,KAAK8D,IAAIjT,EAAiB+wB,EAAU/wB,iBACjEwyB,EAA2BrjB,KAAKc,IAAI9P,EAAe4wB,EAAU5wB,eAC1DskB,EAAI8N,EAA4B9N,GAAK+N,EAA0B/N,IACpEsC,EAAkBtC,EAAIzkB,GAAiBD,KAAKuyB,GAGpD,GAAIJ,EAAkBO,wBACdzyB,GAAmB+wB,EAAU/wB,iBAAmB+wB,EAAU/wB,iBAAmBG,EAAe,CAC5F,IAAMmyB,EAAmB,IAAIlL,EAAAA,GAAiB,IAAIxW,EAAAA,EAAMmgB,EAAU/wB,gBAAiB+wB,EAAU9wB,YAAa8wB,EAAU/wB,gBAAiB+wB,EAAU9wB,aAAciyB,EAAkBO,uBAAwB,GACvM1L,EAAkBgK,EAAU/wB,gBAAkBA,GAAiBD,KAAKuyB,EACxE,CAEJ,GAAIJ,EAAkBQ,uBACd1yB,GAAmB+wB,EAAU5wB,eAAiB4wB,EAAU5wB,eAAiBA,EAAe,CACxF,IAAMmyB,EAAmB,IAAIlL,EAAAA,GAAiB,IAAIxW,EAAAA,EAAMmgB,EAAU5wB,cAAe4wB,EAAU3wB,UAAW2wB,EAAU5wB,cAAe4wB,EAAU3wB,WAAY8xB,EAAkBQ,sBAAuB,GAC9L3L,EAAkBgK,EAAU5wB,cAAgBH,GAAiBD,KAAKuyB,EACtE,CAtBJ,CAwBJ,CACA,MAAO,CACH5yB,YAAasyB,EACbjL,kBAAmBA,EAE3B,KAACqJ,CAAA,CAjH4B,GAmH1B,SAAS+B,EAAyBvM,EAAO/lB,GAC5C,QAAIA,EAAWvB,QAAQq0B,sBAAuBC,EAA2BhN,EAAO/lB,OAG5EA,EAAWvB,QAAQu0B,qBAAsBC,EAA0BlN,EAAO/lB,GAIlF,CACO,SAAS+yB,EAA2BhN,EAAO/lB,GAC9C,OAAOkzB,EAAkBnN,EAAO/lB,EAAWnD,OAAO,SAACsmB,GAAS,OAAmB,IAAdA,CAAe,GACpF,CACO,SAAS8P,EAA0BlN,EAAO/lB,GAC7C,OAAOkzB,EAAkBnN,EAAO/lB,EAAWnD,OAAO,SAACsmB,GAAS,OAAmB,IAAdA,CAAe,GACpF,CAMA,SAAS+P,EAAkBnN,EAAOlpB,EAAOs2B,GACrC,IAAK,IAAI50B,EAAa1B,EAAMsD,gBAAiB5B,GAAc1B,EAAMyD,cAAe/B,IAK5E,IAJA,IAAMuJ,EAAaie,EAAMqN,aAAa1mB,cAAcnO,GAC9C80B,EAAc90B,IAAe1B,EAAMsD,gBACnCmzB,EAAY/0B,IAAe1B,EAAMyD,cACnCizB,EAAWF,EAAcvrB,EAAWgI,uBAAuBjT,EAAMuD,YAAc,GAAK,EACjFmzB,EAAWzrB,EAAWiI,YAAY,CACrC,GAAIujB,EAEA,GADoBxrB,EAAWkI,eAAeujB,GAC5B12B,EAAM0D,UAAY,EAChC,MAIR,IADuB4yB,EAASrrB,EAAW0rB,qBAAqBD,IAE5D,OAAO,EAEXA,GACJ,CAEJ,OAAO,CACX,C,iXC/JME,EAAc,WAChB,SAAAA,KAAcx2B,EAAAA,EAAAA,GAAA,KAAAw2B,GACVv2B,KAAKw2B,aAAc,EACnBx2B,KAAKy2B,SAAW,GAChBz2B,KAAK02B,SAAW,GAChB12B,KAAK22B,SAAW,EACpB,CA4BC,OA5BAj3B,EAAAA,EAAAA,GAAA62B,EAAA,EAAA11B,IAAA,SAAAY,MACD,SAAOm1B,GACH52B,KAAKw2B,aAAc,EACnBx2B,KAAKy2B,SAASzzB,KAAK4zB,EACvB,GAAC,CAAA/1B,IAAA,SAAAY,MACD,SAAOm1B,GACH52B,KAAKw2B,aAAc,EACnBx2B,KAAK02B,SAAS1zB,KAAK4zB,EACvB,GAAC,CAAA/1B,IAAA,SAAAY,MACD,SAAOm1B,GACH52B,KAAKw2B,aAAc,EACnBx2B,KAAK22B,SAAS3zB,KAAK4zB,EACvB,GAAC,CAAA/1B,IAAA,aAAAY,MACD,WACI,OAAOzB,KAAKw2B,WAChB,GAAC,CAAA31B,IAAA,SAAAY,MACD,SAAOo1B,GACH,GAAK72B,KAAKw2B,YAAV,CAGA,IAAMM,EAAU92B,KAAKy2B,SACfxyB,EAAUjE,KAAK02B,SACfK,EAAU/2B,KAAK22B,SACrB32B,KAAKw2B,aAAc,EACnBx2B,KAAKy2B,SAAW,GAChBz2B,KAAK02B,SAAW,GAChB12B,KAAK22B,SAAW,GAChBE,EAAYG,sBAAsBF,EAAS7yB,EAAS8yB,EARpD,CASJ,KAACR,CAAA,CAlCe,GAoCPU,GAAgBv3B,EAAAA,EAAAA,IACzB,SAAAu3B,EAAYhc,EAAIic,EAAiBC,EAAS1N,EAAQ2N,IAAUr3B,EAAAA,EAAAA,GAAA,KAAAk3B,GACxDj3B,KAAKib,GAAKA,EACVjb,KAAKk3B,gBAAkBA,EACvBl3B,KAAKm3B,QAAUA,EACfn3B,KAAKypB,OAASA,EACdzpB,KAAKo3B,SAAWA,EAChBp3B,KAAKq3B,UAAY,CACrB,IAQSC,EAAW,WACpB,SAAAA,EAAYC,EAAW5F,EAAY6F,EAAYC,IAAe13B,EAAAA,EAAAA,GAAA,KAAAu3B,GAC1Dt3B,KAAK03B,YAAc1Y,EAAAA,KAA2BsY,EAAYK,gBAC1D33B,KAAK43B,gBAAkB,IAAIrB,EAC3Bv2B,KAAK63B,kBAAoB,EACzB73B,KAAK83B,KAAO,GACZ93B,KAAK+3B,sBAAwB,EAC7B/3B,KAAKg4B,WAAa,EAClBh4B,KAAKi4B,WAAaV,EAClBv3B,KAAKgxB,YAAcW,EACnB3xB,KAAKk4B,YAAcV,EACnBx3B,KAAKm4B,eAAiBV,CAC1B,CA0BC,OAzBD/3B,EAAAA,EAAAA,GAAA43B,EAAA,EAAAz2B,IAAA,gBAAAY,MA6BA,SAAckwB,GACV3xB,KAAKo4B,uBACLp4B,KAAKgxB,YAAcW,CACvB,GACA,CAAA9wB,IAAA,aAAAY,MAGA,SAAW+1B,EAAYC,GACnBz3B,KAAKk4B,YAAcV,EACnBx3B,KAAKm4B,eAAiBV,CAC1B,GACA,CAAA52B,IAAA,YAAAY,MAKA,SAAU81B,GACNv3B,KAAKo4B,uBACLp4B,KAAKi4B,WAAaV,CACtB,GAAC,CAAA12B,IAAA,mBAAAY,MACD,SAAiBw0B,GAAU,IAAAv1B,EAAA,KACnB23B,GAAa,EACjB,IAuBIpC,EAtBiB,CACbqC,iBAAkB,SAACpB,EAAiBC,EAASoB,EAAYnB,GACrDiB,GAAa,EACbnB,GAAoC,EACpCC,GAAoB,EACpBoB,GAA0B,EAC1BnB,GAAsB,EACtB,IAAMnc,EAAKva,EAAKg3B,eAAiBh3B,EAAKm3B,kBAEtC,OADAn3B,EAAKk3B,gBAAgB/oB,OAAO,IAAIooB,EAAiBhc,EAAIic,EAAiBC,EAASoB,EAAYnB,IACpFnc,CACX,EACAud,oBAAqB,SAACvd,EAAIwd,EAAoBC,GAC1CL,GAAa,EACbI,GAA0C,EAC1CC,GAAwB,EACxBh4B,EAAKk3B,gBAAgBe,OAAO,CAAE1d,GAAAA,EAAIwd,mBAAAA,EAAoBC,UAAAA,GAC1D,EACAE,iBAAkB,SAAC3d,GACfod,GAAa,EACb33B,EAAKk3B,gBAAgBiB,OAAO,CAAE5d,GAAAA,GAClC,GAGR,CAAC,QAEGjb,KAAK43B,gBAAgBkB,OAAO94B,KAChC,CACA,OAAOq4B,CACX,GAAC,CAAAx3B,IAAA,wBAAAY,MACD,SAAsBq1B,EAAS7yB,EAAS8yB,GAIpC,IAHID,EAAQl1B,OAAS,GAAKm1B,EAAQn1B,OAAS,KACvC5B,KAAKg4B,WAAa,GAElBlB,EAAQl1B,OAASqC,EAAQrC,OAASm1B,EAAQn1B,QAAU,EAAxD,CACI,IAC4BC,EAD5BG,GAAAC,EAAAA,EAAAA,GACqB60B,GAAO,IAA5B,IAAA90B,EAAAE,MAAAL,EAAAG,EAAAG,KAAAC,MAA8B,KAAnByM,EAAMhN,EAAAJ,MACbzB,KAAK+4B,kBAAkBlqB,EAC3B,CAAC,OAAArM,GAAAR,EAAAS,EAAAD,EAAA,SAAAR,EAAAU,GAAA,KAC2BE,EAD3BC,GAAAZ,EAAAA,EAAAA,GACoBgC,GAAO,IAA5B,IAAApB,EAAAX,MAAAU,EAAAC,EAAAV,KAAAC,MAA8B,KAAnBu2B,EAAM/1B,EAAAnB,MACbzB,KAAKg5B,qBAAqBL,EAAO1d,GAAI0d,EAAOF,mBAAoBE,EAAOD,UAC3E,CAAC,OAAAl2B,GAAAK,EAAAJ,EAAAD,EAAA,SAAAK,EAAAH,GAAA,KAC2Bu2B,EAD3BC,GAAAj3B,EAAAA,EAAAA,GACoB80B,GAAO,IAA5B,IAAAmC,EAAAh3B,MAAA+2B,EAAAC,EAAA/2B,KAAAC,MAA8B,KAAnBy2B,EAAMI,EAAAx3B,MACP0W,EAAQnY,KAAKm5B,qBAAqBN,EAAO5d,KAChC,IAAX9C,GAGJnY,KAAKo5B,kBAAkBjhB,EAC3B,CAAC,OAAA3V,GAAA02B,EAAAz2B,EAAAD,EAAA,SAAA02B,EAAAx2B,GAAA,CAEL,KAhBA,CAkBA,IAC4B22B,EADtBC,EAAW,IAAIC,IAAMC,GAAAv3B,EAAAA,EAAAA,GACN80B,GAAO,IAA5B,IAAAyC,EAAAt3B,MAAAm3B,EAAAG,EAAAr3B,KAAAC,MAA8B,KAAnBy2B,EAAMQ,EAAA53B,MACb63B,EAASG,IAAIZ,EAAO5d,GACxB,CAAC,OAAAzY,GAAAg3B,EAAA/2B,EAAAD,EAAA,SAAAg3B,EAAA92B,GAAA,CACD,IAC4Bg3B,EADtBC,EAAW,IAAI7yB,IAAM8yB,GAAA33B,EAAAA,EAAAA,GACNgC,GAAO,IAA5B,IAAA21B,EAAA13B,MAAAw3B,EAAAE,EAAAz3B,KAAAC,MAA8B,KAAnBu2B,EAAMe,EAAAj4B,MACbk4B,EAAShyB,IAAIgxB,EAAO1d,GAAI0d,EAC5B,CAAC,OAAAn2B,GAAAo3B,EAAAn3B,EAAAD,EAAA,SAAAo3B,EAAAl3B,GAAA,CACD,IAAMm3B,EAAuB,SAACC,GAC1B,IACoCC,EAD9Bj4B,EAAS,GAAGk4B,GAAA/3B,EAAAA,EAAAA,GACO63B,GAAW,IAApC,IAAAE,EAAA93B,MAAA63B,EAAAC,EAAA73B,KAAAC,MAAsC,KAA3B63B,EAAUF,EAAAt4B,MACjB,IAAI63B,EAASY,IAAID,EAAWhf,IAA5B,CAGA,GAAI0e,EAASO,IAAID,EAAWhf,IAAK,CAC7B,IAAM0d,EAASgB,EAAS74B,IAAIm5B,EAAWhf,IACvCgf,EAAW/C,gBAAkByB,EAAOF,mBACpCwB,EAAWxQ,OAASkP,EAAOD,SAC/B,CACA52B,EAAOkB,KAAKi3B,EANZ,CAOJ,CAAC,OAAAz3B,GAAAw3B,EAAAv3B,EAAAD,EAAA,SAAAw3B,EAAAt3B,GAAA,CACD,OAAOZ,CACX,EACMA,EAAS+3B,EAAqB75B,KAAK83B,MAAMrzB,OAAOo1B,EAAqB/C,IAC3Eh1B,EAAOwB,MAAK,SAACC,EAAGC,GACZ,OAAID,EAAE2zB,kBAAoB1zB,EAAE0zB,gBACjB3zB,EAAE4zB,QAAU3zB,EAAE2zB,QAElB5zB,EAAE2zB,gBAAkB1zB,EAAE0zB,eACjC,IACAl3B,KAAK83B,KAAOh2B,EACZ9B,KAAK+3B,sBAAwB,CAjC7B,CAkCJ,GAAC,CAAAl3B,IAAA,uBAAAY,MACD,WACQzB,KAAK43B,gBAAgBuC,cACrBn6B,KAAK43B,gBAAgBkB,OAAO94B,KAEpC,GAAC,CAAAa,IAAA,oBAAAY,MACD,SAAkBw4B,GACd,IAAMzsB,EAAc8pB,EAAY8C,mBAAmBp6B,KAAK83B,KAAMmC,EAAW/C,gBAAiB+C,EAAW9C,SACrGn3B,KAAK83B,KAAKvqB,OAAOC,EAAa,EAAGysB,GACjCj6B,KAAK+3B,qBAAuB3lB,KAAKc,IAAIlT,KAAK+3B,qBAAsBvqB,EAAc,EAClF,GAAC,CAAA3M,IAAA,uBAAAY,MACD,SAAqBwZ,GAEjB,IADA,IAAMvO,EAAM1M,KAAK83B,KACRvzB,EAAI,EAAGC,EAAMkI,EAAI9K,OAAQ2C,EAAIC,EAAKD,IACvC,GAAImI,EAAInI,GAAG0W,KAAOA,EACd,OAAO1W,EAGf,OAAQ,CACZ,GAAC,CAAA1D,IAAA,uBAAAY,MACD,SAAqBwZ,EAAIwd,EAAoBC,GACzC,IAAMvgB,EAAQnY,KAAKm5B,qBAAqBle,GACxC,IAAe,IAAX9C,IAGAnY,KAAK83B,KAAK3f,GAAOsR,SAAWiP,IAC5B14B,KAAK83B,KAAK3f,GAAOsR,OAASiP,EAC1B14B,KAAK+3B,qBAAuB3lB,KAAKc,IAAIlT,KAAK+3B,qBAAsB5f,EAAQ,IAExEnY,KAAK83B,KAAK3f,GAAO+e,kBAAoBuB,GAAoB,CAGzD,IAAMwB,EAAaj6B,KAAK83B,KAAK3f,GAE7BnY,KAAKo5B,kBAAkBjhB,GACvB8hB,EAAW/C,gBAAkBuB,EAE7Bz4B,KAAK+4B,kBAAkBkB,EAC3B,CACJ,GAAC,CAAAp5B,IAAA,oBAAAY,MACD,SAAkB44B,GACdr6B,KAAK83B,KAAKvqB,OAAO8sB,EAAa,GAC9Br6B,KAAK+3B,qBAAuB3lB,KAAKc,IAAIlT,KAAK+3B,qBAAsBsC,EAAc,EAClF,GACA,CAAAx5B,IAAA,iBAAAY,MAMA,SAAemC,EAAgBC,GAC3B7D,KAAKo4B,uBACLx0B,GAAkC,EAClCC,GAA8B,EAC9B7D,KAAKi4B,YAAep0B,EAAeD,EAAiB,EACpD,IAAK,IAAIW,EAAI,EAAGC,EAAMxE,KAAK83B,KAAKl2B,OAAQ2C,EAAIC,EAAKD,IAAK,CAClD,IAAM2yB,EAAkBl3B,KAAK83B,KAAKvzB,GAAG2yB,gBACjCtzB,GAAkBszB,GAAmBA,GAAmBrzB,EAGxD7D,KAAK83B,KAAKvzB,GAAG2yB,gBAAkBtzB,EAAiB,EAE3CszB,EAAkBrzB,IAGvB7D,KAAK83B,KAAKvzB,GAAG2yB,iBAAoBrzB,EAAeD,EAAiB,EAEzE,CACJ,GACA,CAAA/C,IAAA,kBAAAY,MAMA,SAAgBmC,EAAgBC,GAC5B7D,KAAKo4B,uBACLx0B,GAAkC,EAClCC,GAA8B,EAC9B7D,KAAKi4B,YAAep0B,EAAeD,EAAiB,EACpD,IAAK,IAAIW,EAAI,EAAGC,EAAMxE,KAAK83B,KAAKl2B,OAAQ2C,EAAIC,EAAKD,IAAK,CAE9CX,GADoB5D,KAAK83B,KAAKvzB,GAAG2yB,kBAEjCl3B,KAAK83B,KAAKvzB,GAAG2yB,iBAAoBrzB,EAAeD,EAAiB,EAEzE,CACJ,GACA,CAAA/C,IAAA,4BAAAY,MAGA,WAEI,OADAzB,KAAKo4B,uBACoB,IAArBp4B,KAAK83B,KAAKl2B,OACH,EAEJ5B,KAAKs6B,gCAAgCt6B,KAAK83B,KAAKl2B,OAAS,EACnE,GACA,CAAAf,IAAA,kCAAAY,MAOA,SAAgC0W,GAC5BnY,KAAKo4B,uBACLjgB,GAAgB,EAChB,IAAIsH,EAAarN,KAAK8D,IAAI,EAAGlW,KAAK+3B,qBAAuB,GACtC,IAAftY,IACAzf,KAAK83B,KAAK,GAAGT,UAAYr3B,KAAK83B,KAAK,GAAGrO,OACtChK,KAEJ,IAAK,IAAIlb,EAAIkb,EAAYlb,GAAK4T,EAAO5T,IACjCvE,KAAK83B,KAAKvzB,GAAG8yB,UAAYr3B,KAAK83B,KAAKvzB,EAAI,GAAG8yB,UAAYr3B,KAAK83B,KAAKvzB,GAAGklB,OAGvE,OADAzpB,KAAK+3B,qBAAuB3lB,KAAK8D,IAAIlW,KAAK+3B,qBAAsB5f,GACzDnY,KAAK83B,KAAK3f,GAAOkf,SAC5B,GACA,CAAAx2B,IAAA,sBAAAY,MAKA,WAII,OAHAzB,KAAKo4B,uBACep4B,KAAKgxB,YAAchxB,KAAKi4B,WAClBj4B,KAAKu6B,4BACUv6B,KAAKk4B,YAAcl4B,KAAKm4B,cACrE,GACA,CAAAt3B,IAAA,iDAAAY,MAKA,SAA+CJ,GAC3CrB,KAAKo4B,uBACL/2B,GAA0B,EAC1B,IAAMm5B,EAAiCx6B,KAAKy6B,oCAAoCp5B,GAChF,OAAwC,IAApCm5B,EACO,EAEJx6B,KAAKs6B,gCAAgCE,EAChD,GAAC,CAAA35B,IAAA,sCAAAY,MACD,SAAoCJ,GAChCA,GAA0B,EAK1B,IAHA,IAAMqL,EAAM1M,KAAK83B,KACb7lB,EAAM,EACNC,EAAOxF,EAAI9K,OAAS,EACjBqQ,GAAOC,GAAM,CAChB,IAEMC,EAAOF,IAFEC,EAAOD,EAAO,GACF,EAAK,GACA,EAChC,GAAIvF,EAAIyF,GAAK+kB,gBAAkB71B,EAAY,CACvC,GAAI8Q,EAAM,GAAKzF,EAAI9K,QAAU8K,EAAIyF,EAAM,GAAG+kB,iBAAmB71B,EACzD,OAAO8Q,EAGPF,EAAOE,EAAM,EAAK,CAE1B,MAEID,EAAQC,EAAM,EAAK,CAE3B,CACA,OAAQ,CACZ,GAAC,CAAAtR,IAAA,sCAAAY,MACD,SAAoCJ,GAChCA,GAA0B,EAC1B,IACMq5B,EADiC16B,KAAKy6B,oCAAoCp5B,GACR,EACxE,OAAIq5B,EAAiC16B,KAAK83B,KAAKl2B,OACpC84B,GAEH,CACZ,GACA,CAAA75B,IAAA,yCAAAY,MAIA,SAAuCJ,GAGnC,OAFArB,KAAKo4B,uBACL/2B,GAA0B,EACnBrB,KAAK26B,oCAAoCt5B,EACpD,GACA,CAAAR,IAAA,iCAAAY,MAMA,SAA+BJ,GAAsC,IAA1Bu5B,EAAgBlG,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,IAAAA,UAAA,GAWvD,OAVA10B,KAAKo4B,yBACL/2B,GAA0B,GAET,EACSrB,KAAKgxB,aAAe3vB,EAAa,GAGjC,GAEQrB,KAAK66B,+CAA+Cx5B,GAAcu5B,EAAmB,EAAI,IAClE56B,KAAKk4B,WAClE,GACA,CAAAr3B,IAAA,mCAAAY,MAMA,SAAiCJ,GAAsC,IAA1Bu5B,EAAgBlG,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,IAAAA,UAAA,GAKzD,OAJA10B,KAAKo4B,uBACL/2B,GAA0B,EACErB,KAAKgxB,YAAc3vB,EACbrB,KAAK66B,+CAA+Cx5B,GAAcu5B,EAAmB,EAAI,IAClE56B,KAAKk4B,WAClE,GACA,CAAAr3B,IAAA,wBAAAY,MAGA,WAEI,GADAzB,KAAKo4B,wBACmB,IAApBp4B,KAAKg4B,UAAkB,CAEvB,IADA,IAAIZ,EAAW,EACN7yB,EAAI,EAAGC,EAAMxE,KAAK83B,KAAKl2B,OAAQ2C,EAAIC,EAAKD,IAC7C6yB,EAAWhlB,KAAK8D,IAAIkhB,EAAUp3B,KAAK83B,KAAKvzB,GAAG6yB,UAE/Cp3B,KAAKg4B,UAAYZ,CACrB,CACA,OAAOp3B,KAAKg4B,SAChB,GACA,CAAAn3B,IAAA,eAAAY,MAGA,SAAaq5B,GAGT,OAFA96B,KAAKo4B,uBAEE0C,EADa96B,KAAK+6B,qBAE7B,GAAC,CAAAl6B,IAAA,iBAAAY,MACD,SAAeq5B,GACX,OAAyB,IAArB96B,KAAKk4B,cAGTl4B,KAAKo4B,uBACG0C,EAAiB96B,KAAKk4B,YAClC,GAAC,CAAAr3B,IAAA,oBAAAY,MACD,SAAkBq5B,GACd,OAA4B,IAAxB96B,KAAKm4B,iBAGTn4B,KAAKo4B,uBAEG0C,GADY96B,KAAK+6B,sBACe/6B,KAAKm4B,eACjD,GACA,CAAAt3B,IAAA,uCAAAY,MAQA,SAAqCq5B,GAGjC,GAFA96B,KAAKo4B,wBACL0C,GAAkC,GACb,EACjB,OAAO,EAMX,IAJA,IAAME,EAA+B,EAAlBh7B,KAAKi4B,WAClBtG,EAAa3xB,KAAKgxB,YACpBiK,EAAgB,EAChBC,EAAgBF,EACbC,EAAgBC,GAAe,CAClC,IAAMC,GAAkBF,EAAgBC,GAAiB,EAAK,EACxDE,EAAmF,EAArDp7B,KAAKq7B,+BAA+BF,GACxE,GAAIL,GAAkBM,EAA8BzJ,EAEhDsJ,EAAgBE,EAAgB,MAE/B,IAAIL,GAAkBM,EAEvB,OAAOD,EAIPD,EAAgBC,CACpB,CACJ,CACA,OAAIF,EAAgBD,EACTA,EAEJC,CACX,GACA,CAAAp6B,IAAA,uBAAAY,MAOA,SAAqB65B,EAAiBC,GAClCv7B,KAAKo4B,uBACLkD,GAAoC,EACpCC,GAAoC,EACpC,IASIC,EACAC,EAVE9J,EAAa3xB,KAAKgxB,YAGlB/tB,EAA+E,EAA7DjD,KAAK07B,qCAAqCJ,GAC5DK,EAAuF,EAAvD37B,KAAKq7B,+BAA+Bp4B,GACtEG,EAAkC,EAAlBpD,KAAKi4B,WAErB2D,EAAiF,EAA/D57B,KAAK67B,uCAAuC54B,GAC5D64B,EAA+C,EAA7B97B,KAAK+7B,uBAGJ,IAArBH,GACAA,EAAkBE,EAClBL,EAAmCr4B,EAAgB,EACnDo4B,EAA0B,IAG1BC,EAAgG,EAA7Dz7B,KAAKg8B,qCAAqCJ,GAC7EJ,EAA8E,EAApDx7B,KAAKi8B,4BAA4BL,IAE/D,IAAIM,EAAwBP,EACxBQ,EAA4BD,EAE1BE,EAAY,IACdrT,EAAkB,EAClB4S,GAAiCS,IAEjCrT,EAAkB3W,KAAKC,MAAMspB,EAAgCS,GAAaA,EAE1ED,GADApT,EAAkB3W,KAAKC,MAAM0W,EAAkB4I,GAAcA,GAOjE,IAJA,IAAM0K,EAAe,GACfC,EAAiBhB,GAAmBC,EAAkBD,GAAmB,EAC3EiB,GAAsB,EAEjBl7B,EAAa4B,EAAiB5B,GAAc+B,EAAe/B,IAAc,CAC9E,IAA4B,IAAxBk7B,EAA2B,EACJL,GAEAI,GAAkBA,EADfJ,EAAwBvK,GAD3BuK,EAE0EI,KAC7FC,EAAqBl7B,EAE7B,CAMA,IAJA66B,GAAyBvK,EACzB0K,EAAah7B,EAAa4B,GAAmBk5B,EAE7CA,GAA6BxK,EACtB8J,IAAqCp6B,GAExC86B,GAA6BX,EAE7BU,GAAyBV,IACzBI,GACuBE,EACnBL,EAAmCr4B,EAAgB,GAGnDq4B,EAAgG,EAA7Dz7B,KAAKg8B,qCAAqCJ,GAC7EJ,EAA8E,EAApDx7B,KAAKi8B,4BAA4BL,IAGnE,GAAIM,GAAyBX,EAAiB,CAE1Cn4B,EAAgB/B,EAChB,KACJ,CACJ,EAC4B,IAAxBk7B,IACAA,EAAqBn5B,GAEzB,IAAMo5B,EAAmF,EAArDx8B,KAAKq7B,+BAA+Bj4B,GACpEq5B,EAAmCx5B,EACnCy5B,EAAiCt5B,EAWrC,OAVIq5B,EAAmCC,GAC/Bf,EAAgCL,GAChCmB,IAGJA,EAAmCC,GAC/BF,EAA8B7K,EAAa4J,GAC3CmB,IAGD,CACH3T,gBAAiBA,EACjB9lB,gBAAiBA,EACjBG,cAAeA,EACf0lB,uBAAwBuT,EACxBE,mBAAoBA,EACpBE,iCAAkCA,EAClCC,+BAAgCA,EAExC,GAAC,CAAA77B,IAAA,sCAAAY,MACD,SAAoCm6B,GAChC57B,KAAKo4B,uBACLwD,GAAoC,EACpC,IAAM1E,EAAkBl3B,KAAKg8B,qCAAqCJ,GAelE,OAbI1E,GAAmB,EACGl3B,KAAKgxB,YAAckG,EAGnB,IAGtB0E,EAAkB,EACU57B,KAAKs6B,gCAAgCsB,EAAkB,GAGvD,GAEyB57B,KAAKk4B,WAClE,GAAC,CAAAr3B,IAAA,6CAAAY,MACD,SAA2Cq5B,GACvC96B,KAAKo4B,uBACL0C,GAAkC,EAClC,IAAI6B,EAAqB,EACrBC,EAAqB58B,KAAK+7B,sBAAwB,EACtD,GAAIa,EAAqB,EACrB,OAAQ,EAKZ,GAAI9B,GAFgC96B,KAAK68B,oCAAoCD,GACjD58B,KAAKi8B,4BAA4BW,GAEzD,OAAQ,EAEZ,KAAOD,EAAqBC,GAAoB,CAC5C,IAAME,EAAqB1qB,KAAKC,OAAOsqB,EAAqBC,GAAsB,GAC5EG,EAA8B/8B,KAAK68B,oCAAoCC,GAE7E,GAAIhC,GAAkBiC,EADM/8B,KAAKi8B,4BAA4Ba,GAGzDH,EAAqBG,EAAqB,MAEzC,IAAIhC,GAAkBiC,EAEvB,OAAOD,EAIPF,EAAqBE,CACzB,CACJ,CACA,OAAOH,CACX,GACA,CAAA97B,IAAA,gCAAAY,MAMA,SAA8Bq5B,GAC1B96B,KAAKo4B,uBACL0C,GAAkC,EAClC,IAAMkC,EAAiBh9B,KAAKi9B,2CAA2CnC,GACvE,GAAIkC,EAAiB,EACjB,OAAO,KAEX,GAAIA,GAAkBh9B,KAAK+7B,sBACvB,OAAO,KAEX,IAAMmB,EAAel9B,KAAK68B,oCAAoCG,GAC9D,GAAIE,EAAepC,EACf,OAAO,KAEX,IAAMqC,EAAkBn9B,KAAKi8B,4BAA4Be,GAGzD,MAAO,CACH/hB,GAHgBjb,KAAKo9B,wBAAwBJ,GAI7C9F,gBAH6Bl3B,KAAKg8B,qCAAqCgB,GAIvElC,eAAgBoC,EAChBzT,OAAQ0T,EAEhB,GACA,CAAAt8B,IAAA,4BAAAY,MAOA,SAA0B65B,EAAiBC,GACvCv7B,KAAKo4B,uBACLkD,GAAoC,EACpCC,GAAoC,EACpC,IAAM9b,EAAazf,KAAKi9B,2CAA2C3B,GAC7Djc,EAAWrf,KAAK+7B,sBAAwB,EAC9C,GAAItc,EAAa,EACb,MAAO,GAGX,IADA,IAAM3d,EAAS,GACNyC,EAAIkb,EAAYlb,GAAK8a,EAAU9a,IAAK,CACzC,IAAMsB,EAAM7F,KAAK68B,oCAAoCt4B,GAC/CklB,EAASzpB,KAAKi8B,4BAA4B13B,GAChD,GAAIsB,GAAO01B,EACP,MAEJz5B,EAAOkB,KAAK,CACRiY,GAAIjb,KAAKo9B,wBAAwB74B,GACjC2yB,gBAAiBl3B,KAAKg8B,qCAAqCz3B,GAC3Du2B,eAAgBj1B,EAChB4jB,OAAQA,GAEhB,CACA,OAAO3nB,CACX,GACA,CAAAjB,IAAA,iBAAAY,MAGA,WAEI,OADAzB,KAAKo4B,uBACEp4B,KAAK83B,KAAKuF,MAAM,EAC3B,GACA,CAAAx8B,IAAA,sBAAAY,MAGA,WAEI,OADAzB,KAAKo4B,uBACEp4B,KAAK83B,KAAKl2B,MACrB,GACA,CAAAf,IAAA,0BAAAY,MAMA,SAAwB0W,GAGpB,OAFAnY,KAAKo4B,uBACLjgB,GAAgB,EACTnY,KAAK83B,KAAK3f,GAAO8C,EAC5B,GACA,CAAApa,IAAA,uCAAAY,MAMA,SAAqC0W,GAGjC,OAFAnY,KAAKo4B,uBACLjgB,GAAgB,EACTnY,KAAK83B,KAAK3f,GAAO+e,eAC5B,GACA,CAAAr2B,IAAA,8BAAAY,MAMA,SAA4B0W,GAGxB,OAFAnY,KAAKo4B,uBACLjgB,GAAgB,EACTnY,KAAK83B,KAAK3f,GAAOsR,MAC5B,IAAC,EAAA5oB,IAAA,qBAAAY,MAlrBD,SAA0BiL,EAAKwqB,EAAiBC,GAG5C,IAFA,IAAIllB,EAAM,EACNC,EAAOxF,EAAI9K,OACRqQ,EAAMC,GAAM,CACf,IAAMC,EAAQF,EAAMC,IAAU,EAC1BglB,IAAoBxqB,EAAIyF,GAAK+kB,gBACzBC,EAAUzqB,EAAIyF,GAAKglB,QACnBjlB,EAAOC,EAGPF,EAAME,EAAM,EAGX+kB,EAAkBxqB,EAAIyF,GAAK+kB,gBAChChlB,EAAOC,EAGPF,EAAME,EAAM,CAEpB,CACA,OAAOF,CACX,KAACqlB,CAAA,CAtCmB,GAqsBxBA,EAAYK,eAAiB,E,0BCnvBvB2F,EAAsB,WACxB,SAAAA,EAAY9T,EAAO+T,EAAc9T,EAAQ+T,IAAez9B,EAAAA,EAAAA,GAAA,KAAAu9B,IACpD9T,GAAgB,GAIJ,IACRA,EAAQ,IAJZ+T,GAA8B,GAMX,IACfA,EAAe,IANnB9T,GAAkB,GAQL,IACTA,EAAS,IARb+T,GAAgC,GAUZ,IAChBA,EAAgB,GAEpBx9B,KAAKwpB,MAAQA,EACbxpB,KAAKu9B,aAAeA,EACpBv9B,KAAK0c,YAActK,KAAK8D,IAAIsT,EAAO+T,GACnCv9B,KAAKypB,OAASA,EACdzpB,KAAKw9B,cAAgBA,EACrBx9B,KAAK4c,aAAexK,KAAK8D,IAAIuT,EAAQ+T,EACzC,CAMC,OANA99B,EAAAA,EAAAA,GAAA49B,EAAA,EAAAz8B,IAAA,SAAAY,MACD,SAAOqD,GACH,OAAQ9E,KAAKwpB,QAAU1kB,EAAM0kB,OACtBxpB,KAAKu9B,eAAiBz4B,EAAMy4B,cAC5Bv9B,KAAKypB,SAAW3kB,EAAM2kB,QACtBzpB,KAAKw9B,gBAAkB14B,EAAM04B,aACxC,KAACF,CAAA,CA9BuB,GAgCtBG,EAAgB,SAAAr0B,IAAAjJ,EAAAA,EAAAA,GAAAs9B,EAAAr0B,GAAA,IAAAhJ,GAAAC,EAAAA,EAAAA,GAAAo9B,GAClB,SAAAA,EAAYC,EAAsBC,GAA8B,IAAAj9B,EAUf,OAVeX,EAAAA,EAAAA,GAAA,KAAA09B,IAC5D/8B,EAAAN,EAAAO,KAAA,OACKi9B,wBAA0Bl9B,EAAK2J,UAAU,IAAIpD,EAAAA,IAClDvG,EAAKm9B,uBAAyBn9B,EAAKk9B,wBAAwBz2B,MAC3DzG,EAAKo9B,YAAc,IAAIR,EAAuB,EAAG,EAAG,EAAG,GACvD58B,EAAKq9B,YAAcr9B,EAAK2J,UAAU,IAAI2zB,EAAAA,GAAW,CAC7CC,oBAAoB,EACpBP,qBAAAA,EACAC,6BAAAA,KAEJj9B,EAAKw9B,YAAcx9B,EAAKq9B,YAAYI,SAASz9B,CACjD,CA6CC,OA7CAhB,EAAAA,EAAAA,GAAA+9B,EAAA,EAAA58B,IAAA,gBAAAY,MACD,WACI,OAAOzB,KAAK+9B,WAChB,GAAC,CAAAl9B,IAAA,0BAAAY,MACD,SAAwBi8B,GACpB19B,KAAK+9B,YAAYK,wBAAwBV,EAC7C,GAAC,CAAA78B,IAAA,yBAAAY,MACD,SAAuB48B,GACnB,OAAOr+B,KAAK+9B,YAAYO,uBAAuBD,EACnD,GAAC,CAAAx9B,IAAA,sBAAAY,MACD,WACI,OAAOzB,KAAK89B,WAChB,GAAC,CAAAj9B,IAAA,sBAAAY,MACD,SAAoB88B,GAChB,IAAIv+B,KAAK89B,YAAY9c,OAAOud,GAA5B,CAGA,IAAMC,EAAgBx+B,KAAK89B,YAC3B99B,KAAK89B,YAAcS,EACnBv+B,KAAK+9B,YAAYU,oBAAoB,CACjCjV,MAAO+U,EAAW/U,MAClB9M,YAAa6hB,EAAW7hB,YACxB+M,OAAQ8U,EAAW9U,OACnB7M,aAAc2hB,EAAW3hB,eAC1B,GACH,IAAM8hB,EAAuBF,EAAcjB,eAAiBgB,EAAWhB,aACjEoB,EAAwBH,EAAchB,gBAAkBe,EAAWf,eACrEkB,GAAuBC,IACvB3+B,KAAK49B,wBAAwBt2B,KAAK,IAAIs3B,EAAAA,GAAwBJ,EAAcjB,aAAciB,EAAchB,cAAee,EAAWhB,aAAcgB,EAAWf,eAZ/J,CAcJ,GAAC,CAAA38B,IAAA,0BAAAY,MACD,WACI,OAAOzB,KAAK+9B,YAAYc,yBAC5B,GAAC,CAAAh+B,IAAA,2BAAAY,MACD,WACI,OAAOzB,KAAK+9B,YAAYe,0BAC5B,GAAC,CAAAj+B,IAAA,uBAAAY,MACD,SAAqBs9B,GACjB/+B,KAAK+9B,YAAYiB,qBAAqBD,EAC1C,GAAC,CAAAl+B,IAAA,0BAAAY,MACD,SAAwBs9B,GACpB/+B,KAAK+9B,YAAYkB,wBAAwBF,EAC7C,GAAC,CAAAl+B,IAAA,4BAAAY,MACD,WACI,OAAOzB,KAAK+9B,YAAYmB,2BAC5B,KAACzB,CAAA,CAzDiB,CAASlzB,EAAAA,IA2DlB40B,EAAU,SAAAC,IAAAj/B,EAAAA,EAAAA,GAAAg/B,EAAAC,GAAA,IAAAC,GAAAh/B,EAAAA,EAAAA,GAAA8+B,GACnB,SAAAA,EAAYrM,EAAeyE,EAAWoG,GAA8B,IAAA11B,GAAAlI,EAAAA,EAAAA,GAAA,KAAAo/B,IAChEl3B,EAAAo3B,EAAA1+B,KAAA,OACK2+B,eAAiBxM,EACtB,IAAMvxB,EAAU0G,EAAKq3B,eAAe/9B,QAC9Bg+B,EAAah+B,EAAQT,IAAI,KACzB0+B,EAAUj+B,EAAQT,IAAI,IASP,OARrBmH,EAAKw3B,aAAe,IAAInI,EAAYC,EAAWh2B,EAAQT,IAAI,IAAmC0+B,EAAQ35B,IAAK25B,EAAQE,QACnHz3B,EAAK03B,cAAgB,EACrB13B,EAAK23B,wBAA0B,EAC/B33B,EAAK81B,YAAc91B,EAAKoC,UAAU,IAAIozB,EAAiB,EAAGE,IAC1D11B,EAAK43B,iCACL53B,EAAK81B,YAAYU,oBAAoB,IAAInB,EAAuBiC,EAAWhC,aAAc,EAAGgC,EAAW9V,OAAQ,IAC/GxhB,EAAKi2B,YAAcj2B,EAAK81B,YAAYG,YACpCj2B,EAAK41B,uBAAyB51B,EAAK81B,YAAYF,uBAC/C51B,EAAK63B,gBAAgB73B,CACzB,CA2OC,OA3OAvI,EAAAA,EAAAA,GAAAy/B,EAAA,EAAAt+B,IAAA,UAAAY,MACD,YACImI,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,GAAAs1B,EAAAr1B,WAAA,gBAAAnJ,KAAA,KACJ,GAAC,CAAAE,IAAA,gBAAAY,MACD,WACI,OAAOzB,KAAK+9B,YAAYgC,eAC5B,GAAC,CAAAl/B,IAAA,uBAAAY,MACD,WACIzB,KAAK8/B,eACT,GAAC,CAAAj/B,IAAA,iCAAAY,MACD,WACIzB,KAAK+9B,YAAYK,wBAAwBp+B,KAAKs/B,eAAe/9B,QAAQT,IAAI,KAvHnD,IAuHqH,EAC/I,GACA,CAAAD,IAAA,yBAAAY,MACA,SAAuBgB,GACnB,IAAMlB,EAAUvB,KAAKs/B,eAAe/9B,QAIpC,GAHIkB,EAAEyY,WAAW,KACblb,KAAKy/B,aAAaO,cAAcz+B,EAAQT,IAAI,KAE5C2B,EAAEyY,WAAW,IAAgC,CAC7C,IAAMskB,EAAUj+B,EAAQT,IAAI,IAC5Bd,KAAKy/B,aAAaQ,WAAWT,EAAQ35B,IAAK25B,EAAQE,OACtD,CACA,GAAIj9B,EAAEyY,WAAW,KAAoC,CACjD,IAAMqkB,EAAah+B,EAAQT,IAAI,KACzB0oB,EAAQ+V,EAAWhC,aACnB9T,EAAS8V,EAAW9V,OACpByW,EAAmBlgC,KAAK+9B,YAAYoC,sBACpC5C,EAAe2C,EAAiB3C,aACtCv9B,KAAK+9B,YAAYU,oBAAoB,IAAInB,EAAuB9T,EAAO0W,EAAiB3C,aAAc9T,EAAQzpB,KAAKogC,kBAAkB5W,EAAOC,EAAQ8T,IACxJ,MAEIv9B,KAAK8/B,gBAELr9B,EAAEyY,WAAW,MACblb,KAAK6/B,gCAEb,GAAC,CAAAh/B,IAAA,YAAAY,MACD,SAAU81B,GACNv3B,KAAKy/B,aAAa1lB,UAAUwd,EAChC,GAAC,CAAA12B,IAAA,iBAAAY,MACD,SAAemC,EAAgBC,GAC3B7D,KAAKy/B,aAAarlB,eAAexW,EAAgBC,EACrD,GAAC,CAAAhD,IAAA,kBAAAY,MACD,SAAgBmC,EAAgBC,GAC5B7D,KAAKy/B,aAAaplB,gBAAgBzW,EAAgBC,EACtD,GACA,CAAAhD,IAAA,gCAAAY,MACA,SAA8B+nB,EAAO9M,GACjC,IACM2jB,EADUrgC,KAAKs/B,eAAe/9B,QACVT,IAAI,KAC9B,OAA6B,IAAzBu/B,EAAUC,YAIV9W,GAAS9M,EAFF,EAMJ2jB,EAAUE,uBACrB,GAAC,CAAA1/B,IAAA,oBAAAY,MACD,SAAkB+nB,EAAOC,EAAQ8T,GAC7B,IAAMh8B,EAAUvB,KAAKs/B,eAAe/9B,QAChCO,EAAS9B,KAAKy/B,aAAa1E,sBAO/B,OANIx5B,EAAQT,IAAI,KACZgB,GAAUsQ,KAAK8D,IAAI,EAAGuT,EAASloB,EAAQT,IAAI,IAAoCS,EAAQT,IAAI,IAA+B4+B,QAG1H59B,GAAU9B,KAAKwgC,8BAA8BhX,EAAO+T,GAEjDz7B,CACX,GAAC,CAAAjB,IAAA,gBAAAY,MACD,WACI,IAAMy+B,EAAmBlgC,KAAK+9B,YAAYoC,sBACpC3W,EAAQ0W,EAAiB1W,MACzBC,EAASyW,EAAiBzW,OAC1B8T,EAAe2C,EAAiB3C,aACtCv9B,KAAK+9B,YAAYU,oBAAoB,IAAInB,EAAuB9T,EAAO0W,EAAiB3C,aAAc9T,EAAQzpB,KAAKogC,kBAAkB5W,EAAOC,EAAQ8T,IACxJ,GACA,CAAA18B,IAAA,qBAAAY,MACA,WACI,IAAMy+B,EAAmBlgC,KAAK+9B,YAAYoC,sBACpCM,EAAwBzgC,KAAK+9B,YAAYe,2BAC/C,OAAO,IAAIxV,EAAAA,GAASmX,EAAsB5jB,UAAW4jB,EAAsB9jB,WAAYujB,EAAiB1W,MAAO0W,EAAiBzW,OACpI,GAAC,CAAA5oB,IAAA,oBAAAY,MACD,WACI,IAAMy+B,EAAmBlgC,KAAK+9B,YAAYoC,sBACpCM,EAAwBzgC,KAAK+9B,YAAYc,0BAC/C,OAAO,IAAIvV,EAAAA,GAASmX,EAAsB5jB,UAAW4jB,EAAsB9jB,WAAYujB,EAAiB1W,MAAO0W,EAAiBzW,OACpI,GAAC,CAAA5oB,IAAA,uBAAAY,MACD,WACI,IAAMF,EAAUvB,KAAKs/B,eAAe/9B,QAC9Bm/B,EAAe1gC,KAAK2/B,cACpBgB,EAAep/B,EAAQT,IAAI,KAC3BmrB,EAAW1qB,EAAQT,IAAI,IACvBy+B,EAAah+B,EAAQT,IAAI,KAC/B,GAAI6/B,EAAaC,mBAAoB,CACjC,IAAMC,EAAUt/B,EAAQT,IAAI,IAC5B,OAAI4/B,EAAenB,EAAWhC,aAAetR,EAASW,gCAE9CiU,EAAQC,SAA4B,UAAjBD,EAAQE,KAEpBL,EAAenB,EAAWyB,uBAGlCN,CACX,CAEI,IAAMO,EAAuB1/B,EAAQT,IAAI,KAAiDmrB,EAASW,+BAC7FsU,EAAqBlhC,KAAKy/B,aAAa0B,wBAC7C,OAAO/uB,KAAK8D,IAAIwqB,EAAeO,EAAuB1B,EAAWyB,uBAAwBE,EAAoBlhC,KAAK4/B,wBAE1H,GAAC,CAAA/+B,IAAA,kBAAAY,MACD,SAAgBi/B,GACZ1gC,KAAK2/B,cAAgBe,EACrB1gC,KAAKohC,qBACT,GAAC,CAAAvgC,IAAA,4BAAAY,MACD,SAA0B4/B,GACtBrhC,KAAK4/B,wBAA0ByB,EAC/BrhC,KAAKohC,qBACT,GAAC,CAAAvgC,IAAA,sBAAAY,MACD,WACI,IAAMy+B,EAAmBlgC,KAAK+9B,YAAYoC,sBAC1CngC,KAAK+9B,YAAYU,oBAAoB,IAAInB,EAAuB4C,EAAiB1W,MAAOxpB,KAAKshC,uBAAwBpB,EAAiBzW,OAAQyW,EAAiB1C,gBAE/Jx9B,KAAK8/B,eACT,GACA,CAAAj/B,IAAA,YAAAY,MACA,WACI,IAAMg/B,EAAwBzgC,KAAK+9B,YAAYc,0BACzChiB,EAAY4jB,EAAsB5jB,UAClC0kB,EAA4BvhC,KAAKy/B,aAAa/D,qCAAqC7e,GAEzF,MAAO,CACHA,UAAWA,EACX2kB,0BAA2B3kB,EAHE7c,KAAKy/B,aAAa5E,+CAA+C0G,GAI9F5kB,WAAY8jB,EAAsB9jB,WAE1C,GACA,CAAA9b,IAAA,mBAAAY,MACA,SAAiBw0B,GACb,IAAMoC,EAAar4B,KAAKy/B,aAAagC,iBAAiBxL,GAItD,OAHIoC,GACAr4B,KAAK0hC,uBAEFrJ,CACX,GAAC,CAAAx3B,IAAA,iCAAAY,MACD,SAA+BJ,GAAsC,IAA1Bu5B,EAAgBlG,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,IAAAA,UAAA,GACvD,OAAO10B,KAAKy/B,aAAapE,+BAA+Bh6B,EAAYu5B,EACxE,GAAC,CAAA/5B,IAAA,mCAAAY,MACD,SAAiCJ,GAAsC,IAA1Bu5B,EAAgBlG,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,IAAAA,UAAA,GACzD,OAAO10B,KAAKy/B,aAAakC,iCAAiCtgC,EAAYu5B,EAC1E,GAAC,CAAA/5B,IAAA,eAAAY,MACD,SAAaq5B,GACT,OAAO96B,KAAKy/B,aAAamC,aAAa9G,EAC1C,GAAC,CAAAj6B,IAAA,iBAAAY,MACD,SAAeq5B,GACX,OAAO96B,KAAKy/B,aAAaoC,eAAe/G,EAC5C,GAAC,CAAAj6B,IAAA,oBAAAY,MACD,SAAkBq5B,GACd,OAAO96B,KAAKy/B,aAAaqC,kBAAkBhH,EAC/C,GAAC,CAAAj6B,IAAA,gCAAAY,MACD,SAA8Bq5B,GAC1B,OAAO96B,KAAKy/B,aAAa/D,qCAAqCZ,EAClE,GAAC,CAAAj6B,IAAA,gCAAAY,MACD,SAA8Bq5B,GAC1B,OAAO96B,KAAKy/B,aAAasC,8BAA8BjH,EAC3D,GAAC,CAAAj6B,IAAA,uBAAAY,MACD,WACI,IAAMugC,EAAahiC,KAAKiiC,qBACxB,OAAOjiC,KAAKy/B,aAAayC,qBAAqBF,EAAWn8B,IAAKm8B,EAAWn8B,IAAMm8B,EAAWvY,OAC9F,GAAC,CAAA5oB,IAAA,kCAAAY,MACD,SAAgCob,GAE5B,IAAMqjB,EAAmBlgC,KAAK+9B,YAAYoC,sBAO1C,OANItjB,EAAYqjB,EAAiBzW,OAASyW,EAAiBtjB,eACvDC,EAAYqjB,EAAiBtjB,aAAesjB,EAAiBzW,QAE7D5M,EAAY,IACZA,EAAY,GAET7c,KAAKy/B,aAAayC,qBAAqBrlB,EAAWA,EAAYqjB,EAAiBzW,OAC1F,GAAC,CAAA5oB,IAAA,4BAAAY,MACD,WACI,IAAMugC,EAAahiC,KAAKiiC,qBACxB,OAAOjiC,KAAKy/B,aAAa0C,0BAA0BH,EAAWn8B,IAAKm8B,EAAWn8B,IAAMm8B,EAAWvY,OACnG,GAAC,CAAA5oB,IAAA,iBAAAY,MACD,WACI,OAAOzB,KAAKy/B,aAAa2C,gBAC7B,GACA,CAAAvhC,IAAA,kBAAAY,MACA,WAEI,OADyBzB,KAAK+9B,YAAYoC,sBAClB5C,YAC5B,GAAC,CAAA18B,IAAA,iBAAAY,MACD,WAEI,OADyBzB,KAAK+9B,YAAYoC,sBAClBzjB,WAC5B,GAAC,CAAA7b,IAAA,mBAAAY,MACD,WAEI,OADyBzB,KAAK+9B,YAAYoC,sBAClB3C,aAC5B,GAAC,CAAA38B,IAAA,kBAAAY,MACD,WAEI,OADyBzB,KAAK+9B,YAAYoC,sBAClBvjB,YAC5B,GAAC,CAAA/b,IAAA,uBAAAY,MACD,WAEI,OAD8BzB,KAAK+9B,YAAYe,2BAClBniB,UACjC,GAAC,CAAA9b,IAAA,sBAAAY,MACD,WAEI,OAD8BzB,KAAK+9B,YAAYe,2BAClBjiB,SACjC,GAAC,CAAAhc,IAAA,yBAAAY,MACD,SAAuB48B,GACnB,OAAOr+B,KAAK+9B,YAAYO,uBAAuBD,EACnD,GAAC,CAAAx9B,IAAA,oBAAAY,MACD,SAAkBmN,EAAUtK,GACX,IAATA,EACAtE,KAAK+9B,YAAYiB,qBAAqBpwB,GAGtC5O,KAAK+9B,YAAYkB,wBAAwBrwB,EAEjD,GAAC,CAAA/N,IAAA,4BAAAY,MACD,WACI,OAAOzB,KAAK+9B,YAAYmB,2BAC5B,GAAC,CAAAr+B,IAAA,iBAAAY,MACD,SAAe4gC,EAAiBC,GAC5B,IAAM7B,EAAwBzgC,KAAK+9B,YAAYe,2BAC/C9+B,KAAK+9B,YAAYiB,qBAAqB,CAClCriB,WAAY8jB,EAAsB9jB,WAAa0lB,EAC/CxlB,UAAW4jB,EAAsB5jB,UAAYylB,GAErD,KAACnD,CAAA,CA3PkB,CAAS50B,EAAAA,I,uDC9FzB,SAASg4B,EAA0BC,EAAeC,GACrD,OAAsB,OAAlBD,EAEIC,EACOC,EAA4BC,SAEhCC,EAA0BD,SAG1B,IAAIE,EAAoBL,EAAeC,EAEtD,CACA,IAKMI,EAAmB,WACrB,SAAAA,EAAYL,EAAeC,IAAW1iC,EAAAA,EAAAA,GAAA,KAAA8iC,GAClC7iC,KAAK8iC,gBAAkBN,EACvBxiC,KAAK+iC,WAAaN,CACtB,CA0KC,OA1KA/iC,EAAAA,EAAAA,GAAAmjC,EAAA,EAAAhiC,IAAA,YAAAY,MACD,WACI,OAAOzB,KAAK+iC,UAChB,GAAC,CAAAliC,IAAA,aAAAY,MACD,SAAWghC,GAEP,OADAziC,KAAK+iC,WAAaN,EACXziC,IACX,GAAC,CAAAa,IAAA,oBAAAY,MACD,WACI,OAAOzB,KAAK8iC,eAChB,GAAC,CAAAjiC,IAAA,mBAAAY,MACD,WACI,OAAKzB,KAAK+iC,WAGH/iC,KAAK8iC,gBAAgBE,qBAFjB,CAGf,GAAC,CAAAniC,IAAA,qBAAAY,MACD,SAAmBonB,EAAOoa,EAAiBC,GAAiB,IAAAxiC,EAAA,KACxDV,KAAKmjC,iBACL,IAEIzlB,EAFE0lB,EAAmCF,EAAkB,EAAIljC,KAAK8iC,gBAAgBlV,aAAasV,EAAkB,GAAK,EAClHG,EAAiCrjC,KAAK8iC,gBAAgBlV,aAAasV,GAEzE,GAA8C,OAA1CljC,KAAK8iC,gBAAgBjT,iBAA2B,CAChD,IAAMluB,EAAgB3B,KAAK8iC,gBAAgBjT,iBAAiBE,KAAI,SAAChf,EAAQuyB,GAAG,OAAK,IAAIniC,EAAAA,GAAiB,EAAG,EAAG4P,EAAS,EAAGrQ,EAAKoiC,gBAAgBjW,iBAAiByW,GAAM,EAAE,IAEtK5lB,EAD2Bvc,EAAAA,GAAiB2uB,kBAAkBjH,EAAM7V,eAAeiwB,GAAkBthC,GAC9EW,UAAU8gC,EAAkCC,EACvE,MAEI3lB,EAAImL,EAAM0a,gBAAgB,CACtBtgC,gBAAiBggC,EACjB//B,YAAakgC,EAAmC,EAChDhgC,cAAe6/B,EACf5/B,UAAWggC,EAAiC,IAMpD,OAHIH,EAAkB,IAClBxlB,EAAI8lB,EAAOxjC,KAAK8iC,gBAAgB/U,yBAA2BrQ,GAExDA,CACX,GAAC,CAAA7c,IAAA,oBAAAY,MACD,SAAkBonB,EAAOoa,EAAiBC,GAEtC,OADAljC,KAAKmjC,iBACEnjC,KAAK8iC,gBAAgBvzB,cAAc2zB,EAC9C,GAAC,CAAAriC,IAAA,uBAAAY,MACD,SAAqBunB,EAAQya,EAAkBP,GAE3C,OADAljC,KAAKmjC,iBACEnjC,KAAK8iC,gBAAgBY,mBAAmBR,GAAmB,CACtE,GAAC,CAAAriC,IAAA,uBAAAY,MACD,SAAqBonB,EAAOoa,EAAiBC,GAEzC,OADAljC,KAAKmjC,iBACEnjC,KAAK8iC,gBAAgBa,mBAAmBT,GAAmB,CACtE,GACA,CAAAriC,IAAA,kBAAAY,MAGA,SAAgBonB,EAAOoa,EAAiBC,GACpC,IAAMx2B,EAAM,IAAIzD,MAEhB,OADAjJ,KAAK4jC,iBAAiB/a,EAAOoa,EAAiBC,EAAiB,EAAG,EAAG,EAAC,GAAOx2B,GACtEA,EAAI,EACf,GAAC,CAAA7L,IAAA,mBAAAY,MACD,SAAiBonB,EAAOoa,EAAiBY,EAAetM,EAAWuM,EAAkBC,EAAQjiC,GACzF9B,KAAKmjC,iBACL,IA4CIa,EA5CExB,EAAgBxiC,KAAK8iC,gBACrBjT,EAAmB2S,EAAc3S,iBACjChD,EAAmB2V,EAAc3V,iBACnCoX,EAAiC,KACrC,GAAIpU,EAAkB,CAClBoU,EAAiC,GAGjC,IAFA,IAAIC,EAAgC,EAChCC,EAAwB,EACnBjB,EAAkB,EAAGA,EAAkBV,EAAcQ,qBAAsBE,IAAmB,CACnG,IAAMlZ,EAAoB,IAAI/gB,MAC9Bg7B,EAA+Bf,GAAmBlZ,EAGlD,IAFA,IAAMoa,EAAuClB,EAAkB,EAAIV,EAAc5U,aAAasV,EAAkB,GAAK,EAC/GmB,EAAqC7B,EAAc5U,aAAasV,GAC/DiB,EAAwBtU,EAAiBjuB,QAAQ,CACpD,IAAMA,EAASirB,EAAiBsX,GAAuB5hC,QAAQX,OACzD0iC,EAA+CzU,EAAiBsU,GAAyBD,EACzFK,EAA6CD,EAA+C1iC,EAClG,GAAI0iC,EAA+CD,EAE/C,MAEJ,GAAID,EAAuCG,EAA4C,CAEnF,IAAMhjC,EAAUsrB,EAAiBsX,GACjC,GAAI5iC,EAAQ0c,gBAAiB,CACzB,IAAMlN,EAAUmyB,EAAkB,EAAIV,EAAczU,wBAA0B,EACxE1gB,EAAQ0D,EAASqB,KAAK8D,IAAIouB,EAA+CF,EAAsC,GAC/GhQ,EAAMrjB,EAASqB,KAAKc,IAAIqxB,EAA6CH,EAAsCC,EAAqCD,GAClJ/2B,IAAU+mB,GACVpK,EAAkBhnB,KAAK,IAAIsnB,EAAAA,GAA2Bjd,EAAO+mB,EAAK7yB,EAAQ0c,gBAAiB1c,EAAQgpB,qCAE3G,CACJ,CACA,KAAIga,GAA8CF,GAM9C,MALAH,GAAiCtiC,EACjCuiC,GAMR,CACJ,CACJ,CAGIH,EADAnU,EACqBhH,EAAMqN,aAAa1mB,cAAcyzB,GAAiBuB,aAAa3U,EAAiBE,KAAI,SAAChf,EAAQuyB,GAAG,MAAM,CACvHvyB,OAAAA,EACAjB,KAAM+c,EAAiByW,GAAK/gC,QAC5BoP,cAAe/F,EAAAA,EAAWkG,qBAC7B,KAGoB+W,EAAMqN,aAAa1mB,cAAcyzB,GAE1D,IAAK,IAAIC,EAAkBW,EAAeX,EAAkBW,EAAgBtM,EAAW2L,IAAmB,CACtG,IAAMuB,EAAcX,EAAmBZ,EAAkBW,EACpDE,EAAOU,GAIZ3iC,EAAO2iC,GAAezkC,KAAK0kC,iBAAiBV,EAAoBC,EAAiCA,EAA+Bf,GAAmB,KAAMA,GAHrJphC,EAAO2iC,GAAe,IAI9B,CACJ,GAAC,CAAA5jC,IAAA,mBAAAY,MACD,SAAiBuiC,EAAoBha,EAAmBkZ,GACpDljC,KAAKmjC,iBACL,IAAMX,EAAgBxiC,KAAK8iC,gBACrB6B,EAAmBzB,EAAkB,EAAIV,EAAczU,wBAA0B,EACjFqW,EAAuClB,EAAkB,EAAIV,EAAc5U,aAAasV,EAAkB,GAAK,EAC/GmB,EAAqC7B,EAAc5U,aAAasV,GAChEz4B,EAASu5B,EAAmBY,gBAAgBR,EAAsCC,EAAoCM,GACxH/yB,EAAcnH,EAAOuI,iBACrBkwB,EAAkB,IAClBtxB,EAAc4xB,EAAOhB,EAAczU,yBAA2Bnc,GAElE,IAAMkY,EAAY9pB,KAAK8iC,gBAAgBY,mBAAmBR,GAAmB,EACvEnZ,EAAYnY,EAAYhQ,OAAS,EACjCke,EAA4BojB,EAAkB,EAAIljC,KAAK6kC,mBACvD3kB,EAA0C,IAApBgjB,EAAwB,EAAIV,EAAc1U,0BAA0BoV,EAAkB,GAClH,OAAO,IAAIrZ,EAAAA,GAAajY,EAAakO,EAA0BgK,EAAWC,EAAW7J,EAAoBzV,EAAQuf,EACrH,GAAC,CAAAnpB,IAAA,+BAAAY,MACD,SAA6ByhC,EAAiB4B,GAE1C,OADA9kC,KAAKmjC,iBACEnjC,KAAK8iC,gBAAgBiC,uBAAuB7B,EAAiB4B,EAAe,GAAK,CAC5F,GAAC,CAAAjkC,IAAA,iCAAAY,MACD,SAA+BujC,EAAiBC,GAAuD,IAA1CC,EAAQxQ,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,GAAAA,UAAA,GAAG,EAGpE,OAFA10B,KAAKmjC,iBACKnjC,KAAK8iC,gBAAgBqC,0BAA0BF,EAAc,EAAGC,GACjEE,WAAWJ,EACxB,GAAC,CAAAnkC,IAAA,mCAAAY,MACD,SAAiCujC,EAAiBC,GAG9C,OAFAjlC,KAAKmjC,iBAEE6B,EADGhlC,KAAK8iC,gBAAgBqC,0BAA0BF,EAAc,GAC5C/B,eAC/B,GAAC,CAAAriC,IAAA,oBAAAY,MACD,SAAkByhC,EAAiBmC,EAAgBH,GAC/C,IAAMI,EAAqBD,EAAehkC,WAAa6hC,EAGvD,OAFiCljC,KAAK8iC,gBAAgByC,wBAAwBrC,EAAiBmC,EAAe/jC,OAAS,EAAG4jC,GAClFE,WAAWE,EAEvD,GAAC,CAAAzkC,IAAA,oBAAAY,MACD,SAAkByhC,EAAiB4B,GAC/B,OAAO9kC,KAAK8iC,gBAAgB0C,gBAAgBtC,EAAiB4B,EAAe,EAChF,GAAC,CAAAjkC,IAAA,iBAAAY,MACD,WACI,IAAKzB,KAAK+iC,WACN,MAAM,IAAIp9B,MAAM,gBAExB,KAACk9B,CAAA,CA9KoB,GAmLnBH,EAA2B,WAC7B,SAAAA,KAAc3iC,EAAAA,EAAAA,GAAA,KAAA2iC,EAAE,CAsDf,OAtDgBhjC,EAAAA,EAAAA,GAAAgjC,EAAA,EAAA7hC,IAAA,YAAAY,MACjB,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,aAAAY,MACD,SAAWghC,GACP,OAAIA,EACOziC,KAEJ4iC,EAA0BD,QACrC,GAAC,CAAA9hC,IAAA,oBAAAY,MACD,WACI,OAAO,IACX,GAAC,CAAAZ,IAAA,mBAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,qBAAAY,MACD,SAAmBonB,EAAOoa,EAAiBwC,GACvC,OAAO5c,EAAM7V,eAAeiwB,EAChC,GAAC,CAAApiC,IAAA,oBAAAY,MACD,SAAkBonB,EAAOoa,EAAiBwC,GACtC,OAAO5c,EAAMtZ,cAAc0zB,EAC/B,GAAC,CAAApiC,IAAA,uBAAAY,MACD,SAAqBonB,EAAOoa,EAAiBwC,GACzC,OAAO5c,EAAMK,iBAAiB+Z,EAClC,GAAC,CAAApiC,IAAA,uBAAAY,MACD,SAAqBonB,EAAOoa,EAAiBwC,GACzC,OAAO5c,EAAMM,iBAAiB8Z,EAClC,GAAC,CAAApiC,IAAA,kBAAAY,MACD,SAAgBonB,EAAOoa,EAAiBwC,GACpC,IAAM76B,EAAaie,EAAMqN,aAAa1mB,cAAcyzB,GAC9CrxB,EAAchH,EAAWoI,iBAC/B,OAAO,IAAI6W,EAAAA,GAAajY,GAAa,EAAO,EAAGA,EAAYhQ,OAAS,EAAG,EAAGgJ,EAAW86B,UAAW,KACpG,GAAC,CAAA7kC,IAAA,mBAAAY,MACD,SAAiBonB,EAAOoa,EAAiB0C,EAAqBC,EAAoB9B,EAAkBC,EAAQjiC,GACnGiiC,EAAOD,GAIZhiC,EAAOgiC,GAAoB9jC,KAAK6lC,gBAAgBhd,EAAOoa,EAAiB,GAHpEnhC,EAAOgiC,GAAoB,IAInC,GAAC,CAAAjjC,IAAA,+BAAAY,MACD,SAA6BgkC,EAAkBX,GAC3C,OAAOA,CACX,GAAC,CAAAjkC,IAAA,iCAAAY,MACD,SAA+BujC,EAAiBC,GAC5C,OAAO,IAAI72B,EAAAA,EAAS42B,EAAiBC,EACzC,GAAC,CAAApkC,IAAA,mCAAAY,MACD,SAAiCujC,EAAiBc,GAC9C,OAAOd,CACX,GAAC,CAAAnkC,IAAA,oBAAAY,MACD,SAAkByhC,EAAiBmC,EAAgBH,GAC/C,OAAOG,CACX,GAAC,CAAAxkC,IAAA,oBAAAY,MACD,SAAkBgkC,EAAkBM,GAChC,OAAO,IACX,KAACrD,CAAA,CAvD4B,GAyDjCA,EAA4BC,SAAW,IAAID,EAC3C,IAGME,EAAyB,WAC3B,SAAAA,KAAc7iC,EAAAA,EAAAA,GAAA,KAAA6iC,EAAE,CAgDf,OAhDgBljC,EAAAA,EAAAA,GAAAkjC,EAAA,EAAA/hC,IAAA,YAAAY,MACjB,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,aAAAY,MACD,SAAWghC,GACP,OAAKA,EAGEC,EAA4BC,SAFxB3iC,IAGf,GAAC,CAAAa,IAAA,oBAAAY,MACD,WACI,OAAO,IACX,GAAC,CAAAZ,IAAA,mBAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,qBAAAY,MACD,SAAmBunB,EAAQya,EAAkBgC,GACzC,MAAM,IAAI9/B,MAAM,gBACpB,GAAC,CAAA9E,IAAA,oBAAAY,MACD,SAAkBunB,EAAQya,EAAkBgC,GACxC,MAAM,IAAI9/B,MAAM,gBACpB,GAAC,CAAA9E,IAAA,uBAAAY,MACD,SAAqBunB,EAAQya,EAAkBgC,GAC3C,MAAM,IAAI9/B,MAAM,gBACpB,GAAC,CAAA9E,IAAA,uBAAAY,MACD,SAAqBunB,EAAQya,EAAkBgC,GAC3C,MAAM,IAAI9/B,MAAM,gBACpB,GAAC,CAAA9E,IAAA,kBAAAY,MACD,SAAgBunB,EAAQya,EAAkBgC,GACtC,MAAM,IAAI9/B,MAAM,gBACpB,GAAC,CAAA9E,IAAA,mBAAAY,MACD,SAAiBunB,EAAQya,EAAkBkC,EAAqBC,EAAoBI,EAAmBC,EAASC,GAC5G,MAAM,IAAIvgC,MAAM,gBACpB,GAAC,CAAA9E,IAAA,+BAAAY,MACD,SAA6BgkC,EAAkBM,GAC3C,MAAM,IAAIpgC,MAAM,gBACpB,GAAC,CAAA9E,IAAA,iCAAAY,MACD,SAA+B0kC,EAAkBL,GAC7C,MAAM,IAAIngC,MAAM,gBACpB,GAAC,CAAA9E,IAAA,mCAAAY,MACD,SAAiC0kC,EAAkBL,GAC/C,MAAM,IAAIngC,MAAM,gBACpB,GAAC,CAAA9E,IAAA,oBAAAY,MACD,SAAkByhC,EAAiBmC,EAAgBH,GAC/C,MAAM,IAAIv/B,MAAM,gBACpB,GAAC,CAAA9E,IAAA,oBAAAY,MACD,SAAkBgkC,EAAkBM,GAChC,MAAM,IAAIpgC,MAAM,gBACpB,KAACi9B,CAAA,CAjD0B,GAmD/BA,EAA0BD,SAAW,IAAIC,EACzC,IAAMwD,EAAU,CAAC,IACjB,SAAS5C,EAAOvnB,GACZ,GAAIA,GAASmqB,EAAQxkC,OACjB,IAAK,IAAI2C,EAAI,EAAGA,GAAK0X,EAAO1X,IACxB6hC,EAAQ7hC,GAAK8hC,EAAY9hC,GAGjC,OAAO6hC,EAAQnqB,EACnB,CACA,SAASoqB,EAAYpqB,GACjB,OAAO,IAAIhT,MAAMgT,EAAQ,GAAGvG,KAAK,IACrC,C,eC1Ta4wB,EAAgC,WACzC,SAAAA,EAAYhT,EAAUzK,EAAO0d,EAA8BC,EAAoCva,EAAUhM,EAASwmB,EAAkBva,EAAgBC,EAAgBC,IAAWrsB,EAAAA,EAAAA,GAAA,KAAAumC,GAC3KtmC,KAAK0mC,UAAYpT,EACjBtzB,KAAK6oB,MAAQA,EACb7oB,KAAK2mC,sBAAwB,EAC7B3mC,KAAK4mC,8BAAgCL,EACrCvmC,KAAK6mC,oCAAsCL,EAC3CxmC,KAAKisB,SAAWA,EAChBjsB,KAAKigB,QAAUA,EACfjgB,KAAKymC,iBAAmBA,EACxBzmC,KAAKksB,eAAiBA,EACtBlsB,KAAKmsB,eAAiBA,EACtBnsB,KAAKosB,UAAYA,EACjBpsB,KAAK8mC,iBAAqC,EAAM,KACpD,CAssBC,OAtsBApnC,EAAAA,EAAAA,GAAA4mC,EAAA,EAAAzlC,IAAA,UAAAY,MACD,WACIzB,KAAK+mC,yBAA2B/mC,KAAK6oB,MAAMme,iBAAiBhnC,KAAK+mC,yBAA0B,GAC/F,GAAC,CAAAlmC,IAAA,6BAAAY,MACD,WACI,OAAO,IAAIwlC,GAAqBjnC,KACpC,GAAC,CAAAa,IAAA,kBAAAY,MACD,SAAgBylC,EAAkBC,GAAoB,IAAAzmC,EAAA,KAClDV,KAAKonC,qBAAuB,GACxBF,IACAlnC,KAAK+mC,yBAA2B/mC,KAAK6oB,MAAMme,iBAAiBhnC,KAAK+mC,yBAA0B,KAO/F,IALA,IAAMM,EAAernC,KAAK6oB,MAAMye,kBAC1BC,EAA0BvnC,KAAK6oB,MAAM2e,2BAA2BxnC,KAAK0mC,WACrEnP,EAAY8P,EAAazlC,OACzB6lC,EAAqBznC,KAAK0nC,2BAC1BC,EAAoB,IAAIj6B,EAAAA,GAAkBvM,EAAAA,GAAiBymC,gBAAgBL,IAA0BM,EAAA,SAAAtjC,GAEvG,IAAMujC,EAAmBH,EAAkBI,WAAU,SAAA/X,GAAC,OAAIA,EAAE3uB,aAAekD,EAAI,CAAC,IAChFkjC,EAAmBlb,WAAW8a,EAAa9iC,GAAIujC,EAAkBX,EAAqBA,EAAmB5iC,GAAK,KAClH,EAHSA,EAAI,EAAGA,EAAIgzB,EAAWhzB,IAAGsjC,EAAAtjC,GAUlC,IANA,IAAMyjC,EAAcP,EAAmBhb,WACjCwb,EAAS,GACTC,EAAcloC,KAAK+mC,yBAAyBhX,KAAI,SAACoY,GAAM,OAAKznC,EAAKmoB,MAAMuf,mBAAmBD,EAAO,IAAE7kC,KAAKuQ,EAAAA,EAAMw0B,0BAChHC,EAAkB,EAAGC,EAAgB,EACrCC,GAAiB,EACjBC,EAAoCD,EAAgB,EAAIN,EAAYtmC,OAAU2mC,EAAgB,EAAIhR,EAAY,EACzGhzB,EAAI,EAAGA,EAAIgzB,EAAWhzB,IAAK,CAChC,IAAMlD,EAAakD,EAAI,EACnBlD,IAAeonC,IAEfH,EAAkBJ,IADlBM,GAC6CvlC,gBAC7CslC,EAAgBL,EAAYM,GAAeplC,cAC3CqlC,EAAoCD,EAAgB,EAAIN,EAAYtmC,OAAU2mC,EAAgB,EAAIhR,EAAY,GAElH,IAAMmR,EAAkBrnC,GAAcinC,GAAmBjnC,GAAcknC,EACjEI,EAAOpG,EAA0ByF,EAAYzjC,IAAKmkC,GACxDT,EAAO1jC,GAAKokC,EAAK9D,mBACjB7kC,KAAKonC,qBAAqB7iC,GAAKokC,CACnC,CACA3oC,KAAK2mC,qBAAuB3mC,KAAK6oB,MAAM+f,eACvC5oC,KAAK6oC,6BAA+B,IAAIC,EAAAA,GAA8Bb,EAC1E,GAAC,CAAApnC,IAAA,iBAAAY,MACD,WAAiB,IAAAwG,EAAA,KACb,OAAOjI,KAAK+mC,yBAAyBhX,KAAI,SAACgZ,GAAK,OAAK9gC,EAAK4gB,MAAMuf,mBAAmBW,EAAM,GAC5F,GAAC,CAAAloC,IAAA,iBAAAY,MACD,SAAeunC,GAAS,IAAAx/B,EAAA,KAEdy/B,EAkqBd,SAA6Bj6B,GACzB,GAAsB,IAAlBA,EAAOpN,OACP,MAAO,GAEX,IAAMsnC,EAAel6B,EAAOquB,QAC5B6L,EAAa5lC,KAAKuQ,EAAAA,EAAMw0B,0BAIxB,IAHA,IAAMvmC,EAAS,GACXqnC,EAAoBD,EAAa,GAAGjmC,gBACpCmmC,EAAkBF,EAAa,GAAG9lC,cAC7BmB,EAAI,EAAGC,EAAM0kC,EAAatnC,OAAQ2C,EAAIC,EAAKD,IAAK,CACrD,IAAM5E,EAAQupC,EAAa3kC,GACvB5E,EAAMsD,gBAAkBmmC,EAAkB,GAC1CtnC,EAAOkB,KAAK,IAAI6Q,EAAAA,EAAMs1B,EAAmB,EAAGC,EAAiB,IAC7DD,EAAoBxpC,EAAMsD,gBAC1BmmC,EAAkBzpC,EAAMyD,eAEnBzD,EAAMyD,cAAgBgmC,IAC3BA,EAAkBzpC,EAAMyD,cAEhC,CAEA,OADAtB,EAAOkB,KAAK,IAAI6Q,EAAAA,EAAMs1B,EAAmB,EAAGC,EAAiB,IACtDtnC,CACX,CAxrB0BunC,CADML,EAAQjZ,KAAI,SAAArS,GAAC,OAAIlU,EAAKqf,MAAMygB,cAAc5rB,EAAE,KAI9D6rB,EAAYvpC,KAAK+mC,yBAAyBhX,KAAI,SAACoY,GAAM,OAAK3+B,EAAKqf,MAAMuf,mBAAmBD,EAAO,IAAE7kC,KAAKuQ,EAAAA,EAAMw0B,0BAClH,GAAIY,EAAUrnC,SAAW2nC,EAAU3nC,OAAQ,CAEvC,IADA,IAAI4nC,GAAgB,EACXjlC,EAAI,EAAGA,EAAI0kC,EAAUrnC,OAAQ2C,IAClC,IAAK0kC,EAAU1kC,GAAGiwB,YAAY+U,EAAUhlC,IAAK,CACzCilC,GAAgB,EAChB,KACJ,CAEJ,IAAKA,EACD,OAAO,CAEf,CACA,IAAMC,EAAiBR,EAAUlZ,KAAI,SAACrS,GAAC,MAAM,CACzC/d,MAAO+d,EACPnc,QAASmoC,EAAAA,GAAuBC,MACnC,IACD3pC,KAAK+mC,yBAA2B/mC,KAAK6oB,MAAMme,iBAAiBhnC,KAAK+mC,yBAA0B0C,GAM3F,IALA,IAAMvB,EAAce,EAChBX,EAAkB,EAAGC,EAAgB,EACrCC,GAAiB,EACjBC,EAAoCD,EAAgB,EAAIN,EAAYtmC,OAAU2mC,EAAgB,EAAIvoC,KAAKonC,qBAAqBxlC,OAAS,EACrIgoC,GAAiB,EACZrlC,EAAI,EAAGA,EAAIvE,KAAKonC,qBAAqBxlC,OAAQ2C,IAAK,CACvD,IAAMlD,EAAakD,EAAI,EACnBlD,IAAeonC,IAEfH,EAAkBJ,IADlBM,GAC6CvlC,gBAC7CslC,EAAgBL,EAAYM,GAAeplC,cAC3CqlC,EAAoCD,EAAgB,EAAIN,EAAYtmC,OAAU2mC,EAAgB,EAAIvoC,KAAKonC,qBAAqBxlC,OAAS,GAEzI,IAAIioC,GAAc,EAgBlB,GAfIxoC,GAAcinC,GAAmBjnC,GAAcknC,EAE3CvoC,KAAKonC,qBAAqB7iC,GAAGk+B,cAC7BziC,KAAKonC,qBAAqB7iC,GAAKvE,KAAKonC,qBAAqB7iC,GAAGulC,YAAW,GACvED,GAAc,IAIlBD,GAAiB,EAEZ5pC,KAAKonC,qBAAqB7iC,GAAGk+B,cAC9BziC,KAAKonC,qBAAqB7iC,GAAKvE,KAAKonC,qBAAqB7iC,GAAGulC,YAAW,GACvED,GAAc,IAGlBA,EAAa,CACb,IAAME,EAAqB/pC,KAAKonC,qBAAqB7iC,GAAGsgC,mBACxD7kC,KAAK6oC,6BAA6BmB,SAASzlC,EAAGwlC,EAClD,CACJ,CAKA,OAJKH,GAED5pC,KAAKiqC,eAAe,KAEjB,CACX,GAAC,CAAAppC,IAAA,yBAAAY,MACD,SAAuBwhC,EAAiBiH,GACpC,QAAIjH,EAAkB,GAAKA,EAAkBjjC,KAAKonC,qBAAqBxlC,SAIhE5B,KAAKonC,qBAAqBnE,EAAkB,GAAGR,WAC1D,GAAC,CAAA5hC,IAAA,4BAAAY,MACD,SAA0BwhC,GACtB,OAAIA,EAAkB,GAAKA,EAAkBjjC,KAAKonC,qBAAqBxlC,OAE5D,EAEJ5B,KAAKonC,qBAAqBnE,EAAkB,GAAG4B,kBAC1D,GAAC,CAAAhkC,IAAA,aAAAY,MACD,SAAW0oC,GACP,OAAInqC,KAAKigB,UAAYkqB,IAGrBnqC,KAAKigB,QAAUkqB,EACfnqC,KAAK8mC,iBAAqC,EAAO,OAC1C,EACX,GAAC,CAAAjmC,IAAA,sBAAAY,MACD,SAAoBwqB,EAAUwa,EAAkBva,EAAgBC,EAAgBC,GAC5E,IAAMge,EAAgBpqC,KAAKisB,SAASjL,OAAOiL,GACrCoe,EAAyBrqC,KAAKymC,mBAAqBA,EACnD6D,EAAuBtqC,KAAKksB,iBAAmBA,EAC/Cqe,EAAuBvqC,KAAKmsB,iBAAmBA,EAC/Cqe,EAAkBxqC,KAAKosB,YAAcA,EAC3C,GAAIge,GAAiBC,GAAyBC,GAAuBC,GAAuBC,EACxF,OAAO,EAEX,IAAMC,EAA6BL,GAAiBC,IAA0BC,GAAuBC,GAAuBC,EAC5HxqC,KAAKisB,SAAWA,EAChBjsB,KAAKymC,iBAAmBA,EACxBzmC,KAAKksB,eAAiBA,EACtBlsB,KAAKmsB,eAAiBA,EACtBnsB,KAAKosB,UAAYA,EACjB,IAAI+a,EAAqB,KACzB,GAAIsD,EAA2B,CAC3BtD,EAAqB,GACrB,IAAK,IAAI5iC,EAAI,EAAGC,EAAMxE,KAAKonC,qBAAqBxlC,OAAQ2C,EAAIC,EAAKD,IAC7D4iC,EAAmB5iC,GAAKvE,KAAKonC,qBAAqB7iC,GAAGmmC,mBAE7D,CAEA,OADA1qC,KAAK8mC,iBAAqC,EAAOK,IAC1C,CACX,GAAC,CAAAtmC,IAAA,2BAAAY,MACD,WAII,OAH6D,aAA1BzB,KAAKymC,iBAClCzmC,KAAK4mC,8BACL5mC,KAAK6mC,qCACsBa,yBAAyB1nC,KAAKisB,SAAUjsB,KAAKigB,QAASjgB,KAAKksB,eAAgBlsB,KAAKmsB,eAAgBnsB,KAAKosB,UAC1I,GAAC,CAAAvrB,IAAA,iBAAAY,MACD,WACIzB,KAAK8mC,iBAAqC,EAAM,KACpD,GAAC,CAAAjmC,IAAA,sBAAAY,MACD,SAAoByC,EAAWN,EAAgBC,GAC3C,IAAKK,GAAaA,GAAalE,KAAK2mC,qBAGhC,OAAO,KAEX,IAAMgE,EAA2C,IAAnB/mC,EAAuB,EAAI5D,KAAK6oC,6BAA6B+B,aAAahnC,EAAiB,GAAK,EACxHinC,EAAqB7qC,KAAK6oC,6BAA6B+B,aAAa/mC,GAG1E,OAFA7D,KAAKonC,qBAAqB75B,OAAO3J,EAAiB,EAAGC,EAAeD,EAAiB,GACrF5D,KAAK6oC,6BAA6BiC,aAAalnC,EAAiB,EAAGC,EAAeD,EAAiB,GAC5F,IAAImnC,EAAAA,GAAiCJ,EAAsBE,EACtE,GAAC,CAAAhqC,IAAA,uBAAAY,MACD,SAAqByC,EAAWN,EAAgBonC,EAAeC,GAC3D,IAAK/mC,GAAaA,GAAalE,KAAK2mC,qBAGhC,OAAO,KAQX,IALA,IAAM+B,EAAkB9kC,EAAiB,IAAM5D,KAAKonC,qBAAqBxjC,EAAiB,GAAG6+B,YACvFkI,EAA2C,IAAnB/mC,EAAuB,EAAI5D,KAAK6oC,6BAA6B+B,aAAahnC,EAAiB,GAAK,EAC1HsnC,EAAuB,EACrBC,EAAc,GACdC,EAAwB,GACrB7mC,EAAI,EAAGC,EAAMymC,EAAWrpC,OAAQ2C,EAAIC,EAAKD,IAAK,CACnD,IAAMokC,EAAOpG,EAA0B0I,EAAW1mC,IAAKmkC,GACvDyC,EAAYnoC,KAAK2lC,GACjB,IAAM0C,EAAkB1C,EAAK9D,mBAC7BqG,GAAwBG,EACxBD,EAAsB7mC,GAAK8mC,CAC/B,CAOA,OALArrC,KAAKonC,qBACDpnC,KAAKonC,qBAAqB/J,MAAM,EAAGz5B,EAAiB,GAC/Ca,OAAO0mC,GACP1mC,OAAOzE,KAAKonC,qBAAqB/J,MAAMz5B,EAAiB,IACjE5D,KAAK6oC,6BAA6ByC,aAAa1nC,EAAiB,EAAGwnC,GAC5D,IAAIL,EAAAA,GAAkCJ,EAAsBA,EAAuBO,EAAuB,EACrH,GAAC,CAAArqC,IAAA,qBAAAY,MACD,SAAmByC,EAAW7C,EAAYmhC,GACtC,GAAkB,OAAdt+B,GAAsBA,GAAalE,KAAK2mC,qBAGxC,MAAO,EAAC,EAAO,KAAM,KAAM,MAE/B,IAAM15B,EAAY5L,EAAa,EACzBkqC,EAAqBvrC,KAAKonC,qBAAqBn6B,GAAW43B,mBAE1D8D,EAAOpG,EAA0BC,EADrBxiC,KAAKonC,qBAAqBn6B,GAAWw1B,aAEvDziC,KAAKonC,qBAAqBn6B,GAAa07B,EACvC,IAAMoB,EAAqB/pC,KAAKonC,qBAAqBn6B,GAAW43B,mBAC5D2G,GAAqB,EACrBC,EAAa,EACbC,GAAY,EACZC,EAAa,EACbC,GAAY,EACZC,EAAa,EACbC,GAAY,EAuBhB,OAtBIP,EAAqBxB,GAIrB+B,GADAD,GADAH,GADAD,EAAazrC,KAAK6oC,6BAA6B+B,aAAavpC,EAAa,GAAK,GACtD0oC,EAAqB,GACrB,IACCwB,EAAqBxB,GAAsB,EACpEyB,GAAqB,GAEhBD,EAAqBxB,GAI1B6B,GADAD,GADAD,GADAD,EAAazrC,KAAK6oC,6BAA6B+B,aAAavpC,EAAa,GAAK,GACtDkqC,EAAqB,GACrB,IACCxB,EAAqBwB,GAAsB,EACpEC,GAAqB,GAIrBE,GADAD,EAAazrC,KAAK6oC,6BAA6B+B,aAAavpC,EAAa,GAAK,GACtD0oC,EAAqB,EAEjD/pC,KAAK6oC,6BAA6BmB,SAAS/8B,EAAW88B,GAI/C,CAACyB,EAHuBC,GAAcC,EAAW,IAAIX,EAAAA,GAAiCU,EAAYC,EAAWD,EAAa,GAAK,KACtGE,GAAcC,EAAW,IAAIb,EAAAA,GAAkCY,EAAYC,GAAY,KACxFC,GAAcC,EAAW,IAAIf,EAAAA,GAAiCc,EAAYC,GAAY,KAEzH,GAAC,CAAAjrC,IAAA,kBAAAY,MACD,SAAgByC,GACZlE,KAAK2mC,qBAAuBziC,EACa,IAArClE,KAAKonC,qBAAqBxlC,QAAiB5B,KAAKonC,qBAAqB,GAAG3E,aAExEziC,KAAKiqC,eAAe,GAE5B,GAAC,CAAAppC,IAAA,mBAAAY,MACD,WACI,OAAOzB,KAAK6oC,6BAA6BkD,aAC7C,GAAC,CAAAlrC,IAAA,yBAAAY,MACD,SAAuBuqC,GACnB,GAAIA,EAAiB,EACjB,OAAO,EAEX,IAAMC,EAAgBjsC,KAAK6kC,mBAC3B,OAAImH,EAAiBC,EACVA,EAEa,EAAjBD,CACX,GAAC,CAAAnrC,IAAA,uBAAAY,MACD,SAAqBuqC,EAAgB/Q,EAAeC,GAChD8Q,EAAiBhsC,KAAKksC,uBAAuBF,GAC7C/Q,EAAgBj7B,KAAKksC,uBAAuBjR,GAC5CC,EAAgBl7B,KAAKksC,uBAAuBhR,GAC5C,IAAMiR,EAAgBnsC,KAAKosC,mCAAmCJ,EAAgBhsC,KAAK40B,qBAAqBoX,IAClGK,EAAmBrsC,KAAKosC,mCAAmCnR,EAAej7B,KAAK40B,qBAAqBqG,IACpGqR,EAAmBtsC,KAAKosC,mCAAmClR,EAAel7B,KAAK40B,qBAAqBsG,IACpGp5B,EAAS9B,KAAK6oB,MAAM0jB,OAAOC,qBAAqBL,EAAc9qC,WAAYgrC,EAAiBhrC,WAAYirC,EAAiBjrC,YACxHorC,EAAoBzsC,KAAKm0B,mCAAmCryB,EAAOmB,gBAAiB,GACpFypC,EAAkB1sC,KAAKm0B,mCAAmCryB,EAAOsB,cAAepD,KAAK6oB,MAAMM,iBAAiBrnB,EAAOsB,gBACzH,MAAO,CACHH,gBAAiBwpC,EAAkBprC,WACnC+B,cAAespC,EAAgBrrC,WAC/BsrC,OAAQ7qC,EAAO6qC,OAEvB,GACA,CAAA9rC,IAAA,kBAAAY,MACA,SAAgBuqC,GACZA,EAAiBhsC,KAAKksC,uBAAuBF,GAC7C,IAAMtuB,EAAI1d,KAAK6oC,6BAA6B+D,WAAWZ,EAAiB,GAClE/+B,EAAYyQ,EAAEvF,MACd00B,EAAYnvB,EAAEmvB,UACpB,OAAO,IAAIC,EAAa7/B,EAAY,EAAG4/B,EAC3C,GAAC,CAAAhsC,IAAA,yBAAAY,MACD,SAAuBsrC,GACnB,OAAO/sC,KAAKonC,qBAAqB2F,EAAa9J,gBAAkB,GAAGrO,qBAAqB50B,KAAK6oB,MAAOkkB,EAAa9J,gBAAiB8J,EAAaC,wBACnJ,GAAC,CAAAnsC,IAAA,yBAAAY,MACD,SAAuBsrC,GACnB,OAAO/sC,KAAKonC,qBAAqB2F,EAAa9J,gBAAkB,GAAGpO,qBAAqB70B,KAAK6oB,MAAOkkB,EAAa9J,gBAAiB8J,EAAaC,wBACnJ,GAAC,CAAAnsC,IAAA,kCAAAY,MACD,SAAgCsrC,GAC5B,IAAMpE,EAAO3oC,KAAKonC,qBAAqB2F,EAAa9J,gBAAkB,GAChEgK,EAAgBtE,EAAK/T,qBAAqB50B,KAAK6oB,MAAOkkB,EAAa9J,gBAAiB8J,EAAaC,yBACjG1rC,EAASqnC,EAAKuE,6BAA6BH,EAAaC,wBAAyBC,GACvF,OAAO,IAAI7+B,EAAAA,EAAS2+B,EAAa9J,gBAAiB3hC,EACtD,GAAC,CAAAT,IAAA,gCAAAY,MACD,SAA8BsrC,GAC1B,IAAMpE,EAAO3oC,KAAKonC,qBAAqB2F,EAAa9J,gBAAkB,GAChEkK,EAAgBxE,EAAK9T,qBAAqB70B,KAAK6oB,MAAOkkB,EAAa9J,gBAAiB8J,EAAaC,yBACjG1rC,EAASqnC,EAAKuE,6BAA6BH,EAAaC,wBAAyBG,GACvF,OAAO,IAAI/+B,EAAAA,EAAS2+B,EAAa9J,gBAAiB3hC,EACtD,GAAC,CAAAT,IAAA,uCAAAY,MACD,SAAqC2rC,EAAqBC,GAMtD,IALA,IAAMC,EAAgBttC,KAAKutC,gBAAgBH,GACrCI,EAAcxtC,KAAKutC,gBAAgBF,GACnCvrC,EAAS,IAAImH,MACfwkC,EAAsBztC,KAAK0tC,gCAAgCJ,GAC3DK,EAAY,IAAI1kC,MACX2kC,EAAeN,EAAcrK,gBAAiB2K,GAAgBJ,EAAYvK,gBAAiB2K,IAAgB,CAChH,IAAMjF,EAAO3oC,KAAKonC,qBAAqBwG,EAAe,GACtD,GAAIjF,EAAKlG,YAOL,IANA,IAAMzxB,EAAc48B,IAAiBN,EAAcrK,gBAC7CqK,EAAcN,wBACd,EACA/7B,EAAY28B,IAAiBJ,EAAYvK,gBACzCuK,EAAYR,wBAA0B,EACtCrE,EAAK9D,mBACFtgC,EAAIyM,EAAazM,EAAI0M,EAAW1M,IACrCopC,EAAU3qC,KAAK,IAAI8pC,EAAac,EAAcrpC,IAGtD,IAAKokC,EAAKlG,aAAegL,EAAqB,CAC1C,IAAMI,EAAuB,IAAIz/B,EAAAA,EAASw/B,EAAe,EAAG5tC,KAAK6oB,MAAMM,iBAAiBykB,EAAe,GAAK,GACtG3Z,EAAapgB,EAAAA,EAAMi6B,cAAcL,EAAqBI,GAC5D/rC,EAAOkB,KAAK,IAAI+qC,GAAgC9Z,EAAY0Z,IAC5DA,EAAY,GACZF,EAAsB,IAC1B,MACS9E,EAAKlG,cAAgBgL,IAC1BA,EAAsB,IAAIr/B,EAAAA,EAASw/B,EAAc,GAEzD,CACA,GAAIH,EAAqB,CACrB,IAAMxZ,EAAapgB,EAAAA,EAAMi6B,cAAcL,EAAqBztC,KAAKguC,8BAA8BR,IAC/F1rC,EAAOkB,KAAK,IAAI+qC,GAAgC9Z,EAAY0Z,GAChE,CACA,OAAO7rC,CACX,GACA,CAAAjB,IAAA,4BAAAY,MACA,SAA0B2rC,EAAqBC,EAAmBY,EAAoB1sC,GAAS,IAGUM,EAHVqsC,EAAA,KACrFC,EAAsBF,EAAqBjuC,KAAKosC,mCAAmC6B,EAAmB5sC,WAAY4sC,EAAmB3sC,QAAU,KAC/I8sC,EAAoB,GAAGpsC,GAAAC,EAAAA,EAAAA,GACTjC,KAAKquC,qCAAqCjB,EAAqBC,IAAkB,IAArG,IAAArrC,EAAAE,MAAAL,EAAAG,EAAAG,KAAAC,MAAuG,KAGzDQ,EAHnC0rC,EAAKzsC,EAAAJ,MACN8sC,EAA4BD,EAAMra,WAAWhxB,gBAC7CurC,EAA4BxuC,KAAK6oB,MAAM0jB,OAAOkC,sBAAsBF,EAA2BD,EAAMra,WAAW7wB,cAAe+qC,EAAqB5sC,GAASsB,GAAAZ,EAAAA,EAAAA,GACxIqsC,EAAMX,WAAS,QAAAe,EAAA,WAAE,IAAjC3B,EAAYnqC,EAAAnB,MAIbK,EAHgB0sC,EAA0BzB,EAAa9J,gBAAkBsL,GAGlDxe,KAAI,SAAAzE,GAC7B,IAAsC,IAAlCA,EAAE7lB,4BACQyoC,EAAK9G,qBAAqB2F,EAAa9J,gBAAkB,GAAG0L,+BAA+B,EAAGrjB,EAAE7lB,4BACpGpE,YAAc0rC,EAAaC,wBAC7B,OAGR,IAA2C,IAAvC1hB,EAAE5lB,iCACQwoC,EAAK9G,qBAAqB2F,EAAa9J,gBAAkB,GAAG0L,+BAA+B,EAAGrjB,EAAE5lB,iCACpGrE,WAAa0rC,EAAaC,wBAC5B,OAGR,IAAK1hB,EAAE9lB,eACH,OAAO8lB,EAEX,IAAIhqB,GAAU,EACd,IAAkB,IAAdgqB,EAAEhqB,OAAe,CACjB,IAAMstC,EAAIV,EAAK9G,qBAAqB2F,EAAa9J,gBAAkB,GAAG0L,+BAA+B,EAAGrjB,EAAEhqB,QAC1G,GAAIstC,EAAEvtC,aAAe0rC,EAAaC,wBAC9B1rC,EAASstC,EAAEttC,YAEV,GAAIstC,EAAEvtC,WAAa0rC,EAAaC,wBACjC1rC,EAAS4sC,EAAKW,uBAAuB9B,QAEpC,GAAI6B,EAAEvtC,WAAa0rC,EAAaC,wBACjC,MAER,CACA,IAAM8B,EAAeZ,EAAK/Z,mCAAmC4Y,EAAa9J,gBAAiB3X,EAAE9lB,eAAenC,WACtGurC,EAAIV,EAAK9G,qBAAqB2F,EAAa9J,gBAAkB,GAAG0L,+BAA+B,EAAGrjB,EAAE9lB,eAAenC,WACzH,OAAIurC,EAAEvtC,aAAe0rC,EAAaC,wBACvB,IAAI3nC,EAAAA,GAAYimB,EAAEhmB,cAAehE,EAAQgqB,EAAE/lB,UAAW,IAAIK,EAAAA,GAA0B0lB,EAAE9lB,eAAeK,IAAKipC,EAAaxtC,SAAU,GAAI,GAEvIstC,EAAEvtC,WAAa0rC,EAAaC,0BAIR,IAArB1hB,EAAEhmB,mBAJL,EAQM,IAAID,EAAAA,GAAYimB,EAAEhmB,cAAehE,EAAQgqB,EAAE/lB,UAAW,IAAIK,EAAAA,GAA0B0lB,EAAE9lB,eAAeK,IAAKqoC,EAAKa,uBAAuBhC,KAAiB,GAAI,EAE1K,IACAqB,EAAkBprC,KAAKlB,EAAOktC,QAAO,SAACtxB,GAAC,QAAOA,CAAC,IACnD,EAlDA,IAAA7a,EAAAX,MAAAU,EAAAC,EAAAV,KAAAC,MAAAssC,GAkDC,OAAAlsC,GAAAK,EAAAJ,EAAAD,EAAA,SAAAK,EAAAH,GAAA,CACL,CAAC,OAAAF,GAAAR,EAAAS,EAAAD,EAAA,SAAAR,EAAAU,GAAA,CACD,OAAO0rC,CACX,GAAC,CAAAvtC,IAAA,2BAAAY,MACD,SAAyB2rC,EAAqBC,GAI1CD,EAAsBptC,KAAKksC,uBAAuBkB,GAClDC,EAAoBrtC,KAAKksC,uBAAuBmB,GAShD,IARA,IAAM4B,EAAajvC,KAAKosC,mCAAmCgB,EAAqBptC,KAAK40B,qBAAqBwY,IACpG8B,EAAWlvC,KAAKosC,mCAAmCiB,EAAmBrtC,KAAK60B,qBAAqBwY,IAClGvrC,EAAS,GACPqtC,EAAoB,GACpBC,EAAqB,GACrBC,EAAsBJ,EAAW5tC,WAAa,EAC9CiuC,EAAoBJ,EAAS7tC,WAAa,EAC5CkuC,EAAW,KACNC,EAAiBH,EAAqBG,GAAkBF,EAAmBE,IAAkB,CAClG,IAAM7G,EAAO3oC,KAAKonC,qBAAqBoI,GACvC,GAAI7G,EAAKlG,YAAa,CAClB,IAAMgN,EAAqB9G,EAAK+G,iCAAiC,EAAGF,IAAmBH,EAAsBJ,EAAW3tC,OAAS,GAC3HquC,EAAmBhH,EAAK+G,iCAAiC,EAAG1vC,KAAK6oB,MAAMM,iBAAiBqmB,EAAiB,IACzGvzB,EAAQ0zB,EAAmBF,EAAqB,EAClDG,EAAS,EACT3zB,EAAQ,GAAqF,IAAhF0sB,EAAK/T,qBAAqB50B,KAAK6oB,MAAO2mB,EAAiB,EAAGG,KAEvEC,EAAiC,IAAvBH,EAA2B,EAAkD,GAE3FN,EAAkBnsC,KAAKiZ,GACvBmzB,EAAmBpsC,KAAK4sC,GAEP,OAAbL,IACAA,EAAW,IAAInhC,EAAAA,EAASohC,EAAiB,EAAG,GAEpD,MAGqB,OAAbD,IACAztC,EAASA,EAAO2C,OAAOzE,KAAK6oB,MAAM0jB,OAAOsD,qBAAqBN,EAASluC,WAAYmuC,IACnFD,EAAW,KAGvB,CACiB,OAAbA,IACAztC,EAASA,EAAO2C,OAAOzE,KAAK6oB,MAAM0jB,OAAOsD,qBAAqBN,EAASluC,WAAY6tC,EAAS7tC,aAC5FkuC,EAAW,MAKf,IAHA,IAAMtD,EAAgBoB,EAAoBD,EAAsB,EAC1D0C,EAAc,IAAI7mC,MAAMgjC,GAC1B8D,EAAY,EACPxrC,EAAI,EAAGC,EAAM1C,EAAOF,OAAQ2C,EAAIC,EAAKD,IAAK,CAC/C,IAAI9C,EAAQK,EAAOyC,GACb0X,EAAQ7J,KAAKc,IAAI+4B,EAAgB8D,EAAWZ,EAAkB5qC,IAC9DqrC,EAASR,EAAmB7qC,GAC9ByrC,OAAY,EAEZA,EADW,IAAXJ,EACe,EAEC,IAAXA,EACU,EAGA3zB,EAEnB,IAAK,IAAIyL,EAAI,EAAGA,EAAIzL,EAAOyL,IACnBA,IAAMsoB,IACNvuC,EAAQ,GAEZquC,EAAYC,KAAetuC,CAEnC,CACA,OAAOquC,CACX,GAAC,CAAAjvC,IAAA,qBAAAY,MACD,SAAmBuqC,GACf,IAAMnxB,EAAO7a,KAAKutC,gBAAgBvB,GAClC,OAAOhsC,KAAKonC,qBAAqBvsB,EAAKooB,gBAAkB,GAAGgN,mBAAmBjwC,KAAK6oB,MAAOhO,EAAKooB,gBAAiBpoB,EAAKmyB,wBACzH,GAAC,CAAAnsC,IAAA,oBAAAY,MACD,SAAkBuqC,GACd,IAAMnxB,EAAO7a,KAAKutC,gBAAgBvB,GAClC,OAAOhsC,KAAKonC,qBAAqBvsB,EAAKooB,gBAAkB,GAAGiN,kBAAkBlwC,KAAK6oB,MAAOhO,EAAKooB,gBAAiBpoB,EAAKmyB,wBACxH,GAAC,CAAAnsC,IAAA,uBAAAY,MACD,SAAqBuqC,GACjB,IAAMnxB,EAAO7a,KAAKutC,gBAAgBvB,GAClC,OAAOhsC,KAAKonC,qBAAqBvsB,EAAKooB,gBAAkB,GAAGrO,qBAAqB50B,KAAK6oB,MAAOhO,EAAKooB,gBAAiBpoB,EAAKmyB,wBAC3H,GAAC,CAAAnsC,IAAA,uBAAAY,MACD,SAAqBuqC,GACjB,IAAMnxB,EAAO7a,KAAKutC,gBAAgBvB,GAClC,OAAOhsC,KAAKonC,qBAAqBvsB,EAAKooB,gBAAkB,GAAGpO,qBAAqB70B,KAAK6oB,MAAOhO,EAAKooB,gBAAiBpoB,EAAKmyB,wBAC3H,GAAC,CAAAnsC,IAAA,kBAAAY,MACD,SAAgBuqC,GACZ,IAAMnxB,EAAO7a,KAAKutC,gBAAgBvB,GAClC,OAAOhsC,KAAKonC,qBAAqBvsB,EAAKooB,gBAAkB,GAAG4C,gBAAgB7lC,KAAK6oB,MAAOhO,EAAKooB,gBAAiBpoB,EAAKmyB,wBACtH,GAAC,CAAAnsC,IAAA,mBAAAY,MACD,SAAiB2rC,EAAqBC,EAAmBtJ,GACrDqJ,EAAsBptC,KAAKksC,uBAAuBkB,GAClDC,EAAoBrtC,KAAKksC,uBAAuBmB,GAMhD,IALA,IAAMhgC,EAAQrN,KAAK6oC,6BAA6B+D,WAAWQ,EAAsB,GAC7EpB,EAAiBoB,EACf+C,EAAsB9iC,EAAM8K,MAC5Bi4B,EAAiB/iC,EAAMw/B,UACvB/qC,EAAS,GACN0tC,EAAiBW,EAAqB3rC,EAAMxE,KAAK6oB,MAAMwnB,eAAgBb,EAAiBhrC,EAAKgrC,IAAkB,CACpH,IAAM7G,EAAO3oC,KAAKonC,qBAAqBoI,GACvC,GAAK7G,EAAKlG,YAAV,CAGA,IAAM6N,EAAqBd,IAAmBW,EAAsBC,EAAiB,EACjFG,EAAyB5H,EAAK9D,mBAAqByL,EACnDE,GAAW,EAOf,GANIxE,EAAiBuE,EAAyBlD,IAC1CmD,GAAW,EACXD,EAAyBlD,EAAoBrB,EAAiB,GAElErD,EAAK/E,iBAAiB5jC,KAAK6oB,MAAO2mB,EAAiB,EAAGc,EAAmBC,EAAwBvE,EAAiBoB,EAAqBrJ,EAAQjiC,GAC/IkqC,GAAkBuE,EACdC,EACA,KAXJ,CAaJ,CACA,OAAO1uC,CACX,GAAC,CAAAjB,IAAA,uBAAAY,MACD,SAAqBuqC,EAAgByE,EAAYC,GAC7C1E,EAAiBhsC,KAAKksC,uBAAuBF,GAC7C,IAAMtuB,EAAI1d,KAAK6oC,6BAA6B+D,WAAWZ,EAAiB,GAClE/+B,EAAYyQ,EAAEvF,MACd00B,EAAYnvB,EAAEmvB,UACdlE,EAAO3oC,KAAKonC,qBAAqBn6B,GACjC6c,EAAY6e,EAAK/T,qBAAqB50B,KAAK6oB,MAAO5b,EAAY,EAAG4/B,GACjE9iB,EAAY4e,EAAK9T,qBAAqB70B,KAAK6oB,MAAO5b,EAAY,EAAG4/B,GACnE4D,EAAa3mB,IACb2mB,EAAa3mB,GAEb2mB,EAAa1mB,IACb0mB,EAAa1mB,GAEjB,IAAM4mB,EAAsBhI,EAAKuE,6BAA6BL,EAAW4D,GAEzE,OAD8BzwC,KAAK6oB,MAAM+nB,iBAAiB,IAAIxiC,EAAAA,EAASnB,EAAY,EAAG0jC,IAC5D3vB,OAAO0vB,GACtB,IAAItiC,EAAAA,EAAS49B,EAAgByE,GAEjCzwC,KAAKm0B,mCAAmCuc,EAAsBrvC,WAAYqvC,EAAsBpvC,OAC3G,GAAC,CAAAT,IAAA,oBAAAY,MACD,SAAkBuyB,EAAW6c,GACzB,IAAMC,EAAiB9wC,KAAK+wC,qBAAqB/c,EAAU/wB,gBAAiB+wB,EAAU9wB,YAAa2tC,EAAmBG,oBAChHC,EAAejxC,KAAK+wC,qBAAqB/c,EAAU5wB,cAAe4wB,EAAU3wB,UAAWwtC,EAAmBK,kBAChH,OAAO,IAAIr9B,EAAAA,EAAMi9B,EAAezvC,WAAYyvC,EAAexvC,OAAQ2vC,EAAa5vC,WAAY4vC,EAAa3vC,OAC7G,GAAC,CAAAT,IAAA,qCAAAY,MACD,SAAmCuqC,EAAgByE,GAC/C,IAAM51B,EAAO7a,KAAKutC,gBAAgBvB,GAC5B/G,EAAcjlC,KAAKonC,qBAAqBvsB,EAAKooB,gBAAkB,GAAGiK,6BAA6BryB,EAAKmyB,wBAAyByD,GAEnI,OAAOzwC,KAAK6oB,MAAM+nB,iBAAiB,IAAIxiC,EAAAA,EAASyM,EAAKooB,gBAAiBgC,GAC1E,GAAC,CAAApkC,IAAA,+BAAAY,MACD,SAA6BuyB,GACzB,IAAM3mB,EAAQrN,KAAKosC,mCAAmCpY,EAAU/wB,gBAAiB+wB,EAAU9wB,aACrFkxB,EAAMp0B,KAAKosC,mCAAmCpY,EAAU5wB,cAAe4wB,EAAU3wB,WACvF,OAAO,IAAIwQ,EAAAA,EAAMxG,EAAMhM,WAAYgM,EAAM/L,OAAQ8yB,EAAI/yB,WAAY+yB,EAAI9yB,OACzE,GAAC,CAAAT,IAAA,qCAAAY,MACD,SAAmCgiC,EAAkByG,GAAgH,IAAlGhF,EAAQxQ,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,GAAAA,UAAA,GAAG,EAA+Byc,EAAmBzc,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,IAAAA,UAAA,GAAU0c,EAAiB1c,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,IAAAA,UAAA,GACjJ2c,EAAgBrxC,KAAK6oB,MAAM+nB,iBAAiB,IAAIxiC,EAAAA,EAASq1B,EAAkByG,IAC3EoH,EAAkBD,EAAchwC,WAChC4jC,EAAcoM,EAAc/vC,OAC9B2L,EAAYqkC,EAAkB,EAAGC,GAAmB,EACxD,GAAIH,EACA,KAAOnkC,EAAYjN,KAAKonC,qBAAqBxlC,SAAW5B,KAAKonC,qBAAqBn6B,GAAWw1B,aACzFx1B,IACAskC,GAAmB,OAIvB,KAAOtkC,EAAY,IAAMjN,KAAKonC,qBAAqBn6B,GAAWw1B,aAC1Dx1B,IACAskC,GAAmB,EAG3B,GAAkB,IAAdtkC,IAAoBjN,KAAKonC,qBAAqBn6B,GAAWw1B,YAIzD,OAAO,IAAIr0B,EAAAA,EAAS+iC,EAAsB,EAAI,EAAG,GAErD,IAAMnM,EAAkB,EAAIhlC,KAAK6oC,6BAA6B+B,aAAa39B,GAc3E,OAZIskC,EACIH,EACIpxC,KAAKonC,qBAAqBn6B,GAAW0hC,+BAA+B3J,EAAiB,EAAGE,GAGxFllC,KAAKonC,qBAAqBn6B,GAAW0hC,+BAA+B3J,EAAiBhlC,KAAK6oB,MAAMM,iBAAiBlc,EAAY,GAAIi4B,GAIrIllC,KAAKonC,qBAAqBkK,EAAkB,GAAG3C,+BAA+B3J,EAAiBC,EAAaC,EAIxH,GACA,CAAArkC,IAAA,+BAAAY,MAGA,SAA6BwyB,GAAsD,IAA1CiR,EAAQxQ,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,GAAAA,UAAA,GAAG,EAChD,GAAIT,EAAWvgB,UAAW,CACtB,IAAMrG,EAAQrN,KAAKm0B,mCAAmCF,EAAWhxB,gBAAiBgxB,EAAW/wB,YAAagiC,GAC1G,OAAOrxB,EAAAA,EAAMi6B,cAAczgC,EAC/B,CAEI,IAAMA,EAAQrN,KAAKm0B,mCAAmCF,EAAWhxB,gBAAiBgxB,EAAW/wB,YAAa,GACpGkxB,EAAMp0B,KAAKm0B,mCAAmCF,EAAW7wB,cAAe6wB,EAAW5wB,UAAW,GACpG,OAAO,IAAIwQ,EAAAA,EAAMxG,EAAMhM,WAAYgM,EAAM/L,OAAQ8yB,EAAI/yB,WAAY+yB,EAAI9yB,OAE7E,GAAC,CAAAT,IAAA,mCAAAY,MACD,SAAiCwhC,EAAiBuO,GAC9C,IAAIvkC,EAAYg2B,EAAkB,EAClC,GAAIjjC,KAAKonC,qBAAqBn6B,GAAWw1B,YAAa,CAElD,IAAMuC,EAAkB,EAAIhlC,KAAK6oC,6BAA6B+B,aAAa39B,GAC3E,OAAOjN,KAAKonC,qBAAqBn6B,GAAWyiC,iCAAiC1K,EAAiBwM,EAClG,CAEA,KAAOvkC,EAAY,IAAMjN,KAAKonC,qBAAqBn6B,GAAWw1B,aAC1Dx1B,IAEJ,GAAkB,IAAdA,IAAoBjN,KAAKonC,qBAAqBn6B,GAAWw1B,YAEzD,OAAO,EAEX,IAAMuC,EAAkB,EAAIhlC,KAAK6oC,6BAA6B+B,aAAa39B,GAC3E,OAAOjN,KAAKonC,qBAAqBn6B,GAAWyiC,iCAAiC1K,EAAiBhlC,KAAK6oB,MAAMM,iBAAiBlc,EAAY,GAC1I,GAAC,CAAApM,IAAA,wBAAAY,MACD,SAAsB9B,EAAOyB,EAASqwC,EAAqBhd,EAAwBE,GAC/E,IAAMsa,EAAajvC,KAAKosC,mCAAmCzsC,EAAMsD,gBAAiBtD,EAAMuD,aAClFgsC,EAAWlvC,KAAKosC,mCAAmCzsC,EAAMyD,cAAezD,EAAM0D,WACpF,GAAI6rC,EAAS7tC,WAAa4tC,EAAW5tC,YAAc1B,EAAMyD,cAAgBzD,EAAMsD,gBAG3E,OAAOjD,KAAK6oB,MAAMkM,sBAAsB,IAAIlhB,EAAAA,EAAMo7B,EAAW5tC,WAAY,EAAG6tC,EAAS7tC,WAAY6tC,EAAS5tC,QAASF,EAASqwC,EAAqBhd,EAAwBE,GAM7K,IAJA,IAAI7yB,EAAS,GACPutC,EAAsBJ,EAAW5tC,WAAa,EAC9CiuC,EAAoBJ,EAAS7tC,WAAa,EAC5CkuC,EAAW,KACNC,EAAiBH,EAAqBG,GAAkBF,EAAmBE,IAAkB,CAElG,GADaxvC,KAAKonC,qBAAqBoI,GAC9B/M,YAEY,OAAb8M,IACAA,EAAW,IAAInhC,EAAAA,EAASohC,EAAiB,EAAGA,IAAmBH,EAAsBJ,EAAW3tC,OAAS,SAK7G,GAAiB,OAAbiuC,EAAmB,CACnB,IAAMxxB,EAAgB/d,KAAK6oB,MAAMM,iBAAiBqmB,GAClD1tC,EAASA,EAAO2C,OAAOzE,KAAK6oB,MAAMkM,sBAAsB,IAAIlhB,EAAAA,EAAM07B,EAASluC,WAAYkuC,EAASjuC,OAAQkuC,EAAgBzxB,GAAgB3c,EAASqwC,EAAqBhd,IACtK8a,EAAW,IACf,CAER,CACiB,OAAbA,IACAztC,EAASA,EAAO2C,OAAOzE,KAAK6oB,MAAMkM,sBAAsB,IAAIlhB,EAAAA,EAAM07B,EAASluC,WAAYkuC,EAASjuC,OAAQ4tC,EAAS7tC,WAAY6tC,EAAS5tC,QAASF,EAASqwC,EAAqBhd,IAC7K8a,EAAW,MAEfztC,EAAOwB,MAAK,SAACC,EAAGC,GACZ,IAAMkuC,EAAM79B,EAAAA,EAAMw0B,yBAAyB9kC,EAAE5D,MAAO6D,EAAE7D,OACtD,OAAY,IAAR+xC,EACInuC,EAAE0X,GAAKzX,EAAEyX,IACD,EAER1X,EAAE0X,GAAKzX,EAAEyX,GACF,EAEJ,EAEJy2B,CACX,IAEA,IAGwBzY,EAHlB0Y,EAAc,GAChBC,EAAiB,EACjBC,EAAY,KAAK3Y,GAAAj3B,EAAAA,EAAAA,GACHH,GAAM,IAAxB,IAAAo3B,EAAAh3B,MAAA+2B,EAAAC,EAAA/2B,KAAAC,MAA0B,KAAfwb,EAAGqb,EAAAx3B,MACJsnC,EAAQnrB,EAAI3C,GACd42B,IAAc9I,IAIlB8I,EAAY9I,EACZ4I,EAAYC,KAAoBh0B,EACpC,CAAC,OAAApb,GAAA02B,EAAAz2B,EAAAD,EAAA,SAAA02B,EAAAx2B,GAAA,CACD,OAAOivC,CACX,GAAC,CAAA9wC,IAAA,oBAAAY,MACD,SAAkBmN,GACd,IAAMiM,EAAO7a,KAAKutC,gBAAgB3+B,EAASvN,YAC3C,OAAOrB,KAAKonC,qBAAqBvsB,EAAKooB,gBAAkB,GAAG6O,kBAAkBj3B,EAAKmyB,wBAAyBp+B,EAAStN,OACxH,GAAC,CAAAT,IAAA,oBAAAY,MACD,SAAkBmN,EAAUs2B,GACxB,IAAMrqB,EAAO7a,KAAKutC,gBAAgB3+B,EAASvN,YAC3C,OAAOrB,KAAKonC,qBAAqBvsB,EAAKooB,gBAAkB,GAAG8O,kBAAkBl3B,EAAKmyB,wBAAyBp+B,EAAUs2B,EACzH,GAAC,CAAArkC,IAAA,sBAAAY,MACD,SAAoBJ,GAChB,IAAMwZ,EAAO7a,KAAKutC,gBAAgBlsC,GAClC,OAAqC,IAAjCwZ,EAAKmyB,wBACEhtC,KAAK6oB,MAAMmpB,oBAAoBn3B,EAAKooB,iBAKxC,CACX,KAACqD,CAAA,CAptBwC,GAuvB7C,IAGMwG,GAAYptC,EAAAA,EAAAA,IACd,SAAAotC,EAAY7J,EAAiB+J,IAAyBjtC,EAAAA,EAAAA,GAAA,KAAA+sC,GAClD9sC,KAAKijC,gBAAkBA,EACvBjjC,KAAKgtC,wBAA0BA,CACnC,IAKEe,IAA+BruC,EAAAA,EAAAA,IACjC,SAAAquC,EAAY9Z,EAAY0Z,IAAW5tC,EAAAA,EAAAA,GAAA,KAAAguC,GAC/B/tC,KAAKi0B,WAAaA,EAClBj0B,KAAK2tC,UAAYA,CACrB,IAEE1G,GAAoB,WACtB,SAAAA,EAAYgL,IAAOlyC,EAAAA,EAAAA,GAAA,KAAAknC,GACfjnC,KAAKkyC,OAASD,CAClB,CA6BC,OA5BDvyC,EAAAA,EAAAA,GAAAunC,EAAA,EAAApmC,IAAA,qCAAAY,MACA,SAAmCqtC,GAC/B,OAAO9uC,KAAKkyC,OAAO9F,mCAAmC0C,EAAaztC,WAAYytC,EAAaxtC,OAChG,GAAC,CAAAT,IAAA,+BAAAY,MACD,SAA6BuyB,GACzB,OAAOh0B,KAAKkyC,OAAOC,6BAA6Bne,EACpD,GAAC,CAAAnzB,IAAA,uBAAAY,MACD,SAAqBqtC,EAAc4B,GAC/B,OAAO1wC,KAAKkyC,OAAOnB,qBAAqBjC,EAAaztC,WAAYytC,EAAaxtC,OAAQovC,EAC1F,GAAC,CAAA7vC,IAAA,oBAAAY,MACD,SAAkBuyB,EAAW6c,GACzB,OAAO7wC,KAAKkyC,OAAOE,kBAAkBpe,EAAW6c,EACpD,GACA,CAAAhwC,IAAA,qCAAAY,MACA,SAAmC0qC,EAAejH,EAAUmN,EAAWjB,GACnE,OAAOpxC,KAAKkyC,OAAO/d,mCAAmCgY,EAAc9qC,WAAY8qC,EAAc7qC,OAAQ4jC,EAAUmN,EAAWjB,EAC/H,GAAC,CAAAvwC,IAAA,+BAAAY,MACD,SAA6BwyB,EAAYiR,GACrC,OAAOllC,KAAKkyC,OAAO7d,6BAA6BJ,EAAYiR,EAChE,GAAC,CAAArkC,IAAA,yBAAAY,MACD,SAAuB0qC,GACnB,OAAOnsC,KAAKkyC,OAAOI,uBAAuBnG,EAAc9qC,WAAY8qC,EAAc7qC,OACtF,GAAC,CAAAT,IAAA,4BAAAY,MACD,SAA0BwhC,GACtB,OAAOjjC,KAAKkyC,OAAOK,0BAA0BtP,EACjD,GAAC,CAAApiC,IAAA,mCAAAY,MACD,SAAiCwhC,EAAiBuO,GAC9C,OAAOxxC,KAAKkyC,OAAOxC,iCAAiCzM,EAAiBuO,EACzE,KAACvK,CAAA,CAhCqB,GAkCbuL,GAA2B,WACpC,SAAAA,EAAY3pB,IAAO9oB,EAAAA,EAAAA,GAAA,KAAAyyC,GACfxyC,KAAK6oB,MAAQA,CACjB,CAuGC,OAvGAnpB,EAAAA,EAAAA,GAAA8yC,EAAA,EAAA3xC,IAAA,UAAAY,MACD,WACA,GAAC,CAAAZ,IAAA,6BAAAY,MACD,WACI,OAAO,IAAIgxC,GAA6BzyC,KAC5C,GAAC,CAAAa,IAAA,iBAAAY,MACD,WACI,MAAO,EACX,GAAC,CAAAZ,IAAA,iBAAAY,MACD,SAAeunC,GACX,OAAO,CACX,GAAC,CAAAnoC,IAAA,aAAAY,MACD,SAAWixC,GACP,OAAO,CACX,GAAC,CAAA7xC,IAAA,sBAAAY,MACD,SAAoBkxC,EAAWC,EAAmBC,EAAiBC,GAC/D,OAAO,CACX,GAAC,CAAAjyC,IAAA,2BAAAY,MACD,WACI,IAAMK,EAAS,GACf,MAAO,CACHyqB,WAAY,SAAC7qB,EAAUW,EAAcmqB,GACjC1qB,EAAOkB,KAAK,KAChB,EACAypB,SAAU,WACN,OAAO3qB,CACX,EAER,GAAC,CAAAjB,IAAA,iBAAAY,MACD,WACA,GAAC,CAAAZ,IAAA,sBAAAY,MACD,SAAoBsxC,EAAYnvC,EAAgBC,GAC5C,OAAO,IAAIknC,EAAAA,GAAiCnnC,EAAgBC,EAChE,GAAC,CAAAhD,IAAA,uBAAAY,MACD,SAAqBsxC,EAAYnvC,EAAgBC,EAAconC,GAC3D,OAAO,IAAIF,EAAAA,GAAkCnnC,EAAgBC,EACjE,GAAC,CAAAhD,IAAA,qBAAAY,MACD,SAAmBsxC,EAAY1xC,EAAYmhC,GACvC,MAAO,EAAC,EAAO,IAAIuI,EAAAA,GAAiC1pC,EAAY,GAAI,KAAM,KAC9E,GAAC,CAAAR,IAAA,kBAAAY,MACD,SAAgBsxC,GAChB,GAAC,CAAAlyC,IAAA,mBAAAY,MACD,WACI,OAAOzB,KAAK6oB,MAAMwnB,cACtB,GAAC,CAAAxvC,IAAA,uBAAAY,MACD,SAAqBuqC,EAAgBgH,EAAgBC,GACjD,MAAO,CACHhwC,gBAAiB+oC,EACjB5oC,cAAe4oC,EACfW,OAAQ,EAEhB,GAAC,CAAA9rC,IAAA,4BAAAY,MACD,SAA0BwB,EAAiBG,EAAe8vC,GACtD,OAAO,IAAIjqC,MAAM7F,EAAgBH,EAAkB,GAAGkwC,KAAK,GAC/D,GAAC,CAAAtyC,IAAA,2BAAAY,MACD,SAAyB2rC,EAAqBC,GAG1C,IAFA,IAAMpB,EAAgBoB,EAAoBD,EAAsB,EAC1DtrC,EAAS,IAAImH,MAAMgjC,GAChB1nC,EAAI,EAAGA,EAAI0nC,EAAe1nC,IAC/BzC,EAAOyC,GAAK,EAEhB,OAAOzC,CACX,GAAC,CAAAjB,IAAA,qBAAAY,MACD,SAAmBuqC,GACf,OAAOhsC,KAAK6oB,MAAM7V,eAAeg5B,EACrC,GAAC,CAAAnrC,IAAA,oBAAAY,MACD,SAAkBuqC,GACd,OAAOhsC,KAAK6oB,MAAMtZ,cAAcy8B,EACpC,GAAC,CAAAnrC,IAAA,uBAAAY,MACD,SAAqBuqC,GACjB,OAAOhsC,KAAK6oB,MAAMK,iBAAiB8iB,EACvC,GAAC,CAAAnrC,IAAA,uBAAAY,MACD,SAAqBuqC,GACjB,OAAOhsC,KAAK6oB,MAAMM,iBAAiB6iB,EACvC,GAAC,CAAAnrC,IAAA,kBAAAY,MACD,SAAgBuqC,GACZ,IAAMphC,EAAa5K,KAAK6oB,MAAMqN,aAAa1mB,cAAcw8B,GACnDp6B,EAAchH,EAAWoI,iBAC/B,OAAO,IAAI6W,EAAAA,GAAajY,GAAa,EAAO,EAAGA,EAAYhQ,OAAS,EAAG,EAAGgJ,EAAW86B,UAAW,KACpG,GAAC,CAAA7kC,IAAA,mBAAAY,MACD,SAAiB2rC,EAAqBC,EAAmBtJ,GACrD,IAAMxM,EAAYv3B,KAAK6oB,MAAMwnB,eAC7BjD,EAAsBh7B,KAAKc,IAAId,KAAK8D,IAAI,EAAGk3B,GAAsB7V,GACjE8V,EAAoBj7B,KAAKc,IAAId,KAAK8D,IAAI,EAAGm3B,GAAoB9V,GAE7D,IADA,IAAMz1B,EAAS,GACNT,EAAa+rC,EAAqB/rC,GAAcgsC,EAAmBhsC,IAAc,CACtF,IAAMiiC,EAAMjiC,EAAa+rC,EACzBtrC,EAAOwhC,GAAOS,EAAOT,GAAOtjC,KAAK6lC,gBAAgBxkC,GAAc,IACnE,CACA,OAAOS,CACX,GAAC,CAAAjB,IAAA,wBAAAY,MACD,SAAsB9B,EAAOyB,EAASqwC,EAAqBhd,EAAwBE,GAC/E,OAAO30B,KAAK6oB,MAAMkM,sBAAsBp1B,EAAOyB,EAASqwC,EAAqBhd,EAAwBE,EACzG,GAAC,CAAA9zB,IAAA,oBAAAY,MACD,SAAkBmN,EAAUs2B,GACxB,OAAOllC,KAAK6oB,MAAMkpB,kBAAkBnjC,EAAUs2B,EAClD,GAAC,CAAArkC,IAAA,sBAAAY,MACD,SAAoBJ,GAChB,OAAOrB,KAAK6oB,MAAMmpB,oBAAoB3wC,EAC1C,GAAC,CAAAR,IAAA,oBAAAY,MACD,SAAkBmN,GAEd,OAAO,IACX,KAAC4jC,CAAA,CA1GmC,GA4GlCC,GAA4B,WAC9B,SAAAA,EAAYR,IAAOlyC,EAAAA,EAAAA,GAAA,KAAA0yC,GACfzyC,KAAKkyC,OAASD,CAClB,CAwCC,OAxCAvyC,EAAAA,EAAAA,GAAA+yC,EAAA,EAAA5xC,IAAA,iBAAAY,MACD,SAAe2xC,GACX,OAAOpzC,KAAKkyC,OAAOrpB,MAAM+nB,iBAAiBwC,EAC9C,GAAC,CAAAvyC,IAAA,cAAAY,MACD,SAAY9B,GACR,OAAOK,KAAKkyC,OAAOrpB,MAAMygB,cAAc3pC,EAC3C,GACA,CAAAkB,IAAA,qCAAAY,MACA,SAAmCqtC,GAC/B,OAAO9uC,KAAKqzC,eAAevE,EAC/B,GAAC,CAAAjuC,IAAA,+BAAAY,MACD,SAA6BuyB,GACzB,OAAOh0B,KAAKszC,YAAYtf,EAC5B,GAAC,CAAAnzB,IAAA,uBAAAY,MACD,SAAqB8xC,EAAe7C,GAChC,OAAO1wC,KAAKqzC,eAAe3C,EAC/B,GAAC,CAAA7vC,IAAA,oBAAAY,MACD,SAAkB+xC,EAAY3C,GAC1B,OAAO7wC,KAAKszC,YAAYzC,EAC5B,GACA,CAAAhwC,IAAA,qCAAAY,MACA,SAAmC0qC,GAC/B,OAAOnsC,KAAKqzC,eAAelH,EAC/B,GAAC,CAAAtrC,IAAA,+BAAAY,MACD,SAA6BwyB,GACzB,OAAOj0B,KAAKszC,YAAYrf,EAC5B,GAAC,CAAApzB,IAAA,yBAAAY,MACD,SAAuB0qC,GACnB,IAAM5U,EAAYv3B,KAAKkyC,OAAOrpB,MAAMwnB,eACpC,QAAIlE,EAAc9qC,WAAa,GAAK8qC,EAAc9qC,WAAak2B,EAKnE,GAAC,CAAA12B,IAAA,4BAAAY,MACD,SAA0BwhC,GACtB,OAAO,CACX,GAAC,CAAApiC,IAAA,mCAAAY,MACD,SAAiCwhC,EAAiBuO,GAC9C,OAAOvO,CACX,KAACwP,CAAA,CA3C6B,GC14BrBgB,GAAS,SAAArqC,IAAAjJ,EAAAA,EAAAA,GAAAszC,EAAArqC,GAAA,IAAAhJ,GAAAC,EAAAA,EAAAA,GAAAozC,GAClB,SAAAA,EAAYngB,EAAUR,EAAejK,EAAO0d,EAA8BC,EAAoC7I,EAA8B+V,EAA8BC,EAAeC,GAAe,IAAAlzC,EAgBpM,IAhBoMX,EAAAA,EAAAA,GAAA,KAAA0zC,IACpM/yC,EAAAN,EAAAO,KAAA,OACK+yC,6BAA+BA,EACpChzC,EAAKizC,cAAgBA,EACrBjzC,EAAKkzC,cAAgBA,EACrBlzC,EAAKmzC,iBAAmB,IAAIC,GAC5BpzC,EAAKqzC,oBAAsB,GAC3BrzC,EAAKgmC,UAAYpT,EACjB5yB,EAAK4+B,eAAiBxM,EACtBpyB,EAAKmoB,MAAQA,EACbnoB,EAAKszC,iBAAmB,IAAIC,EAAAA,GAC5BvzC,EAAKwzC,QAAUxzC,EAAKszC,iBAAiBE,QACrCxzC,EAAKyzC,aAAe,IAAIC,EAAAA,GAAoB1zC,EAAKmoB,MAAMvZ,gBAAiB5O,EAAKmoB,MAAMwrB,aAAc3zC,EAAK4+B,eAAgB5+B,EAAKgzC,8BAC3HhzC,EAAK4zC,kCAAoC5zC,EAAK2J,UAAU,IAAIkqC,EAAAA,IAAiB,kBAAM7zC,EAAK8zC,sCAAsC,GAAE,IAChI9zC,EAAK+zC,WAAY,EACjB/zC,EAAKg0C,eAAiBC,GAAcnjB,OAAO9wB,EAAKmoB,OACXnoB,EAAKmoB,MAAM+rB,4BAC5Cl0C,EAAKwxC,OAAS,IAAIM,GAA4B9xC,EAAKmoB,WAElD,CACD,IAAMtnB,EAAUb,EAAK4+B,eAAe/9B,QAC9B0qB,EAAW1qB,EAAQT,IAAI,IACvB2lC,EAAmBllC,EAAQT,IAAI,KAC/B6/B,EAAep/B,EAAQT,IAAI,KAC3BqrB,EAAiB5qB,EAAQT,IAAI,KAC7BsrB,EAAY7qB,EAAQT,IAAI,KAC9BJ,EAAKwxC,OAAS,IAAI5L,EAAiC5lC,EAAKgmC,UAAWhmC,EAAKmoB,MAAO0d,EAA8BC,EAAoCva,EAAUvrB,EAAKmoB,MAAMwrB,aAAap0B,QAASwmB,EAAkB9F,EAAazU,eAAgBC,EAAgBC,EAC/P,CAmC4C,OAlC5C1rB,EAAK8yB,qBAAuB9yB,EAAKwxC,OAAO2C,6BACxCn0C,EAAKo0C,QAAUp0C,EAAK2J,UAAU,IAAI0qC,EAAAA,EAAkBlsB,GAAKmsB,EAAAA,EAAAA,GAAAt0C,GAAQA,EAAK8yB,qBAAsB9yB,EAAKyzC,eACjGzzC,EAAKuyB,WAAavyB,EAAK2J,UAAU,IAAI80B,EAAWz+B,EAAK4+B,eAAgB5+B,EAAK2vC,eAAgB1S,IAC1Fj9B,EAAK2J,UAAU3J,EAAKuyB,WAAWiL,aAAY,SAACz7B,GACpCA,EAAEwa,kBACFvc,EAAKu0C,6BAELxyC,EAAEwa,kBACFvc,EAAKg0C,eAAeQ,aAExBx0C,EAAKszC,iBAAiBmB,oBAAoB,IAAIpK,EAAAA,GAAkCtoC,IAChF/B,EAAKszC,iBAAiBoB,kBAAkB,IAAIC,EAAAA,GAAmB5yC,EAAE6yC,eAAgB7yC,EAAE8yC,cAAe9yC,EAAE+yC,gBAAiB/yC,EAAEgzC,aAAchzC,EAAEia,YAAaja,EAAEka,WAAYla,EAAEma,aAAcna,EAAEoa,WACxL,KACAnc,EAAK2J,UAAU3J,EAAKuyB,WAAW4K,wBAAuB,SAACp7B,GACnD/B,EAAKszC,iBAAiBoB,kBAAkB3yC,EAC5C,KACA/B,EAAKg1C,aAAe,IAAIriB,EAAAA,GAAqB3yB,EAAKgmC,UAAWhmC,EAAKmoB,MAAOnoB,EAAK4+B,eAAgB5+B,EAAKwxC,OAAQxxC,EAAK8yB,sBAChH9yB,EAAKi1C,uBACLj1C,EAAK2J,UAAU3J,EAAK4+B,eAAesW,iBAAgB,SAACnzC,GAChD,IACI,IAAMozC,EAAkBn1C,EAAKszC,iBAAiB8B,sBAC9Cp1C,EAAKq1C,wBAAwBF,EAAiBpzC,EAClD,CAAC,QAEG/B,EAAKszC,iBAAiBgC,mBAC1B,CACJ,KACAt1C,EAAK2J,UAAUwgB,EAAAA,EAA0BorB,cAAc/uC,aAAY,WAC/DxG,EAAKszC,iBAAiBmB,oBAAoB,IAAIpK,EAAAA,GAClD,KACArqC,EAAK2J,UAAU3J,EAAKizC,cAAcuC,uBAAsB,SAAC/4B,GACrDzc,EAAKy1C,mCACLz1C,EAAKszC,iBAAiBmB,oBAAoB,IAAIpK,EAAAA,GAAiC5tB,GACnF,KACAzc,EAAK8zC,uCAAuC9zC,CAChD,CA0xBC,OA1xBAhB,EAAAA,EAAAA,GAAA+zC,EAAA,EAAA5yC,IAAA,UAAAY,MACD,YAGImI,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,GAAA4pC,EAAA3pC,WAAA,gBAAAnJ,KAAA,MACAX,KAAK01C,aAAaxtC,UAClBlI,KAAKkyC,OAAOhqC,UACZlI,KAAK00C,eAAexsC,UACpBlI,KAAKg0C,iBAAiB9rC,SAC1B,GAAC,CAAArH,IAAA,2BAAAY,MACD,WACI,OAAOzB,KAAKkyC,OAAOxK,0BACvB,GAAC,CAAA7mC,IAAA,sBAAAY,MACD,SAAoByxB,GAChBlzB,KAAKg0C,iBAAiB7gB,oBAAoBD,EAC9C,GAAC,CAAAryB,IAAA,yBAAAY,MACD,SAAuByxB,GACnBlzB,KAAKg0C,iBAAiB5gB,uBAAuBF,EACjD,GAAC,CAAAryB,IAAA,uCAAAY,MACD,WACIzB,KAAKs/B,eAAe8W,iBAAiBp2C,KAAKkyC,OAAOrN,mBACrD,GAAC,CAAAhkC,IAAA,wBAAAY,MACD,WACI,IAAM40C,EAAoBr2C,KAAKizB,WAAWiP,uBACpCoU,EAAmB,IAAIziC,EAAAA,EAAMwiC,EAAkBpzC,gBAAiBjD,KAAKkpB,iBAAiBmtB,EAAkBpzC,iBAAkBozC,EAAkBjzC,cAAepD,KAAKmpB,iBAAiBktB,EAAkBjzC,gBAEzM,OAD2BpD,KAAKu2C,sBAAsBD,EAE1D,GAAC,CAAAz1C,IAAA,yBAAAY,MACD,WACI,IAAM+0C,EAAqBx2C,KAAKy2C,wBAChCz2C,KAAK4zC,cAAc8C,gBAAgBF,GAAoB,EAC3D,GAAC,CAAA31C,IAAA,6BAAAY,MACD,WACI,IAAM+0C,EAAqBx2C,KAAKy2C,wBAChCz2C,KAAK4zC,cAAc8C,gBAAgBF,GAAoB,EAC3D,GAAC,CAAA31C,IAAA,cAAAY,MACD,SAAYk1C,GACR32C,KAAKy0C,UAAYkC,EACjB32C,KAAK80C,QAAQ8B,YAAYD,GACzB32C,KAAKg0C,iBAAiBmB,oBAAoB,IAAIpK,EAAAA,GAAiC4L,IAC/E32C,KAAKg0C,iBAAiBoB,kBAAkB,IAAIyB,EAAAA,IAAmBF,EAAUA,GAC7E,GAAC,CAAA91C,IAAA,qBAAAY,MACD,WACIzB,KAAKg0C,iBAAiBmB,oBAAoB,IAAIpK,EAAAA,GAClD,GAAC,CAAAlqC,IAAA,mBAAAY,MACD,WACIzB,KAAKg0C,iBAAiBmB,oBAAoB,IAAIpK,EAAAA,GAClD,GAAC,CAAAlqC,IAAA,yBAAAY,MACD,WAGI,GAAIzB,KAAK00C,eAAeoC,SAAW92C,KAAKizB,WAAW8jB,sBAAwB,EAAG,CAC1E,IAAMC,EAAoC,IAAI5oC,EAAAA,EAASpO,KAAK00C,eAAe1I,eAAgBhsC,KAAKkpB,iBAAiBlpB,KAAK00C,eAAe1I,iBAC/HiL,EAAqCj3C,KAAKwzB,qBAAqB4Y,mCAAmC4K,GACxG,OAAO,IAAIE,GAAeD,EAAoCj3C,KAAK00C,eAAeyC,eACtF,CACA,OAAO,IAAID,GAAe,KAAM,EACpC,GAAC,CAAAr2C,IAAA,0BAAAY,MACD,SAAwBo0C,EAAiBpzC,GACrC,IAAM20C,EAAiBp3C,KAAKq3C,yBACtB91C,EAAUvB,KAAKs/B,eAAe/9B,QAC9B0qB,EAAW1qB,EAAQT,IAAI,IACvB2lC,EAAmBllC,EAAQT,IAAI,KAC/B6/B,EAAep/B,EAAQT,IAAI,KAC3BqrB,EAAiB5qB,EAAQT,IAAI,KAC7BsrB,EAAY7qB,EAAQT,IAAI,KAC1Bd,KAAKkyC,OAAOoF,oBAAoBrrB,EAAUwa,EAAkB9F,EAAazU,eAAgBC,EAAgBC,KACzGypB,EAAgB0B,cAAc,IAAIxM,EAAAA,IAClC8K,EAAgB0B,cAAc,IAAIxM,EAAAA,IAClC8K,EAAgB0B,cAAc,IAAIxM,EAAAA,GAAuC,OACzE/qC,KAAK80C,QAAQ56B,qBAAqB27B,GAClC71C,KAAK01C,aAAax7B,uBAClBla,KAAKizB,WAAWlZ,UAAU/Z,KAAKqwC,gBAC/BrwC,KAAKs0C,kCAAkCkD,YAEvC/0C,EAAEyY,WAAW,MAEblb,KAAK01C,aAAa+B,QAClB5B,EAAgB0B,cAAc,IAAIxM,EAAAA,GAAuC,QAE7E8K,EAAgB0B,cAAc,IAAIxM,EAAAA,GAAyCtoC,IAC3EzC,KAAKizB,WAAWrZ,uBAAuBnX,GACvC20C,EAAeM,qBAAqB13C,KAAKwzB,qBAAsBxzB,KAAKizB,YAChEmhB,EAAAA,GAAoBuD,eAAel1C,KACnCzC,KAAKm0C,aAAe,IAAIC,EAAAA,GAAoBp0C,KAAK6oB,MAAMvZ,gBAAiBtP,KAAK6oB,MAAMwrB,aAAcr0C,KAAKs/B,eAAgBt/B,KAAK0zC,8BAC3H1zC,KAAK80C,QAAQ8C,oBAAoB53C,KAAKm0C,cAE9C,GAAC,CAAAtzC,IAAA,uBAAAY,MACD,WAAuB,IAAAwG,EAAA,KACnBjI,KAAKqK,UAAUrK,KAAK6oB,MAAMgvB,kCAAiC,SAACp1C,GACxD,IACI,IAO4BZ,EAPtBg0C,EAAkB5tC,EAAK+rC,iBAAiB8B,sBAC1CgC,GAAsB,EACtBC,GAA2C,EACzC9zC,EAAWxB,aAAau1C,EAAAA,GAAkDv1C,EAAEmC,uBAAuBX,QAAUxB,EAAEwB,QAC/GC,EAAazB,aAAau1C,EAAAA,GAAkDv1C,EAAEmC,uBAAuBV,UAAY,KAEjHujC,EAAqBx/B,EAAKiqC,OAAOxK,2BAA2B1lC,GAAAC,EAAAA,EAAAA,GAC7CgC,GAAO,IAA5B,IAAAjC,EAAAE,MAAAL,EAAAG,EAAAG,KAAAC,MAA8B,KAAnBu2B,EAAM92B,EAAAJ,MACb,OAAQk3B,EAAOz3B,YACX,KAAK,EACD,IAAK,IAAI+2C,EAAU,EAAGA,EAAUtf,EAAOj1B,OAAO9B,OAAQq2C,IAAW,CAC7D,IAAMtP,EAAOhQ,EAAOj1B,OAAOu0C,GACvB51C,EAAes2B,EAAOh3B,cAAcs2C,GACpC51C,IACAA,EAAeA,EAAa2sC,QAAO,SAAA//B,GAAO,OAAMA,EAAQ7N,SAAW6N,EAAQ7N,UAAY6G,EAAKy+B,SAAS,KAEzGe,EAAmBlb,WAAWoc,EAAMtmC,EAAc,KACtD,CACA,MAEJ,KAAK,EACD,IAAIA,EAAe,KACfs2B,EAAOt2B,eACPA,EAAes2B,EAAOt2B,aAAa2sC,QAAO,SAAA//B,GAAO,OAAMA,EAAQ7N,SAAW6N,EAAQ7N,UAAY6G,EAAKy+B,SAAS,KAEhHe,EAAmBlb,WAAWoM,EAAOj1B,OAAQrB,EAAc,MAIvE,CAAC,OAAAG,GAAAR,EAAAS,EAAAD,EAAA,SAAAR,EAAAU,GAAA,CACD,IAE4BE,EAFtBqoC,EAAaxD,EAAmBhb,WAChCyrB,EAAiB,IAAIC,EAAAA,GAAWlN,GAAYpoC,GAAAZ,EAAAA,EAAAA,GAC7BgC,GAAO,IAA5B,IAAApB,EAAAX,MAAAU,EAAAC,EAAAV,KAAAC,MAA8B,KAAnBu2B,EAAM/1B,EAAAnB,MACb,OAAQk3B,EAAOz3B,YACX,KAAK,EACD+G,EAAKiqC,OAAOkG,iBACZvC,EAAgB0B,cAAc,IAAIxM,EAAAA,IAClC9iC,EAAKytC,aAAa+B,QAClBxvC,EAAKgrB,WAAWlZ,UAAU9R,EAAKooC,gBAC/ByH,GAAsB,EACtB,MAEJ,KAAK,EACD,IAAMO,EAAoBpwC,EAAKiqC,OAAOoG,oBAAoBp0C,EAAWy0B,EAAO/0B,eAAgB+0B,EAAO90B,cACzE,OAAtBw0C,IACAxC,EAAgB0B,cAAcc,GAC9BpwC,EAAKgrB,WAAW7Y,eAAei+B,EAAkBz0C,eAAgBy0C,EAAkBx0C,eAEvFi0C,GAAsB,EACtB,MAEJ,KAAK,EACD,IAAMS,EAAqBL,EAAeM,UAAU7f,EAAOj1B,OAAO9B,QAC5D62C,EAAqBxwC,EAAKiqC,OAAOwG,qBAAqBx0C,EAAWy0B,EAAO/0B,eAAgB+0B,EAAO90B,aAAc00C,GACxF,OAAvBE,IACA5C,EAAgB0B,cAAckB,GAC9BxwC,EAAKgrB,WAAW5Y,gBAAgBo+B,EAAmB70C,eAAgB60C,EAAmB50C,eAE1Fi0C,GAAsB,EACtB,MAEJ,KAAK,EACD,IAAMa,EAAuBT,EAAeU,UAC5CC,EAAuF5wC,EAAKiqC,OAAO4G,mBAAmB50C,EAAWy0B,EAAOt3B,WAAYs3C,GAAqBI,GAAA1kC,EAAAA,EAAAA,GAAAwkC,EAAA,GAAlKrN,EAAkBuN,EAAA,GAAEC,EAAiBD,EAAA,GAAEN,EAAkBM,EAAA,GAAEV,EAAiBU,EAAA,GACnFhB,EAA2CvM,EACvCwN,GACAnD,EAAgB0B,cAAcyB,GAE9BP,IACA5C,EAAgB0B,cAAckB,GAC9BxwC,EAAKgrB,WAAW5Y,gBAAgBo+B,EAAmB70C,eAAgB60C,EAAmB50C,eAEtFw0C,IACAxC,EAAgB0B,cAAcc,GAC9BpwC,EAAKgrB,WAAW7Y,eAAei+B,EAAkBz0C,eAAgBy0C,EAAkBx0C,eASnG,CAAC,OAAArB,GAAAK,EAAAJ,EAAAD,EAAA,SAAAK,EAAAH,GAAA,CACiB,OAAdwB,GACA+D,EAAKiqC,OAAO+G,gBAAgB/0C,GAEhC+D,EAAKgrB,WAAWyO,wBACXoW,GAAuBC,IACxBlC,EAAgB0B,cAAc,IAAIxM,EAAAA,IAClC8K,EAAgB0B,cAAc,IAAIxM,EAAAA,GAAuC,OACzE9iC,EAAK6sC,QAAQ56B,qBAAqB27B,GAClC5tC,EAAKytC,aAAax7B,uBAE1B,CAAC,QAEGjS,EAAK+rC,iBAAiBgC,mBAC1B,CAEA,IAAMkD,EAAwBjxC,EAAKysC,eAAeoC,QAKlD,GAJA7uC,EAAKysC,eAAeQ,aACpBjtC,EAAKq3B,eAAe6Z,kBAAkBlxC,EAAK4gB,MAAMwnB,gBACjDpoC,EAAKusC,wCAEAvsC,EAAKwsC,WAAaxsC,EAAK4gB,MAAMuwB,0BAA4B,GAAKF,EAAuB,CACtF,IAAMjlB,EAAahsB,EAAK4gB,MAAMwwB,iBAAiBpxC,EAAKysC,eAAe4E,mBACnE,GAAIrlB,EAAY,CACZ,IAAM6a,EAAe7mC,EAAKurB,qBAAqBW,mCAAmCF,EAAW+c,oBACvFuI,EAAkBtxC,EAAKgrB,WAAWoI,+BAA+ByT,EAAaztC,YACpF4G,EAAKgrB,WAAWumB,kBAAkB,CAAE38B,UAAW08B,EAAkBtxC,EAAKysC,eAAeyC,gBAAkB,EAC3G,CACJ,CACA,IACI,IAAMtB,EAAkB5tC,EAAK+rC,iBAAiB8B,sBAC1CrzC,aAAau1C,EAAAA,IACbnC,EAAgBT,kBAAkB,IAAIqE,EAAAA,GAAyBh3C,EAAEoC,sBAErEoD,EAAK6sC,QAAQ4E,sBAAsB7D,EAAiBpzC,EACxD,CAAC,QAEGwF,EAAK+rC,iBAAiBgC,mBAC1B,CACA/tC,EAAKgtC,4BACT,KACAj1C,KAAKqK,UAAUrK,KAAK6oB,MAAM8wB,mBAAkB,SAACl3C,GAEzC,IADA,IAAMm3C,EAAa,GACVlyB,EAAI,EAAGmyB,EAAOp3C,EAAEuM,OAAOpN,OAAQ8lB,EAAImyB,EAAMnyB,IAAK,CACnD,IAAMuM,EAAaxxB,EAAEuM,OAAO0Y,GACtB0lB,EAAsBnlC,EAAKurB,qBAAqBW,mCAAmC,IAAI/lB,EAAAA,EAAS6lB,EAAWrwB,eAAgB,IAAIvC,WAC/HgsC,EAAoBplC,EAAKurB,qBAAqBW,mCAAmC,IAAI/lB,EAAAA,EAAS6lB,EAAWpwB,aAAcoE,EAAK4gB,MAAMM,iBAAiB8K,EAAWpwB,gBAAgBxC,WACpLu4C,EAAWlyB,GAAK,CACZ9jB,eAAgBwpC,EAChBvpC,aAAcwpC,EAEtB,CACAplC,EAAK+rC,iBAAiBmB,oBAAoB,IAAIpK,EAAAA,GAAkC6O,IAChF3xC,EAAK+rC,iBAAiBoB,kBAAkB,IAAI0E,EAAAA,GAAwBr3C,GACxE,KACAzC,KAAKqK,UAAUrK,KAAK6oB,MAAMkxB,kCAAiC,SAACt3C,GACxDwF,EAAK+rC,iBAAiBmB,oBAAoB,IAAIpK,EAAAA,IAC9C9iC,EAAKksC,aAAe,IAAIC,EAAAA,GAAoBnsC,EAAK4gB,MAAMvZ,gBAAiBrH,EAAK4gB,MAAMwrB,aAAcpsC,EAAKq3B,eAAgBr3B,EAAKyrC,8BAC3HzrC,EAAK6sC,QAAQ8C,oBAAoB3vC,EAAKksC,cACtClsC,EAAK+rC,iBAAiBoB,kBAAkB,IAAI4E,EAAAA,GAAuCv3C,GACvF,KACAzC,KAAKqK,UAAUrK,KAAK6oB,MAAMoxB,qBAAoB,SAACx3C,GAC3CwF,EAAKksC,aAAe,IAAIC,EAAAA,GAAoBnsC,EAAK4gB,MAAMvZ,gBAAiBrH,EAAK4gB,MAAMwrB,aAAcpsC,EAAKq3B,eAAgBr3B,EAAKyrC,8BAC3HzrC,EAAK6sC,QAAQ8C,oBAAoB3vC,EAAKksC,cACtClsC,EAAK+rC,iBAAiBoB,kBAAkB,IAAI8E,EAAAA,GAA0Bz3C,GAC1E,KACAzC,KAAKqK,UAAUrK,KAAK6oB,MAAMsxB,oBAAmB,SAAC13C,GAE1C,GAAIwF,EAAKiqC,OAAOkI,WAAWnyC,EAAK4gB,MAAMwrB,aAAap0B,SAAU,CACzD,IACI,IAAM41B,EAAkB5tC,EAAK+rC,iBAAiB8B,sBAC9CD,EAAgB0B,cAAc,IAAIxM,EAAAA,IAClC8K,EAAgB0B,cAAc,IAAIxM,EAAAA,IAClC8K,EAAgB0B,cAAc,IAAIxM,EAAAA,GAAuC,OACzE9iC,EAAK6sC,QAAQ56B,qBAAqB27B,GAClC5tC,EAAKytC,aAAax7B,uBAClBjS,EAAKgrB,WAAWlZ,UAAU9R,EAAKooC,eACnC,CAAC,QAEGpoC,EAAK+rC,iBAAiBgC,mBAC1B,CACA/tC,EAAKqsC,kCAAkCkD,UAC3C,CACAvvC,EAAKksC,aAAe,IAAIC,EAAAA,GAAoBnsC,EAAK4gB,MAAMvZ,gBAAiBrH,EAAK4gB,MAAMwrB,aAAcpsC,EAAKq3B,eAAgBr3B,EAAKyrC,8BAC3HzrC,EAAK6sC,QAAQ8C,oBAAoB3vC,EAAKksC,cACtClsC,EAAK+rC,iBAAiBoB,kBAAkB,IAAIiF,EAAAA,GAAyB53C,GACzE,KACAzC,KAAKqK,UAAUrK,KAAK6oB,MAAMyxB,wBAAuB,SAAC73C,GAC9CwF,EAAKytC,aAAa6E,4BAClBtyC,EAAK+rC,iBAAiBmB,oBAAoB,IAAIpK,EAAAA,GAAuCtoC,IACrFwF,EAAK+rC,iBAAiBoB,kBAAkB,IAAIoF,EAAAA,GAA6B/3C,GAC7E,IACJ,GAAC,CAAA5B,IAAA,iBAAAY,MACD,SAAeuN,EAAQsD,GACnBtS,KAAK6zC,iBAAiB5J,eAAe33B,EAAQtD,GAC7C,IAAMyrC,EAAez6C,KAAK6zC,iBAAiB6G,kBAC3C,GAAID,IAAiBz6C,KAAK+zC,oBAA1B,CAGA/zC,KAAK+zC,oBAAsB0G,EAC3B,IAAMrD,EAAiBp3C,KAAKq3C,yBACxB7L,GAAqB,EACzB,IACI,IAAMqK,EAAkB71C,KAAKg0C,iBAAiB8B,uBAC9CtK,EAAqBxrC,KAAKkyC,OAAOjI,eAAewQ,MAE5C5E,EAAgB0B,cAAc,IAAIxM,EAAAA,IAClC8K,EAAgB0B,cAAc,IAAIxM,EAAAA,IAClC8K,EAAgB0B,cAAc,IAAIxM,EAAAA,GAAuC,OACzE/qC,KAAK80C,QAAQ56B,qBAAqB27B,GAClC71C,KAAK01C,aAAax7B,uBAClBla,KAAKizB,WAAWlZ,UAAU/Z,KAAKqwC,gBAC/BrwC,KAAKizB,WAAWyO,wBAEpB0V,EAAeM,qBAAqB13C,KAAKwzB,qBAAsBxzB,KAAKizB,WACxE,CAAC,QAEGjzB,KAAKg0C,iBAAiBgC,mBAC1B,CACAh2C,KAAKs0C,kCAAkCkD,WACnChM,GACAxrC,KAAKg0C,iBAAiBoB,kBAAkB,IAAIuF,EAAAA,GAvBhD,CAyBJ,GAAC,CAAA95C,IAAA,yCAAAY,MACD,WACI,IAAM89B,EAAav/B,KAAKs/B,eAAe/9B,QAAQT,IAAI,KAC7C6wB,EAAa3xB,KAAKs/B,eAAe/9B,QAAQT,IAAI,IAC7C85C,EAAcxoC,KAAK8D,IAAI,GAAI9D,KAAKmZ,MAAMgU,EAAW9V,OAASkI,IAC1DhJ,EAAc3oB,KAAKizB,WAAWiP,uBAC9B2Y,EAAsBzoC,KAAK8D,IAAI,EAAGyS,EAAY8T,iCAAmCme,GACjFE,EAAoB1oC,KAAKc,IAAIlT,KAAKqwC,eAAgB1nB,EAAY+T,+BAAiCke,GACrG,OAAO56C,KAAKu2C,sBAAsB,IAAI1iC,EAAAA,EAAMgnC,EAAqB76C,KAAKkpB,iBAAiB2xB,GAAsBC,EAAmB96C,KAAKmpB,iBAAiB2xB,IAC1J,GAAC,CAAAj6C,IAAA,mBAAAY,MACD,WACI,IAAMs5C,EAAmB/6C,KAAKg7C,gCAC9B,OAAOh7C,KAAKu2C,sBAAsBwE,EACtC,GAAC,CAAAl6C,IAAA,iBAAAY,MACD,WACI,OAAOzB,KAAKkyC,OAAO+I,gBACvB,GAAC,CAAAp6C,IAAA,wBAAAY,MACD,SAAsBs5C,GAClB,IAAM9xB,EAAejpB,KAAKwzB,qBAAqB2e,6BAA6B4I,GACtE7S,EAAcloC,KAAKkyC,OAAO+I,iBAChC,GAA2B,IAAvB/S,EAAYtmC,OACZ,MAAO,CAACqnB,GAQZ,IANA,IAAMnnB,EAAS,GACX4W,EAAY,EACZzV,EAAkBgmB,EAAahmB,gBAC/BC,EAAc+lB,EAAa/lB,YACzBE,EAAgB6lB,EAAa7lB,cAC7BC,EAAY4lB,EAAa5lB,UACtBkB,EAAI,EAAGC,EAAM0jC,EAAYtmC,OAAQ2C,EAAIC,EAAKD,IAAK,CACpD,IAAM22C,EAAwBhT,EAAY3jC,GAAGtB,gBACvCk4C,EAAsBjT,EAAY3jC,GAAGnB,cACvC+3C,EAAsBl4C,IAGtBi4C,EAAwB93C,IAGxBH,EAAkBi4C,IAClBp5C,EAAO4W,KAAe,IAAI7E,EAAAA,EAAM5Q,EAAiBC,EAAag4C,EAAwB,EAAGl7C,KAAK6oB,MAAMM,iBAAiB+xB,EAAwB,KAEjJj4C,EAAkBk4C,EAAsB,EACxCj4C,EAAc,GAClB,CAIA,OAHID,EAAkBG,GAAkBH,IAAoBG,GAAiBF,EAAcG,KACvFvB,EAAO4W,KAAe,IAAI7E,EAAAA,EAAM5Q,EAAiBC,EAAaE,EAAeC,IAE1EvB,CACX,GAAC,CAAAjB,IAAA,gCAAAY,MACD,WACI,IAAMknB,EAAc3oB,KAAKizB,WAAWiP,uBAC9B2Y,EAAsBlyB,EAAY8T,iCAClCqe,EAAoBnyB,EAAY+T,+BACtC,OAAO,IAAI7oB,EAAAA,EAAMgnC,EAAqB76C,KAAKkpB,iBAAiB2xB,GAAsBC,EAAmB96C,KAAKmpB,iBAAiB2xB,GAC/H,GAAC,CAAAj6C,IAAA,2CAAAY,MACD,SAAyCob,GACrC,IAAM8L,EAAc3oB,KAAKizB,WAAWmoB,gCAAgCv+B,GAC9Dg+B,EAAsBlyB,EAAY8T,iCAClCqe,EAAoBnyB,EAAY+T,+BACtC,OAAO,IAAI7oB,EAAAA,EAAMgnC,EAAqB76C,KAAKkpB,iBAAiB2xB,GAAsBC,EAAmB96C,KAAKmpB,iBAAiB2xB,GAC/H,GAAC,CAAAj6C,IAAA,YAAAY,MACD,WACI,IAAM45C,EAAkBr7C,KAAKizB,WAAWqoB,YAClCz+B,EAAYw+B,EAAgBx+B,UAC5B0+B,EAAsBv7C,KAAKizB,WAAWuoB,8BAA8B3+B,GACpE4+B,EAAgBz7C,KAAKwzB,qBAAqB4Y,mCAAmC,IAAIh+B,EAAAA,EAASmtC,EAAqBv7C,KAAKkpB,iBAAiBqyB,KACrIG,EAAwB17C,KAAKizB,WAAWoI,+BAA+BkgB,GAAuB1+B,EACpG,MAAO,CACHF,WAAY0+B,EAAgB1+B,WAC5B8+B,cAAeA,EACfC,sBAAuBA,EAE/B,GAAC,CAAA76C,IAAA,qBAAAY,MACD,SAAmBk6C,GACf,GAAmC,qBAAxBA,EAAMF,cAEb,OAAOz7C,KAAK47C,iCAAiCD,GAEjD,IAAMxP,EAAgBnsC,KAAK6oB,MAAM+nB,iBAAiB+K,EAAMF,eAClD3M,EAAe9uC,KAAKwzB,qBAAqBW,mCAAmCgY,GAC5EtvB,EAAY7c,KAAKizB,WAAWoI,+BAA+ByT,EAAaztC,YAAcs6C,EAAMD,sBAClG,MAAO,CACH/+B,WAAYg/B,EAAMh/B,WAClBE,UAAWA,EAEnB,GAAC,CAAAhc,IAAA,mCAAAY,MACD,SAAiCk6C,GAC7B,MAAO,CACHh/B,WAAYg/B,EAAMh/B,WAClBE,UAAW8+B,EAAMna,0BAEzB,GAAC,CAAA3gC,IAAA,aAAAY,MACD,WACI,OAAOzB,KAAK6oB,MAAMwrB,aAAap0B,OACnC,GAAC,CAAApf,IAAA,eAAAY,MACD,WACI,OAAOzB,KAAKkyC,OAAOrN,kBACvB,GACA,CAAAhkC,IAAA,cAAAY,MAGA,SAAYwB,EAAiBG,EAAem5B,GACxCv8B,KAAK00C,eAAe3V,OAAO/+B,KAAMiD,EACrC,GAAC,CAAApC,IAAA,uBAAAY,MACD,SAAqBJ,EAAY45B,EAAeC,GAC5C,OAAOl7B,KAAKkyC,OAAO1F,qBAAqBnrC,EAAY45B,EAAeC,EACvE,GAAC,CAAAr6B,IAAA,uBAAAY,MACD,SAAqBwB,EAAiBG,GAClC,OAAOpD,KAAKkyC,OAAO2J,yBAAyB54C,EAAiBG,EACjE,GAAC,CAAAvC,IAAA,gCAAAY,MACD,SAA8BwB,EAAiBG,EAAe8vC,EAAgB3xC,GAC1E,OAAOvB,KAAKkyC,OAAO4J,0BAA0B74C,EAAiBG,EAAe8vC,EAAgB3xC,EACjG,GAAC,CAAAV,IAAA,iBAAAY,MACD,SAAeJ,GACX,OAAOrB,KAAKkyC,OAAOjC,mBAAmB5uC,EAC1C,GAAC,CAAAR,IAAA,gBAAAY,MACD,SAAcJ,GACV,OAAOrB,KAAKkyC,OAAOhC,kBAAkB7uC,EACzC,GAAC,CAAAR,IAAA,mBAAAY,MACD,SAAiBJ,GACb,OAAOrB,KAAKkyC,OAAOtd,qBAAqBvzB,EAC5C,GAAC,CAAAR,IAAA,mBAAAY,MACD,SAAiBJ,GACb,OAAOrB,KAAKkyC,OAAOrd,qBAAqBxzB,EAC5C,GAAC,CAAAR,IAAA,kCAAAY,MACD,SAAgCJ,GAC5B,IAAMS,EAASkd,EAAAA,GAAgChf,KAAKgT,eAAe3R,IACnE,OAAgB,IAAZS,EACO,EAEJA,EAAS,CACpB,GAAC,CAAAjB,IAAA,iCAAAY,MACD,SAA+BJ,GAC3B,IAAMS,EAASkd,EAAAA,GAA+Bhf,KAAKgT,eAAe3R,IAClE,OAAgB,IAAZS,EACO,EAEJA,EAAS,CACpB,GAAC,CAAAjB,IAAA,+BAAAY,MACD,SAA6B9B,GACzB,OAAOK,KAAK01C,aAAaqG,6BAA6Bp8C,EAC1D,GAAC,CAAAkB,IAAA,2BAAAY,MACD,SAAyBwnB,GACrB,OAAOjpB,KAAK01C,aAAasG,2BAA2B/yB,GAActmB,WACtE,GAAC,CAAA9B,IAAA,oBAAAY,MACD,SAAkBqtC,GACd,OAAO9uC,KAAKkyC,OAAOJ,kBAAkBhD,EACzC,GAAC,CAAAjuC,IAAA,mCAAAY,MACD,SAAiCwnB,EAAc5nB,GAC3C,IACM2oB,EADuBhqB,KAAK01C,aAAasG,2BAA2B/yB,GAAce,kBACzC3oB,EAAa4nB,EAAahmB,iBACzE,OAAOjD,KAAKi8C,0BAA0B56C,EAAY2oB,EACtD,GAAC,CAAAnpB,IAAA,2BAAAY,MACD,SAAyBJ,GACrB,IAAM2oB,EAAoBhqB,KAAK01C,aAAawG,2BAA2B76C,GACvE,OAAOrB,KAAKi8C,0BAA0B56C,EAAY2oB,EACtD,GAAC,CAAAnpB,IAAA,4BAAAY,MACD,SAA0BJ,EAAY2oB,GAClC,IAAMG,EAAkBnqB,KAAK6oB,MAAMsB,kBAC7BC,EAA4BpqB,KAAK6oB,MAAMuB,4BACvCnK,EAAUjgB,KAAKm8C,aACfC,EAAWp8C,KAAKkyC,OAAOrM,gBAAgBxkC,GAO7C,OANI+6C,EAASpyB,oBACTA,EAAoB,GAAHvlB,QAAA43C,EAAAA,EAAAA,GACVryB,IAAiBqyB,EAAAA,EAAAA,GACjBD,EAASpyB,kBAAkB+F,KAAI,SAAA/R,GAAC,OAAIA,EAAEs+B,mBAAmBj7C,EAAW,OAGxE,IAAI6oB,EAAAA,GAAsBkyB,EAAStyB,UAAWsyB,EAASryB,UAAWqyB,EAAS75C,QAAS65C,EAASt8B,yBAA0BqK,EAAiBC,EAA2BgyB,EAAS3xC,OAAQuf,EAAmB/J,EAASm8B,EAASl8B,mBACpO,GAAC,CAAArf,IAAA,kBAAAY,MACD,SAAgBJ,GACZ,OAAOrB,KAAKkyC,OAAOrM,gBAAgBxkC,EACvC,GAAC,CAAAR,IAAA,+BAAAY,MACD,SAA6BwB,EAAiBG,EAAe2gC,GACzD,IAAMjiC,EAAS9B,KAAKkyC,OAAOtO,iBAAiB3gC,EAAiBG,EAAe2gC,GAC5E,OAAO,IAAIpa,EAAAA,GAA0B3pB,KAAKm8C,aAAcr6C,EAC5D,GAAC,CAAAjB,IAAA,iCAAAY,MACD,SAA+B0b,GAC3B,IAEoC8b,EAF9Bt2B,EAAc3C,KAAK6oB,MAAM0zB,4BAA4Bv8C,KAAK0mC,WAAW1R,EAAAA,EAAAA,IAA4Bh1B,KAAKs/B,eAAe/9B,UACrHO,EAAS,IAAI06C,GAA2BtjB,GAAAj3B,EAAAA,EAAAA,GACrBU,GAAW,IAApC,IAAAu2B,EAAAh3B,MAAA+2B,EAAAC,EAAA/2B,KAAAC,MAAsC,KAA3BU,EAAUm2B,EAAAx3B,MACX0zB,EAAoBryB,EAAWvB,QAC/Bk7C,EAAOtnB,EAAkBunB,cAC/B,GAAKD,EAAL,CAGA,IAAME,EAAOF,EAAK7tC,SAClB,GAAa,IAAT+tC,EAAJ,CAGA,IAAMhyB,EAAQ8xB,EAAKG,SAASz/B,EAAM1b,OAC5B2rC,EAAsBptC,KAAKwzB,qBAAqBkc,iCAAiC5sC,EAAWnD,MAAMsD,gBAAiBH,EAAWnD,MAAMuD,aACpImqC,EAAoBrtC,KAAKwzB,qBAAqBkc,iCAAiC5sC,EAAWnD,MAAMyD,cAAeN,EAAWnD,MAAM0D,WACtIvB,EAAO+6C,OAAOlyB,EAAOwK,EAAkBvK,OAAQwiB,EAAqBC,EAAmBsP,EAJvF,CAJA,CASJ,CAAC,OAAAn6C,GAAA02B,EAAAz2B,EAAAD,EAAA,SAAA02B,EAAAx2B,GAAA,CACD,OAAOZ,EAAOg7C,OAClB,GAAC,CAAAj8C,IAAA,mCAAAY,MACD,WACI,IACoC43B,EAD9B12B,EAAc3C,KAAK6oB,MAAM0zB,8BAA8B/iB,GAAAv3B,EAAAA,EAAAA,GACpCU,GAAW,IAApC,IAAA62B,EAAAt3B,MAAAm3B,EAAAG,EAAAr3B,KAAAC,MAAsC,KAA3BU,EAAUu2B,EAAA53B,MACXs7C,EAAQj6C,EAAWvB,QAAQm7C,cACvB,OAAVK,QAA4B,IAAVA,GAA4BA,EAAMC,wBACpD,IAAMC,EAAQn6C,EAAWvB,QAAQs/B,QACvB,OAAVoc,QAA4B,IAAVA,GAA4BA,EAAMD,uBACxD,CAAC,OAAAx6C,GAAAg3B,EAAA/2B,EAAAD,EAAA,SAAAg3B,EAAA92B,GAAA,CACL,GAAC,CAAA7B,IAAA,kBAAAY,MACD,SAAgB9B,EAAOsF,GACnB,IAAMgvB,EAAaj0B,KAAKwzB,qBAAqB2e,6BAA6BxyC,GAC1E,OAAOK,KAAK6oB,MAAM0a,gBAAgBtP,EAAYhvB,EAClD,GAAC,CAAApE,IAAA,wBAAAY,MACD,SAAsB9B,EAAOsF,GACzB,IAAMgvB,EAAaj0B,KAAKwzB,qBAAqB2e,6BAA6BxyC,GAC1E,OAAOK,KAAK6oB,MAAMq0B,sBAAsBjpB,EAAYhvB,EACxD,GAAC,CAAApE,IAAA,iBAAAY,MACD,SAAemN,EAAUmC,GACrB,IAAMo7B,EAAgBnsC,KAAKwzB,qBAAqB4Y,mCAAmCx9B,GACnF,OAAO5O,KAAK6oB,MAAMs0B,eAAehR,EAAep7B,EACpD,GAAC,CAAAlQ,IAAA,4CAAAY,MACD,SAA0C27C,EAAoBlsC,EAAamsC,GACvE,IAAMC,EAAct9C,KAAKwzB,qBAAqB4Y,mCAAmCgR,GAC9C,IAA/Bp9C,KAAK6oB,MAAM00B,SAAS37C,SAEhBsP,EAAc,EACdA,GAAemsC,EAGfnsC,GAAemsC,GAGvB,IACMG,EADoBx9C,KAAK6oB,MAAM40B,YAAYH,GACRpsC,EACzC,OAAOlR,KAAK6oB,MAAM60B,cAAcF,EACpC,GAAC,CAAA38C,IAAA,qBAAAY,MACD,SAAmBk8C,EAAaC,EAAyBC,GACrD,IAAMC,EAAmBD,EAAY,OAAS79C,KAAK6oB,MAAM00B,UACzDI,EAAcA,EAAYtgB,MAAM,IACpB/5B,KAAKuQ,EAAAA,EAAMw0B,0BACvB,IAE+B3O,EAF3BqkB,GAAgB,EAChBC,GAAmB,EAAMpkB,GAAA33B,EAAAA,EAAAA,GACT07C,GAAW,IAA/B,IAAA/jB,EAAA13B,MAAAw3B,EAAAE,EAAAz3B,KAAAC,MAAiC,CAAjBs3B,EAAAj4B,MACFiS,UACNqqC,GAAgB,EAGhBC,GAAmB,CAE3B,CAAC,OAAAx7C,GAAAo3B,EAAAn3B,EAAAD,EAAA,SAAAo3B,EAAAl3B,GAAA,CACD,IAAKs7C,EAAkB,CAEnB,IAAKJ,EACD,MAAO,GAIX,IAFA,IAAMK,EAAmBN,EAAY5tB,KAAI,SAACrS,GAAC,OAAKA,EAAEza,eAAe,IAC7DnB,EAAS,GACJyC,EAAI,EAAGA,EAAI05C,EAAiBr8C,OAAQ2C,IACrCA,EAAI,GAAK05C,EAAiB15C,EAAI,KAAO05C,EAAiB15C,KAG1DzC,GAAU9B,KAAK6oB,MAAM7V,eAAeirC,EAAiB15C,IAAMu5C,GAE/D,OAAOh8C,CACX,CACA,GAAIi8C,GAAiBH,EAAyB,CAE1C,IAEoC7jB,EAF9Bj4B,EAAS,GACXo8C,EAAsB,EAAElkB,GAAA/3B,EAAAA,EAAAA,GACH07C,GAAW,IAApC,IAAA3jB,EAAA93B,MAAA63B,EAAAC,EAAA73B,KAAAC,MAAsC,KAA3B6xB,EAAU8F,EAAAt4B,MACXwhC,EAAkBhP,EAAWhxB,gBAC/BgxB,EAAWvgB,UACPuvB,IAAoBib,GACpBp8C,EAAOkB,KAAKhD,KAAK6oB,MAAM7V,eAAeiwB,IAI1CnhC,EAAOkB,KAAKhD,KAAK6oB,MAAM0a,gBAAgBtP,EAAY4pB,EAAY,EAAmC,IAEtGK,EAAsBjb,CAC1B,CAAC,OAAAzgC,GAAAw3B,EAAAv3B,EAAAD,EAAA,SAAAw3B,EAAAt3B,GAAA,CACD,OAAyB,IAAlBZ,EAAOF,OAAeE,EAAO,GAAKA,CAC7C,CACA,IACoCq8C,EAD9Br8C,EAAS,GAAGs8C,GAAAn8C,EAAAA,EAAAA,GACO07C,GAAW,IAApC,IAAAS,EAAAl8C,MAAAi8C,EAAAC,EAAAj8C,KAAAC,MAAsC,KAA3B6xB,EAAUkqB,EAAA18C,MACZwyB,EAAWvgB,WACZ5R,EAAOkB,KAAKhD,KAAK6oB,MAAM0a,gBAAgBtP,EAAY4pB,EAAY,EAAmC,GAE1G,CAAC,OAAAr7C,GAAA47C,EAAA37C,EAAAD,EAAA,SAAA47C,EAAA17C,GAAA,CACD,OAAyB,IAAlBZ,EAAOF,OAAeE,EAAO,GAAKA,CAC7C,GAAC,CAAAjB,IAAA,oBAAAY,MACD,SAAkBk8C,EAAaC,GAC3B,IAAMn2C,EAAazH,KAAK6oB,MAAMvZ,gBAC9B,GAAI7H,IAAe42C,EAAAA,GACf,OAAO,KAEX,GAA2B,IAAvBV,EAAY/7C,OAEZ,OAAO,KAEX,IAAIjC,EAAQg+C,EAAY,GACxB,GAAIh+C,EAAM+T,UAAW,CACjB,IAAKkqC,EAED,OAAO,KAEX,IAAMv8C,EAAa1B,EAAMsD,gBACzBtD,EAAQ,IAAIkU,EAAAA,EAAMxS,EAAYrB,KAAK6oB,MAAMK,iBAAiB7nB,GAAaA,EAAYrB,KAAK6oB,MAAMM,iBAAiB9nB,GACnH,CACA,IAIIi9C,EAJEryB,EAAWjsB,KAAKs/B,eAAe/9B,QAAQT,IAAI,IAC3CkI,EAAWhJ,KAAKu+C,eAItB,GAHqB,aAAaC,KAAKvyB,EAASqyB,aACHryB,EAASqyB,aAAeG,EAAAA,GAAqBH,WAGtFA,EAAaG,EAAAA,GAAqBH,eAEjC,CAID,GAFAA,GADAA,EAAaryB,EAASqyB,YACEI,QAAQ,KAAM,MACZ,OAAOF,KAAKF,GAEd,OAAOE,KAAKF,KAE5BA,EAAa,IAAH75C,OAAO65C,EAAU,MAGnCA,EAAa,GAAH75C,OAAM65C,EAAU,MAAA75C,OAAKg6C,EAAAA,GAAqBH,WACxD,CACA,MAAO,CACHK,KAAMl3C,EACN0gB,KAAO,yBAAA1jB,OACSuE,EAAS,GAAkC,KAAG,qBAAAvE,OACnCuE,EAAS,GAAkC,KAAG,gBAAAvE,OACnD65C,EAAU,KAAG,gBAAA75C,OACbwnB,EAAS2yB,WAAU,KAAG,cAAAn6C,OACxBwnB,EAAS4yB,SAAQ,OAAK,gBAAAp6C,OACpBwnB,EAAS0F,WAAU,OANlC,sBASD3xB,KAAK8+C,eAAen/C,EAAOqJ,GAC3B,SAEd,GAAC,CAAAnI,IAAA,iBAAAY,MACD,SAAewyB,EAAYjrB,GAOvB,IANA,IAAM/F,EAAkBgxB,EAAWhxB,gBAC7BC,EAAc+wB,EAAW/wB,YACzBE,EAAgB6wB,EAAW7wB,cAC3BC,EAAY4wB,EAAW5wB,UACvB4c,EAAUjgB,KAAKm8C,aACjBr6C,EAAS,GACJT,EAAa4B,EAAiB5B,GAAc+B,EAAe/B,IAAc,CAC9E,IAAMuJ,EAAa5K,KAAK6oB,MAAMqN,aAAa1mB,cAAcnO,GACnDuQ,EAAchH,EAAWoI,iBACzBhC,EAAe3P,IAAe4B,EAAkBC,EAAc,EAAI,EAClE+N,EAAa5P,IAAe+B,EAAgBC,EAAY,EAAIuO,EAAYhQ,OAE1EE,GADgB,KAAhB8P,EACU,QAGAmtC,EAAAA,EAAAA,IAAmBntC,EAAahH,EAAW86B,UAAW18B,EAAUgI,EAAaC,EAAWgP,EAAS++B,EAAAA,GAEnH,CACA,OAAOl9C,CACX,GAAC,CAAAjB,IAAA,eAAAY,MACD,WACI,IAAMuH,EAAWpC,EAAAA,GAAqBmkB,cAChCjpB,EAAS,CAAC,WAChB,GAAIkH,EACA,IAAK,IAAIzE,EAAI,EAAGC,EAAMwE,EAASpH,OAAQ2C,EAAIC,EAAKD,IAC5CzC,EAAOyC,GAAK06C,EAAAA,GAAMC,OAAOC,IAAIC,UAAUp2C,EAASzE,IAGxD,OAAOzC,CACX,GACA,CAAAjB,IAAA,wBAAAY,MACA,WACI,OAAOzB,KAAK80C,QAAQuK,uBACxB,GAAC,CAAAx+C,IAAA,0BAAAY,MACD,WACI,OAAOzB,KAAK80C,QAAQwK,yBACxB,GAAC,CAAAz+C,IAAA,kBAAAY,MACD,WACI,OAAOzB,KAAK80C,QAAQyK,iBACxB,GAAC,CAAA1+C,IAAA,kBAAAY,MACD,SAAgB6Q,EAAQgJ,EAAQkkC,GAAQ,IAAAh2C,EAAA,KACpC,OAAOxJ,KAAKy/C,0BAAyB,SAAA5J,GAAe,OAAIrsC,EAAKsrC,QAAQ4K,UAAU7J,EAAiBvjC,EAAQgJ,EAAQkkC,EAAO,GAC3H,GAAC,CAAA3+C,IAAA,4BAAAY,MACD,WACI,OAAOzB,KAAK80C,QAAQ6K,2BACxB,GAAC,CAAA9+C,IAAA,gCAAAY,MACD,WACI,OAAOzB,KAAK80C,QAAQ8K,yBACxB,GAAC,CAAA/+C,IAAA,4BAAAY,MACD,SAA0Bo+C,GACtB7/C,KAAK80C,QAAQgL,0BAA0BD,EAC3C,GAAC,CAAAh/C,IAAA,2BAAAY,MACD,WACI,OAAOzB,KAAK80C,QAAQiL,0BACxB,GAAC,CAAAl/C,IAAA,2BAAAY,MACD,SAAyB6C,GACrBtE,KAAK80C,QAAQkL,yBAAyB17C,EAC1C,GAAC,CAAAzD,IAAA,eAAAY,MACD,WACI,OAAOzB,KAAK80C,QAAQmL,cACxB,GAAC,CAAAp/C,IAAA,gBAAAY,MACD,WACI,OAAOzB,KAAK80C,QAAQoL,eACxB,GAAC,CAAAr/C,IAAA,cAAAY,MACD,WACI,OAAOzB,KAAK80C,QAAQuK,wBAAwBc,WAAWvxC,QAC3D,GAAC,CAAA/N,IAAA,gBAAAY,MACD,SAAc6Q,EAAQ8I,GAAwD,IAAA8yB,EAAA,KAA5C5yB,EAAMoZ,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,GAAAA,UAAA,GAAG,EACvC10B,KAAKy/C,0BAAyB,SAAA5J,GAAe,OAAI3H,EAAK4G,QAAQsL,cAAcvK,EAAiBvjC,EAAQ8I,EAAYE,EAAO,GAC5H,GAAC,CAAAza,IAAA,kBAAAY,MACD,WACI,OAAOzB,KAAK80C,QAAQwG,WACxB,GAAC,CAAAz6C,IAAA,qBAAAY,MACD,SAAmB+9C,GAAQ,IAAAa,EAAA,KACvBrgD,KAAKy/C,0BAAyB,SAAA5J,GAAe,OAAIwK,EAAKvL,QAAQwL,aAAazK,EAAiB2J,EAAO,GACvG,GAAC,CAAA3+C,IAAA,qBAAAY,MACD,SAAmBw0B,GACXj2B,KAAK80C,QAAQyL,QAAQpM,aAAaqM,SAElCxgD,KAAKg0C,iBAAiBoB,kBAAkB,IAAIqL,EAAAA,IAGhDzgD,KAAKy/C,yBAAyBxpB,EAClC,GAAC,CAAAp1B,IAAA,eAAAY,MACD,SAAa6Q,EAAQouC,EAAOC,GAAqB,IAAAC,EAAA,KAC7C5gD,KAAK6gD,oBAAmB,SAAAhL,GAAe,OAAI+K,EAAK9L,QAAQgM,aAAajL,EAAiBvjC,EAAQouC,EAAOC,EAAoB,GAC7H,GAAC,CAAA9/C,IAAA,mBAAAY,MACD,WAAmB,IAAAs/C,EAAA,KACf/gD,KAAK6gD,oBAAmB,SAAAhL,GAAe,OAAIkL,EAAKjM,QAAQkM,iBAAiBnL,EAAgB,GAC7F,GAAC,CAAAh1C,IAAA,iBAAAY,MACD,SAAe6Q,GAAQ,IAAA2uC,EAAA,KACnBjhD,KAAK6gD,oBAAmB,SAAAhL,GAAe,OAAIoL,EAAKnM,QAAQoM,eAAerL,EAAiBvjC,EAAO,GACnG,GAAC,CAAAzR,IAAA,OAAAY,MACD,SAAKqO,EAAMwC,GAAQ,IAAA6uC,EAAA,KACfnhD,KAAK6gD,oBAAmB,SAAAhL,GAAe,OAAIsL,EAAKrM,QAAQxwC,KAAKuxC,EAAiB/lC,EAAMwC,EAAO,GAC/F,GAAC,CAAAzR,IAAA,kBAAAY,MACD,SAAgBqO,EAAMsxC,EAAoBC,EAAoBC,EAAehvC,GAAQ,IAAAivC,EAAA,KACjFvhD,KAAK6gD,oBAAmB,SAAAhL,GAAe,OAAI0L,EAAKzM,QAAQ0M,gBAAgB3L,EAAiB/lC,EAAMsxC,EAAoBC,EAAoBC,EAAehvC,EAAO,GACjK,GAAC,CAAAzR,IAAA,QAAAY,MACD,SAAMqO,EAAM2xC,EAAgBC,EAAiBpvC,GAAQ,IAAAqvC,EAAA,KACjD3hD,KAAK6gD,oBAAmB,SAAAhL,GAAe,OAAI8L,EAAK7M,QAAQ8M,MAAM/L,EAAiB/lC,EAAM2xC,EAAgBC,EAAiBpvC,EAAO,GACjI,GAAC,CAAAzR,IAAA,MAAAY,MACD,SAAI6Q,GAAQ,IAAAuvC,EAAA,KACR7hD,KAAK6gD,oBAAmB,SAAAhL,GAAe,OAAIgM,EAAK/M,QAAQgN,IAAIjM,EAAiBvjC,EAAO,GACxF,GAAC,CAAAzR,IAAA,iBAAAY,MACD,SAAesgD,EAASzvC,GAAQ,IAAA0vC,EAAA,KAC5BhiD,KAAK6gD,oBAAmB,SAAAhL,GAAe,OAAImM,EAAKlN,QAAQmN,eAAepM,EAAiBkM,EAASzvC,EAAO,GAC5G,GAAC,CAAAzR,IAAA,kBAAAY,MACD,SAAgBygD,EAAU5vC,GAAQ,IAAA6vC,EAAA,KAC9BniD,KAAK6gD,oBAAmB,SAAAhL,GAAe,OAAIsM,EAAKrN,QAAQsN,gBAAgBvM,EAAiBqM,EAAU5vC,EAAO,GAC9G,GAAC,CAAAzR,IAAA,sBAAAY,MACD,SAAoB6Q,EAAQiK,GAAyC,IAAA8lC,EAAA,KAAvBhmC,EAAaqY,UAAA9yB,OAAA,QAAAqO,IAAAykB,UAAA,IAAAA,UAAA,GACvD10B,KAAKy/C,0BAAyB,SAAA5J,GAAe,OAAIwM,EAAKvN,QAAQwN,cAAczM,EAAiBvjC,EAAQ+J,EAAe,EAA8CE,EAAkB,EAA0B,GAClN,GAAC,CAAA1b,IAAA,sBAAAY,MACD,SAAoB6Q,GAChB,IAAMw8B,EAAe9uC,KAAK80C,QAAQyN,yBAC5BvuB,EAAY,IAAIngB,EAAAA,EAAMi7B,EAAaztC,WAAYytC,EAAaxtC,OAAQwtC,EAAaztC,WAAYytC,EAAaxtC,QAChHtB,KAAKy/C,0BAAyB,SAAA5J,GAAe,OAAIA,EAAgB0B,cAAc,IAAIxM,EAAAA,GAAuCz4B,GAAQ,EAAO0hB,EAAW,KAAM,GAA8C,EAAM,GAA2B,GAC7O,GAAC,CAAAnzB,IAAA,yBAAAY,MACD,SAAuB6Q,GACnB,IAAMw8B,EAAe9uC,KAAK80C,QAAQ0N,4BAC5BxuB,EAAY,IAAIngB,EAAAA,EAAMi7B,EAAaztC,WAAYytC,EAAaxtC,OAAQwtC,EAAaztC,WAAYytC,EAAaxtC,QAChHtB,KAAKy/C,0BAAyB,SAAA5J,GAAe,OAAIA,EAAgB0B,cAAc,IAAIxM,EAAAA,GAAuCz4B,GAAQ,EAAO0hB,EAAW,KAAM,GAA8C,EAAM,GAA2B,GAC7O,GAAC,CAAAnzB,IAAA,cAAAY,MACD,SAAY6Q,EAAQiK,EAAkByX,EAAW1X,EAAcE,GAC3Dxc,KAAKy/C,0BAAyB,SAAA5J,GAAe,OAAIA,EAAgB0B,cAAc,IAAIxM,EAAAA,GAAuCz4B,GAAQ,EAAO0hB,EAAW,KAAM1X,EAAcC,EAAkBC,GAAY,GAC1M,GAEA,CAAA3b,IAAA,mBAAAY,MACA,SAAiBw0B,GACMj2B,KAAKizB,WAAWwO,iBAAiBxL,KAEhDj2B,KAAKg0C,iBAAiBmB,oBAAoB,IAAIpK,EAAAA,IAC9C/qC,KAAKg0C,iBAAiBoB,kBAAkB,IAAI93B,EAAAA,IAEpD,GACA,CAAAzc,IAAA,2BAAAY,MACA,SAAyBw0B,GACrB,IAEI,OAAOA,EADiBj2B,KAAKg0C,iBAAiB8B,sBAElD,CAAC,QAEG91C,KAAKg0C,iBAAiBgC,mBAC1B,CACJ,GAAC,CAAAn1C,IAAA,oBAAAY,MACD,SAAkBmN,EAAUs2B,GACxB,OAAOllC,KAAKkyC,OAAOH,kBAAkBnjC,EAAUs2B,EACnD,GACA,CAAArkC,IAAA,sBAAAY,MAIA,SAAoBJ,GAChB,OAAOrB,KAAKkyC,OAAOF,oBAAoB3wC,EAC3C,KAACoyC,CAAA,CA11BiB,CAASlpC,EAAAA,IA41BzBoqC,GAAa,WAiBf,SAAAA,EAAY3rB,EAAQy5B,EAAiBC,EAAUC,EAAoBC,IAAiB7iD,EAAAA,EAAAA,GAAA,KAAA40C,GAChF30C,KAAKgpB,OAASA,EACdhpB,KAAKyiD,gBAAkBA,EACvBziD,KAAK0iD,SAAWA,EAChB1iD,KAAK2iD,mBAAqBA,EAC1B3iD,KAAK4iD,gBAAkBA,CAC3B,CAnBC,OAmBAljD,EAAAA,EAAAA,GAAAi1C,EAAA,EAAA9zC,IAAA,iBAAAC,IAlBD,WACI,OAAOd,KAAKyiD,eAChB,GAAC,CAAA5hD,IAAA,UAAAC,IACD,WACI,OAAOd,KAAK0iD,QAChB,GAAC,CAAA7hD,IAAA,oBAAAC,IACD,WACI,OAAOd,KAAK2iD,kBAChB,GAAC,CAAA9hD,IAAA,iBAAAC,IACD,WACI,OAAOd,KAAK4iD,eAChB,GAAC,CAAA/hD,IAAA,UAAAY,MAQD,WACIzB,KAAKgpB,OAAO65B,iBAAiB7iD,KAAK2iD,mBAAoB,KAAM,EAChE,GAAC,CAAA9hD,IAAA,SAAAY,MACD,SAAOuxB,EAAW/vB,GACd,IAAM2L,EAAWokB,EAAUQ,qBAAqB4Y,mCAAmC,IAAIh+B,EAAAA,EAASnL,EAAiB+vB,EAAU9J,iBAAiBjmB,KACtI6/C,EAAgC9vB,EAAUnK,MAAMg6B,iBAAiB7iD,KAAK2iD,mBAAoB,IAAI9uC,EAAAA,EAAMjF,EAASvN,WAAYuN,EAAStN,OAAQsN,EAASvN,WAAYuN,EAAStN,QAAS,GACjLyhD,EAAuB/vB,EAAUC,WAAWoI,+BAA+Bp4B,GAC3E4Z,EAAYmW,EAAUC,WAAW8jB,sBACvC/2C,KAAKyiD,gBAAkBx/C,EACvBjD,KAAK0iD,UAAW,EAChB1iD,KAAK2iD,mBAAqBG,EAC1B9iD,KAAK4iD,gBAAkB/lC,EAAYkmC,CACvC,GAAC,CAAAliD,IAAA,aAAAY,MACD,WACIzB,KAAK0iD,UAAW,CACpB,IAAC,EAAA7hD,IAAA,SAAAY,MAtCD,SAAconB,GACV,IAAMi6B,EAAgCj6B,EAAMg6B,iBAAiB,KAAM,IAAIhvC,EAAAA,EAAM,EAAG,EAAG,EAAG,GAAI,GAC1F,OAAO,IAAI8gC,EAAc9rB,EAAO,GAAG,EAAOi6B,EAA+B,EAC7E,KAACnO,CAAA,CAJc,GAyCb6H,GAAwB,WAC1B,SAAAA,KAAcz8C,EAAAA,EAAAA,GAAA,KAAAy8C,GACVx8C,KAAKgjD,OAASzxB,OAAOC,OAAO,MAC5BxxB,KAAK88C,QAAU,EACnB,CAsBC,OAtBAp9C,EAAAA,EAAAA,GAAA88C,EAAA,EAAA37C,IAAA,SAAAY,MACD,SAAOkpB,EAAOC,EAAQ3nB,EAAiBG,EAAeu5C,GAClD,IAAMsG,EAAYjjD,KAAKgjD,OAAOr4B,GAC9B,GAAIs4B,EAAW,CACX,IAAMC,EAAWD,EAAUr5B,KACrBu5B,EAAWD,EAASA,EAASthD,OAAS,GACtCwhD,EAAoBF,EAASA,EAASthD,OAAS,GACrD,GAAIuhD,IAAaxG,GAAQyG,EAAoB,GAAKngD,EAK9C,YAHIG,EAAgBggD,IAChBF,EAASA,EAASthD,OAAS,GAAKwB,IAKxC8/C,EAASlgD,KAAK25C,EAAM15C,EAAiBG,EACzC,KACK,CACD,IAAMkrC,EAAQ,IAAI5jB,EAAAA,GAA8BC,EAAOC,EAAQ,CAAC+xB,EAAM15C,EAAiBG,IACvFpD,KAAKgjD,OAAOr4B,GAAS2jB,EACrBtuC,KAAK88C,QAAQ95C,KAAKsrC,EACtB,CACJ,KAACkO,CAAA,CA1ByB,GA4BxB1I,GAAgB,WAClB,SAAAA,KAAc/zC,EAAAA,EAAAA,GAAA,KAAA+zC,GACV9zC,KAAKkoC,YAAc,IAAIphC,IACvB9G,KAAKqjD,iBAAkB,EACvBrjD,KAAKgP,OAAS,EAClB,CAuBC,OAvBAtP,EAAAA,EAAAA,GAAAo0C,EAAA,EAAAjzC,IAAA,iBAAAY,MACD,SAAe6Q,EAAQtD,GACnB,IAAMs0C,EAAWtjD,KAAKkoC,YAAYpnC,IAAIwR,GAClCgxC,GAAYC,GAAiBD,EAAUt0C,KAG3ChP,KAAKkoC,YAAYvgC,IAAI2K,EAAQtD,GAC7BhP,KAAKqjD,iBAAkB,EAC3B,GACA,CAAAxiD,IAAA,kBAAAY,MAGA,WACI,IAAKzB,KAAKqjD,gBACN,OAAOrjD,KAAKgP,OAEhBhP,KAAKqjD,iBAAkB,EACvB,IAAMpa,EAAYhgC,MAAMC,KAAKlJ,KAAKkoC,YAAYD,UAAUub,QAAO,SAAC9lC,EAAGwqB,GAAW,OAQtF,SAA6Bub,EAAMC,GAC/B,IAAM5hD,EAAS,GACXyC,EAAI,EACJmjB,EAAI,EACR,KAAOnjB,EAAIk/C,EAAK7hD,QAAU8lB,EAAIg8B,EAAK9hD,QAAQ,CACvC,IAAM+hD,EAAQF,EAAKl/C,GACbq/C,EAAQF,EAAKh8B,GACnB,GAAIi8B,EAAMvgD,cAAgBwgD,EAAM3gD,gBAAkB,EAC9CnB,EAAOkB,KAAKygD,EAAKl/C,WAEhB,GAAIq/C,EAAMxgD,cAAgBugD,EAAM1gD,gBAAkB,EACnDnB,EAAOkB,KAAK0gD,EAAKh8B,UAEhB,CACD,IAAMzkB,EAAkBmP,KAAKc,IAAIywC,EAAM1gD,gBAAiB2gD,EAAM3gD,iBACxDG,EAAgBgP,KAAK8D,IAAIytC,EAAMvgD,cAAewgD,EAAMxgD,eAC1DtB,EAAOkB,KAAK,IAAI6Q,EAAAA,EAAM5Q,EAAiB,EAAGG,EAAe,IACzDmB,IACAmjB,GACJ,CACJ,CACA,KAAOnjB,EAAIk/C,EAAK7hD,QACZE,EAAOkB,KAAKygD,EAAKl/C,MAErB,KAAOmjB,EAAIg8B,EAAK9hD,QACZE,EAAOkB,KAAK0gD,EAAKh8B,MAErB,OAAO5lB,CACX,CApC2F+hD,CAAoBnmC,EAAGwqB,EAAY,GAAE,IACxH,OAAIqb,GAAiBvjD,KAAKgP,OAAQi6B,KAGlCjpC,KAAKgP,OAASi6B,GAFHjpC,KAAKgP,MAIpB,KAAC8kC,CAAA,CA5BiB,GA2DtB,SAASyP,GAAiBE,EAAMC,GAC5B,GAAID,EAAK7hD,SAAW8hD,EAAK9hD,OACrB,OAAO,EAEX,IAAK,IAAI2C,EAAI,EAAGA,EAAIk/C,EAAK7hD,OAAQ2C,IAC7B,IAAKk/C,EAAKl/C,GAAGiwB,YAAYkvB,EAAKn/C,IAC1B,OAAO,EAGf,OAAO,CACX,CACA,IAGM2yC,GAAc,WAChB,SAAAA,EAAY4M,EAA4B3M,IAAgBp3C,EAAAA,EAAAA,GAAA,KAAAm3C,GACpDl3C,KAAK8jD,2BAA6BA,EAClC9jD,KAAKm3C,eAAiBA,CAC1B,CAQC,OARAz3C,EAAAA,EAAAA,GAAAw3C,EAAA,EAAAr2C,IAAA,uBAAAY,MACD,SAAqB+xB,EAAsBP,GACvC,GAAKjzB,KAAK8jD,2BAAV,CAGA,IAAMhV,EAAetb,EAAqBW,mCAAmCn0B,KAAK8jD,4BAC5EvK,EAAkBtmB,EAAWoI,+BAA+ByT,EAAaztC,YAC/E4xB,EAAWumB,kBAAkB,CAAE38B,UAAW08B,EAAkBv5C,KAAKm3C,gBAAkB,EAHnF,CAIJ,KAACD,CAAA,CAZe,E,ubC//BPjD,EAAwB,SAAA7qC,IAAAjJ,EAAAA,EAAAA,GAAA8zC,EAAA7qC,GAAA,IAAAhJ,GAAAC,EAAAA,EAAAA,GAAA4zC,GACjC,SAAAA,IAAc,IAAAvzC,EASgB,OAThBX,EAAAA,EAAAA,GAAA,KAAAk0C,IACVvzC,EAAAN,EAAAO,KAAA,OACKojD,SAAWrjD,EAAK2J,UAAU,IAAIpD,EAAAA,IACnCvG,EAAKwzC,QAAUxzC,EAAKqjD,SAAS58C,MAC7BzG,EAAKsjD,eAAiB,GACtBtjD,EAAKujD,gBAAkB,KACvBvjD,EAAKwjD,4BAA6B,EAClCxjD,EAAKyjD,WAAa,KAClBzjD,EAAK0jD,cAAgB,EACrB1jD,EAAK2jD,gBAAkB,GAAG3jD,CAC9B,CA2GC,OA3GAhB,EAAAA,EAAAA,GAAAu0C,EAAA,EAAApzC,IAAA,oBAAAY,MACD,SAAkBgB,GACdzC,KAAKskD,kBAAkB7hD,GACvBzC,KAAKukD,qBACT,GAAC,CAAA1jD,IAAA,oBAAAY,MACD,SAAkBgB,GACd,IAAK,IAAI8B,EAAI,EAAGC,EAAMxE,KAAKqkD,gBAAgBziD,OAAQ2C,EAAIC,EAAKD,IAAK,CAC7D,IAAMigD,EAAexkD,KAAKqkD,gBAAgB9/C,GAAGkgD,OAAShiD,EAAEgiD,KAAOzkD,KAAKqkD,gBAAgB9/C,GAAGmgD,eAAejiD,GAAK,KAC3G,GAAI+hD,EAEA,YADAxkD,KAAKqkD,gBAAgB9/C,GAAKigD,EAGlC,CAEAxkD,KAAKqkD,gBAAgBrhD,KAAKP,EAC9B,GAAC,CAAA5B,IAAA,sBAAAY,MACD,WACI,KAAOzB,KAAKqkD,gBAAgBziD,OAAS,GAAG,CACpC,GAAI5B,KAAKmkD,YAAcnkD,KAAKkkD,2BAExB,OAEJ,IAAM/8C,EAAQnH,KAAKqkD,gBAAgBM,QAC/Bx9C,EAAMy9C,UAGV5kD,KAAK+jD,SAASz8C,KAAKH,EACvB,CACJ,GAAC,CAAAtG,IAAA,sBAAAY,MACD,SAAoByxB,GAChB,IAAK,IAAI3uB,EAAI,EAAGC,EAAMxE,KAAKgkD,eAAepiD,OAAQ2C,EAAIC,EAAKD,IACnDvE,KAAKgkD,eAAez/C,KAAO2uB,GAC3BtY,QAAQiqC,KAAK,qDAAsD3xB,GAG3ElzB,KAAKgkD,eAAehhD,KAAKkwB,EAC7B,GAAC,CAAAryB,IAAA,yBAAAY,MACD,SAAuByxB,GACnB,IAAK,IAAI3uB,EAAI,EAAGA,EAAIvE,KAAKgkD,eAAepiD,OAAQ2C,IAC5C,GAAIvE,KAAKgkD,eAAez/C,KAAO2uB,EAAc,CACzClzB,KAAKgkD,eAAez2C,OAAOhJ,EAAG,GAC9B,KACJ,CAER,GAAC,CAAA1D,IAAA,sBAAAY,MACD,WAKI,OAJAzB,KAAKokD,gBACsB,IAAvBpkD,KAAKokD,gBACLpkD,KAAKmkD,WAAa,IAAIW,GAEnB9kD,KAAKmkD,UAChB,GAAC,CAAAtjD,IAAA,oBAAAY,MACD,WAEI,GADAzB,KAAKokD,gBACsB,IAAvBpkD,KAAKokD,cAAqB,CAC1B,IAAMW,EAAiB/kD,KAAKmkD,WAAWY,eACjCha,EAAa/qC,KAAKmkD,WAAWpZ,WACnC/qC,KAAKmkD,WAAa,KAAK,IACmBtiD,EADnBG,GAAAC,EAAAA,EAAAA,GACK8iD,GAAc,IAA1C,IAAA/iD,EAAAE,MAAAL,EAAAG,EAAAG,KAAAC,MAA4C,KAAjC4iD,EAAanjD,EAAAJ,MACpBzB,KAAKskD,kBAAkBU,EAC3B,CAAC,OAAAxiD,GAAAR,EAAAS,EAAAD,EAAA,SAAAR,EAAAU,GAAA,CACGqoC,EAAWnpC,OAAS,GACpB5B,KAAKilD,UAAUla,EAEvB,CACA/qC,KAAKukD,qBACT,GAAC,CAAA1jD,IAAA,sBAAAY,MACD,SAAoB0F,GAChB,IAC4BnH,KAAK81C,sBACbyB,cAAcpwC,EAClC,CAAC,QAEGnH,KAAKg2C,mBACT,CACJ,GAAC,CAAAn1C,IAAA,YAAAY,MACD,SAAU+X,GACFxZ,KAAKikD,gBACLjkD,KAAKikD,gBAAkBjkD,KAAKikD,gBAAgBx/C,OAAO+U,GAGnDxZ,KAAKikD,gBAAkBzqC,EAEtBxZ,KAAKkkD,4BACNlkD,KAAKklD,wBAEb,GAAC,CAAArkD,IAAA,yBAAAY,MACD,WACI,IACIzB,KAAKkkD,4BAA6B,EAClClkD,KAAKmlD,iBACT,CAAC,QAEGnlD,KAAKkkD,4BAA6B,CACtC,CACJ,GAAC,CAAArjD,IAAA,kBAAAY,MACD,WACI,KAAOzB,KAAKikD,iBAAiB,CAEzB,IAAMzqC,EAASxZ,KAAKikD,gBACpBjkD,KAAKikD,gBAAkB,KAEvB,IACwCrhD,EADlCwiD,EAAgBplD,KAAKgkD,eAAe3mB,MAAM,GAAGx6B,GAAAZ,EAAAA,EAAAA,GACxBmjD,GAAa,IAAxC,IAAAviD,EAAAX,MAAAU,EAAAC,EAAAV,KAAAC,MAA0C,CAAnBQ,EAAAnB,MACN4jD,aAAa7rC,EAC9B,CAAC,OAAAhX,GAAAK,EAAAJ,EAAAD,EAAA,SAAAK,EAAAH,GAAA,CACL,CACJ,KAACuxC,CAAA,CAtHgC,C,SAAS1pC,IAwHjCu6C,EAAwB,WACjC,SAAAA,KAAc/kD,EAAAA,EAAAA,GAAA,KAAA+kD,GACV9kD,KAAK+qC,WAAa,GAClB/qC,KAAK+kD,eAAiB,EAC1B,CAMC,OANArlD,EAAAA,EAAAA,GAAAolD,EAAA,EAAAjkD,IAAA,gBAAAY,MACD,SAAc0F,GACVnH,KAAK+qC,WAAW/nC,KAAKmE,EACzB,GAAC,CAAAtG,IAAA,oBAAAY,MACD,SAAkBgB,GACdzC,KAAK+kD,eAAe/hD,KAAKP,EAC7B,KAACqiD,CAAA,CAVgC,GAYxBlmB,EAAuB,WAChC,SAAAA,EAAY0mB,EAAiBC,EAAkBhoB,EAAcC,IAAez9B,EAAAA,EAAAA,GAAA,KAAA6+B,GACxE5+B,KAAKykD,KAAO,EACZzkD,KAAKwlD,iBAAmBF,EACxBtlD,KAAKylD,kBAAoBF,EACzBvlD,KAAKu9B,aAAeA,EACpBv9B,KAAKw9B,cAAgBA,EACrBx9B,KAAK0+B,oBAAuB1+B,KAAKwlD,mBAAqBxlD,KAAKu9B,aAC3Dv9B,KAAK2+B,qBAAwB3+B,KAAKylD,oBAAsBzlD,KAAKw9B,aACjE,CASC,OATA99B,EAAAA,EAAAA,GAAAk/B,EAAA,EAAA/9B,IAAA,SAAAY,MACD,WACI,OAASzB,KAAK0+B,sBAAwB1+B,KAAK2+B,oBAC/C,GAAC,CAAA99B,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAIA,EAAM2/C,OAASzkD,KAAKykD,KACb,KAEJ,IAAI7lB,EAAwB5+B,KAAKwlD,iBAAkBxlD,KAAKylD,kBAAmB3gD,EAAMy4B,aAAcz4B,EAAM04B,cAChH,KAACoB,CAAA,CAlB+B,GAoBvBiY,EAAiB,WAC1B,SAAAA,EAAY6O,EAAa/O,IAAU52C,EAAAA,EAAAA,GAAA,KAAA82C,GAC/B72C,KAAKykD,KAAO,EACZzkD,KAAK0lD,YAAcA,EACnB1lD,KAAK22C,SAAWA,CACpB,CASC,OATAj3C,EAAAA,EAAAA,GAAAm3C,EAAA,EAAAh2C,IAAA,SAAAY,MACD,WACI,OAAQzB,KAAK0lD,cAAgB1lD,KAAK22C,QACtC,GAAC,CAAA91C,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAIA,EAAM2/C,OAASzkD,KAAKykD,KACb,KAEJ,IAAI5N,EAAkB72C,KAAK0lD,YAAa5gD,EAAM6xC,SACzD,KAACE,CAAA,CAdyB,GAgBjBxB,EAAkB,WAC3B,SAAAA,EAAYC,EAAgBC,EAAeC,EAAiBC,EAAc/4B,EAAaC,EAAYC,EAAcC,IAAW9c,EAAAA,EAAAA,GAAA,KAAAs1C,GACxHr1C,KAAKykD,KAAO,EACZzkD,KAAK2lD,gBAAkBrQ,EACvBt1C,KAAK4lD,eAAiBrQ,EACtBv1C,KAAK6lD,iBAAmBrQ,EACxBx1C,KAAK8lD,cAAgBrQ,EACrBz1C,KAAK0c,YAAcA,EACnB1c,KAAK2c,WAAaA,EAClB3c,KAAK4c,aAAeA,EACpB5c,KAAK6c,UAAYA,EACjB7c,KAAK8c,mBAAsB9c,KAAK2lD,kBAAoB3lD,KAAK0c,YACzD1c,KAAK+c,kBAAqB/c,KAAK4lD,iBAAmB5lD,KAAK2c,WACvD3c,KAAKgd,oBAAuBhd,KAAK6lD,mBAAqB7lD,KAAK4c,aAC3D5c,KAAKid,iBAAoBjd,KAAK8lD,gBAAkB9lD,KAAK6c,SACzD,CASC,OATAnd,EAAAA,EAAAA,GAAA21C,EAAA,EAAAx0C,IAAA,SAAAY,MACD,WACI,OAASzB,KAAK8c,qBAAuB9c,KAAK+c,oBAAsB/c,KAAKgd,sBAAwBhd,KAAKid,gBACtG,GAAC,CAAApc,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAIA,EAAM2/C,OAASzkD,KAAKykD,KACb,KAEJ,IAAIpP,EAAmBr1C,KAAK2lD,gBAAiB3lD,KAAK4lD,eAAgB5lD,KAAK6lD,iBAAkB7lD,KAAK8lD,cAAehhD,EAAM4X,YAAa5X,EAAM6X,WAAY7X,EAAM8X,aAAc9X,EAAM+X,UACvL,KAACw4B,CAAA,CAxB0B,GA0BlB/3B,EAAqB,WAC9B,SAAAA,KAAcvd,EAAAA,EAAAA,GAAA,KAAAud,GACVtd,KAAKykD,KAAO,CAChB,CASC,OATA/kD,EAAAA,EAAAA,GAAA4d,EAAA,EAAAzc,IAAA,SAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAIA,EAAM2/C,OAASzkD,KAAKykD,KACb,KAEJzkD,IACX,KAACsd,CAAA,CAZ6B,GAcrBq9B,EAAuB,WAChC,SAAAA,KAAc56C,EAAAA,EAAAA,GAAA,KAAA46C,GACV36C,KAAKykD,KAAO,CAChB,CASC,OATA/kD,EAAAA,EAAAA,GAAAi7C,EAAA,EAAA95C,IAAA,SAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAIA,EAAM2/C,OAASzkD,KAAKykD,KACb,KAEJzkD,IACX,KAAC26C,CAAA,CAZ+B,GAcvBoL,EAAuB,WAChC,SAAAA,EAAYC,EAAe5qC,EAAY6qC,EAAmBC,EAAgB5zC,EAAQgJ,EAAQ6qC,IAAuBpmD,EAAAA,EAAAA,GAAA,KAAAgmD,GAC7G/lD,KAAKykD,KAAO,EACZzkD,KAAKgmD,cAAgBA,EACrBhmD,KAAKob,WAAaA,EAClBpb,KAAKimD,kBAAoBA,EACzBjmD,KAAKkmD,eAAiBA,EACtBlmD,KAAKsS,OAASA,EACdtS,KAAKsb,OAASA,EACdtb,KAAKmmD,sBAAwBA,CACjC,CAmBC,OAnBAzmD,EAAAA,EAAAA,GAAAqmD,EAAA,EAAAllD,IAAA,SAAAY,MAoBD,WACI,OAAQskD,EAAwBK,oBAAoBpmD,KAAKgmD,cAAehmD,KAAKob,aACtEpb,KAAKimD,oBAAsBjmD,KAAKkmD,cAC3C,GAAC,CAAArlD,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAIA,EAAM2/C,OAASzkD,KAAKykD,KACb,KAEJ,IAAIsB,EAAwB/lD,KAAKgmD,cAAelhD,EAAMsW,WAAYpb,KAAKimD,kBAAmBnhD,EAAMohD,eAAgBphD,EAAMwN,OAAQxN,EAAMwW,OAAQtb,KAAKmmD,uBAAyBrhD,EAAMqhD,sBAC3L,IAAC,EAAAtlD,IAAA,sBAAAY,MA5BD,SAA2B8B,EAAGC,GAC1B,IAAKD,IAAMC,EACP,OAAO,EAEX,IAAKD,IAAMC,EACP,OAAO,EAEX,IAAM+U,EAAOhV,EAAE3B,OAEf,GAAI2W,IADS/U,EAAE5B,OAEX,OAAO,EAEX,IAAK,IAAI2C,EAAI,EAAGA,EAAIgU,EAAMhU,IACtB,IAAKhB,EAAEgB,GAAG8hD,gBAAgB7iD,EAAEe,IACxB,OAAO,EAGf,OAAO,CACX,KAACwhD,CAAA,CA7B+B,GAyCvBtF,EAAwB,WACjC,SAAAA,KAAc1gD,EAAAA,EAAAA,GAAA,KAAA0gD,GACVzgD,KAAKykD,KAAO,CAChB,CASC,OATA/kD,EAAAA,EAAAA,GAAA+gD,EAAA,EAAA5/C,IAAA,SAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAIA,EAAM2/C,OAASzkD,KAAKykD,KACb,KAEJzkD,IACX,KAACygD,CAAA,CAZgC,GAcxBjG,EAA4B,WACrC,SAAAA,EAAYrzC,IAAOpH,EAAAA,EAAAA,GAAA,KAAAy6C,GACfx6C,KAAKmH,MAAQA,EACbnH,KAAKykD,KAAO,CAChB,CAMC,OANA/kD,EAAAA,EAAAA,GAAA86C,EAAA,EAAA35C,IAAA,SAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAO,IACX,KAAC01C,CAAA,CAVoC,GAY5BN,EAAyB,WAClC,SAAAA,EAAY/yC,IAAOpH,EAAAA,EAAAA,GAAA,KAAAm6C,GACfl6C,KAAKmH,MAAQA,EACbnH,KAAKykD,KAAO,CAChB,CAMC,OANA/kD,EAAAA,EAAAA,GAAAw6C,EAAA,EAAAr5C,IAAA,SAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAO,IACX,KAACo1C,CAAA,CAViC,GAYzBF,EAAsC,WAC/C,SAAAA,EAAY7yC,IAAOpH,EAAAA,EAAAA,GAAA,KAAAi6C,GACfh6C,KAAKmH,MAAQA,EACbnH,KAAKykD,KAAO,CAChB,CAMC,OANA/kD,EAAAA,EAAAA,GAAAs6C,EAAA,EAAAn5C,IAAA,SAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAO,IACX,KAACk1C,CAAA,CAV8C,GAYtCP,EAAwB,WACjC,SAAAA,EAAYtyC,IAAOpH,EAAAA,EAAAA,GAAA,KAAA05C,GACfz5C,KAAKmH,MAAQA,EACbnH,KAAKykD,KAAO,EAChB,CAMC,OANA/kD,EAAAA,EAAAA,GAAA+5C,EAAA,EAAA54C,IAAA,SAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAO,IACX,KAAC20C,CAAA,CAVgC,GAYxBY,EAAwB,WACjC,SAAAA,EAAYlzC,IAAOpH,EAAAA,EAAAA,GAAA,KAAAs6C,GACfr6C,KAAKmH,MAAQA,EACbnH,KAAKykD,KAAO,EAChB,CAMC,OANA/kD,EAAAA,EAAAA,GAAA26C,EAAA,EAAAx5C,IAAA,SAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAO,IACX,KAACu1C,CAAA,CAVgC,GAYxBP,EAAuB,WAChC,SAAAA,EAAY3yC,IAAOpH,EAAAA,EAAAA,GAAA,KAAA+5C,GACf95C,KAAKmH,MAAQA,EACbnH,KAAKykD,KAAO,EAChB,CAMC,OANA/kD,EAAAA,EAAAA,GAAAo6C,EAAA,EAAAj5C,IAAA,SAAAY,MACD,WACI,OAAO,CACX,GAAC,CAAAZ,IAAA,iBAAAY,MACD,SAAeqD,GACX,OAAO,IACX,KAACg1C,CAAA,CAV+B,E","sources":["../node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","../node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/viewEventHandler.js","../node_modules/monaco-editor/esm/vs/editor/common/viewEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linePart.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLinesViewportData.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/minimapTokensColorTracker.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/overviewZoneManager.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewContext.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelDecorations.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLayout.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjection.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModelEventDispatcher.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits\n        return {\n            changes: changes,\n            eol: eol,\n            isEolChange: isEolChange,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../base/common/lifecycle.js';\nexport class TokenizationRegistry {\n    constructor() {\n        this._tokenizationSupports = new Map();\n        this._factories = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._colorMap = null;\n    }\n    handleChange(languageIds) {\n        this._onDidChange.fire({\n            changedLanguages: languageIds,\n            changedColorMap: false\n        });\n    }\n    register(languageId, support) {\n        this._tokenizationSupports.set(languageId, support);\n        this.handleChange([languageId]);\n        return toDisposable(() => {\n            if (this._tokenizationSupports.get(languageId) !== support) {\n                return;\n            }\n            this._tokenizationSupports.delete(languageId);\n            this.handleChange([languageId]);\n        });\n    }\n    get(languageId) {\n        return this._tokenizationSupports.get(languageId) || null;\n    }\n    registerFactory(languageId, factory) {\n        var _a;\n        (_a = this._factories.get(languageId)) === null || _a === void 0 ? void 0 : _a.dispose();\n        const myData = new TokenizationSupportFactoryData(this, languageId, factory);\n        this._factories.set(languageId, myData);\n        return toDisposable(() => {\n            const v = this._factories.get(languageId);\n            if (!v || v !== myData) {\n                return;\n            }\n            this._factories.delete(languageId);\n            v.dispose();\n        });\n    }\n    getOrCreate(languageId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // check first if the support is already set\n            const tokenizationSupport = this.get(languageId);\n            if (tokenizationSupport) {\n                return tokenizationSupport;\n            }\n            const factory = this._factories.get(languageId);\n            if (!factory || factory.isResolved) {\n                // no factory or factory.resolve already finished\n                return null;\n            }\n            yield factory.resolve();\n            return this.get(languageId);\n        });\n    }\n    isResolved(languageId) {\n        const tokenizationSupport = this.get(languageId);\n        if (tokenizationSupport) {\n            return true;\n        }\n        const factory = this._factories.get(languageId);\n        if (!factory || factory.isResolved) {\n            return true;\n        }\n        return false;\n    }\n    setColorMap(colorMap) {\n        this._colorMap = colorMap;\n        this._onDidChange.fire({\n            changedLanguages: Array.from(this._tokenizationSupports.keys()),\n            changedColorMap: true\n        });\n    }\n    getColorMap() {\n        return this._colorMap;\n    }\n    getDefaultBackground() {\n        if (this._colorMap && this._colorMap.length > 2 /* ColorId.DefaultBackground */) {\n            return this._colorMap[2 /* ColorId.DefaultBackground */];\n        }\n        return null;\n    }\n}\nclass TokenizationSupportFactoryData extends Disposable {\n    get isResolved() {\n        return this._isResolved;\n    }\n    constructor(_registry, _languageId, _factory) {\n        super();\n        this._registry = _registry;\n        this._languageId = _languageId;\n        this._factory = _factory;\n        this._isDisposed = false;\n        this._resolvePromise = null;\n        this._isResolved = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    resolve() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._resolvePromise) {\n                this._resolvePromise = this._create();\n            }\n            return this._resolvePromise;\n        });\n    }\n    _create() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const value = yield this._factory.tokenizationSupport;\n            this._isResolved = true;\n            if (value && !this._isDisposed) {\n                this._register(this._registry.register(this._languageId, value));\n            }\n        });\n    }\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this._languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this._languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n    }\n}\nLineTokens.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n    | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n    | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n    static create(startLineNumber, tokens) {\n        return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._endLineNumber;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    toString() {\n        return this._tokens.toString(this._startLineNumber);\n    }\n    _updateEndLineNumber() {\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    isEmpty() {\n        return this._tokens.isEmpty();\n    }\n    getLineTokens(lineNumber) {\n        if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n            return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n        }\n        return null;\n    }\n    getRange() {\n        const deltaRange = this._tokens.getRange();\n        if (!deltaRange) {\n            return deltaRange;\n        }\n        return new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n    removeTokens(range) {\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        this._updateEndLineNumber();\n    }\n    split(range) {\n        // split tokens to two:\n        // a) all the tokens before `range`\n        // b) all the tokens after `range`\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n    }\n    applyEdit(range, text) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* CharCode.Null */);\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n        this._updateEndLineNumber();\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            // Nothing to delete\n            return;\n        }\n        const firstLineIndex = range.startLineNumber - this._startLineNumber;\n        const lastLineIndex = range.endLineNumber - this._startLineNumber;\n        if (lastLineIndex < 0) {\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\n            this._startLineNumber -= deletedLinesCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion occurs entirely after this block, so there is nothing to do\n            return;\n        }\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion completely encompasses this block\n            this._startLineNumber = 0;\n            this._tokens.clear();\n            return;\n        }\n        if (firstLineIndex < 0) {\n            const deletedBefore = -firstLineIndex;\n            this._startLineNumber -= deletedBefore;\n            this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n        }\n        else {\n            this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n        }\n    }\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - this._startLineNumber;\n        if (lineIndex < 0) {\n            // this insertion occurs before this block, so we only need to adjust line numbers\n            this._startLineNumber += eolCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\n            // this insertion occurs after this block, so there is nothing to do\n            return;\n        }\n        this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n}\nclass SparseMultilineTokensStorage {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._tokenCount = tokens.length / 4;\n    }\n    toString(startLineNumber) {\n        const pieces = [];\n        for (let i = 0; i < this._tokenCount; i++) {\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n        }\n        return `[${pieces.join(',')}]`;\n    }\n    getMaxDeltaLine() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return -1;\n        }\n        return this._getDeltaLine(tokenCount - 1);\n    }\n    getRange() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return null;\n        }\n        const startChar = this._getStartCharacter(0);\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n        const endChar = this._getEndCharacter(tokenCount - 1);\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n    _getTokenCount() {\n        return this._tokenCount;\n    }\n    _getDeltaLine(tokenIndex) {\n        return this._tokens[4 * tokenIndex];\n    }\n    _getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    _getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    isEmpty() {\n        return (this._getTokenCount() === 0);\n    }\n    getLineTokens(deltaLine) {\n        let low = 0;\n        let high = this._getTokenCount() - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const midDeltaLine = this._getDeltaLine(mid);\n            if (midDeltaLine < deltaLine) {\n                low = mid + 1;\n            }\n            else if (midDeltaLine > deltaLine) {\n                high = mid - 1;\n            }\n            else {\n                let min = mid;\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n                    min--;\n                }\n                let max = mid;\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n                    max++;\n                }\n                return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n            }\n        }\n        if (this._getDeltaLine(low) === deltaLine) {\n            return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n        }\n        return null;\n    }\n    clear() {\n        this._tokenCount = 0;\n    }\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        let firstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                hasDeletedTokens = true;\n            }\n            else {\n                if (newTokenCount === 0) {\n                    firstDeltaLine = tokenDeltaLine;\n                }\n                if (hasDeletedTokens) {\n                    // must move the token to the left\n                    const destOffset = 4 * newTokenCount;\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n                    tokens[destOffset + 1] = tokenStartCharacter;\n                    tokens[destOffset + 2] = tokenEndCharacter;\n                    tokens[destOffset + 3] = tokenMetadata;\n                }\n                newTokenCount++;\n            }\n        }\n        this._tokenCount = newTokenCount;\n        return firstDeltaLine;\n    }\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const aTokens = [];\n        const bTokens = [];\n        let destTokens = aTokens;\n        let destOffset = 0;\n        let destFirstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                    // this token is touching the range\n                    continue;\n                }\n                else {\n                    // this token is after the range\n                    if (destTokens !== bTokens) {\n                        // this token is the first token after the range\n                        destTokens = bTokens;\n                        destOffset = 0;\n                        destFirstDeltaLine = tokenDeltaLine;\n                    }\n                }\n            }\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n            destTokens[destOffset++] = tokenStartCharacter;\n            destTokens[destOffset++] = tokenEndCharacter;\n            destTokens[destOffset++] = tokenMetadata;\n        }\n        return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n        // This is a bit complex, here are the cases I used to think about this:\n        //\n        // 1. The token starts before the deletion range\n        // 1a. The token is completely before the deletion range\n        //               -----------\n        //                          xxxxxxxxxxx\n        // 1b. The token starts before, the deletion range ends after the token\n        //               -----------\n        //                      xxxxxxxxxxx\n        // 1c. The token starts before, the deletion range ends precisely with the token\n        //               ---------------\n        //                      xxxxxxxx\n        // 1d. The token starts before, the deletion range is inside the token\n        //               ---------------\n        //                    xxxxx\n        //\n        // 2. The token starts at the same position with the deletion range\n        // 2a. The token starts at the same position, and ends inside the deletion range\n        //               -------\n        //               xxxxxxxxxxx\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\n        //               ----------\n        //               xxxxxxxxxx\n        // 2c. The token starts at the same position, and ends after the deletion range\n        //               -------------\n        //               xxxxxxx\n        //\n        // 3. The token starts inside the deletion range\n        // 3a. The token is inside the deletion range\n        //                -------\n        //             xxxxxxxxxxxxx\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n        //                ----------\n        //             xxxxxxxxxxxxx\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\n        //                ------------\n        //             xxxxxxxxxxx\n        //\n        // 4. The token starts after the deletion range\n        //                  -----------\n        //          xxxxxxxx\n        //\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            let tokenDeltaLine = tokens[srcOffset];\n            let tokenStartCharacter = tokens[srcOffset + 1];\n            let tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n                // 1a. The token is completely before the deletion range\n                // => nothing to do\n                newTokenCount++;\n                continue;\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n                // 1b, 1c, 1d\n                // => the token survives, but it needs to shrink\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 1d. The token starts before, the deletion range is inside the token\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 1b. The token starts before, the deletion range ends after the token\n                    // 1c. The token starts before, the deletion range ends precisely with the token\n                    // => the token shrinks its ending to the deletion start\n                    tokenEndCharacter = startCharacter;\n                }\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n                // 2a, 2b, 2c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 2c. The token starts at the same position, and ends after the deletion range\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 2a. The token starts at the same position, and ends inside the deletion range\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n                // 3a, 3b, 3c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\n                    // => the token moves to continue right after the deletion\n                    tokenDeltaLine = startDeltaLine;\n                    tokenStartCharacter = startCharacter;\n                    tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                }\n                else {\n                    // 3a. The token is inside the deletion range\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine > endDeltaLine) {\n                // 4. (partial) The token starts after the deletion range, on a line below...\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\n                    // early stop, there is no need to walk all the tokens and do nothing...\n                    newTokenCount = tokenCount;\n                    break;\n                }\n                tokenDeltaLine -= deletedLineCount;\n            }\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\n                }\n                tokenDeltaLine -= deletedLineCount;\n                tokenStartCharacter -= (endCharacter - startCharacter);\n                tokenEndCharacter -= (endCharacter - startCharacter);\n            }\n            else {\n                throw new Error(`Not possible!`);\n            }\n            const destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n            newTokenCount++;\n        }\n        this._tokenCount = newTokenCount;\n    }\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        // Here are the cases I used to think about this:\n        //\n        // 1. The token is completely before the insertion point\n        //            -----------   |\n        // 2. The token ends precisely at the insertion point\n        //            -----------|\n        // 3. The token contains the insertion point\n        //            -----|------\n        // 4. The token starts precisely at the insertion point\n        //            |-----------\n        // 5. The token is completely after the insertion point\n        //            |   -----------\n        //\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\n            && firstLineLength === 1\n            && ((firstCharCode >= 48 /* CharCode.Digit0 */ && firstCharCode <= 57 /* CharCode.Digit9 */)\n                || (firstCharCode >= 65 /* CharCode.A */ && firstCharCode <= 90 /* CharCode.Z */)\n                || (firstCharCode >= 97 /* CharCode.a */ && firstCharCode <= 122 /* CharCode.z */)));\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        for (let i = 0; i < tokenCount; i++) {\n            const offset = 4 * i;\n            let tokenDeltaLine = tokens[offset];\n            let tokenStartCharacter = tokens[offset + 1];\n            let tokenEndCharacter = tokens[offset + 2];\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n                // 1. The token is completely before the insertion point\n                // => nothing to do\n                continue;\n            }\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n                // 2. The token ends precisely at the insertion point\n                // => expand the end character only if inserting precisely one character that is a word character\n                if (isInsertingPreciselyOneWordCharacter) {\n                    tokenEndCharacter += 1;\n                }\n                else {\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n                // 3. The token contains the insertion point\n                if (eolCount === 0) {\n                    // => just expand the end character\n                    tokenEndCharacter += firstLineLength;\n                }\n                else {\n                    // => cut off the token\n                    tokenEndCharacter = character;\n                }\n            }\n            else {\n                // 4. or 5.\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n                    // 4. The token starts precisely at the insertion point\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n                    // => otherwise behave as in case 5.\n                    if (isInsertingPreciselyOneWordCharacter) {\n                        continue;\n                    }\n                }\n                // => the token must move and keep its size constant\n                if (tokenDeltaLine === deltaLine) {\n                    tokenDeltaLine += eolCount;\n                    // this token is on the line where the insertion is taking place\n                    if (eolCount === 0) {\n                        tokenStartCharacter += firstLineLength;\n                        tokenEndCharacter += firstLineLength;\n                    }\n                    else {\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\n                    }\n                }\n                else {\n                    tokenDeltaLine += eolCount;\n                }\n            }\n            tokens[offset] = tokenDeltaLine;\n            tokens[offset + 1] = tokenStartCharacter;\n            tokens[offset + 2] = tokenEndCharacter;\n        }\n    }\n}\nexport class SparseLineTokens {\n    constructor(tokens) {\n        this._tokens = tokens;\n    }\n    getCount() {\n        return this._tokens.length / 4;\n    }\n    getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    getMetadata(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 3];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../base/common/lifecycle.js';\nexport class ViewEventHandler extends Disposable {\n    constructor() {\n        super();\n        this._shouldRender = true;\n    }\n    shouldRender() {\n        return this._shouldRender;\n    }\n    forceShouldRender() {\n        this._shouldRender = true;\n    }\n    setShouldRender() {\n        this._shouldRender = true;\n    }\n    onDidRender() {\n        this._shouldRender = false;\n    }\n    // --- begin event handlers\n    onCompositionStart(e) {\n        return false;\n    }\n    onCompositionEnd(e) {\n        return false;\n    }\n    onConfigurationChanged(e) {\n        return false;\n    }\n    onCursorStateChanged(e) {\n        return false;\n    }\n    onDecorationsChanged(e) {\n        return false;\n    }\n    onFlushed(e) {\n        return false;\n    }\n    onFocusChanged(e) {\n        return false;\n    }\n    onLanguageConfigurationChanged(e) {\n        return false;\n    }\n    onLineMappingChanged(e) {\n        return false;\n    }\n    onLinesChanged(e) {\n        return false;\n    }\n    onLinesDeleted(e) {\n        return false;\n    }\n    onLinesInserted(e) {\n        return false;\n    }\n    onRevealRangeRequest(e) {\n        return false;\n    }\n    onScrollChanged(e) {\n        return false;\n    }\n    onThemeChanged(e) {\n        return false;\n    }\n    onTokensChanged(e) {\n        return false;\n    }\n    onTokensColorsChanged(e) {\n        return false;\n    }\n    onZonesChanged(e) {\n        return false;\n    }\n    // --- end event handlers\n    handleEvents(events) {\n        let shouldRender = false;\n        for (let i = 0, len = events.length; i < len; i++) {\n            const e = events[i];\n            switch (e.type) {\n                case 0 /* viewEvents.ViewEventType.ViewCompositionStart */:\n                    if (this.onCompositionStart(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 1 /* viewEvents.ViewEventType.ViewCompositionEnd */:\n                    if (this.onCompositionEnd(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 2 /* viewEvents.ViewEventType.ViewConfigurationChanged */:\n                    if (this.onConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 3 /* viewEvents.ViewEventType.ViewCursorStateChanged */:\n                    if (this.onCursorStateChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 4 /* viewEvents.ViewEventType.ViewDecorationsChanged */:\n                    if (this.onDecorationsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 5 /* viewEvents.ViewEventType.ViewFlushed */:\n                    if (this.onFlushed(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 6 /* viewEvents.ViewEventType.ViewFocusChanged */:\n                    if (this.onFocusChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 7 /* viewEvents.ViewEventType.ViewLanguageConfigurationChanged */:\n                    if (this.onLanguageConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 8 /* viewEvents.ViewEventType.ViewLineMappingChanged */:\n                    if (this.onLineMappingChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 9 /* viewEvents.ViewEventType.ViewLinesChanged */:\n                    if (this.onLinesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 10 /* viewEvents.ViewEventType.ViewLinesDeleted */:\n                    if (this.onLinesDeleted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 11 /* viewEvents.ViewEventType.ViewLinesInserted */:\n                    if (this.onLinesInserted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 12 /* viewEvents.ViewEventType.ViewRevealRangeRequest */:\n                    if (this.onRevealRangeRequest(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 13 /* viewEvents.ViewEventType.ViewScrollChanged */:\n                    if (this.onScrollChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 15 /* viewEvents.ViewEventType.ViewTokensChanged */:\n                    if (this.onTokensChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 14 /* viewEvents.ViewEventType.ViewThemeChanged */:\n                    if (this.onThemeChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 16 /* viewEvents.ViewEventType.ViewTokensColorsChanged */:\n                    if (this.onTokensColorsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 17 /* viewEvents.ViewEventType.ViewZonesChanged */:\n                    if (this.onZonesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                default:\n                    console.info('View received unknown event: ');\n                    console.info(e);\n            }\n        }\n        if (shouldRender) {\n            this._shouldRender = true;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ViewCompositionStartEvent {\n    constructor() {\n        this.type = 0 /* ViewEventType.ViewCompositionStart */;\n    }\n}\nexport class ViewCompositionEndEvent {\n    constructor() {\n        this.type = 1 /* ViewEventType.ViewCompositionEnd */;\n    }\n}\nexport class ViewConfigurationChangedEvent {\n    constructor(source) {\n        this.type = 2 /* ViewEventType.ViewConfigurationChanged */;\n        this._source = source;\n    }\n    hasChanged(id) {\n        return this._source.hasChanged(id);\n    }\n}\nexport class ViewCursorStateChangedEvent {\n    constructor(selections, modelSelections, reason) {\n        this.selections = selections;\n        this.modelSelections = modelSelections;\n        this.reason = reason;\n        this.type = 3 /* ViewEventType.ViewCursorStateChanged */;\n    }\n}\nexport class ViewDecorationsChangedEvent {\n    constructor(source) {\n        this.type = 4 /* ViewEventType.ViewDecorationsChanged */;\n        if (source) {\n            this.affectsMinimap = source.affectsMinimap;\n            this.affectsOverviewRuler = source.affectsOverviewRuler;\n            this.affectsGlyphMargin = source.affectsGlyphMargin;\n        }\n        else {\n            this.affectsMinimap = true;\n            this.affectsOverviewRuler = true;\n            this.affectsGlyphMargin = true;\n        }\n    }\n}\nexport class ViewFlushedEvent {\n    constructor() {\n        this.type = 5 /* ViewEventType.ViewFlushed */;\n        // Nothing to do\n    }\n}\nexport class ViewFocusChangedEvent {\n    constructor(isFocused) {\n        this.type = 6 /* ViewEventType.ViewFocusChanged */;\n        this.isFocused = isFocused;\n    }\n}\nexport class ViewLanguageConfigurationEvent {\n    constructor() {\n        this.type = 7 /* ViewEventType.ViewLanguageConfigurationChanged */;\n    }\n}\nexport class ViewLineMappingChangedEvent {\n    constructor() {\n        this.type = 8 /* ViewEventType.ViewLineMappingChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewLinesChangedEvent {\n    constructor(\n    /**\n     * The first line that has changed.\n     */\n    fromLineNumber, \n    /**\n     * The number of lines that have changed.\n     */\n    count) {\n        this.fromLineNumber = fromLineNumber;\n        this.count = count;\n        this.type = 9 /* ViewEventType.ViewLinesChanged */;\n    }\n}\nexport class ViewLinesDeletedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 10 /* ViewEventType.ViewLinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewLinesInsertedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 11 /* ViewEventType.ViewLinesInserted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewRevealRangeRequestEvent {\n    constructor(\n    /**\n     * Source of the call that caused the event.\n     */\n    source, \n    /**\n     * Reduce the revealing to a minimum (e.g. avoid scrolling if the bounding box is visible and near the viewport edge).\n     */\n    minimalReveal, \n    /**\n     * Range to be reavealed.\n     */\n    range, \n    /**\n     * Selections to be revealed.\n     */\n    selections, \n    /**\n     * The vertical reveal strategy.\n     */\n    verticalType, \n    /**\n     * If true: there should be a horizontal & vertical revealing.\n     * If false: there should be just a vertical revealing.\n     */\n    revealHorizontal, \n    /**\n     * The scroll type.\n     */\n    scrollType) {\n        this.source = source;\n        this.minimalReveal = minimalReveal;\n        this.range = range;\n        this.selections = selections;\n        this.verticalType = verticalType;\n        this.revealHorizontal = revealHorizontal;\n        this.scrollType = scrollType;\n        this.type = 12 /* ViewEventType.ViewRevealRangeRequest */;\n    }\n}\nexport class ViewScrollChangedEvent {\n    constructor(source) {\n        this.type = 13 /* ViewEventType.ViewScrollChanged */;\n        this.scrollWidth = source.scrollWidth;\n        this.scrollLeft = source.scrollLeft;\n        this.scrollHeight = source.scrollHeight;\n        this.scrollTop = source.scrollTop;\n        this.scrollWidthChanged = source.scrollWidthChanged;\n        this.scrollLeftChanged = source.scrollLeftChanged;\n        this.scrollHeightChanged = source.scrollHeightChanged;\n        this.scrollTopChanged = source.scrollTopChanged;\n    }\n}\nexport class ViewThemeChangedEvent {\n    constructor(theme) {\n        this.theme = theme;\n        this.type = 14 /* ViewEventType.ViewThemeChanged */;\n    }\n}\nexport class ViewTokensChangedEvent {\n    constructor(ranges) {\n        this.type = 15 /* ViewEventType.ViewTokensChanged */;\n        this.ranges = ranges;\n    }\n}\nexport class ViewTokensColorsChangedEvent {\n    constructor() {\n        this.type = 16 /* ViewEventType.ViewTokensColorsChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.type = 17 /* ViewEventType.ViewZonesChanged */;\n        // Nothing to do\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n    constructor(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n        this._lineDecorationBrand = undefined;\n    }\n    static _equals(a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    }\n    static equalsArr(a, b) {\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static extractWrapped(arr, startOffset, endOffset) {\n        if (arr.length === 0) {\n            return arr;\n        }\n        const startColumn = startOffset + 1;\n        const endColumn = endOffset + 1;\n        const lineLength = endOffset - startOffset;\n        const r = [];\n        let rLength = 0;\n        for (const dec of arr) {\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n                continue;\n            }\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n        return r;\n    }\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            const range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === 0 /* InlineDecorationType.Regular */ || d.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    }\n    static _typeCompare(a, b) {\n        const ORDER = [2, 0, 1, 3];\n        return ORDER[a] - ORDER[b];\n    }\n    static compare(a, b) {\n        if (a.startColumn !== b.startColumn) {\n            return a.startColumn - b.startColumn;\n        }\n        if (a.endColumn !== b.endColumn) {\n            return a.endColumn - b.endColumn;\n        }\n        const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n        if (typeCmp !== 0) {\n            return typeCmp;\n        }\n        if (a.className !== b.className) {\n            return a.className < b.className ? -1 : 1;\n        }\n        return 0;\n    }\n}\nexport class DecorationSegment {\n    constructor(startOffset, endOffset, className, metadata) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n        this.metadata = metadata;\n    }\n}\nclass Stack {\n    constructor() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.metadata = [];\n        this.count = 0;\n    }\n    static _metadata(metadata) {\n        let result = 0;\n        for (let i = 0, len = metadata.length; i < len; i++) {\n            result |= metadata[i];\n        }\n        return result;\n    }\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            let i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.metadata.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    }\n    insert(stopOffset, className, metadata) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n            this.metadata.push(metadata);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (let i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    this.metadata.splice(i, 0, metadata);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    }\n}\nexport class LineDecorationsNormalizer {\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    static normalize(lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        const stack = new Stack();\n        let nextStartOffset = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            let startColumn = d.startColumn;\n            let endColumn = d.endColumn;\n            const className = d.className;\n            const metadata = (d.type === 1 /* InlineDecorationType.Before */\n                ? 2 /* LinePartMetadata.PSEUDO_BEFORE */\n                : d.type === 2 /* InlineDecorationType.After */\n                    ? 4 /* LinePartMetadata.PSEUDO_AFTER */\n                    : 0);\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            const currentStartOffset = startColumn - 1;\n            const currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className, metadata);\n        }\n        stack.consumeLowerThan(1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LinePart {\n    constructor(\n    /**\n     * last char index of this token (not inclusive).\n     */\n    endIndex, type, metadata, containsRTL) {\n        this.endIndex = endIndex;\n        this.type = type;\n        this.metadata = metadata;\n        this.containsRTL = containsRTL;\n        this._linePartBrand = undefined;\n    }\n    isWhitespace() {\n        return (this.metadata & 1 /* LinePartMetadata.IS_WHITESPACE_MASK */ ? true : false);\n    }\n    isPseudoAfter() {\n        return (this.metadata & 4 /* LinePartMetadata.PSEUDO_AFTER_MASK */ ? true : false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { StringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart } from './linePart.js';\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* RenderWhitespace.All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* RenderWhitespace.Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* RenderWhitespace.Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* RenderWhitespace.Trailing */\n                        : 0 /* RenderWhitespace.None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\nexport class DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* CharacterMappingConstants.PART_INDEX_MASK */) >>> 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CharacterMappingConstants.CHAR_INDEX_MASK */) >>> 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */;\n    }\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._horizontalOffset = new Uint32Array(this.length);\n    }\n    setColumnInfo(column, partIndex, charIndex, horizontalOffset) {\n        const partData = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._horizontalOffset[column - 1] = horizontalOffset;\n    }\n    getHorizontalOffset(column) {\n        if (this._horizontalOffset.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._horizontalOffset[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* ForeignElementType.None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* InlineDecorationType.Before */ || lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                    sb.appendString(`<span class=\"`);\n                    sb.appendString(lineDecoration.className);\n                    sb.appendString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                        containsForeignElements |= 1 /* ForeignElementType.Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                        containsForeignElements |= 2 /* ForeignElementType.After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* ForeignElementType.None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    const sb = new StringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.overflowingCharCount = overflowingCharCount;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let overflowingCharCount;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        overflowingCharCount = lineContent.length - input.stopRenderingLineAfter;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        overflowingCharCount = 0;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* RenderWhitespace.All */ ||\n        input.renderWhitespace === 1 /* RenderWhitespace.Boundary */ ||\n        (input.renderWhitespace === 2 /* RenderWhitespace.Selection */ && !!input.selectionsOnLine) ||\n        (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */ && !input.continuesWithWrappedLine)) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* ForeignElementType.None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                containsForeignElements |= 2 /* ForeignElementType.After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent, lineContainsRTL, tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n    }\n    let startOffset = fauxIndentLength;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false);\n            result[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n            break;\n        }\n        const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false);\n        result[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n        startOffset = endIndex;\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* Constants.LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* CharCode.Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* Constants.LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* Constants.LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                const piecesCount = Math.ceil(diff / 50 /* Constants.LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* Constants.LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* CharCode.Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0, false);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* RenderWhitespace.Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenContainsRTL = tokens[tokenIndex].containsRTL;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* CharCode.Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */);\n                    isInWhitespace = (nextChCode === 32 /* CharCode.Space */ || nextChCode === 9 /* CharCode.Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (isInWhitespace && tokenContainsRTL) {\n            // If the token contains RTL text, breaking it up into multiple line parts\n            // to render whitespace might affect the browser's bidi layout.\n            //\n            // We render whitespace in such tokens only if the whitespace\n            // is the leading or the trailing whitespace of the line,\n            // which doesn't affect the browser's bidi layout.\n            if (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n                isInWhitespace = false;\n            }\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* CharCode.Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenContainsRTL = tokens[tokenIndex].containsRTL;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* CharCode.Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* CharCode.Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* CharCode.Space */ && (prevCharCode !== 32 /* CharCode.Space */ && prevCharCode !== 9 /* CharCode.Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const tokenContainsRTL = token.containsRTL;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const overflowingCharCount = input.overflowingCharCount;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0; // the character offset in the current part\n    let charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n    let partDisplacement = 0;\n    if (containsRTL) {\n        sb.appendString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partContainsRTL = part.containsRTL;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* RenderWhitespace.None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendString('<span ');\n        if (partContainsRTL) {\n            sb.appendString('style=\"unicode-bidi:isolate\" ');\n        }\n        sb.appendString('class=\"');\n        sb.appendString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCIICharCode(34 /* CharCode.DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partWidth = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* CharCode.Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partWidth += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendString(' style=\"width:');\n                sb.appendString(String(spaceWidth * partWidth));\n                sb.appendString('px\"');\n            }\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters;\n                let charWidth;\n                if (charCode === 9 /* CharCode.Tab */) {\n                    producedCharacters = (tabSize - (visibleColumn % tabSize)) | 0;\n                    charWidth = producedCharacters;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.appendCharCode(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.appendCharCode(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.appendCharCode(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    producedCharacters = 2;\n                    charWidth = 1;\n                    sb.appendCharCode(renderSpaceCharCode); // &middot; or word separator middle dot\n                    sb.appendCharCode(0x200C); // ZERO WIDTH NON-JOINER\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        else {\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* CharCode.Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.appendCharCode(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* CharCode.Space */:\n                        sb.appendCharCode(0xA0); // &nbsp;\n                        break;\n                    case 60 /* CharCode.LessThan */:\n                        sb.appendString('&lt;');\n                        break;\n                    case 62 /* CharCode.GreaterThan */:\n                        sb.appendString('&gt;');\n                        break;\n                    case 38 /* CharCode.Ampersand */:\n                        sb.appendString('&amp;');\n                        break;\n                    case 0 /* CharCode.Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.appendCharCode(9216);\n                        }\n                        else {\n                            sb.appendString('&#00;');\n                        }\n                        break;\n                    case 65279 /* CharCode.UTF8_BOM */:\n                    case 8232 /* CharCode.LINE_SEPARATOR */:\n                    case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                    case 133 /* CharCode.NEXT_LINE */:\n                        sb.appendCharCode(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.appendCharCode(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.appendCharCode(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendString('[U+');\n                            sb.appendString(to4CharHex(charCode));\n                            sb.appendString(']');\n                            producedCharacters = 8;\n                            charWidth = producedCharacters;\n                        }\n                        else {\n                            sb.appendCharCode(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n        }\n        sb.appendString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n    }\n    if (isOverflowing) {\n        sb.appendString('<span class=\"mtkoverflow\">');\n        sb.appendString(nls.localize('showMore', \"Show more ({0})\", renderOverflowingCharCount(overflowingCharCount)));\n        sb.appendString('</span>');\n    }\n    sb.appendString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\nfunction renderOverflowingCharCount(n) {\n    if (n < 1024) {\n        return nls.localize('overflow.chars', \"{0} chars\", n);\n    }\n    if (n < 1024 * 1024) {\n        return `${(n / 1024).toFixed(1)} KB`;\n    }\n    return `${(n / 1024 / 1024).toFixed(1)} MB`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\n/**\n * Contains all data needed to render at a specific viewport.\n */\nexport class ViewportData {\n    constructor(selections, partialData, whitespaceViewportData, model) {\n        this.selections = selections;\n        this.startLineNumber = partialData.startLineNumber | 0;\n        this.endLineNumber = partialData.endLineNumber | 0;\n        this.relativeVerticalOffset = partialData.relativeVerticalOffset;\n        this.bigNumbersDelta = partialData.bigNumbersDelta | 0;\n        this.whitespaceViewportData = whitespaceViewportData;\n        this._model = model;\n        this.visibleRange = new Range(partialData.startLineNumber, this._model.getLineMinColumn(partialData.startLineNumber), partialData.endLineNumber, this._model.getLineMaxColumn(partialData.endLineNumber));\n    }\n    getViewLineRenderingData(lineNumber) {\n        return this._model.getViewportViewLineRenderingData(this.visibleRange, lineNumber);\n    }\n    getDecorationsInViewport() {\n        return this._model.getDecorationsInViewport(this.visibleRange);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../base/common/arrays.js';\nimport * as strings from '../../base/common/strings.js';\nimport { Range } from './core/range.js';\nexport class Viewport {\n    constructor(top, left, width, height) {\n        this._viewportBrand = undefined;\n        this.top = top | 0;\n        this.left = left | 0;\n        this.width = width | 0;\n        this.height = height | 0;\n    }\n}\nexport class MinimapLinesRenderingData {\n    constructor(tabSize, data) {\n        this.tabSize = tabSize;\n        this.data = data;\n    }\n}\nexport class ViewLineData {\n    constructor(content, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations) {\n        this._viewLineDataBrand = undefined;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.startVisibleColumn = startVisibleColumn;\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n    }\n}\nexport class ViewLineRenderingData {\n    constructor(minColumn, maxColumn, content, continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize, startVisibleColumn) {\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n        this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n    }\n    static isBasicASCII(lineContent, mightContainNonBasicASCII) {\n        if (mightContainNonBasicASCII) {\n            return strings.isBasicASCII(lineContent);\n        }\n        return true;\n    }\n    static containsRTL(lineContent, isBasicASCII, mightContainRTL) {\n        if (!isBasicASCII && mightContainRTL) {\n            return strings.containsRTL(lineContent);\n        }\n        return false;\n    }\n}\nexport class InlineDecoration {\n    constructor(range, inlineClassName, type) {\n        this.range = range;\n        this.inlineClassName = inlineClassName;\n        this.type = type;\n    }\n}\nexport class SingleLineInlineDecoration {\n    constructor(startOffset, endOffset, inlineClassName, inlineClassNameAffectsLetterSpacing) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.inlineClassName = inlineClassName;\n        this.inlineClassNameAffectsLetterSpacing = inlineClassNameAffectsLetterSpacing;\n    }\n    toInlineDecoration(lineNumber) {\n        return new InlineDecoration(new Range(lineNumber, this.startOffset + 1, lineNumber, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n    }\n}\nexport class ViewModelDecoration {\n    constructor(range, options) {\n        this._viewModelDecorationBrand = undefined;\n        this.range = range;\n        this.options = options;\n    }\n}\nexport class OverviewRulerDecorationsGroup {\n    constructor(color, zIndex, \n    /**\n     * Decorations are encoded in a number array using the following scheme:\n     *  - 3*i = lane\n     *  - 3*i+1 = startLineNumber\n     *  - 3*i+2 = endLineNumber\n     */\n    data) {\n        this.color = color;\n        this.zIndex = zIndex;\n        this.data = data;\n    }\n    static compareByRenderingProps(a, b) {\n        if (a.zIndex === b.zIndex) {\n            if (a.color < b.color) {\n                return -1;\n            }\n            if (a.color > b.color) {\n                return 1;\n            }\n            return 0;\n        }\n        return a.zIndex - b.zIndex;\n    }\n    static equals(a, b) {\n        return (a.color === b.color\n            && a.zIndex === b.zIndex\n            && arrays.equals(a.data, b.data));\n    }\n    static equalsArr(a, b) {\n        return arrays.equals(a, b, OverviewRulerDecorationsGroup.equals);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, markAsSingleton } from '../../../base/common/lifecycle.js';\nimport { RGBA8 } from '../core/rgba.js';\nimport { TokenizationRegistry } from '../languages.js';\nexport class MinimapTokensColorTracker extends Disposable {\n    static getInstance() {\n        if (!this._INSTANCE) {\n            this._INSTANCE = markAsSingleton(new MinimapTokensColorTracker());\n        }\n        return this._INSTANCE;\n    }\n    constructor() {\n        super();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._updateColorMap();\n        this._register(TokenizationRegistry.onDidChange(e => {\n            if (e.changedColorMap) {\n                this._updateColorMap();\n            }\n        }));\n    }\n    _updateColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        if (!colorMap) {\n            this._colors = [RGBA8.Empty];\n            this._backgroundIsLight = true;\n            return;\n        }\n        this._colors = [RGBA8.Empty];\n        for (let colorId = 1; colorId < colorMap.length; colorId++) {\n            const source = colorMap[colorId].rgba;\n            // Use a VM friendly data-type\n            this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));\n        }\n        const backgroundLuminosity = colorMap[2 /* ColorId.DefaultBackground */].getRelativeLuminance();\n        this._backgroundIsLight = backgroundLuminosity >= 0.5;\n        this._onDidChange.fire(undefined);\n    }\n    getColor(colorId) {\n        if (colorId < 1 || colorId >= this._colors.length) {\n            // background color (basically invisible)\n            colorId = 2 /* ColorId.DefaultBackground */;\n        }\n        return this._colors[colorId];\n    }\n    backgroundIsLight() {\n        return this._backgroundIsLight;\n    }\n}\nMinimapTokensColorTracker._INSTANCE = null;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from '../modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(132 /* EditorOption.wordWrapBreakBeforeCharacters */), options.get(131 /* EditorOption.wordWrapBreakAfterCharacters */));\n    }\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n        const requests = [];\n        const injectedTexts = [];\n        const previousBreakingData = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n                const result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const injectedText = injectedTexts[i];\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* CharacterClass.NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* CharacterClass.BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* CharacterClass.BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* CharacterClass.BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const isKeepAll = (wordBreak === 'keepAll');\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = arrPool1;\n    const breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* CharCode.Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* CharacterClass.NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* CharacterClass.NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* CharCode.Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* CharacterClass.NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n    const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n    let injectionOptions;\n    let injectionOffsets;\n    if (injectedTexts && injectedTexts.length > 0) {\n        injectionOptions = injectedTexts.map(t => t.options);\n        injectionOffsets = injectedTexts.map(text => text.column - 1);\n    }\n    else {\n        injectionOptions = null;\n        injectionOffsets = null;\n    }\n    if (firstLineBreakColumn === -1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const isKeepAll = (wordBreak === 'keepAll');\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = [];\n    const breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* CharacterClass.NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* CharCode.Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll) {\n    return (charCode !== 32 /* CharCode.Space */\n        && ((prevCharCodeClass === 2 /* CharacterClass.BREAK_AFTER */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */) // break at the end of multiple BREAK_AFTER\n            || (prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */ && charCodeClass === 1 /* CharacterClass.BREAK_BEFORE */) // break at the start of multiple BREAK_BEFORE\n            || (!isKeepAll && prevCharCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */)\n            || (!isKeepAll && charCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* CharCode.Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ColorZone {\n    constructor(from, to, colorId) {\n        this._colorZoneBrand = undefined;\n        this.from = from | 0;\n        this.to = to | 0;\n        this.colorId = colorId | 0;\n    }\n    static compare(a, b) {\n        if (a.colorId === b.colorId) {\n            if (a.from === b.from) {\n                return a.to - b.to;\n            }\n            return a.from - b.from;\n        }\n        return a.colorId - b.colorId;\n    }\n}\n/**\n * A zone in the overview ruler\n */\nexport class OverviewRulerZone {\n    constructor(startLineNumber, endLineNumber, heightInLines, color) {\n        this._overviewRulerZoneBrand = undefined;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n        this.heightInLines = heightInLines;\n        this.color = color;\n        this._colorZone = null;\n    }\n    static compare(a, b) {\n        if (a.color === b.color) {\n            if (a.startLineNumber === b.startLineNumber) {\n                if (a.heightInLines === b.heightInLines) {\n                    return a.endLineNumber - b.endLineNumber;\n                }\n                return a.heightInLines - b.heightInLines;\n            }\n            return a.startLineNumber - b.startLineNumber;\n        }\n        return a.color < b.color ? -1 : 1;\n    }\n    setColorZone(colorZone) {\n        this._colorZone = colorZone;\n    }\n    getColorZones() {\n        return this._colorZone;\n    }\n}\nexport class OverviewZoneManager {\n    constructor(getVerticalOffsetForLine) {\n        this._getVerticalOffsetForLine = getVerticalOffsetForLine;\n        this._zones = [];\n        this._colorZonesInvalid = false;\n        this._lineHeight = 0;\n        this._domWidth = 0;\n        this._domHeight = 0;\n        this._outerHeight = 0;\n        this._pixelRatio = 1;\n        this._lastAssignedId = 0;\n        this._color2Id = Object.create(null);\n        this._id2Color = [];\n    }\n    getId2Color() {\n        return this._id2Color;\n    }\n    setZones(newZones) {\n        this._zones = newZones;\n        this._zones.sort(OverviewRulerZone.compare);\n    }\n    setLineHeight(lineHeight) {\n        if (this._lineHeight === lineHeight) {\n            return false;\n        }\n        this._lineHeight = lineHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    setPixelRatio(pixelRatio) {\n        this._pixelRatio = pixelRatio;\n        this._colorZonesInvalid = true;\n    }\n    getDOMWidth() {\n        return this._domWidth;\n    }\n    getCanvasWidth() {\n        return this._domWidth * this._pixelRatio;\n    }\n    setDOMWidth(width) {\n        if (this._domWidth === width) {\n            return false;\n        }\n        this._domWidth = width;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getDOMHeight() {\n        return this._domHeight;\n    }\n    getCanvasHeight() {\n        return this._domHeight * this._pixelRatio;\n    }\n    setDOMHeight(height) {\n        if (this._domHeight === height) {\n            return false;\n        }\n        this._domHeight = height;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getOuterHeight() {\n        return this._outerHeight;\n    }\n    setOuterHeight(outerHeight) {\n        if (this._outerHeight === outerHeight) {\n            return false;\n        }\n        this._outerHeight = outerHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    resolveColorZones() {\n        const colorZonesInvalid = this._colorZonesInvalid;\n        const lineHeight = Math.floor(this._lineHeight);\n        const totalHeight = Math.floor(this.getCanvasHeight());\n        const outerHeight = Math.floor(this._outerHeight);\n        const heightRatio = totalHeight / outerHeight;\n        const halfMinimumHeight = Math.floor(4 /* Constants.MINIMUM_HEIGHT */ * this._pixelRatio / 2);\n        const allColorZones = [];\n        for (let i = 0, len = this._zones.length; i < len; i++) {\n            const zone = this._zones[i];\n            if (!colorZonesInvalid) {\n                const colorZone = zone.getColorZones();\n                if (colorZone) {\n                    allColorZones.push(colorZone);\n                    continue;\n                }\n            }\n            const offset1 = this._getVerticalOffsetForLine(zone.startLineNumber);\n            const offset2 = (zone.heightInLines === 0\n                ? this._getVerticalOffsetForLine(zone.endLineNumber) + lineHeight\n                : offset1 + zone.heightInLines * lineHeight);\n            const y1 = Math.floor(heightRatio * offset1);\n            const y2 = Math.floor(heightRatio * offset2);\n            let ycenter = Math.floor((y1 + y2) / 2);\n            let halfHeight = (y2 - ycenter);\n            if (halfHeight < halfMinimumHeight) {\n                halfHeight = halfMinimumHeight;\n            }\n            if (ycenter - halfHeight < 0) {\n                ycenter = halfHeight;\n            }\n            if (ycenter + halfHeight > totalHeight) {\n                ycenter = totalHeight - halfHeight;\n            }\n            const color = zone.color;\n            let colorId = this._color2Id[color];\n            if (!colorId) {\n                colorId = (++this._lastAssignedId);\n                this._color2Id[color] = colorId;\n                this._id2Color[colorId] = color;\n            }\n            const colorZone = new ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId);\n            zone.setColorZone(colorZone);\n            allColorZones.push(colorZone);\n        }\n        this._colorZonesInvalid = false;\n        allColorZones.sort(ColorZone.compare);\n        return allColorZones;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorTheme } from '../editorTheme.js';\nexport class ViewContext {\n    constructor(configuration, theme, model) {\n        this.configuration = configuration;\n        this.theme = new EditorTheme(theme);\n        this.viewModel = model;\n        this.viewLayout = model.viewLayout;\n    }\n    addEventHandler(eventHandler) {\n        this.viewModel.addViewEventHandler(eventHandler);\n    }\n    removeEventHandler(eventHandler) {\n        this.viewModel.removeViewEventHandler(eventHandler);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { InlineDecoration, ViewModelDecoration } from '../viewModel.js';\nimport { filterValidationDecorations } from '../config/editorOptions.js';\nexport class ViewModelDecorations {\n    constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n        this.editorId = editorId;\n        this.model = model;\n        this.configuration = configuration;\n        this._linesCollection = linesCollection;\n        this._coordinatesConverter = coordinatesConverter;\n        this._decorationsCache = Object.create(null);\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    _clearCachedModelDecorationsResolver() {\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    dispose() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    reset() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onModelDecorationsChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onLineMappingChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    _getOrCreateViewModelDecoration(modelDecoration) {\n        const id = modelDecoration.id;\n        let r = this._decorationsCache[id];\n        if (!r) {\n            const modelRange = modelDecoration.range;\n            const options = modelDecoration.options;\n            let viewRange;\n            if (options.isWholeLine) {\n                const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1), 0 /* PositionAffinity.Left */, false, true);\n                const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)), 1 /* PositionAffinity.Right */);\n                viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n            }\n            else {\n                // For backwards compatibility reasons, we want injected text before any decoration.\n                // Thus, move decorations to the right.\n                viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange, 1 /* PositionAffinity.Right */);\n            }\n            r = new ViewModelDecoration(viewRange, options);\n            this._decorationsCache[id] = r;\n        }\n        return r;\n    }\n    getMinimapDecorationsInRange(range) {\n        return this._getDecorationsInRange(range, true, false).decorations;\n    }\n    getDecorationsViewportData(viewRange) {\n        let cacheIsValid = (this._cachedModelDecorationsResolver !== null);\n        cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));\n        if (!cacheIsValid) {\n            this._cachedModelDecorationsResolver = this._getDecorationsInRange(viewRange, false, false);\n            this._cachedModelDecorationsResolverViewRange = viewRange;\n        }\n        return this._cachedModelDecorationsResolver;\n    }\n    getInlineDecorationsOnLine(lineNumber, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const range = new Range(lineNumber, this._linesCollection.getViewLineMinColumn(lineNumber), lineNumber, this._linesCollection.getViewLineMaxColumn(lineNumber));\n        return this._getDecorationsInRange(range, onlyMinimapDecorations, onlyMarginDecorations).inlineDecorations[0];\n    }\n    _getDecorationsInRange(viewRange, onlyMinimapDecorations, onlyMarginDecorations) {\n        const modelDecorations = this._linesCollection.getDecorationsInRange(viewRange, this.editorId, filterValidationDecorations(this.configuration.options), onlyMinimapDecorations, onlyMarginDecorations);\n        const startLineNumber = viewRange.startLineNumber;\n        const endLineNumber = viewRange.endLineNumber;\n        const decorationsInViewport = [];\n        let decorationsInViewportLen = 0;\n        const inlineDecorations = [];\n        for (let j = startLineNumber; j <= endLineNumber; j++) {\n            inlineDecorations[j - startLineNumber] = [];\n        }\n        for (let i = 0, len = modelDecorations.length; i < len; i++) {\n            const modelDecoration = modelDecorations[i];\n            const decorationOptions = modelDecoration.options;\n            if (!isModelDecorationVisible(this.model, modelDecoration)) {\n                continue;\n            }\n            const viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n            const viewRange = viewModelDecoration.range;\n            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n            if (decorationOptions.inlineClassName) {\n                const inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n                const intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n                const intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n                for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n                    inlineDecorations[j - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.beforeContentClassName) {\n                if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* InlineDecorationType.Before */);\n                    inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.afterContentClassName) {\n                if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* InlineDecorationType.After */);\n                    inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n        }\n        return {\n            decorations: decorationsInViewport,\n            inlineDecorations: inlineDecorations\n        };\n    }\n}\nexport function isModelDecorationVisible(model, decoration) {\n    if (decoration.options.hideInCommentTokens && isModelDecorationInComment(model, decoration)) {\n        return false;\n    }\n    if (decoration.options.hideInStringTokens && isModelDecorationInString(model, decoration)) {\n        return false;\n    }\n    return true;\n}\nexport function isModelDecorationInComment(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 1 /* StandardTokenType.Comment */);\n}\nexport function isModelDecorationInString(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 2 /* StandardTokenType.String */);\n}\n/**\n * Calls the callback for every token that intersects the range.\n * If the callback returns `false`, iteration stops and `false` is returned.\n * Otherwise, `true` is returned.\n */\nfunction testTokensInRange(model, range, callback) {\n    for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n        const lineTokens = model.tokenization.getLineTokens(lineNumber);\n        const isFirstLine = lineNumber === range.startLineNumber;\n        const isEndLine = lineNumber === range.endLineNumber;\n        let tokenIdx = isFirstLine ? lineTokens.findTokenIndexAtOffset(range.startColumn - 1) : 0;\n        while (tokenIdx < lineTokens.getCount()) {\n            if (isEndLine) {\n                const startOffset = lineTokens.getStartOffset(tokenIdx);\n                if (startOffset > range.endColumn - 1) {\n                    break;\n                }\n            }\n            const callbackResult = callback(lineTokens.getStandardTokenType(tokenIdx));\n            if (!callbackResult) {\n                return false;\n            }\n            tokenIdx++;\n        }\n    }\n    return true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    mustCommit() {\n        return this._hasPending;\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nexport class EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setLineHeight(lineHeight) {\n        this._checkPendingChanges();\n        this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount) {\n        this._checkPendingChanges();\n        this._lineCount = lineCount;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            const result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _checkPendingChanges() {\n        if (this._pendingChanges.mustCommit()) {\n            this._pendingChanges.commit(this);\n        }\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        this._checkPendingChanges();\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        this._checkPendingChanges();\n        const linesHeight = this._lineHeight * this._lineCount;\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const previousLinesHeight = this._lineHeight * lineNumber;\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        this._checkPendingChanges();\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        const lineHeight = this._lineHeight;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        this._checkPendingChanges();\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        const result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        this._checkPendingChanges();\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        this._checkPendingChanges();\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\nLinesLayout.INSTANCE_COUNT = 0;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Scrollable } from '../../../base/common/scrollable.js';\nimport { LinesLayout } from './linesLayout.js';\nimport { Viewport } from '../viewModel.js';\nimport { ContentSizeChangedEvent } from '../viewModelEventDispatcher.js';\nconst SMOOTH_SCROLLING_TIME = 125;\nclass EditorScrollDimensions {\n    constructor(width, contentWidth, height, contentHeight) {\n        width = width | 0;\n        contentWidth = contentWidth | 0;\n        height = height | 0;\n        contentHeight = contentHeight | 0;\n        if (width < 0) {\n            width = 0;\n        }\n        if (contentWidth < 0) {\n            contentWidth = 0;\n        }\n        if (height < 0) {\n            height = 0;\n        }\n        if (contentHeight < 0) {\n            contentHeight = 0;\n        }\n        this.width = width;\n        this.contentWidth = contentWidth;\n        this.scrollWidth = Math.max(width, contentWidth);\n        this.height = height;\n        this.contentHeight = contentHeight;\n        this.scrollHeight = Math.max(height, contentHeight);\n    }\n    equals(other) {\n        return (this.width === other.width\n            && this.contentWidth === other.contentWidth\n            && this.height === other.height\n            && this.contentHeight === other.contentHeight);\n    }\n}\nclass EditorScrollable extends Disposable {\n    constructor(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n        super();\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._dimensions = new EditorScrollDimensions(0, 0, 0, 0);\n        this._scrollable = this._register(new Scrollable({\n            forceIntegerValues: true,\n            smoothScrollDuration,\n            scheduleAtNextAnimationFrame\n        }));\n        this.onDidScroll = this._scrollable.onScroll;\n    }\n    getScrollable() {\n        return this._scrollable;\n    }\n    setSmoothScrollDuration(smoothScrollDuration) {\n        this._scrollable.setSmoothScrollDuration(smoothScrollDuration);\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    getScrollDimensions() {\n        return this._dimensions;\n    }\n    setScrollDimensions(dimensions) {\n        if (this._dimensions.equals(dimensions)) {\n            return;\n        }\n        const oldDimensions = this._dimensions;\n        this._dimensions = dimensions;\n        this._scrollable.setScrollDimensions({\n            width: dimensions.width,\n            scrollWidth: dimensions.scrollWidth,\n            height: dimensions.height,\n            scrollHeight: dimensions.scrollHeight\n        }, true);\n        const contentWidthChanged = (oldDimensions.contentWidth !== dimensions.contentWidth);\n        const contentHeightChanged = (oldDimensions.contentHeight !== dimensions.contentHeight);\n        if (contentWidthChanged || contentHeightChanged) {\n            this._onDidContentSizeChange.fire(new ContentSizeChangedEvent(oldDimensions.contentWidth, oldDimensions.contentHeight, dimensions.contentWidth, dimensions.contentHeight));\n        }\n    }\n    getFutureScrollPosition() {\n        return this._scrollable.getFutureScrollPosition();\n    }\n    getCurrentScrollPosition() {\n        return this._scrollable.getCurrentScrollPosition();\n    }\n    setScrollPositionNow(update) {\n        this._scrollable.setScrollPositionNow(update);\n    }\n    setScrollPositionSmooth(update) {\n        this._scrollable.setScrollPositionSmooth(update);\n    }\n    hasPendingScrollAnimation() {\n        return this._scrollable.hasPendingScrollAnimation();\n    }\n}\nexport class ViewLayout extends Disposable {\n    constructor(configuration, lineCount, scheduleAtNextAnimationFrame) {\n        super();\n        this._configuration = configuration;\n        const options = this._configuration.options;\n        const layoutInfo = options.get(143 /* EditorOption.layoutInfo */);\n        const padding = options.get(83 /* EditorOption.padding */);\n        this._linesLayout = new LinesLayout(lineCount, options.get(66 /* EditorOption.lineHeight */), padding.top, padding.bottom);\n        this._maxLineWidth = 0;\n        this._overlayWidgetsMinWidth = 0;\n        this._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame));\n        this._configureSmoothScrollDuration();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(layoutInfo.contentWidth, 0, layoutInfo.height, 0));\n        this.onDidScroll = this._scrollable.onDidScroll;\n        this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;\n        this._updateHeight();\n    }\n    dispose() {\n        super.dispose();\n    }\n    getScrollable() {\n        return this._scrollable.getScrollable();\n    }\n    onHeightMaybeChanged() {\n        this._updateHeight();\n    }\n    _configureSmoothScrollDuration() {\n        this._scrollable.setSmoothScrollDuration(this._configuration.options.get(113 /* EditorOption.smoothScrolling */) ? SMOOTH_SCROLLING_TIME : 0);\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        const options = this._configuration.options;\n        if (e.hasChanged(66 /* EditorOption.lineHeight */)) {\n            this._linesLayout.setLineHeight(options.get(66 /* EditorOption.lineHeight */));\n        }\n        if (e.hasChanged(83 /* EditorOption.padding */)) {\n            const padding = options.get(83 /* EditorOption.padding */);\n            this._linesLayout.setPadding(padding.top, padding.bottom);\n        }\n        if (e.hasChanged(143 /* EditorOption.layoutInfo */)) {\n            const layoutInfo = options.get(143 /* EditorOption.layoutInfo */);\n            const width = layoutInfo.contentWidth;\n            const height = layoutInfo.height;\n            const scrollDimensions = this._scrollable.getScrollDimensions();\n            const contentWidth = scrollDimensions.contentWidth;\n            this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n        }\n        else {\n            this._updateHeight();\n        }\n        if (e.hasChanged(113 /* EditorOption.smoothScrolling */)) {\n            this._configureSmoothScrollDuration();\n        }\n    }\n    onFlushed(lineCount) {\n        this._linesLayout.onFlushed(lineCount);\n    }\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n    }\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n    }\n    // ---- end view event handlers\n    _getHorizontalScrollbarHeight(width, scrollWidth) {\n        const options = this._configuration.options;\n        const scrollbar = options.get(102 /* EditorOption.scrollbar */);\n        if (scrollbar.horizontal === 2 /* ScrollbarVisibility.Hidden */) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        if (width >= scrollWidth) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        return scrollbar.horizontalScrollbarSize;\n    }\n    _getContentHeight(width, height, contentWidth) {\n        const options = this._configuration.options;\n        let result = this._linesLayout.getLinesTotalHeight();\n        if (options.get(104 /* EditorOption.scrollBeyondLastLine */)) {\n            result += Math.max(0, height - options.get(66 /* EditorOption.lineHeight */) - options.get(83 /* EditorOption.padding */).bottom);\n        }\n        else {\n            result += this._getHorizontalScrollbarHeight(width, contentWidth);\n        }\n        return result;\n    }\n    _updateHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const width = scrollDimensions.width;\n        const height = scrollDimensions.height;\n        const contentWidth = scrollDimensions.contentWidth;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n    }\n    // ---- Layouting logic\n    getCurrentViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    getFutureViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    _computeContentWidth() {\n        const options = this._configuration.options;\n        const maxLineWidth = this._maxLineWidth;\n        const wrappingInfo = options.get(144 /* EditorOption.wrappingInfo */);\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const layoutInfo = options.get(143 /* EditorOption.layoutInfo */);\n        if (wrappingInfo.isViewportWrapping) {\n            const minimap = options.get(72 /* EditorOption.minimap */);\n            if (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {\n                // This is a case where viewport wrapping is on, but the line extends above the viewport\n                if (minimap.enabled && minimap.side === 'right') {\n                    // We need to accomodate the scrollbar width\n                    return maxLineWidth + layoutInfo.verticalScrollbarWidth;\n                }\n            }\n            return maxLineWidth;\n        }\n        else {\n            const extraHorizontalSpace = options.get(103 /* EditorOption.scrollBeyondLastColumn */) * fontInfo.typicalHalfwidthCharacterWidth;\n            const whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n            return Math.max(maxLineWidth + extraHorizontalSpace + layoutInfo.verticalScrollbarWidth, whitespaceMinWidth, this._overlayWidgetsMinWidth);\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        this._maxLineWidth = maxLineWidth;\n        this._updateContentWidth();\n    }\n    setOverlayWidgetsMinWidth(maxMinWidth) {\n        this._overlayWidgetsMinWidth = maxMinWidth;\n        this._updateContentWidth();\n    }\n    _updateContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(scrollDimensions.width, this._computeContentWidth(), scrollDimensions.height, scrollDimensions.contentHeight));\n        // The height might depend on the fact that there is a horizontal scrollbar or not\n        this._updateHeight();\n    }\n    // ---- view state\n    saveState() {\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        const scrollTop = currentScrollPosition.scrollTop;\n        const firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n        const whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n        return {\n            scrollTop: scrollTop,\n            scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n            scrollLeft: currentScrollPosition.scrollLeft\n        };\n    }\n    // ----\n    changeWhitespace(callback) {\n        const hadAChange = this._linesLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this.onHeightMaybeChanged();\n        }\n        return hadAChange;\n    }\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber, includeViewZones);\n    }\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        return this._linesLayout.getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones);\n    }\n    isAfterLines(verticalOffset) {\n        return this._linesLayout.isAfterLines(verticalOffset);\n    }\n    isInTopPadding(verticalOffset) {\n        return this._linesLayout.isInTopPadding(verticalOffset);\n    }\n    isInBottomPadding(verticalOffset) {\n        return this._linesLayout.isInBottomPadding(verticalOffset);\n    }\n    getLineNumberAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n    }\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n    }\n    getLinesViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getLinesViewportDataAtScrollTop(scrollTop) {\n        // do some minimal validations on scrollTop\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n            scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n        }\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n    }\n    getWhitespaceViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getWhitespaces() {\n        return this._linesLayout.getWhitespaces();\n    }\n    // ----\n    getContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentWidth;\n    }\n    getScrollWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollWidth;\n    }\n    getContentHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentHeight;\n    }\n    getScrollHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollHeight;\n    }\n    getCurrentScrollLeft() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollLeft;\n    }\n    getCurrentScrollTop() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollTop;\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    setScrollPosition(position, type) {\n        if (type === 1 /* ScrollType.Immediate */) {\n            this._scrollable.setScrollPositionNow(position);\n        }\n        else {\n            this._scrollable.setScrollPositionSmooth(position);\n        }\n    }\n    hasPendingScrollAnimation() {\n        return this._scrollable.hasPendingScrollAnimation();\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        this._scrollable.setScrollPositionNow({\n            scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n            scrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from '../viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return IdentityModelLineProjection.INSTANCE;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    else {\n        return new ModelLineProjection(lineBreakData, isVisible);\n    }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection {\n    constructor(lineBreakData, isVisible) {\n        this._projectionData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getProjectionData() {\n        return this._projectionData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._projectionData.getOutputLineCount();\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n        let r;\n        if (this._projectionData.injectionOffsets !== null) {\n            const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));\n            const lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n            r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n        }\n        else {\n            r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffsetInInputWithInjections + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffsetInInputWithInjections + 1\n            });\n        }\n        if (outputLineIndex > 0) {\n            r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getLineLength(outputLineIndex);\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n    }\n    /**\n     * Try using {@link getViewLinesData} instead.\n    */\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        const arr = new Array();\n        this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n        return arr[0];\n    }\n    getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const injectionOffsets = lineBreakData.injectionOffsets;\n        const injectionOptions = lineBreakData.injectionOptions;\n        let inlineDecorationsPerOutputLine = null;\n        if (injectionOffsets) {\n            inlineDecorationsPerOutputLine = [];\n            let totalInjectedTextLengthBefore = 0;\n            let currentInjectedOffset = 0;\n            for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n                const inlineDecorations = new Array();\n                inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n                const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n                const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n                while (currentInjectedOffset < injectionOffsets.length) {\n                    const length = injectionOptions[currentInjectedOffset].content.length;\n                    const injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n                    const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n                    if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n                        // Injected text only starts in later wrapped lines.\n                        break;\n                    }\n                    if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n                        // Injected text ends after or in this line (but also starts in or before this line).\n                        const options = injectionOptions[currentInjectedOffset];\n                        if (options.inlineClassName) {\n                            const offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n                            const start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n                            const end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections);\n                            if (start !== end) {\n                                inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                            }\n                        }\n                    }\n                    if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n                        totalInjectedTextLengthBefore += length;\n                        currentInjectedOffset++;\n                    }\n                    else {\n                        // injected text breaks into next line, process it again\n                        break;\n                    }\n                }\n            }\n        }\n        let lineWithInjections;\n        if (injectionOffsets) {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n                offset,\n                text: injectionOptions[idx].content,\n                tokenMetadata: LineTokens.defaultTokenMetadata\n            })));\n        }\n        else {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber);\n        }\n        for (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n            const globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n        }\n    }\n    _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n        const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n        const tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n        let lineContent = tokens.getLineContent();\n        if (outputLineIndex > 0) {\n            lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n        const maxColumn = lineContent.length + 1;\n        const continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        this._assertVisible();\n        return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2 /* PositionAffinity.None */) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n        return r.toPosition(deltaLineNumber);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n        return deltaLineNumber + r.outputLineIndex;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n        const normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n        const result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n        return result;\n    }\n    getInjectedTextAt(outputLineIndex, outputColumn) {\n        return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n    _assertVisible() {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n    }\n}\n/**\n * This projection does not change the model line.\n*/\nclass IdentityModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        const lineTokens = model.tokenization.getLineTokens(modelLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        return outputPosition;\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        return null;\n    }\n}\nIdentityModelLineProjection.INSTANCE = new IdentityModelLineProjection();\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return IdentityModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        throw new Error('Not supported');\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n}\nHiddenModelLineProjection.INSTANCE = new HiddenModelLineProjection();\nconst _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        const equalWordBreak = (this.wordBreak === wordBreak);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getMaxColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                const bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                // model-columns must be converted to view-model columns.\n                const result = bracketGuides.map(g => {\n                    if (g.forWrappedLinesAfterColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n                        if (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n                        if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (!g.horizontalLine) {\n                        return g;\n                    }\n                    let column = -1;\n                    if (g.column !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n                        if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                            column = p.column;\n                        }\n                        else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            column = this.getMinColumnOfViewLine(viewLineInfo);\n                        }\n                        else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    const viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n                    const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n                    if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n                    }\n                    else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                        return undefined;\n                    }\n                    else {\n                        if (g.visibleColumn !== -1) {\n                            // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n                            return undefined;\n                        }\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n                    }\n                });\n                resultPerViewLine.push(result.filter((r) => !!r));\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* IndentGuideRepeatOption.BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* PositionAffinity.None */, allowZeroLineNumber = false, belowHiddenRanges = false) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        if (belowHiddenRanges) {\n            while (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex++;\n                lineIndexChanged = true;\n            }\n        }\n        else {\n            while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex--;\n                lineIndexChanged = true;\n            }\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            // TODO@alexdima@hediet this isn't soo pretty\n            return new Position(allowZeroLineNumber ? 0 : 1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            if (belowHiddenRanges) {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n            }\n            else {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n            }\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* PositionAffinity.Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, onlyMinimapDecorations));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        const finalResult = [];\n        let finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity, allowZero, belowHiddenRanges) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService, _attachedView) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._themeService = _themeService;\n        this._attachedView = _attachedView;\n        this.hiddenAreasModel = new HiddenAreasModel();\n        this.previousHiddenAreas = [];\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStart = ViewportStart.create(this.model);\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n            const wrappingStrategy = options.get(137 /* EditorOption.wrappingStrategy */);\n            const wrappingInfo = options.get(144 /* EditorOption.wrappingInfo */);\n            const wrappingIndent = options.get(136 /* EditorOption.wrappingIndent */);\n            const wordBreak = options.get(128 /* EditorOption.wordBreak */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._handleVisibleLinesChanged();\n            }\n            if (e.scrollTopChanged) {\n                this._viewportStart.invalidate();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._register(this._themeService.onDidColorThemeChange((theme) => {\n            this._invalidateDecorationsColorCache();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this._viewportStart.dispose();\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    getModelVisibleRanges() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        return modelVisibleRanges;\n    }\n    visibleLinesStabilized() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, true);\n    }\n    _handleVisibleLinesChanged() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, false);\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    _captureStableViewport() {\n        // We might need to restore the current start view range, so save it (if available)\n        // But only if the scroll position is not at the top of the file\n        if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {\n            const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n            const previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n            return new StableViewport(previousViewportStartModelPosition, this._viewportStart.startLineDelta);\n        }\n        return new StableViewport(null, 0);\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        const stableViewport = this._captureStableViewport();\n        const options = this._configuration.options;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const wrappingStrategy = options.get(137 /* EditorOption.wrappingStrategy */);\n        const wrappingInfo = options.get(144 /* EditorOption.wrappingInfo */);\n        const wrappingIndent = options.get(136 /* EditorOption.wrappingIndent */);\n        const wordBreak = options.get(128 /* EditorOption.wordBreak */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(90 /* EditorOption.readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes);\n                const versionId = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* textModelEvents.RawContentChangedType.Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* textModelEvents.RawContentChangedType.EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            const viewportStartWasValid = this._viewportStart.isValid;\n            this._viewportStart.invalidate();\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n                const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n                    eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n                }\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._handleVisibleLinesChanged();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges, source) {\n        this.hiddenAreasModel.setHiddenAreas(source, ranges);\n        const mergedRanges = this.hiddenAreasModel.getMergedRanges();\n        if (mergedRanges === this.previousHiddenAreas) {\n            return;\n        }\n        this.previousHiddenAreas = mergedRanges;\n        const stableViewport = this._captureStableViewport();\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(mergedRanges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n            stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(143 /* EditorOption.layoutInfo */);\n        const lineHeight = this._configuration.options.get(66 /* EditorOption.lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    getHiddenAreas() {\n        return this._lines.getHiddenAreas();\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStart.update(this, startLineNumber);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getMinimapDecorationsInRange(range) {\n        return this._decorations.getMinimapDecorationsInRange(range);\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewportViewLineRenderingData(visibleRange, lineNumber) {\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    getViewLineRenderingData(lineNumber) {\n        const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    _getViewLineRenderingData(lineNumber, inlineDecorations) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    _invalidateDecorationsColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts1 = decoration.options.overviewRuler;\n            opts1 === null || opts1 === void 0 ? void 0 : opts1.invalidateCachedColor();\n            const opts2 = decoration.options.minimap;\n            opts2 === null || opts2 === void 0 ? void 0 : opts2.invalidateCachedColor();\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    getValueLengthInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueLengthInRange(modelRange, eol);\n    }\n    modifyPosition(position, offset) {\n        const modelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(position);\n        return this.model.modifyPosition(modelPosition, offset);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(50 /* EditorOption.fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* CursorChangeReason.NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            return callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass ViewportStart {\n    static create(model) {\n        const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n    }\n    get viewLineNumber() {\n        return this._viewLineNumber;\n    }\n    get isValid() {\n        return this._isValid;\n    }\n    get modelTrackedRange() {\n        return this._modelTrackedRange;\n    }\n    get startLineDelta() {\n        return this._startLineDelta;\n    }\n    constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n        this._model = _model;\n        this._viewLineNumber = _viewLineNumber;\n        this._isValid = _isValid;\n        this._modelTrackedRange = _modelTrackedRange;\n        this._startLineDelta = _startLineDelta;\n    }\n    dispose() {\n        this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    }\n    update(viewModel, startLineNumber) {\n        const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n        const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n        this._viewLineNumber = startLineNumber;\n        this._isValid = true;\n        this._modelTrackedRange = viewportStartLineTrackedRange;\n        this._startLineDelta = scrollTop - viewportStartLineTop;\n    }\n    invalidate() {\n        this._isValid = false;\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\nclass HiddenAreasModel {\n    constructor() {\n        this.hiddenAreas = new Map();\n        this.shouldRecompute = false;\n        this.ranges = [];\n    }\n    setHiddenAreas(source, ranges) {\n        const existing = this.hiddenAreas.get(source);\n        if (existing && rangeArraysEqual(existing, ranges)) {\n            return;\n        }\n        this.hiddenAreas.set(source, ranges);\n        this.shouldRecompute = true;\n    }\n    /**\n     * The returned array is immutable.\n    */\n    getMergedRanges() {\n        if (!this.shouldRecompute) {\n            return this.ranges;\n        }\n        this.shouldRecompute = false;\n        const newRanges = Array.from(this.hiddenAreas.values()).reduce((r, hiddenAreas) => mergeLineRangeArray(r, hiddenAreas), []);\n        if (rangeArraysEqual(this.ranges, newRanges)) {\n            return this.ranges;\n        }\n        this.ranges = newRanges;\n        return this.ranges;\n    }\n}\nfunction mergeLineRangeArray(arr1, arr2) {\n    const result = [];\n    let i = 0;\n    let j = 0;\n    while (i < arr1.length && j < arr2.length) {\n        const item1 = arr1[i];\n        const item2 = arr2[j];\n        if (item1.endLineNumber < item2.startLineNumber - 1) {\n            result.push(arr1[i++]);\n        }\n        else if (item2.endLineNumber < item1.startLineNumber - 1) {\n            result.push(arr2[j++]);\n        }\n        else {\n            const startLineNumber = Math.min(item1.startLineNumber, item2.startLineNumber);\n            const endLineNumber = Math.max(item1.endLineNumber, item2.endLineNumber);\n            result.push(new Range(startLineNumber, 1, endLineNumber, 1));\n            i++;\n            j++;\n        }\n    }\n    while (i < arr1.length) {\n        result.push(arr1[i++]);\n    }\n    while (j < arr2.length) {\n        result.push(arr2[j++]);\n    }\n    return result;\n}\nfunction rangeArraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (!arr1[i].equalsRange(arr2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Maintain a stable viewport by trying to keep the first line in the viewport constant.\n */\nclass StableViewport {\n    constructor(viewportStartModelPosition, startLineDelta) {\n        this.viewportStartModelPosition = viewportStartModelPosition;\n        this.startLineDelta = startLineDelta;\n    }\n    recoverViewportStart(coordinatesConverter, viewLayout) {\n        if (!this.viewportStartModelPosition) {\n            return;\n        }\n        const viewPosition = coordinatesConverter.convertModelPositionToViewPosition(this.viewportStartModelPosition);\n        const viewPositionTop = viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n        viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this.startLineDelta }, 1 /* ScrollType.Immediate */);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable } from '../../base/common/lifecycle.js';\nexport class ViewModelEventDispatcher extends Disposable {\n    constructor() {\n        super();\n        this._onEvent = this._register(new Emitter());\n        this.onEvent = this._onEvent.event;\n        this._eventHandlers = [];\n        this._viewEventQueue = null;\n        this._isConsumingViewEventQueue = false;\n        this._collector = null;\n        this._collectorCnt = 0;\n        this._outgoingEvents = [];\n    }\n    emitOutgoingEvent(e) {\n        this._addOutgoingEvent(e);\n        this._emitOutgoingEvents();\n    }\n    _addOutgoingEvent(e) {\n        for (let i = 0, len = this._outgoingEvents.length; i < len; i++) {\n            const mergeResult = (this._outgoingEvents[i].kind === e.kind ? this._outgoingEvents[i].attemptToMerge(e) : null);\n            if (mergeResult) {\n                this._outgoingEvents[i] = mergeResult;\n                return;\n            }\n        }\n        // not merged\n        this._outgoingEvents.push(e);\n    }\n    _emitOutgoingEvents() {\n        while (this._outgoingEvents.length > 0) {\n            if (this._collector || this._isConsumingViewEventQueue) {\n                // right now collecting or emitting view events, so let's postpone emitting\n                return;\n            }\n            const event = this._outgoingEvents.shift();\n            if (event.isNoOp()) {\n                continue;\n            }\n            this._onEvent.fire(event);\n        }\n    }\n    addViewEventHandler(eventHandler) {\n        for (let i = 0, len = this._eventHandlers.length; i < len; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                console.warn('Detected duplicate listener in ViewEventDispatcher', eventHandler);\n            }\n        }\n        this._eventHandlers.push(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        for (let i = 0; i < this._eventHandlers.length; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                this._eventHandlers.splice(i, 1);\n                break;\n            }\n        }\n    }\n    beginEmitViewEvents() {\n        this._collectorCnt++;\n        if (this._collectorCnt === 1) {\n            this._collector = new ViewModelEventsCollector();\n        }\n        return this._collector;\n    }\n    endEmitViewEvents() {\n        this._collectorCnt--;\n        if (this._collectorCnt === 0) {\n            const outgoingEvents = this._collector.outgoingEvents;\n            const viewEvents = this._collector.viewEvents;\n            this._collector = null;\n            for (const outgoingEvent of outgoingEvents) {\n                this._addOutgoingEvent(outgoingEvent);\n            }\n            if (viewEvents.length > 0) {\n                this._emitMany(viewEvents);\n            }\n        }\n        this._emitOutgoingEvents();\n    }\n    emitSingleViewEvent(event) {\n        try {\n            const eventsCollector = this.beginEmitViewEvents();\n            eventsCollector.emitViewEvent(event);\n        }\n        finally {\n            this.endEmitViewEvents();\n        }\n    }\n    _emitMany(events) {\n        if (this._viewEventQueue) {\n            this._viewEventQueue = this._viewEventQueue.concat(events);\n        }\n        else {\n            this._viewEventQueue = events;\n        }\n        if (!this._isConsumingViewEventQueue) {\n            this._consumeViewEventQueue();\n        }\n    }\n    _consumeViewEventQueue() {\n        try {\n            this._isConsumingViewEventQueue = true;\n            this._doConsumeQueue();\n        }\n        finally {\n            this._isConsumingViewEventQueue = false;\n        }\n    }\n    _doConsumeQueue() {\n        while (this._viewEventQueue) {\n            // Empty event queue, as events might come in while sending these off\n            const events = this._viewEventQueue;\n            this._viewEventQueue = null;\n            // Use a clone of the event handlers list, as they might remove themselves\n            const eventHandlers = this._eventHandlers.slice(0);\n            for (const eventHandler of eventHandlers) {\n                eventHandler.handleEvents(events);\n            }\n        }\n    }\n}\nexport class ViewModelEventsCollector {\n    constructor() {\n        this.viewEvents = [];\n        this.outgoingEvents = [];\n    }\n    emitViewEvent(event) {\n        this.viewEvents.push(event);\n    }\n    emitOutgoingEvent(e) {\n        this.outgoingEvents.push(e);\n    }\n}\nexport class ContentSizeChangedEvent {\n    constructor(oldContentWidth, oldContentHeight, contentWidth, contentHeight) {\n        this.kind = 0 /* OutgoingViewModelEventKind.ContentSizeChanged */;\n        this._oldContentWidth = oldContentWidth;\n        this._oldContentHeight = oldContentHeight;\n        this.contentWidth = contentWidth;\n        this.contentHeight = contentHeight;\n        this.contentWidthChanged = (this._oldContentWidth !== this.contentWidth);\n        this.contentHeightChanged = (this._oldContentHeight !== this.contentHeight);\n    }\n    isNoOp() {\n        return (!this.contentWidthChanged && !this.contentHeightChanged);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new ContentSizeChangedEvent(this._oldContentWidth, this._oldContentHeight, other.contentWidth, other.contentHeight);\n    }\n}\nexport class FocusChangedEvent {\n    constructor(oldHasFocus, hasFocus) {\n        this.kind = 1 /* OutgoingViewModelEventKind.FocusChanged */;\n        this.oldHasFocus = oldHasFocus;\n        this.hasFocus = hasFocus;\n    }\n    isNoOp() {\n        return (this.oldHasFocus === this.hasFocus);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new FocusChangedEvent(this.oldHasFocus, other.hasFocus);\n    }\n}\nexport class ScrollChangedEvent {\n    constructor(oldScrollWidth, oldScrollLeft, oldScrollHeight, oldScrollTop, scrollWidth, scrollLeft, scrollHeight, scrollTop) {\n        this.kind = 2 /* OutgoingViewModelEventKind.ScrollChanged */;\n        this._oldScrollWidth = oldScrollWidth;\n        this._oldScrollLeft = oldScrollLeft;\n        this._oldScrollHeight = oldScrollHeight;\n        this._oldScrollTop = oldScrollTop;\n        this.scrollWidth = scrollWidth;\n        this.scrollLeft = scrollLeft;\n        this.scrollHeight = scrollHeight;\n        this.scrollTop = scrollTop;\n        this.scrollWidthChanged = (this._oldScrollWidth !== this.scrollWidth);\n        this.scrollLeftChanged = (this._oldScrollLeft !== this.scrollLeft);\n        this.scrollHeightChanged = (this._oldScrollHeight !== this.scrollHeight);\n        this.scrollTopChanged = (this._oldScrollTop !== this.scrollTop);\n    }\n    isNoOp() {\n        return (!this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new ScrollChangedEvent(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, other.scrollWidth, other.scrollLeft, other.scrollHeight, other.scrollTop);\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.kind = 3 /* OutgoingViewModelEventKind.ViewZonesChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class HiddenAreasChangedEvent {\n    constructor() {\n        this.kind = 4 /* OutgoingViewModelEventKind.HiddenAreasChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class CursorStateChangedEvent {\n    constructor(oldSelections, selections, oldModelVersionId, modelVersionId, source, reason, reachedMaxCursorCount) {\n        this.kind = 6 /* OutgoingViewModelEventKind.CursorStateChanged */;\n        this.oldSelections = oldSelections;\n        this.selections = selections;\n        this.oldModelVersionId = oldModelVersionId;\n        this.modelVersionId = modelVersionId;\n        this.source = source;\n        this.reason = reason;\n        this.reachedMaxCursorCount = reachedMaxCursorCount;\n    }\n    static _selectionsAreEqual(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!a[i].equalsSelection(b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isNoOp() {\n        return (CursorStateChangedEvent._selectionsAreEqual(this.oldSelections, this.selections)\n            && this.oldModelVersionId === this.modelVersionId);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new CursorStateChangedEvent(this.oldSelections, other.selections, this.oldModelVersionId, other.modelVersionId, other.source, other.reason, this.reachedMaxCursorCount || other.reachedMaxCursorCount);\n    }\n}\nexport class ReadOnlyEditAttemptEvent {\n    constructor() {\n        this.kind = 5 /* OutgoingViewModelEventKind.ReadOnlyEditAttempt */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class ModelDecorationsChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 7 /* OutgoingViewModelEventKind.ModelDecorationsChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelLanguageChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 8 /* OutgoingViewModelEventKind.ModelLanguageChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelLanguageConfigurationChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 9 /* OutgoingViewModelEventKind.ModelLanguageConfigurationChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelContentChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 10 /* OutgoingViewModelEventKind.ModelContentChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelOptionsChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 11 /* OutgoingViewModelEventKind.ModelOptionsChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelTokensChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 12 /* OutgoingViewModelEventKind.ModelTokensChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\n"],"names":["BracketInfo","_createClass","range","nestingLevel","nestingLevelOfEqualBracketType","isInvalid","_classCallCheck","this","BracketPairWithMinIndentationInfo","_BracketPairInfo","_inherits","_super","_createSuper","openingBracketRange","closingBracketRange","bracketPairNode","minVisibleColumnIndentation","_this","call","BracketPairInfo","key","get","openingBracket","bracketInfo","ModelRawFlush","changeType","LineInjectedText","ownerId","lineNumber","column","options","order","value","lineText","injectedTexts","length","_step","result","lastOriginalOffset","_iterator","_createForOfIteratorHelper","s","n","done","injectedText","substring","content","err","e","f","decorations","_step2","_iterator2","decoration","before","push","startLineNumber","startColumn","after","endLineNumber","endColumn","sort","a","b","ModelRawLineChanged","detail","ModelRawLinesDeleted","fromLineNumber","toLineNumber","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","changes","versionId","isUndoing","isRedoing","resultingSelection","type","i","len","concat","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","rawContentChangedEvent","contentChangedEvent","other","merge","_mergeChangeEvents","eol","isFlush","isEolChange","HorizontalGuidesState","IndentGuide","visibleColumn","className","horizontalLine","forWrappedLinesAfterColumn","forWrappedLinesBeforeOrAtColumn","Error","IndentGuideHorizontalLine","top","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","then","apply","TokenizationRegistry","_tokenizationSupports","Map","_factories","_onDidChange","Emitter","onDidChange","event","_colorMap","languageIds","fire","changedLanguages","changedColorMap","languageId","support","set","handleChange","toDisposable","delete","factory","_a","_this2","dispose","myData","TokenizationSupportFactoryData","v","_regeneratorRuntime","mark","_callee","tokenizationSupport","wrap","_context","prev","abrupt","isResolved","stop","colorMap","Array","from","keys","_Disposable","_registry","_languageId","_factory","_this3","_isDisposed","_resolvePromise","_isResolved","_get","_getPrototypeOf","prototype","_callee2","_context2","_create","_callee3","_context3","sent","_register","register","Disposable","ContiguousMultilineTokens","tokens","_startLineNumber","_tokens","lineTokens","ContiguousMultilineTokensBuilder","last","appendLineTokens","EMPTY_LINE_TOKENS","Uint32Array","buffer","ContiguousTokensEditing","toChIndex","fromChIndex","toUint32Array","lineTextLength","tokensCount","dest","lastEnd","fromTokenIndex","LineTokens","findIndexInTokensArray","fromTokenStartOffset","delta","tokenIndex","tokenEndOffset","tmp","subarray","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength","arr","ContiguousTokensStore","languageIdCodec","_lineTokens","_len","_languageIdCodec","topLevelLanguageId","lineIndex","rawLineTokens","getDefaultMetadata","encodeLanguageId","start","deleteCount","splice","insertIndex","insertCount","arrays","checkEquality","_massageTokens","_ensureLine","oldTokens","_equals","eolCount","firstLineLength","_acceptDeleteRange","_acceptInsertText","Position","firstLineIndex","deleteEnding","lastLineIndex","lastLineTokens","deleteBeginning","append","_deleteLines","position","insert","_insertLines","textModel","ranges","element","minChangedLineNumber","maxChangedLineNumber","hasChange","setTokens","getLanguageId","getLineLength","getLineTokens","hasDifferentLanguageId","TokenMetadata","byteOffset","byteLength","_b","text","decoder","_lineTokensBrand","undefined","_tokensCount","_text","slicedEquals","sliceFromTokenIndex","sliceTokenCount","to","metadata","decodeLanguageId","getTokenType","getForeground","getClassNameFromMetadata","getInlineStyleFromMetadata","getPresentationFromMetadata","offset","startOffset","endOffset","deltaOffset","SliceLineTokens","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","tokenMetadata","lineContent","defaultMetadata","defaultTokenMetadata","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","findTokenIndexAtOffset","getCount","getStartOffset","getMetadata","getLineContent","getEndOffset","min","getClassName","getInlineStyle","getPresentation","SparseMultilineTokens","_endLineNumber","getMaxDeltaLine","toString","isEmpty","deltaRange","getRange","Range","startLineIndex","endLineIndex","removeTokens","_updateEndLineNumber","_this$_tokens$split","split","_this$_tokens$split2","_slicedToArray","bDeltaLine","_countEOL","countEOL","_countEOL2","lastLineLength","acceptEdit","charCodeAt","firstCharCode","deletedLinesCount","tokenMaxDeltaLine","clear","deletedBefore","acceptDeleteRange","acceptInsertText","SparseMultilineTokensStorage","_tokenCount","pieces","_getDeltaLine","_getStartCharacter","_getEndCharacter","join","tokenCount","_getTokenCount","startChar","maxDeltaLine","endChar","deltaLine","midDeltaLine","max","SparseLineTokens","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","destOffset","aTokens","bTokens","destTokens","destFirstDeltaLine","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","character","isInsertingPreciselyOneWordCharacter","tokenLength","SparseTokensStore","_pieces","_isComplete","isComplete","_range","_firstRange","_lastRange","plusRange","insertPosition","piece","index","_piece$split","_piece$split2","_findFirstPieceWithLine","aLen","bLen","aIndex","resultLen","lastEndOffset","emitToken","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","bMask","aMask","aMergeIndex","ViewEventHandler","_shouldRender","events","shouldRender","onCompositionStart","onCompositionEnd","onConfigurationChanged","onCursorStateChanged","onDecorationsChanged","onFlushed","onFocusChanged","onLanguageConfigurationChanged","onLineMappingChanged","onLinesChanged","onLinesDeleted","onLinesInserted","onRevealRangeRequest","onScrollChanged","onTokensChanged","onThemeChanged","onTokensColorsChanged","onZonesChanged","console","info","ViewCompositionStartEvent","ViewCompositionEndEvent","ViewConfigurationChangedEvent","id","hasChanged","ViewCursorStateChangedEvent","selections","modelSelections","reason","ViewDecorationsChangedEvent","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","ViewFlushedEvent","ViewFocusChangedEvent","isFocused","ViewLanguageConfigurationEvent","ViewLineMappingChangedEvent","ViewLinesChangedEvent","count","ViewLinesDeletedEvent","ViewLinesInsertedEvent","ViewRevealRangeRequestEvent","minimalReveal","verticalType","revealHorizontal","scrollType","ViewScrollChangedEvent","scrollWidth","scrollLeft","scrollHeight","scrollTop","scrollWidthChanged","scrollLeftChanged","scrollHeightChanged","scrollTopChanged","ViewThemeChangedEvent","theme","ViewTokensChangedEvent","ViewTokensColorsChangedEvent","ViewZonesChangedEvent","LineDecoration","_lineDecorationBrand","lineLength","r","rLength","dec","lineDecorations","minLineColumn","maxLineColumn","d","inlineClassName","ORDER","typeCmp","_typeCompare","DecorationSegment","Stack","stopOffsets","classNames","maxStopOffset","nextStartOffset","_metadata","stopOffset","LineDecorationsNormalizer","stack","charCodeBefore","strings","currentStartOffset","currentEndOffset","consumeLowerThan","LinePart","endIndex","containsRTL","_linePartBrand","LineRange","startIndex","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","continuesWithWrappedLine","isBasicASCII","fauxIndentLength","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","compare","abs","renderSpaceWidth","renderSpaceCharCode","otherSelections","equals","equalsArr","sameSelection","DomPosition","partIndex","charIndex","CharacterMapping","partCount","_data","_horizontalOffset","horizontalOffset","partData","charOffset","charOffsetToPartData","getPartIndex","getCharIndex","domPosition","partLength","partDataToCharOffset","searchEntry","midEntry","minEntry","maxEntry","minPartIndex","RenderLineOutput","characterMapping","containsForeignElements","_renderLineOutputBrand","renderViewLine","input","sb","appendString","beforeCount","afterCount","lineDecoration","setColumnInfo","fontIsMonospace","isOverflowing","overflowingCharCount","parts","lastCharacterMappingDefined","charOffsetInPart","charHorizontalOffset","partDisplacement","tokensLen","part","partEndIndex","partType","partContainsRTL","partRendersWhitespace","isWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","isPseudoAfter","appendASCIICharCode","partWidth","_charIndex","_visibleColumn","charWidth","String","producedCharacters","appendCharCode","space","charCode","isControlCharacter","to4CharHex","nls","toFixed","renderOverflowingCharCount","_renderLine","lineContainsRTL","tokenContainsRTL","transformAndRemoveOverflowing","lastLinePart","token","tokenEndIndex","extractControlCharacters","lastNonWhitespaceIndex","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokenType","tokensLength","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","generateWhitespace","lastCharCode","prevCharCode","_applyRenderWhitespace","_lineDecorations","normalize","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastTokenEndIndex","_applyInlineDecorations","onlyAtSpaces","lastSpaceOffset","currTokenStart","j","diff","piecesCount","ceil","pieceEndIndex","splitLargeTokens","ResolvedRenderLineInput","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","StringBuilder","out","build","toUpperCase","padStart","ViewportData","partialData","whitespaceViewportData","model","relativeVerticalOffset","bigNumbersDelta","_model","visibleRange","getLineMinColumn","getLineMaxColumn","getViewportViewLineRenderingData","getDecorationsInViewport","Viewport","left","width","height","_viewportBrand","MinimapLinesRenderingData","data","ViewLineData","minColumn","maxColumn","inlineDecorations","_viewLineDataBrand","ViewLineRenderingData","mightContainRTL","mightContainNonBasicASCII","InlineDecoration","SingleLineInlineDecoration","inlineClassNameAffectsLetterSpacing","ViewModelDecoration","_viewModelDecorationBrand","OverviewRulerDecorationsGroup","color","zIndex","MinimapTokensColorTracker","_updateColorMap","getColorMap","_colors","RGBA8","Empty","_backgroundIsLight","colorId","rgba","g","round","backgroundLuminosity","getRelativeLuminance","_INSTANCE","markAsSingleton","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","classifier","WrappingCharacterClassifier","fontInfo","wrappingColumn","wrappingIndent","wordBreak","requests","previousBreakingData","addRequest","previousLineBreakData","finalize","columnsForFullWidthChar","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","injectionOptions","createLineBreaks","createLineBreaksFromPreviousLineBreaks","arrPool1","arrPool2","_CharacterClassifier","BREAK_BEFORE","BREAK_AFTER","_asciiMap","_map","_defaultValue","CharacterClassifier","firstLineBreakColumn","isKeepAll","prevBreakingOffsets","breakOffsets","prevBreakingOffsetsVisibleColumn","breakOffsetsVisibleColumn","wrappedTextIndentLength","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","lastBreakingOffset","lastBreakingOffsetVisibleColumn","breakingColumn","prevLen","prevIndex","bestDistance","distance","prevBreakOffset","prevBreakOffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","_lineText","injectionOffsets","applyInjectedText","map","t","ModelLineProjectionData","tabCharacterWidth","numberOfAdditionalTabs","ColorZone","_colorZoneBrand","OverviewRulerZone","heightInLines","_overviewRulerZoneBrand","_colorZone","colorZone","OverviewZoneManager","getVerticalOffsetForLine","_getVerticalOffsetForLine","_zones","_colorZonesInvalid","_lineHeight","_domWidth","_domHeight","_outerHeight","_pixelRatio","_lastAssignedId","_color2Id","Object","create","_id2Color","newZones","lineHeight","pixelRatio","outerHeight","colorZonesInvalid","totalHeight","getCanvasHeight","heightRatio","halfMinimumHeight","allColorZones","zone","getColorZones","offset1","offset2","y1","y2","ycenter","halfHeight","setColorZone","ViewContext","configuration","EditorTheme","viewModel","viewLayout","eventHandler","addViewEventHandler","removeViewEventHandler","ViewModelDecorations","editorId","linesCollection","coordinatesConverter","_linesCollection","_coordinatesConverter","_decorationsCache","_cachedModelDecorationsResolver","_cachedModelDecorationsResolverViewRange","_clearCachedModelDecorationsResolver","modelDecoration","viewRange","modelRange","isWholeLine","convertModelPositionToViewPosition","end","convertModelRangeToViewRange","_getDecorationsInRange","cacheIsValid","equalsRange","onlyMinimapDecorations","arguments","onlyMarginDecorations","getViewLineMinColumn","getViewLineMaxColumn","modelDecorations","getDecorationsInRange","filterValidationDecorations","decorationsInViewport","decorationsInViewportLen","decorationOptions","isModelDecorationVisible","viewModelDecoration","_getOrCreateViewModelDecoration","inlineDecoration","intersectedStartLineNumber","intersectedEndLineNumber","beforeContentClassName","afterContentClassName","hideInCommentTokens","isModelDecorationInComment","hideInStringTokens","isModelDecorationInString","testTokensInRange","callback","tokenization","isFirstLine","isEndLine","tokenIdx","getStandardTokenType","PendingChanges","_hasPending","_inserts","_changes","_removes","x","linesLayout","inserts","removes","_commitPendingChanges","EditorWhitespace","afterLineNumber","ordinal","minWidth","prefixSum","LinesLayout","lineCount","paddingTop","paddingBottom","_instanceId","INSTANCE_COUNT","_pendingChanges","_lastWhitespaceId","_arr","_prefixSumValidIndex","_minWidth","_lineCount","_paddingTop","_paddingBottom","_checkPendingChanges","hadAChange","insertWhitespace","heightInPx","changeOneWhitespace","newAfterLineNumber","newHeight","change","removeWhitespace","remove","commit","_insertWhitespace","_changeOneWhitespace","_step3","_iterator3","_findWhitespaceIndex","_removeWhitespace","_step4","toRemove","Set","_iterator4","add","_step5","toChange","_iterator5","applyRemoveAndChange","whitespaces","_step6","_iterator6","whitespace","has","mustCommit","findInsertionIndex","removeIndex","getWhitespacesAccumulatedHeight","getWhitespacesTotalHeight","lastWhitespaceBeforeLineNumber","_findLastWhitespaceBeforeLineNumber","firstWhitespaceAfterLineNumber","_findFirstWhitespaceAfterLineNumber","includeViewZones","getWhitespaceAccumulatedHeightBeforeLineNumber","verticalOffset","getLinesTotalHeight","linesCount","minLineNumber","maxLineNumber","midLineNumber","midLineNumberVerticalOffset","getVerticalOffsetForLineNumber","verticalOffset1","verticalOffset2","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","getLineNumberAtOrAfterVerticalOffset","startLineNumberVerticalOffset","whitespaceIndex","getFirstWhitespaceIndexAfterLineNumber","whitespaceCount","getWhitespacesCount","getAfterLineNumberForWhitespaceIndex","getHeightForWhitespaceIndex","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","linesOffsets","verticalCenter","centeredLineNumber","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","minWhitespaceIndex","maxWhitespaceIndex","getVerticalOffsetForWhitespaceIndex","midWhitespaceIndex","midWhitespaceVerticalOffset","candidateIndex","getWhitespaceIndexAtOrAfterVerticallOffset","candidateTop","candidateHeight","getIdForWhitespaceIndex","slice","EditorScrollDimensions","contentWidth","contentHeight","EditorScrollable","smoothScrollDuration","scheduleAtNextAnimationFrame","_onDidContentSizeChange","onDidContentSizeChange","_dimensions","_scrollable","Scrollable","forceIntegerValues","onDidScroll","onScroll","setSmoothScrollDuration","scrollPosition","validateScrollPosition","dimensions","oldDimensions","setScrollDimensions","contentWidthChanged","contentHeightChanged","ContentSizeChangedEvent","getFutureScrollPosition","getCurrentScrollPosition","update","setScrollPositionNow","setScrollPositionSmooth","hasPendingScrollAnimation","ViewLayout","_Disposable2","_super2","_configuration","layoutInfo","padding","_linesLayout","bottom","_maxLineWidth","_overlayWidgetsMinWidth","_configureSmoothScrollDuration","_updateHeight","getScrollable","setLineHeight","setPadding","scrollDimensions","getScrollDimensions","_getContentHeight","scrollbar","horizontal","horizontalScrollbarSize","_getHorizontalScrollbarHeight","currentScrollPosition","maxLineWidth","wrappingInfo","isViewportWrapping","minimap","enabled","side","verticalScrollbarWidth","extraHorizontalSpace","whitespaceMinWidth","getWhitespaceMinWidth","_updateContentWidth","maxMinWidth","_computeContentWidth","firstLineNumberInViewport","scrollTopWithoutViewZones","changeWhitespace","onHeightMaybeChanged","getVerticalOffsetAfterLineNumber","isAfterLines","isInTopPadding","isInBottomPadding","getWhitespaceAtVerticalOffset","visibleBox","getCurrentViewport","getLinesViewportData","getWhitespaceViewportData","getWhitespaces","deltaScrollLeft","deltaScrollTop","createModelLineProjection","lineBreakData","isVisible","IdentityModelLineProjection","INSTANCE","HiddenModelLineProjection","ModelLineProjection","_projectionData","_isVisible","getOutputLineCount","modelLineNumber","outputLineIndex","_assertVisible","startOffsetInInputWithInjections","endOffsetInInputWithInjections","idx","getValueInRange","spaces","_modelLineNumber","getMinOutputOffset","getMaxOutputOffset","getViewLinesData","outputLineIdx","globalStartIndex","needed","lineWithInjections","inlineDecorationsPerOutputLine","totalInjectedTextLengthBefore","currentInjectedOffset","lineStartOffsetInInputWithInjections","lineEndOffsetInInputWithInjections","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","withInserted","globalIndex","_getViewLineData","deltaStartIndex","sliceAndInflate","getViewLineCount","outputColumn","translateToInputOffset","deltaLineNumber","inputColumn","affinity","translateToOutputPosition","toPosition","outputPosition","baseViewLineNumber","normalizeOutputPosition","getInjectedText","_outputLineIndex","inflate","_fromOuputLineIndex","_toOutputLineIndex","getViewLineData","_inputColumn","_outputColumn","_globalStartIndex","_needed","_result","_deltaLineNumber","_spaces","_makeSpaces","ViewModelLinesFromProjectedModel","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","wrappingStrategy","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","hiddenAreasDecorationIds","deltaDecorations","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","modelLineProjections","linesContent","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineBreaksComputer","createLineBreaksComputer","injectedTextQueue","fromDecorations","_loop","lineInjectedText","takeWhile","linesBreaks","values","hiddenAreas","areaId","getDecorationRange","compareRangesUsingStarts","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","isInHiddenArea","line","getVersionId","projectedModelLineLineCounts","ConstantTimePrefixSumComputer","decId","_ranges","newRanges","sortedRanges","currentRangeStart","currentRangeEnd","normalizeLineRanges","validateRange","oldRanges","hasDifference","newDecorations","ModelDecorationOptions","EMPTY","hasVisibleLine","lineChanged","setVisible","newOutputLineCount","setValue","setHiddenAreas","_modelColumn","newTabSize","equalFontInfo","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","equalWordBreak","onlyWrappingColumnChanged","getProjectionData","outputFromLineNumber","getPrefixSum","outputToLineNumber","removeValues","viewEvents","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","outputLineCount","insertValues","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","getTotalSum","viewLineNumber","viewLineCount","_toValidViewLineNumber","modelPosition","convertViewPositionToModelPosition","modelMinPosition","modelMaxPosition","guides","getActiveIndentGuide","viewStartPosition","viewEndPosition","indent","getIndexOf","remainder","ViewLineInfo","viewLineInfo","modelLineWrappedLineIdx","minViewColumn","getModelColumnOfViewPosition","maxViewColumn","viewStartLineNumber","viewEndLineNumber","startViewLine","getViewLineInfo","endViewLine","lastVisibleModelPos","getModelStartPositionOfViewLine","viewLines","curModelLine","lastVisibleModelPos2","fromPositions","ViewLineInfoGroupedByModelRange","getModelEndPositionOfViewLine","activeViewPosition","_this4","modelActivePosition","resultPerViewLine","getViewLineInfosGroupedByModelRanges","group","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","_loop2","getViewPositionOfModelPosition","p","getMinColumnOfViewLine","viewPosition","getMaxColumnOfViewLine","filter","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","getViewLineNumberOfModelPosition","viewLineEndIndex","option","getLinesIndentGuides","viewIndents","currIndex","blockAtIndex","getViewLineContent","getViewLineLength","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","viewColumn","expectedModelPosition","computedModelColumn","validatePosition","expectedModelRange","validViewStart","validateViewPosition","getStartPosition","validViewEnd","getEndPosition","allowZeroLineNumber","belowHiddenRanges","validPosition","inputLineNumber","lineIndexChanged","modelColumn","filterOutValidation","res","finalResult","finalResultLen","prevDecId","getInjectedTextAt","normalizePosition","getLineIndentColumn","lines","_lines","convertViewRangeToModelRange","validateViewRange","allowZero","modelPositionIsVisible","getModelLineViewLineCount","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","_versionId","_minLineNumber","_maxLineNumber","activePosition","fill","pos","_validPosition","_validRange","_viewPosition","_viewRange","ViewModel","languageConfigurationService","_themeService","_attachedView","hiddenAreasModel","HiddenAreasModel","previousHiddenAreas","_eventDispatcher","ViewModelEventDispatcher","onEvent","cursorConfig","CursorConfiguration","getOptions","_updateConfigurationViewLineCount","RunOnceScheduler","_updateConfigurationViewLineCountNow","_hasFocus","_viewportStart","ViewportStart","isTooLargeForTokenization","createCoordinatesConverter","_cursor","CursorsController","_assertThisInitialized","_handleVisibleLinesChanged","invalidate","emitSingleViewEvent","emitOutgoingEvent","ScrollChangedEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","_decorations","_registerModelEvents","onDidChangeFast","eventsCollector","beginEmitViewEvents","_onConfigurationChanged","endEmitViewEvents","getInstance","onDidColorThemeChange","_invalidateDecorationsColorCache","setViewLineCount","linesViewportData","viewVisibleRange","_toModelVisibleRanges","modelVisibleRanges","getModelVisibleRanges","setVisibleLines","hasFocus","setHasFocus","FocusChangedEvent","isValid","getCurrentScrollTop","previousViewportStartViewPosition","previousViewportStartModelPosition","StableViewport","startLineDelta","stableViewport","_captureStableViewport","setWrappingSettings","emitViewEvent","schedule","reset","recoverViewportStart","shouldRecreate","updateConfiguration","onDidChangeContentOrInjectedText","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","textModelEvents","lineIdx","lineBreakQueue","ArrayQueue","onModelFlushed","linesDeletedEvent","onModelLinesDeleted","insertedLineBreaks","takeCount","linesInsertedEvent","onModelLinesInserted","changedLineBreakData","dequeue","_this2$_lines$onModel","onModelLineChanged","_this2$_lines$onModel2","linesChangedEvent","acceptVersionId","viewportStartWasValid","setModelLineCount","getAttachedEditorCount","_getTrackedRange","modelTrackedRange","viewPositionTop","setScrollPosition","ModelContentChangedEvent","onModelContentChanged","onDidChangeTokens","viewRanges","lenJ","ModelTokensChangedEvent","onDidChangeLanguageConfiguration","ModelLanguageConfigurationChangedEvent","onDidChangeLanguage","ModelLanguageChangedEvent","onDidChangeOptions","setTabSize","ModelOptionsChangedEvent","onDidChangeDecorations","onModelDecorationsChanged","ModelDecorationsChangedEvent","mergedRanges","getMergedRanges","HiddenAreasChangedEvent","linesAround","startViewLineNumber","endViewLineNumber","visibleViewRange","getCompletelyVisibleViewRange","getHiddenAreas","hiddenStartLineNumber","hiddenEndLineNumber","getLinesViewportDataAtScrollTop","compatViewState","saveState","firstViewLineNumber","getLineNumberAtVerticalOffset","firstPosition","firstPositionDeltaTop","state","_reduceRestoreStateCompatibility","getViewLinesIndentGuides","getViewLinesBracketGuides","getMinimapDecorationsInRange","getDecorationsViewportData","_getViewLineRenderingData","getInlineDecorationsOnLine","getTabSize","lineData","_toConsumableArray","toInlineDecoration","getOverviewRulerDecorations","OverviewRulerDecorations","opts","overviewRuler","lane","getColor","accept","asArray","opts1","invalidateCachedColor","opts2","getValueLengthInRange","modifyPosition","viewAnchorPosition","lineFeedCnt","modelAnchor","getEOL","resultOffset","getOffsetAt","getPositionAt","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","hasEmptyRange","hasNonEmptyRange","modelLineNumbers","prevModelLineNumber","_step7","_iterator7","PLAINTEXT_LANGUAGE_ID","fontFamily","_getColorMap","test","EDITOR_FONT_DEFAULTS","replace","mode","fontWeight","fontSize","_getHTMLToCopy","tokenizeLineToHTML","platform","Color","Format","CSS","formatHex","getPrimaryCursorState","getLastAddedCursorIndex","getCursorStates","states","_withViewEventsCollector","setStates","getCursorColumnSelectData","getAutoClosedCharacters","columnSelectData","setCursorColumnSelectData","getPrevEditOperationType","setPrevEditOperationType","getSelection","getSelections","modelState","setSelections","_this5","restoreState","context","readOnly","ReadOnlyEditAttemptEvent","edits","cursorStateComputer","_this6","_executeCursorEdit","executeEdits","_this7","startComposition","_this8","endComposition","_this9","replacePrevCharCnt","replaceNextCharCnt","positionDelta","_this10","compositionType","pasteOnNewLine","multicursorText","_this11","paste","_this12","cut","command","_this13","executeCommand","commands","_this14","executeCommands","_this15","revealPrimary","getTopMostViewPosition","getBottomMostViewPosition","_viewLineNumber","_isValid","_modelTrackedRange","_startLineDelta","_setTrackedRange","viewportStartLineTrackedRange","viewportStartLineTop","_asMap","prevGroup","prevData","prevLane","prevEndLineNumber","shouldRecompute","existing","rangeArraysEqual","reduce","arr1","arr2","item1","item2","mergeLineRangeArray","viewportStartModelPosition","_onEvent","_eventHandlers","_viewEventQueue","_isConsumingViewEventQueue","_collector","_collectorCnt","_outgoingEvents","_addOutgoingEvent","_emitOutgoingEvents","mergeResult","kind","attemptToMerge","shift","isNoOp","warn","ViewModelEventsCollector","outgoingEvents","outgoingEvent","_emitMany","_consumeViewEventQueue","_doConsumeQueue","eventHandlers","handleEvents","oldContentWidth","oldContentHeight","_oldContentWidth","_oldContentHeight","oldHasFocus","_oldScrollWidth","_oldScrollLeft","_oldScrollHeight","_oldScrollTop","CursorStateChangedEvent","oldSelections","oldModelVersionId","modelVersionId","reachedMaxCursorCount","_selectionsAreEqual","equalsSelection"],"sourceRoot":""}