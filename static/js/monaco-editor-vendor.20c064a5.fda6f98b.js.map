{"version":3,"file":"static/js/monaco-editor-vendor.20c064a5.fda6f98b.js","mappings":"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","sources":["../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/position.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/range.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/cursorCommon.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/diff/smartLinesDiffComputer.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/diffAlgorithm.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/utils.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        asciiMap.fill(defaultValue);\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n    clear() {\n        this._asciiMap.fill(this._defaultValue);\n        this._map.clear();\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n    clear() {\n        return this._actual.clear();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'), true);\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'));\nexport const editorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hcDark: deprecatedEditorActiveLineNumber, hcLight: deprecatedEditorActiveLineNumber }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\nexport const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hcDark: rulerRangeDefault, hcLight: rulerRangeDefault }, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', { dark: '#BD9B03', light: '#CEA33D', hcDark: '#ff0000', hcLight: '#CEA33D' }, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', { dark: '#bd9b0326', light: '#cea33d14', hcDark: '#00000000', hcLight: '#cea33d14' }, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nclass RGBA8 {\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\nRGBA8.Empty = new RGBA8(0, 0, 0, 0);\nexport { RGBA8 };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators) {\n        super(0 /* WordCharacterClass.Regular */);\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n}\nfunction once(computeFn) {\n    const cache = {}; // TODO@Alex unbounded cache\n    return (input) => {\n        if (!cache.hasOwnProperty(input)) {\n            cache[input] = computeFn(input);\n        }\n        return cache[input];\n    };\n}\nexport const getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        if (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n            // Avoid selecting text when recovering from markers\n            return Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n        }\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy, findLastMaxBy, findMinBy } from '../../../base/common/arrays.js';\nimport { CursorState } from '../cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findMinBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMaxBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CursorContext {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        this._cursorContextBrand = undefined;\n        this.model = model;\n        this.viewModel = viewModel;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealPrimary(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../core/cursorColumns.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Direction.Left */:\n                left = true;\n                break;\n            case 1 /* Direction.Right */:\n                left = false;\n                break;\n            case 2 /* Direction.Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* CharCode.Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* CharCode.Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 2 /* SelectionStartKind.Line */, 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(true, viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(true, selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(true, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        if (inSelectionMode) {\n            if (cursor.modelState.selectionStartKind === 1 /* SelectionStartKind.Word */) {\n                return this.word(viewModel, cursor, inSelectionMode, _position);\n            }\n            if (cursor.modelState.selectionStartKind === 2 /* SelectionStartKind.Line */) {\n                return this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n            }\n        }\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.description = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n            if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        const chIsQuote = isQuote(ch);\n        const autoCloseConfig = (chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets);\n        const shouldAutoCloseBefore = (chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket);\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './core/position.js';\nimport { Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { createScopedLineTokens } from './languages/supports.js';\nimport { CursorColumns } from './core/cursorColumns.js';\nimport { normalizeIndentation } from './core/indentation.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    static shouldRecreate(e) {\n        return (e.hasChanged(138 /* EditorOption.layoutInfo */)\n            || e.hasChanged(124 /* EditorOption.wordSeparators */)\n            || e.hasChanged(34 /* EditorOption.emptySelectionClipboard */)\n            || e.hasChanged(73 /* EditorOption.multiCursorMergeOverlapping */)\n            || e.hasChanged(75 /* EditorOption.multiCursorPaste */)\n            || e.hasChanged(76 /* EditorOption.multiCursorLimit */)\n            || e.hasChanged(5 /* EditorOption.autoClosingBrackets */)\n            || e.hasChanged(8 /* EditorOption.autoClosingQuotes */)\n            || e.hasChanged(6 /* EditorOption.autoClosingDelete */)\n            || e.hasChanged(7 /* EditorOption.autoClosingOvertype */)\n            || e.hasChanged(11 /* EditorOption.autoSurround */)\n            || e.hasChanged(122 /* EditorOption.useTabStops */)\n            || e.hasChanged(47 /* EditorOption.fontInfo */)\n            || e.hasChanged(86 /* EditorOption.readOnly */));\n    }\n    constructor(languageId, modelOptions, configuration, languageConfigurationService) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._cursorMoveConfigurationBrand = undefined;\n        this._languageId = languageId;\n        const options = configuration.options;\n        const layoutInfo = options.get(138 /* EditorOption.layoutInfo */);\n        const fontInfo = options.get(47 /* EditorOption.fontInfo */);\n        this.readOnly = options.get(86 /* EditorOption.readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(110 /* EditorOption.stickyTabStops */);\n        this.lineHeight = fontInfo.lineHeight;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(122 /* EditorOption.useTabStops */);\n        this.wordSeparators = options.get(124 /* EditorOption.wordSeparators */);\n        this.emptySelectionClipboard = options.get(34 /* EditorOption.emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(22 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(73 /* EditorOption.multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(75 /* EditorOption.multiCursorPaste */);\n        this.multiCursorLimit = options.get(76 /* EditorOption.multiCursorLimit */);\n        this.autoClosingBrackets = options.get(5 /* EditorOption.autoClosingBrackets */);\n        this.autoClosingQuotes = options.get(8 /* EditorOption.autoClosingQuotes */);\n        this.autoClosingDelete = options.get(6 /* EditorOption.autoClosingDelete */);\n        this.autoClosingOvertype = options.get(7 /* EditorOption.autoClosingOvertype */);\n        this.autoSurround = options.get(11 /* EditorOption.autoSurround */);\n        this.autoIndent = options.get(9 /* EditorOption.autoIndent */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: this._getShouldAutoClose(languageId, this.autoClosingQuotes, true),\n            bracket: this._getShouldAutoClose(languageId, this.autoClosingBrackets, false)\n        };\n        this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoClosingPairs();\n        const surroundingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getSurroundingPairs();\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n    }\n    get electricChars() {\n        var _a;\n        if (!this._electricChars) {\n            this._electricChars = {};\n            const electricChars = (_a = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || _a === void 0 ? void 0 : _a.getElectricCharacters();\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        const electricCharacterSupport = this.languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).electricCharacter;\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    normalizeIndentation(str) {\n        return normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    _getShouldAutoClose(languageId, autoCloseConfig, forQuotes) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return this._getLanguageDefinedShouldAutoClose(languageId, forQuotes);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    _getLanguageDefinedShouldAutoClose(languageId, forQuotes) {\n        const autoCloseBeforeSet = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoCloseBeforeSet(forQuotes);\n        return c => autoCloseBeforeSet.indexOf(c) !== -1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    visibleColumnFromColumn(model, position) {\n        return CursorColumns.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, this.tabSize);\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    columnFromVisibleColumn(model, lineNumber, visibleColumn) {\n        const result = CursorColumns.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, this.tabSize);\n        const minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n}\nexport class CursorState {\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selection = Selection.liftSelection(modelSelection);\n        const modelState = new SingleCursorState(Range.fromPositions(selection.getSelectionStart()), 0 /* SelectionStartKind.Simple */, 0, selection.getPosition(), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        const states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    constructor(modelState, viewState) {\n        this._cursorStateBrand = undefined;\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this.selectionStart = selectionStart;\n        this.selectionStartKind = selectionStartKind;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this._singleCursorStateBrand = undefined;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.selectionStartKind === other.selectionStartKind\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        if (selectionStart.isEmpty() || !position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n            return Selection.fromPositions(selectionStart.getStartPosition(), position);\n        }\n        else {\n            return Selection.fromPositions(selectionStart.getEndPosition(), position);\n        }\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this._editOperationResultBrand = undefined;\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    constructor(originalRange, modifiedRange, innerChanges) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n        this.innerChanges = innerChanges;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n}\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    constructor(startLineNumber, endLineNumberExclusive) {\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LineRange, RangeMapping, LineRangeMapping } from './linesDiffComputer.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class SmartLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new LineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber\n                    || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n                m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n        });\n        return {\n            quitEarly: result.quitEarly,\n            changes,\n        };\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SequenceDiff {\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    reverse() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n}\n/**\n * Todo move this class to some top level utils.\n*/\nexport class OffsetRange {\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff, OffsetRange } from './diffAlgorithm.js';\nimport { Array2D } from './utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, equalityScore) {\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange, SequenceDiff } from './diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffs(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\nexport function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nexport function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    if (sequenceDiffs.length > 0) {\n        result.push(sequenceDiffs[0]);\n    }\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const lastResult = result[result.length - 1];\n        const cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty) {\n            let all = true;\n            const length = cur.seq1Range.start - lastResult.seq1Range.endExclusive;\n            for (let i = 1; i <= length; i++) {\n                if (sequence2.getElement(cur.seq2Range.start - i) !== sequence2.getElement(cur.seq2Range.endExclusive - i)) {\n                    all = false;\n                    break;\n                }\n            }\n            if (all) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(lastResult.seq1Range, new OffsetRange(lastResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n        }\n        result.push(cur);\n    }\n    return result;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nexport function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const diff = sequenceDiffs[i];\n        if (diff.seq1Range.isEmpty) {\n            const seq2PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq2Range.endExclusive : -1);\n            const seq2NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq2Range.start : sequence2.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            const seq1PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq1Range.endExclusive : -1);\n            const seq1NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq1Range.start : sequence1.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq1NextStart, seq1PrevEndExclusive).reverse();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive) {\n    const maxShiftLimit = 20; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq2Range.start - deltaBefore > seq2PrevEndExclusive &&\n        sequence2.getElement(diff.seq2Range.start - deltaBefore) ===\n            sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq2Range.start + deltaAfter < seq2NextStart &&\n        sequence2.getElement(diff.seq2Range.start + deltaAfter) ===\n            sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    if (bestDelta !== 0) {\n        return new SequenceDiff(diff.seq1Range.delta(bestDelta), diff.seq2Range.delta(bestDelta));\n    }\n    return diff;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff, OffsetRange } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0) {\n            return [new SequenceDiff(new OffsetRange(0, 0), new OffsetRange(0, seq2.length))];\n        }\n        else if (seq2.length === 0) {\n            return [new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, 0))];\n        }\n        function getXAfterSnake(x, y) {\n            while (x < seq1.length && y < seq2.length && seq1.getElement(x) === seq2.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            for (k = -d; k <= d; k += 2) {\n                const maxXofDLineTop = k === d ? -1 : V.get(k + 1); // We take a vertical non-diagonal\n                const maxXofDLineLeft = k === -d ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x)\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);\n                const y = x - k;\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seq1.length && V.get(k) - k === seq2.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seq1.length;\n        let lastAligningPosS2 = seq2.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return result;\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { OffsetRange, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { optimizeSequenceDiffs, smoothenSequenceDiffs } from './algorithms/joinSequenceDiffs.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { LineRange, LineRangeMapping, RangeMapping } from './linesDiffComputer.js';\nexport class StandardLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const srcDocLines = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const tgtDocLines = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(srcDocLines, originalLines);\n        const sequence2 = new LineSequence(tgtDocLines, modifiedLines);\n        let lineAlignments = (() => {\n            if (sequence1.length + sequence2.length < 1500) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)));\n                    for (const a of characterDiffs) {\n                        alignments.push(a);\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff);\n            for (const a of characterDiffs) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments);\n        return {\n            quitEarly: false,\n            changes: changes,\n        };\n    }\n    refineDiff(originalLines, modifiedLines, diff) {\n        const sourceSlice = new Slice(originalLines, diff.seq1Range);\n        const targetSlice = new Slice(modifiedLines, diff.seq2Range);\n        const originalDiffs = sourceSlice.length + targetSlice.length < 500\n            ? this.dynamicProgrammingDiffing.compute(sourceSlice, targetSlice)\n            : this.myersDiffingAlgorithm.compute(sourceSlice, targetSlice);\n        let diffs = optimizeSequenceDiffs(sourceSlice, targetSlice, originalDiffs);\n        diffs = smoothenSequenceDiffs(sourceSlice, targetSlice, diffs);\n        const result = diffs.map((d) => new RangeMapping(sourceSlice.translateRange(d.seq1Range).delta(diff.seq1Range.start), targetSlice.translateRange(d.seq2Range).delta(diff.seq2Range.start)));\n        return result;\n    }\n}\nexport function lineRangeMappingFromRangeMappings(alignments) {\n    const changes = [];\n    for (const g of group(alignments, (a1, a2) => (a2.originalRange.startLineNumber - (a1.originalRange.endLineNumber - (a1.originalRange.endColumn > 1 ? 0 : 1)) <= 1)\n        || (a2.modifiedRange.startLineNumber - (a1.modifiedRange.endLineNumber - (a1.modifiedRange.endColumn > 1 ? 0 : 1)) <= 1))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new LineRangeMapping(new LineRange(first.originalRange.startLineNumber, last.originalRange.endLineNumber + (last.originalRange.endColumn > 1 || last.modifiedRange.endColumn > 1 ? 1 : 0)), new LineRange(first.modifiedRange.startLineNumber, last.modifiedRange.endLineNumber + (last.originalRange.endColumn > 1 || last.modifiedRange.endColumn > 1 ? 1 : 0)), g));\n    }\n    assertFn(() => {\n        return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n            m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n    });\n    return changes;\n}\nfunction* group(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\nclass Slice {\n    constructor(lines, lineRange) {\n        this.lines = lines;\n        this.lineRange = lineRange;\n        let chars = 0;\n        this.firstCharOnLineOffsets = new Int32Array(lineRange.length);\n        for (let i = lineRange.start; i < lineRange.endExclusive; i++) {\n            const line = lines[i];\n            chars += line.length;\n            this.firstCharOnLineOffsets[i - lineRange.start] = chars + 1;\n            chars++;\n        }\n        this.elements = new Int32Array(chars);\n        let offset = 0;\n        for (let i = lineRange.start; i < lineRange.endExclusive; i++) {\n            const line = lines[i];\n            for (let i = 0; i < line.length; i++) {\n                this.elements[offset + i] = line.charCodeAt(i);\n            }\n            offset += line.length;\n            if (i < lines.length - 1) {\n                this.elements[offset] = '\\n'.charCodeAt(0);\n                offset += 1;\n            }\n        }\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] > offset using binary search\n        let i = 0;\n        let j = this.firstCharOnLineOffsets.length;\n        while (i < j) {\n            const k = Math.floor((i + j) / 2);\n            if (this.firstCharOnLineOffsets[k] > offset) {\n                j = k;\n            }\n            else {\n                i = k + 1;\n            }\n        }\n        const offsetOfPrevLineBreak = i === 0 ? 0 : this.firstCharOnLineOffsets[i - 1];\n        return new Position(i + 1, offset - offsetOfPrevLineBreak + 1);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Space */]: 3,\n    [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [7 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 7 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 6 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 5 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\nfunction isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SmartLinesDiffComputer } from './smartLinesDiffComputer.js';\nimport { StandardLinesDiffComputer } from './standardLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    smart: new SmartLinesDiffComputer(),\n    experimental: new StandardLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run() {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run();\n    }\n}\n","/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst editorFeatures = [];\n/**\n * Registers an editor feature. Editor features will be instantiated only once, as soon as\n * the first code editor is instantiated.\n */\nexport function registerEditorFeature(ctor) {\n    editorFeatures.push(ctor);\n}\nexport function getEditorFeatures() {\n    return editorFeatures.slice(0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    constructor(theme) {\n        this._theme = theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n"],"names":["CharacterClassifier","_defaultValue","_classCallCheck","defaultValue","toUint8","this","_asciiMap","_createAsciiMap","_map","Map","_createClass","key","value","charCode","_value","set","get","fill","clear","asciiMap","Uint8Array","CharacterSet","_actual","CursorColumns","codePoint","visibleColumn","tabSize","nextRenderTabStop","strings","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","offset","nextGraphemeLength","_nextVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","indentSize","max","EditOperation","position","range","Range","lineNumber","forceMoveMarkers","editorLineHighlight","registerColor","dark","light","hcDark","hcLight","nls","editorLineHighlightBorder","contrastBorder","editorCursorForeground","activeContrastBorder","editorFindMatchHighlight","Color","black","white","editorCursorBackground","editorWhitespaces","editorIndentGuides","editorActiveIndentGuides","editorLineNumbers","deprecatedEditorActiveLineNumber","editorDimmedLineNumber","editorOverviewRulerBorder","lightgrey","editorOverviewRulerBackground","editorUnnecessaryCodeOpacity","editorBackground","fromHex","transparent","rulerRangeDefault","RGBA","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","editorWarningForeground","editorWarningBorder","overviewRulerInfo","editorInfoForeground","editorInfoBorder","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","registerThemingParticipant","theme","collector","background","getColor","lineHighlight","imeBackground","isTransparent","addRule","concat","countEOL","eolCount","firstLineLength","lastLineStart","i","len","chr","charCodeAt","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","spacesCnt","charAt","nextIndentTabStop","tabsCnt","floor","_normalizeIndentationFromWhitespace","Position","newLineNumber","arguments","undefined","newColumn","deltaLineNumber","deltaColumn","with","other","equals","isBefore","isBeforeOrEqual","a","b","aLineNumber","bLineNumber","pos","obj","startLineNumber","startColumn","endLineNumber","endColumn","isEmpty","containsPosition","containsRange","strictContainsRange","plusRange","intersectRanges","equalsRange","getEndPosition","getStartPosition","collapseToStart","collapseToEnd","lineCount","otherRange","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","start","end","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","RGBA8","r","g","_rgba8Brand","_clamp","c","Empty","Selection","_Range","_inherits","_super","_createSuper","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_this","call","selectionsEqual","getDirection","direction","sel","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","platform","decodeUTF16LE","source","view","Uint16Array","buffer","resultLen","String","fromCharCode","join","compatDecodeUTF16LE","decode","StringBuilder","capacity","_capacity","_buffer","_completedStrings","_bufferLength","_flushBuffer","_buildBuffer","bufferString","remainingSpace","strLen","escapeNewLine","replace","TextChange","oldPosition","oldText","newPosition","newText","_writeStringSize","_writeString","dest","_readString","push","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","oldEnd","_acceptCurr","newEnd","_acceptPrev","_TextChangeCompressor","_splitCurr","_TextChangeCompressor2","_slicedToArray","e1","e2","_TextChangeCompressor3","_splitPrev","_TextChangeCompressor4","mergePrev","mergeCurr","_TextChangeCompressor5","oldLength","_TextChangeCompressor6","_TextChangeCompressor7","newLength","_TextChangeCompressor8","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","prev","curr","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","independentColorPoolPerBracketType","WordCharacterClassifier","_CharacterClassifier","wordSeparators","getMapForWordSeparators","computeFn","cache","input","hasOwnProperty","once","USUAL_WORD_SEPARATORS","DEFAULT_WORD_REGEXP","_step","allowInWords","_iterator","_createForOfIteratorHelper","s","n","done","sep","indexOf","err","e","f","RegExp","createWordRegExp","ensureValidWordDefinition","wordDefinition","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","LinkedList","getWordAtText","textOffset","config","Iterable","first","maxLen","t1","Date","now","prevRegexIndex","match","timeBudget","regexIndex","windowSize","thisMatch","_findRegexMatchEnclosingPosition","word","index","stopPos","exec","matchIndex","unshift","Cursor","context","_selTrackedRange","_trackSelection","_setState","SingleCursorState","_removeTrackedRange","_updateTrackedRange","model","_setTrackedRange","modelState","selection","CursorState","viewState","_getTrackedRange","fromRange","_validateViewState","viewModel","selectionStart","validateRange","selectionStartLeftoverVisibleColumns","validatePosition","leftoverVisibleColumns","selectionStartKind","coordinatesConverter","convertViewRangeToModelRange","convertViewPositionToModelPosition","viewSelectionStart","validateViewRange","viewPosition","validateViewPosition","viewSelectionStart1","convertModelPositionToViewPosition","viewSelectionStart2","cacheInput","cacheOutput","normalizePosition","sStartPosition","sEndPosition","validPosition","validSStartPosition","_validatePositionWithCache","validSEndPosition","fromPositions","CursorCollection","cursors","lastAddedCursorIndex","dispose","_step2","_iterator2","startTrackingSelection","_step3","_iterator3","stopTrackingSelection","_step4","_iterator4","ensureValidState","map","readSelectionFromMarkers","asCursorState","findMinBy","compareBy","compare","findLastMaxBy","selections","setStates","fromModelSelections","states","setState","_setSecondaryStates","slice","secondaryStates","secondaryCursorsLength","secondaryStatesLength","createCnt","_addSecondaryCursor","removeCnt","_removeSecondaryCursor","removeIndex","splice","sortedCursors","sort","compareRangesUsingStarts","sortedCursorIndex","current","next","currentSelection","nextSelection","cursorConfig","multiCursorMergeOverlapping","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","equalsSelection","resultingRange","looserSelectionIsLTR","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingSelection","resultingState","fromModelSelection","_step5","_iterator5","sortedCursor","CursorContext","_cursorContextBrand","CursorsController","_Disposable","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","_cursors","_hasFocus","_isHandling","_compositionState","_columnSelectData","_autoClosedActions","_prevEditOperationType","_get","_getPrototypeOf","prototype","updateContext","eventsCollector","getCursorStates","hasFocus","getSelections","autoClosedAction","isValid","getPrimaryCursor","getLastAddedCursorIndex","getAll","reason","reachedMaxCursorCount","multiCursorLimit","oldState","CursorModelState","from","normalize","_validateAutoClosedActions","_emitStateChangedIfNecessary","columnSelectData","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","emitViewEvent","ViewRevealRangeRequestEvent","inSelectionMode","desiredSelections","state","revealPrimary","event","ModelInjectedTextChangedEvent","rawContentChangedEvent","versionId","hadFlushEvent","containsEvent","cursorState","isUndoing","isRedoing","selectionsFromMarkers","getTopMostViewPosition","getBottomMostViewPosition","primaryCursor","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","type","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","TypeWithAutoClosingCommand","enclosingRange","closeCharacterRange","_pushAutoClosedAction","shouldPushStackElementAfter","setSelections","newState","viewSelections","ViewCursorStateChangedEvent","some","newCursorState","oldSelections","oldModelVersionId","modelVersionId","emitOutgoingEvent","CursorStateChangedEvent","indices","m","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","cursorStateComputer","_this2","autoClosingIndices","_findAutoClosingPairs","_isTracked","pushEditOperations","undoEdits","_autoClosingIndices$i","openCharInnerIndex","closeCharInnerIndex","undoEdit","callback","cursorChangeReason","readOnly","stopTrackingSelections","onUnexpectedError","startTrackingSelections","getAllAutoClosedCharacters","CompositionState","_this3","compositionOutcome","deduceOutcome","_executeEdit","_executeEditOperation","TypeOperations","compositionEndWithInterceptors","getAutoClosedCharacters","_this4","charLength","typeWithInterceptors","typeWithoutInterceptors","replacePrevCharCnt","replaceNextCharCnt","positionDelta","_this5","compositionType","newSelections","getPosition","pasteOnNewLine","multicursorText","_this6","paste","_this7","DeleteOperations","cut","_this8","killSecondaryCursors","EditOperationResult","_this9","Disposable","cursor","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","decorationRange","getDecorationRange","enclosingRanges","autoClosedActions","autoClosedCharacters","getAutoClosedCharactersRanges","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","minor","cursorSelections","_loop","_i3","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","losingCursors","losingCursorIndex","_i4","_losingCursors","losingCursor","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","isAutoWhitespaceEdit","insertsAutoWhitespace","editOperationBuilder","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","loserMajor","j","CompositionLineState","startSelection","endSelection","textModel","_original","_capture","_deduceOutcome","getLineContent","original","commonPrefix","commonSuffix","deletedText","insertedText","CompositionOutcome","AtomicTabMoveOperations","lineLength","prevTabStopPosition","prevTabStopVisibleColumn","left","_AtomicTabMoveOperati","whitespaceVisibleColumn","_AtomicTabMoveOperati2","currentVisibleColumn","targetVisibleColumn","ColumnSelection","fromLineNumber","fromVisibleColumn","toLineNumber","toVisibleColumn","abs","reversed","isRTL","isLTR","columnFromVisibleColumn","visibleStartColumn","visibleEndColumn","maxColumn","viewStates","fromVisualColumn","toVisualColumn","prevColumnSelectData","columnSelect","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","isPaged","linesCount","pageSize","getLineCount","prevEditOperationType","deleteSelection","rightOfPosition","MoveOperations","right","ReplaceCommand","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","lineText","character","autoClosingPairCandidates","isQuote","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","close","found","lenJ","autoClosedCharacter","isAutoClosingPairDelete","autoClosingPairsOpenByEnd","_runAutoClosingPairDelete","deleteRange","getDeleteRange","useTabStops","lastIndentationColumn","prevIndentTabStop","toColumn","getPositionAfterDeleteLeft","newLine","lastCutRange","emptySelectionClipboard","CursorMove","CursorMoveCommands","useLogicalLine","fromModelState","translateDown","fromViewState","translateUp","_moveToLineStart","currentViewStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","firstNonBlankColumn","getLineFirstNonWhitespaceColumn","_moveToLineStartByModel","_moveToLineStartByView","moveToBeginningOfLine","sticky","_moveToLineEnd","viewStatePosition","viewModelMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_moveToLineEndByModel","_moveToLineEndByView","moveToEndOfLine","moveToBeginningOfBuffer","moveToEndOfBuffer","_position","_viewPosition","selectToLineNumber","selectToColumn","enteringLineNumber","move","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","WordOperations","hasSelection","line","unit","_moveHalfLineLeft","_moveLeft","_moveHalfLineRight","_moveRight","_moveUpByViewLines","_moveUpByModelLines","_moveDownByViewLines","_moveDownByModelLines","moveToPrevBlankLine","moveToNextBlankLine","_moveToViewMinColumn","_moveToViewFirstNonWhitespaceColumn","_moveToViewCenterColumn","_moveToViewMaxColumn","_moveToViewLastNonWhitespaceColumn","visibleViewRange","getCompletelyVisibleViewRange","visibleModelRange","modelLineNumber","_firstLineNumberInRange","modelColumn","_moveToModelPosition","_lastLineNumberInRange","round","findPositionInViewportIfOutside","newViewLineNumber","viewLineNumber","vertical","count","getLineMinColumn","noOfColumns","moveLeft","halfLine","moveRight","moveDown","moveUp","toViewColumn","toModelLineNumber","toModelColumn","viewColumn","_moveToViewPosition","getLineLastNonWhitespaceColumn","args","name","constraint","arg","types","cursorMoveArg","to","select","by","schema","RawDirection","Left","Right","Up","Down","PrevBlankLine","NextBlankLine","WrappedLineStart","WrappedLineFirstNonWhitespaceCharacter","WrappedLineColumnCenter","WrappedLineEnd","WrappedLineLastNonWhitespaceCharacter","ViewPortTop","ViewPortCenter","ViewPortBottom","ViewPortIfOutside","RawUnit","Line","WrappedLine","Character","HalfLine","parse","CursorPosition","_cursorPositionBrand","delta","getLineIndentColumn","minColumn","atomicPosition","leftPosition","stickyTabStops","leftPositionAtomicSoftTabs","normalizedPos","clipPositionColumn","p","clipRange","rightPosition","rightPositionAtomicSoftTabs","allowMoveOnEdgeLine","normalizationAffinity","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","allowMoveOnLastLine","down","allowMoveOnFirstLine","up","_isBlankLine","lastLineNumber","lastColumn","ShiftCommand","isUnshift","autoIndent","languageConfigurationService","indentation","shiftIndent","unshiftIndent","typeSelection","ReplaceCommandThatPreservesSelection","multiCursorPaste","lines","distributedPaste","_distributePasteToCursors","_distributedPaste","_simplePaste","action","expectedIndentAction","getInheritIndentForLine","expectedEnterAction","getEnterAction","appendText","IndentAction","Indent","Outdent","typeText","test","tokenization","isCheapToTokenize","goodIndent","_goodIndentForLine","possibleTypeText","startsWith","_replaceJumpToNextIndent","lineMaxColumn","_compositionType","shouldPushStackElementBetween","getValueInRange","ReplaceCommandWithOffsetCursorState","keepPosition","ReplaceCommandWithoutChangingPosition","_typeCommand","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","indent","oldEndViewColumn","oldEndColumn","newLineContent","firstNonWhitespace","setEndPosition","afterEnter","ceil","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","autoClosingOvertype","has","chIsQuote","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","x","isBeforeClosingBrace","positions","candidates","candidate","candidateIsMatch","pair","lastChar","autoClosingPairsCloseByEnd","includes","endsWith","chIsAlreadyTyped","autoCloseConfig","shouldAutoCloseBefore","quote","bracket","_findAutoClosingPairOpen","containedPair","_findContainedAutoClosingPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","_isBeforeClosingBrace","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","autoClosingPairClose","autoSurround","_shouldSurroundChar","surroundingPairs","_step6","isTypingAQuoteCharacter","_iterator6","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","closeCharacter","SurroundSelectionCommand","electricChars","electricAction","onElectricCharacter","matchOpenBracket","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","getTypingOperation","compositions","_step7","_iterator7","composition","_step8","hasDeletion","_iterator8","_step9","_iterator9","deletedSelectionStart","deletedSelectionEnd","_step10","_iterator10","CompositionSurroundSelectionCommand","_isAutoClosingOvertype","_getAutoClosingPairClose","_runAutoClosingOpenCharType","isDoingComposition","_enter","_isAutoIndentType","autoIndentFails","_runAutoIndentType","_runAutoClosingOvertype","_isSurroundSelectionType","_runSurroundSelectionType","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","opType","_ReplaceCommandWithOf","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","helper","insertedSelectionStart","insertedSelectionEnd","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","wordType","nextCharClass","_doFindPreviousWordOnLine","chIndex","chCode","chClass","_createWord","_findEndOfWord","_doFindNextWordOnLine","_findStartOfWord","wordNavigationType","prevWordOnLine","_findPreviousWordOnLine","rightRight","movedDown","nextWordOnLine","_findNextWordOnLine","lastNonWhitespace","whitespaceHeuristics","_deleteWordLeftWhitespace","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","leftIndex","_charAtIsWhitespace","rightIndex","touchesWord","createRangeWithPosition","deleteWordAndAdjacentWhitespace","expandedToTheRight","toPosition","_moveWordPartLeft","_findFirstNonWhitespaceChar","_deleteWordRightWhitespace","_moveWordPartRight","_wordSeparators","prevWord","_createWordAtPosition","nextWord","possiblePosition","WordPartOperations","_WordOperations","apply","enforceDefined","deleteWordLeft","_deleteWordPartLeft","deleteWordRight","_deleteWordPartRight","moveWordLeft","moveWordRight","arr","filter","el","Boolean","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","CursorConfiguration","languageId","modelOptions","configuration","_cursorMoveConfigurationBrand","_languageId","layoutInfo","fontInfo","lineHeight","typicalHalfwidthCharacterWidth","height","copyWithSyntaxHighlighting","_electricChars","_getShouldAutoClose","getLanguageConfiguration","getAutoClosingPairs","getSurroundingPairs","_a","electricCharacter","getElectricCharacters","char","electricCharacterSupport","forQuotes","_getLanguageDefinedShouldAutoClose","autoCloseBeforeSet","getAutoCloseBeforeSet","hasChanged","_cursorStateBrand","PartialModelCursorState","PartialViewCursorState","modelSelection","getSelectionStart","modelSelections","_singleCursorStateBrand","_computeSelection","opts","_editOperationResultBrand","LineRangeMapping","originalRange","modifiedRange","innerChanges","RangeMapping","LineRange","endLineNumberExclusive","SmartLinesDiffComputer","originalLines","modifiedLines","DiffComputer","maxComputationTime","maxComputationTimeMs","shouldIgnoreTrimWhitespace","ignoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","computeDiff","changes","lastChange","originalEndLineNumber","originalStartLineNumber","modifiedEndLineNumber","modifiedStartLineNumber","change","charChanges","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","pop","assertFn","checkAdjacentItems","m1","m2","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","LineSequence","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","elements","charCodes","lineNumbers","columns","col","CharSequence","_charCodes","_lineNumbers","_columns","Error","getEndLineNumber","_assertIndex","getStartLineNumber","getEndColumn","getStartColumn","CharChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","LineChange","originalLineSequence","modifiedLineSequence","continueCharDiff","createCharSequence","getElements","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","postProcessCharChanges","createFromDiffChange","modified","continueLineDiff","createContinueProcessingPredicate","diffResult","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","maximumRuntime","startTime","SequenceDiff","seq1Range","seq2Range","OffsetRange","endExclusive","Array2D","width","array","Array","y","DynamicProgrammingDiffing","sequence1","sequence2","equalityScore","lcsLengths","directions","lengths","s1","s2","horizontalLen","verticalLen","extendedSeqScore","getElement","newValue","prevLen","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","reverse","optimizeSequenceDiffs","sequenceDiffs","lastResult","cur","all","joinSequenceDiffs","getBoundaryScore","diff","seq2PrevEndExclusive","seq2NextStart","shiftDiffToBetterPosition","seq1PrevEndExclusive","seq1NextStart","shiftSequenceDiffs","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","score","MyersDiffAlgorithm","seq1","seq2","getXAfterSnake","d","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","k","loop","maxXofDLineTop","maxXofDLineLeft","newMaxX","lastPath","path","endX","endY","positiveArr","Int32Array","negativeArr","group","StandardLinesDiffComputer","dynamicProgrammingDiffing","myersDiffingAlgorithm","perfectHashes","getOrCreateHash","hash","size","srcDocLines","trim","tgtDocLines","lineAlignments","compute","offset1","offset2","log","alignments","scanForWhitespaceChanges","equalLinesCount","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","a1","a2","last","lineRangeMappingFromRangeMappings","sourceSlice","Slice","targetSlice","originalDiffs","diffs","smoothenSequenceDiffs","translateRange","items","shouldBeGrouped","currentGroup","item","_regeneratorRuntime","wrap","_context","t0","finish","stop","_marked","trimmedHash","getIndentation","lineRange","chars","firstCharOnLineOffsets","prevCategory","getCategory","nextCategory","getCategoryBoundaryScore","offsetOfPrevLineBreak","translateOffset","_score","_defineProperty","category","isSpace","linesDiffComputers","smart","experimental","InternalEditorAction","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","contextMatchesRules","isSupported","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","focus","textInputFocus","inDiffEditor","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","inCompositeEditor","notInCompositeEditor","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","editorFeatures","registerEditorFeature","ctor","getEditorFeatures","EditorTheme","_theme","color"],"sourceRoot":""}