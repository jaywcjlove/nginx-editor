{"version":3,"file":"static/js/monaco-editor-vendor.afb535f1.97cb3283.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js","../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js","../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/offsetRange.js';\nexport class DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class SequenceDiff {\n    static invert(sequenceDiffs, doc1Length) {\n        const result = [];\n        forEachAdjacent(sequenceDiffs, (a, b) => {\n            result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));\n        });\n        return result;\n    }\n    static fromOffsetPairs(start, endExclusive) {\n        return new SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));\n    }\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    swap() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n    }\n    deltaStart(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n    }\n    deltaEnd(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n    }\n    intersect(other) {\n        const i1 = this.seq1Range.intersect(other.seq1Range);\n        const i2 = this.seq2Range.intersect(other.seq2Range);\n        if (!i1 || !i2) {\n            return undefined;\n        }\n        return new SequenceDiff(i1, i2);\n    }\n    getStarts() {\n        return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n    }\n    getEndExclusives() {\n        return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n    }\n}\nexport class OffsetPair {\n    constructor(offset1, offset2) {\n        this.offset1 = offset1;\n        this.offset2 = offset2;\n    }\n    toString() {\n        return `${this.offset1} <-> ${this.offset2}`;\n    }\n}\nOffsetPair.zero = new OffsetPair(0, 0);\nOffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\nexport class InfiniteTimeout {\n    isValid() {\n        return true;\n    }\n}\nInfiniteTimeout.instance = new InfiniteTimeout();\nexport class DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\nexport function isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\nexport class LineRangeFragment {\n    static getKey(chr) {\n        let key = this.chrKeys.get(chr);\n        if (key === undefined) {\n            key = this.chrKeys.size;\n            this.chrKeys.set(chr, key);\n        }\n        return key;\n    }\n    constructor(range, lines, source) {\n        this.range = range;\n        this.lines = lines;\n        this.source = source;\n        this.histogram = [];\n        let counter = 0;\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n            const line = lines[i];\n            for (let j = 0; j < line.length; j++) {\n                counter++;\n                const chr = line[j];\n                const key = LineRangeFragment.getKey(chr);\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\n            }\n            counter++;\n            const key = LineRangeFragment.getKey('\\n');\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\n        }\n        this.totalCount = counter;\n    }\n    computeSimilarity(other) {\n        var _a, _b;\n        let sumDifferences = 0;\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\n        for (let i = 0; i < maxLength; i++) {\n            sumDifferences += Math.abs(((_a = this.histogram[i]) !== null && _a !== void 0 ? _a : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));\n        }\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\n    }\n}\nLineRangeFragment.chrKeys = new Map();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        const seqX = seq1; // Text on the x axis\n        const seqY = seq2; // Text on the y axis\n        function getXAfterSnake(x, y) {\n            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        // k=1 -> (1,0),(2,1)\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n            }\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n            const lowerBound = -Math.min(d, seqY.length + (d % 2));\n            const upperBound = Math.min(d, seqX.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                let step = 0;\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n                step++;\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n                const y = x - k;\n                step++;\n                if (x > seqX.length || y > seqY.length) {\n                    // This diagonal is irrelevant for the result.\n                    // TODO: Don't pay the cost for this in the next iteration.\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seqX.length;\n        let lastAligningPosS2 = seqY.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nexport class LinesSliceCharSequence {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLine = [];\n        // To account for trimming\n        this.additionalOffsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        this.firstCharOffsetByLine[0] = 0;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.additionalOffsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.additionalOffsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new Position(this.lineRange.start + 1, 1);\n        }\n        const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);\n        return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.elements[offset1] === this.elements[offset2];\n    }\n    extendToFullLines(range) {\n        var _a, _b;\n        const start = (_a = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start)) !== null && _a !== void 0 ? _a : 0;\n        const end = (_b = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Space */]: 3,\n    [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [7 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 7 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 6 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 5 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    // Ignore too short moves\n    moves = moves.filter(current => {\n        const originalText = current.original.toOffsetRange().slice(originalLines).map(l => l.trim()).join('\\n');\n        return originalText.length >= 10;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => new LineRangeFragment(d.original, originalLines, d));\n    const insertions = new Set(changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n    const excludedChanges = new Set();\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(new LineRangeMapping(deletion.range, best.range));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = new SetMap();\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = new LineRange(i, i + 3);\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    // does this match extend some last match?\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n                        lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = new LineRangeSet();\n    const originalSet = new LineRangeSet();\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = new MonotonousArray(changes);\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n            modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n            modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = new MonotonousArray(changes);\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.endLineNumberExclusive < m.original.endLineNumberExclusive)\n            || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.endLineNumberExclusive < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n    getText(range) {\n        return this.lines.slice(range.start, range.endExclusive).join('\\n');\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.lines[offset1] === this.lines[offset2];\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals, groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Range } from '../../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs, removeShortMatches } from './heuristicSequenceOptimizations.js';\nimport { LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, RangeMapping } from '../rangeMapping.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineSequence } from './lineSequence.js';\nexport class DefaultLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n            return new LinesDiff([], [], false);\n        }\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return new LinesDiff([\n                new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n                    new RangeMapping(new Range(1, 1, originalLines.length, originalLines[0].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))\n                ])\n            ], [], false);\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(originalLinesHashes, originalLines);\n        const sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1700) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        let moves = [];\n        if (options.computeMoves) {\n            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n        }\n        // Make sure all ranges are valid\n        assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return new LinesDiff(changes, moves, hitTimeout);\n    }\n    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n        const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n        const movesWithDiffs = moves.map(m => {\n            const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n            return new MovedText(m, mappings);\n        });\n        return movesWithDiffs;\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\n        const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n        diffs = removeShortMatches(slice1, slice2, diffs);\n        diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n        const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of groupAdjacentBy(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original)\n        || a1.modified.overlapOrTouch(a2.modified))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        if (!dontAssertStartLine) {\n            if (changes.length > 0 && changes[0].original.startLineNumber !== changes[0].modified.startLineNumber) {\n                return false;\n            }\n        }\n        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        // We can only do this if the range is not empty yet\n        lineEndDelta = -1;\n    }\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        // We can only do this if the range is not empty yet\n        lineStartDelta = 1;\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\nexport function removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nexport function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n    const additional = [];\n    let lastModifiedWord = undefined;\n    function maybePushWordToAdditional() {\n        if (!lastModifiedWord) {\n            return;\n        }\n        const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n        const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n        if (originalLength1 !== originalLength2) {\n            // TODO figure out why this happens\n        }\n        if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {\n            additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n        }\n        lastModifiedWord = undefined;\n    }\n    for (const s of sequenceDiffs) {\n        function processWord(s1Range, s2Range) {\n            var _a, _b, _c, _d;\n            if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n                if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {\n                    const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n                    const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n                    lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;\n                    lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;\n                    lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n                    lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n                }\n                else {\n                    maybePushWordToAdditional();\n                    lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range: s1Range, s2Range: s2Range };\n                }\n            }\n            const changedS1 = s1Range.intersect(s.seq1Range);\n            const changedS2 = s2Range.intersect(s.seq2Range);\n            lastModifiedWord.count++;\n            lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;\n            lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;\n        }\n        const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n        const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n        const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n        const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n        if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {\n            processWord(w1Before, w2Before);\n        }\n        else {\n            if (w1Before && w2Before) {\n                processWord(w1Before, w2Before);\n            }\n            if (w1After && w2After) {\n                processWord(w1After, w2After);\n            }\n        }\n    }\n    maybePushWordToAdditional();\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedText = sequence1.getText(unchangedRange);\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n                if (unchangedTextWithoutWs.length <= 4\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (Math.pow((Math.pow(max, 1.5)), 1.5)) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    const newDiffs = [];\n    // Remove short suffixes/prefixes\n    forEachWithNeighbors(diffs, (prev, cur, next) => {\n        let newDiff = cur;\n        function shouldMarkAsChanged(text) {\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n        }\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n        const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n        if (shouldMarkAsChanged(prefix)) {\n            newDiff = newDiff.deltaStart(-prefix.length);\n        }\n        const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n        if (shouldMarkAsChanged(suffix)) {\n            newDiff = newDiff.deltaEnd(suffix.length);\n        }\n        const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n        const result = newDiff.intersect(availableSpace);\n        newDiffs.push(result);\n    });\n    return newDiffs;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LinesDiff {\n    constructor(changes, \n    /**\n     * Sorted by original line ranges.\n     * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n     */\n    moves, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.moves = moves;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class MovedText {\n    constructor(lineRangeMapping, changes) {\n        this.lineRangeMapping = lineRangeMapping;\n        this.changes = changes;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class LegacyLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n        });\n        return new LinesDiff(changes, [], result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    getLegacy: () => new LegacyLinesDiffComputer(),\n    getDefault: () => new DefaultLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineRange } from '../core/lineRange.js';\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new DetailedLineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber), undefined);\n            if (!r.modified.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n        }\n        const r = new DetailedLineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), undefined);\n        if (!r.modified.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange) {\n        this.original = originalRange;\n        this.modified = modifiedRange;\n    }\n    toString() {\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\n    }\n    flip() {\n        return new LineRangeMapping(this.modified, this.original);\n    }\n    join(other) {\n        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n    }\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n    constructor(originalRange, modifiedRange, innerChanges) {\n        super(originalRange, modifiedRange);\n        this.innerChanges = innerChanges;\n    }\n    flip() {\n        var _a;\n        return new DetailedLineRangeMapping(this.modified, this.original, (_a = this.innerChanges) === null || _a === void 0 ? void 0 : _a.map(c => c.flip()));\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    flip() {\n        return new RangeMapping(this.modifiedRange, this.originalRange);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run(args) {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run(args);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read-only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.isEmbeddedDiffEditor = new RawContextKey('isEmbeddedDiffEditor', false, nls.localize('isEmbeddedDiffEditor', \"Whether the context is an embedded diff editor\"));\n    EditorContextKeys.comparingMovedCode = new RawContextKey('comparingMovedCode', false, nls.localize('comparingMovedCode', \"Whether a moved code block is selected for comparison\"));\n    EditorContextKeys.accessibleDiffViewerVisible = new RawContextKey('accessibleDiffViewerVisible', false, nls.localize('accessibleDiffViewerVisible', \"Whether the accessible diff viewer is visible\"));\n    EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached = new RawContextKey('diffEditorRenderSideBySideInlineBreakpointReached', false, nls.localize('diffEditorRenderSideBySideInlineBreakpointReached', \"Whether the diff editor render side by side inline breakpoint is reached\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    EditorContextKeys.hoverFocused = new RawContextKey('editorHoverFocused', false, nls.localize('editorHoverFocused', \"Whether the editor hover is focused\"));\n    EditorContextKeys.stickyScrollFocused = new RawContextKey('stickyScrollFocused', false, nls.localize('stickyScrollFocused', \"Whether the sticky scroll is focused\"));\n    EditorContextKeys.stickyScrollVisible = new RawContextKey('stickyScrollVisible', false, nls.localize('stickyScrollVisible', \"Whether the sticky scroll is visible\"));\n    EditorContextKeys.standaloneColorPickerVisible = new RawContextKey('standaloneColorPickerVisible', false, nls.localize('standaloneColorPickerVisible', \"Whether the standalone color picker is visible\"));\n    EditorContextKeys.standaloneColorPickerFocused = new RawContextKey('standaloneColorPickerFocused', false, nls.localize('standaloneColorPickerFocused', \"Whether the standalone color picker is focused\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst editorFeatures = [];\n/**\n * Registers an editor feature. Editor features will be instantiated only once, as soon as\n * the first code editor is instantiated.\n */\nexport function registerEditorFeature(ctor) {\n    editorFeatures.push(ctor);\n}\nexport function getEditorFeatures() {\n    return editorFeatures.slice(0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    constructor(theme) {\n        this._theme = theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n"],"names":["DiffAlgorithmResult","diffs","hitTimeout","_classCallCheck","this","_createClass","key","value","seq1","seq2","SequenceDiff","OffsetRange","ofLength","length","seq1Range","seq2Range","concat","other","join","offset","delta","deltaStart","deltaEnd","i1","intersect","i2","OffsetPair","start","endExclusive","sequenceDiffs","doc1Length","result","forEachAdjacent","a","b","push","fromOffsetPairs","getEndExclusives","zero","getStarts","offset1","offset2","max","Number","MAX_SAFE_INTEGER","InfiniteTimeout","instance","DateTimeout","timeout","startTime","Date","now","valid","BugIndicatingError","Array2D","width","height","array","Array","x","y","isSpace","charCode","LineRangeFragment","range","lines","source","histogram","counter","i","startLineNumber","endLineNumberExclusive","line","j","chr","getKey","totalCount","_a","_b","sumDifferences","maxLength","Math","abs","chrKeys","get","undefined","size","set","Map","DynamicProgrammingDiffing","sequence1","sequence2","arguments","equalityScore","trivial","lcsLengths","directions","lengths","s1","s2","isValid","trivialTimedOut","horizontalLen","verticalLen","extendedSeqScore","getElement","newValue","prevLen","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","reverse","MyersDiffAlgorithm","seqX","seqY","getXAfterSnake","d","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","k","loop","lowerBound","min","upperBound","maxXofDLineTop","maxXofDLineLeft","step","newMaxX","lastPath","path","endX","endY","prev","positiveArr","Int32Array","negativeArr","idx","arr","LinesSliceCharSequence","lineRange","considerWhitespaceChanges","elements","firstCharOffsetByLine","additionalOffsetByLine","trimFirstLineFully","trimmedStartLine","trimStart","trimEnd","charCodeAt","text","getText","slice","map","e","String","fromCharCode","prevCategory","getCategory","nextCategory","score","getCategoryBoundaryScore","isEmpty","Position","findLastIdxMonotonous","Range","fromPositions","translateOffset","isWordChar","end","lineNumber","findLastMonotonous","findFirstMonotonous","_score","_defineProperty","category","computeMovedLines","changes","originalLines","modifiedLines","hashedOriginalLines","hashedModifiedLines","_computeMovesFromSimp","_step","moves","deletions","filter","c","modified","original","insertions","Set","excludedChanges","_iterator","_createForOfIteratorHelper","s","n","done","_step2","deletion","highestSimilarity","best","_iterator2","insertion","similarity","computeSimilarity","err","f","delete","LineRangeMapping","add","computeMovesFromSimpleDeletionsToSimpleInsertions","unchangedMoves","_step3","original3LineHashes","SetMap","_iterator3","change","LineRange","possibleMappings","sort","compareBy","numberComparator","_step4","_iterator4","_ret","_loop2","lastMappings","_loop3","currentModifiedRange","nextMappings","forEach","_ref","_i4","_lastMappings","lastMapping","originalLineRange","modifiedLineRange","mapping","v","reverseOrder","m","modifiedSet","LineRangeSet","originalSet","_i","_possibleMappings","_step5","diffOrigToMod","modifiedSections","subtractFrom","originalTranslatedSections","getWithDelta","modifiedIntersectedSections","getIntersection","_iterator5","ranges","addRange","monotonousChanges","MonotonousArray","_loop","extendToTop","extendToBottom","move","firstTouchingChangeOrig","firstTouchingChangeMod","linesAbove","lastTouchingChangeOrig","lastTouchingChangeMod","linesBelow","origLine","modLine","contains","areLinesSimilar","computeUnchangedMoves","has","pushMany","changesMonotonous","removeMovesInSameDiff","last","current","originalDist","modifiedDist","joinCloseConsecutiveMoves","toOffsetRange","l","trim","line1","line2","_step6","compute","commonNonSpaceCharCount","inverted","invert","_iterator6","longerLineLength","str","count","countNonWsChars","LineSequence","trimmedHash","getIndentation","DefaultLinesDiffComputer","dynamicProgrammingDiffing","myersDiffingAlgorithm","options","_this","equals","LinesDiff","DetailedLineRangeMapping","RangeMapping","maxComputationTimeMs","ignoreTrimWhitespace","perfectHashes","getOrCreateHash","hash","originalLinesHashes","modifiedLinesHashes","lineAlignmentResult","log","lineAlignments","optimizeSequenceDiffs","removeVeryShortMatchingLinesBetweenDiffs","alignments","scanForWhitespaceChanges","equalLinesCount","seq1Offset","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","mappings","diff","assertFn","lineRangeMappingFromRangeMappings","computeMoves","validatePosition","pos","column","validateRange","innerChanges","ic","modifiedRange","getStartPosition","getEndPosition","originalRange","_this2","MovedText","slice1","slice2","diffResult","extendDiffsToEntireWordIfAppropriate","removeShortMatches","removeVeryShortMatchingTextBetweenLongDiffs","translateRange","dontAssertStartLine","groupAdjacentBy","rangeMapping","lineStartDelta","lineEndDelta","endColumn","endLineNumber","startColumn","getLineRangeMapping","a1","a2","overlapOrTouch","g","first","checkAdjacentItems","m1","m2","prevResult","cur","result2","nextResult","isStronglyEqual","joinSequenceDiffsByShifting","getBoundaryScore","prevDiff","nextDiff","seq1ValidRange","seq2ValidRange","shiftDiffToBetterPosition","swap","shiftSequenceDiffs","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","additional","lastModifiedWord","maybePushWordToAdditional","originalLength1","s1Range","deleted","s2Range","added","processWord","_c","_d","containsRange","s1Added","tryCreate","s2Added","changedS1","changedS2","w1Before","findWordContaining","w2Before","w1After","w2After","sequenceDiffs1","sequenceDiffs2","sd1","sd2","next","shift","mergeSequenceDiffs","_sequence2","shouldRepeat","lastResult","before","after","unchangedRange","replace","shouldJoinDiffs","countLinesIn","unchangedText","split","beforeLineCount1","beforeSeq1Length","beforeLineCount2","beforeSeq2Length","afterLineCount1","afterSeq1Length","afterLineCount2","afterSeq2Length","cap","pow","newDiffs","forEachWithNeighbors","newDiff","shouldMarkAsChanged","fullRange1","extendToFullLines","prefix","suffix","availableSpace","lineRangeMapping","LegacyLinesDiffComputer","DiffComputer","maxComputationTime","shouldIgnoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","computeDiff","lastChange","originalEndLineNumber","originalStartLineNumber","modifiedEndLineNumber","modifiedStartLineNumber","charChanges","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","pop","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","len","substring","index","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","col","CharSequence","_charCodes","_lineNumbers","_columns","Error","getEndLineNumber","_assertIndex","getStartLineNumber","getEndColumn","getStartColumn","CharChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","LineChange","originalLineSequence","modifiedLineSequence","continueCharDiff","createCharSequence","getElements","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","postProcessCharChanges","createFromDiffChange","opts","continueLineDiff","createContinueProcessingPredicate","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","strings","maximumRuntime","linesDiffComputers","getLegacy","getDefault","toString","originalLineCount","modifiedLineCount","lastOriginalEndLineNumber","lastModifiedEndLineNumber","_LineRangeMapping","_inherits","_super","_createSuper","call","flip","InternalEditorAction","id","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","contextMatchesRules","args","isSupported","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","nls","focus","textInputFocus","readOnly","inDiffEditor","isEmbeddedDiffEditor","comparingMovedCode","accessibleDiffViewerVisible","diffEditorRenderSideBySideInlineBreakpointReached","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","hoverFocused","stickyScrollFocused","stickyScrollVisible","standaloneColorPickerVisible","standaloneColorPickerFocused","inCompositeEditor","notInCompositeEditor","languageId","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","editorFeatures","registerEditorFeature","ctor","getEditorFeatures","EditorTheme","theme","_theme","type","color","getColor"],"sourceRoot":""}