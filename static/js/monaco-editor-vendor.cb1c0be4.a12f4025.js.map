{"version":3,"file":"static/js/monaco-editor-vendor.cb1c0be4.a12f4025.js","mappings":"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","sources":["../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languageSelector.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/autoIndent.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/enterAction.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/language.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/languages/textToHtmlTokenizer.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","../node_modules/@uiw/react-monacoeditor/node_modules/monaco-editor/esm/vs/editor/common/modelLineProjectionData.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* MetadataConsts.LANGUAGEID_MASK */) >>> 0 /* MetadataConsts.LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 768 /* MetadataConsts.TOKEN_TYPE_MASK */) >>> 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */;\n    }\n    static containsBalancedBrackets(metadata) {\n        return (metadata & 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 30720 /* MetadataConsts.FONT_STYLE_MASK */) >>> 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 16744448 /* MetadataConsts.FOREGROUND_MASK */) >>> 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4278190080 /* MetadataConsts.BACKGROUND_MASK */) >>> 24 /* MetadataConsts.BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        const fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            className += ' mtku';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            className += ' mtks';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            result += 'font-weight: bold;';\n        }\n        let textDecoration = '';\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            textDecoration += ' underline';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            textDecoration += ' line-through';\n        }\n        if (textDecoration) {\n            result += `text-decoration:${textDecoration};`;\n        }\n        return result;\n    }\n    static getPresentationFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */),\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { match as matchGlobPattern } from '../../base/common/glob.js';\nimport { normalize } from '../../base/common/path.js';\nexport function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector; // TODO: microsoft/TypeScript#42768\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        // selector targets a notebook -> use the notebook uri instead\n        // of the \"normal\" document uri.\n        if (notebookType && candidateNotebookUri) {\n            candidateUri = candidateNotebookUri;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (notebookType) {\n            if (notebookType === candidateNotebookType) {\n                ret = 10;\n            }\n            else if (notebookType === '*' && candidateNotebookType !== undefined) {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                // Since this pattern has a `base` property, we need\n                // to normalize this path first before passing it on\n                // because we will compare it against `Uri.fsPath`\n                // which uses platform specific separators.\n                // Refs: https://github.com/microsoft/vscode/issues/99938\n                normalizedPattern = Object.assign(Object.assign({}, pattern), { base: normalize(pattern.base) });\n            }\n            if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nclass MatchCandidate {\n    constructor(uri, languageId, notebookUri, notebookType) {\n        this.uri = uri;\n        this.languageId = languageId;\n        this.notebookUri = notebookUri;\n        this.notebookType = notebookType;\n    }\n    equals(other) {\n        var _a, _b;\n        return this.notebookType === other.notebookType\n            && this.languageId === other.languageId\n            && this.uri.toString() === other.uri.toString()\n            && ((_a = this.notebookUri) === null || _a === void 0 ? void 0 : _a.toString()) === ((_b = other.notebookUri) === null || _b === void 0 ? void 0 : _b.toString());\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor(_notebookInfoResolver) {\n        this._notebookInfoResolver = _notebookInfoResolver;\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model);\n        const result = [];\n        // from registry\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model) {\n        const result = [];\n        this._orderedForEach(model, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, callback) {\n        this._updateScores(model);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model) {\n        var _a, _b;\n        const notebookInfo = (_a = this._notebookInfoResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);\n        // use the uri (scheme, pattern) of the notebook info iff we have one\n        // otherwise it's the model's/document's uri\n        const candidate = notebookInfo\n            ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type)\n            : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined);\n        if ((_b = this._lastCandidate) === null || _b === void 0 ? void 0 : _b.equals(candidate)) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (const entry of this._entries) {\n            entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                // support for one exclusive selector that overwrites\n                // any other selector\n                for (const entry of this._entries) {\n                    entry._score = 0;\n                }\n                entry._score = 1000;\n                break;\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        else if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Codicon } from '../../base/common/codicons.js';\nimport { URI } from '../../base/common/uri.js';\nimport { Range } from './core/range.js';\nimport { TokenizationRegistry as TokenizationRegistryImpl } from './tokenizationRegistry.js';\nexport class Token {\n    constructor(offset, type, language) {\n        this.offset = offset;\n        this.type = type;\n        this.language = language;\n        this._tokenBrand = undefined;\n    }\n    toString() {\n        return '(' + this.offset + ', ' + this.type + ')';\n    }\n}\n/**\n * @internal\n */\nexport class TokenizationResult {\n    constructor(tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._tokenizationResultBrand = undefined;\n    }\n}\n/**\n * @internal\n */\nexport class EncodedTokenizationResult {\n    constructor(\n    /**\n     * The tokens in binary format. Each token occupies two array indices. For token i:\n     *  - at offset 2*i => startIndex\n     *  - at offset 2*i + 1 => metadata\n     *\n     */\n    tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._encodedTokenizationResultBrand = undefined;\n    }\n}\n/**\n * @internal\n */\nexport var CompletionItemKinds;\n(function (CompletionItemKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* CompletionItemKind.Method */, Codicon.symbolMethod);\n    byKind.set(1 /* CompletionItemKind.Function */, Codicon.symbolFunction);\n    byKind.set(2 /* CompletionItemKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(3 /* CompletionItemKind.Field */, Codicon.symbolField);\n    byKind.set(4 /* CompletionItemKind.Variable */, Codicon.symbolVariable);\n    byKind.set(5 /* CompletionItemKind.Class */, Codicon.symbolClass);\n    byKind.set(6 /* CompletionItemKind.Struct */, Codicon.symbolStruct);\n    byKind.set(7 /* CompletionItemKind.Interface */, Codicon.symbolInterface);\n    byKind.set(8 /* CompletionItemKind.Module */, Codicon.symbolModule);\n    byKind.set(9 /* CompletionItemKind.Property */, Codicon.symbolProperty);\n    byKind.set(10 /* CompletionItemKind.Event */, Codicon.symbolEvent);\n    byKind.set(11 /* CompletionItemKind.Operator */, Codicon.symbolOperator);\n    byKind.set(12 /* CompletionItemKind.Unit */, Codicon.symbolUnit);\n    byKind.set(13 /* CompletionItemKind.Value */, Codicon.symbolValue);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(14 /* CompletionItemKind.Constant */, Codicon.symbolConstant);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(16 /* CompletionItemKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(17 /* CompletionItemKind.Keyword */, Codicon.symbolKeyword);\n    byKind.set(27 /* CompletionItemKind.Snippet */, Codicon.symbolSnippet);\n    byKind.set(18 /* CompletionItemKind.Text */, Codicon.symbolText);\n    byKind.set(19 /* CompletionItemKind.Color */, Codicon.symbolColor);\n    byKind.set(20 /* CompletionItemKind.File */, Codicon.symbolFile);\n    byKind.set(21 /* CompletionItemKind.Reference */, Codicon.symbolReference);\n    byKind.set(22 /* CompletionItemKind.Customcolor */, Codicon.symbolCustomColor);\n    byKind.set(23 /* CompletionItemKind.Folder */, Codicon.symbolFolder);\n    byKind.set(24 /* CompletionItemKind.TypeParameter */, Codicon.symbolTypeParameter);\n    byKind.set(25 /* CompletionItemKind.User */, Codicon.account);\n    byKind.set(26 /* CompletionItemKind.Issue */, Codicon.issues);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let codicon = byKind.get(kind);\n        if (!codicon) {\n            console.info('No codicon found for CompletionItemKind ' + kind);\n            codicon = Codicon.symbolProperty;\n        }\n        return codicon;\n    }\n    CompletionItemKinds.toIcon = toIcon;\n    const data = new Map();\n    data.set('method', 0 /* CompletionItemKind.Method */);\n    data.set('function', 1 /* CompletionItemKind.Function */);\n    data.set('constructor', 2 /* CompletionItemKind.Constructor */);\n    data.set('field', 3 /* CompletionItemKind.Field */);\n    data.set('variable', 4 /* CompletionItemKind.Variable */);\n    data.set('class', 5 /* CompletionItemKind.Class */);\n    data.set('struct', 6 /* CompletionItemKind.Struct */);\n    data.set('interface', 7 /* CompletionItemKind.Interface */);\n    data.set('module', 8 /* CompletionItemKind.Module */);\n    data.set('property', 9 /* CompletionItemKind.Property */);\n    data.set('event', 10 /* CompletionItemKind.Event */);\n    data.set('operator', 11 /* CompletionItemKind.Operator */);\n    data.set('unit', 12 /* CompletionItemKind.Unit */);\n    data.set('value', 13 /* CompletionItemKind.Value */);\n    data.set('constant', 14 /* CompletionItemKind.Constant */);\n    data.set('enum', 15 /* CompletionItemKind.Enum */);\n    data.set('enum-member', 16 /* CompletionItemKind.EnumMember */);\n    data.set('enumMember', 16 /* CompletionItemKind.EnumMember */);\n    data.set('keyword', 17 /* CompletionItemKind.Keyword */);\n    data.set('snippet', 27 /* CompletionItemKind.Snippet */);\n    data.set('text', 18 /* CompletionItemKind.Text */);\n    data.set('color', 19 /* CompletionItemKind.Color */);\n    data.set('file', 20 /* CompletionItemKind.File */);\n    data.set('reference', 21 /* CompletionItemKind.Reference */);\n    data.set('customcolor', 22 /* CompletionItemKind.Customcolor */);\n    data.set('folder', 23 /* CompletionItemKind.Folder */);\n    data.set('type-parameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('typeParameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('account', 25 /* CompletionItemKind.User */);\n    data.set('issue', 26 /* CompletionItemKind.Issue */);\n    /**\n     * @internal\n     */\n    function fromString(value, strict) {\n        let res = data.get(value);\n        if (typeof res === 'undefined' && !strict) {\n            res = 9 /* CompletionItemKind.Property */;\n        }\n        return res;\n    }\n    CompletionItemKinds.fromString = fromString;\n})(CompletionItemKinds || (CompletionItemKinds = {}));\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport var SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * @internal\n */\nexport function isLocationLink(thing) {\n    return thing\n        && URI.isUri(thing.uri)\n        && Range.isIRange(thing.range)\n        && (Range.isIRange(thing.originSelectionRange) || Range.isIRange(thing.targetSelectionRange));\n}\n/**\n * @internal\n */\nexport var SymbolKinds;\n(function (SymbolKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* SymbolKind.File */, Codicon.symbolFile);\n    byKind.set(1 /* SymbolKind.Module */, Codicon.symbolModule);\n    byKind.set(2 /* SymbolKind.Namespace */, Codicon.symbolNamespace);\n    byKind.set(3 /* SymbolKind.Package */, Codicon.symbolPackage);\n    byKind.set(4 /* SymbolKind.Class */, Codicon.symbolClass);\n    byKind.set(5 /* SymbolKind.Method */, Codicon.symbolMethod);\n    byKind.set(6 /* SymbolKind.Property */, Codicon.symbolProperty);\n    byKind.set(7 /* SymbolKind.Field */, Codicon.symbolField);\n    byKind.set(8 /* SymbolKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(9 /* SymbolKind.Enum */, Codicon.symbolEnum);\n    byKind.set(10 /* SymbolKind.Interface */, Codicon.symbolInterface);\n    byKind.set(11 /* SymbolKind.Function */, Codicon.symbolFunction);\n    byKind.set(12 /* SymbolKind.Variable */, Codicon.symbolVariable);\n    byKind.set(13 /* SymbolKind.Constant */, Codicon.symbolConstant);\n    byKind.set(14 /* SymbolKind.String */, Codicon.symbolString);\n    byKind.set(15 /* SymbolKind.Number */, Codicon.symbolNumber);\n    byKind.set(16 /* SymbolKind.Boolean */, Codicon.symbolBoolean);\n    byKind.set(17 /* SymbolKind.Array */, Codicon.symbolArray);\n    byKind.set(18 /* SymbolKind.Object */, Codicon.symbolObject);\n    byKind.set(19 /* SymbolKind.Key */, Codicon.symbolKey);\n    byKind.set(20 /* SymbolKind.Null */, Codicon.symbolNull);\n    byKind.set(21 /* SymbolKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(22 /* SymbolKind.Struct */, Codicon.symbolStruct);\n    byKind.set(23 /* SymbolKind.Event */, Codicon.symbolEvent);\n    byKind.set(24 /* SymbolKind.Operator */, Codicon.symbolOperator);\n    byKind.set(25 /* SymbolKind.TypeParameter */, Codicon.symbolTypeParameter);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let icon = byKind.get(kind);\n        if (!icon) {\n            console.info('No codicon found for SymbolKind ' + kind);\n            icon = Codicon.symbolProperty;\n        }\n        return icon;\n    }\n    SymbolKinds.toIcon = toIcon;\n})(SymbolKinds || (SymbolKinds = {}));\nclass FoldingRangeKind {\n    /**\n     * Returns a {@link FoldingRangeKind} for the given value.\n     *\n     * @param value of the kind.\n     */\n    static fromValue(value) {\n        switch (value) {\n            case 'comment': return FoldingRangeKind.Comment;\n            case 'imports': return FoldingRangeKind.Imports;\n            case 'region': return FoldingRangeKind.Region;\n        }\n        return new FoldingRangeKind(value);\n    }\n    /**\n     * Creates a new {@link FoldingRangeKind}.\n     *\n     * @param value of the kind.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Kind for folding range representing a comment. The value of the kind is 'comment'.\n */\nFoldingRangeKind.Comment = new FoldingRangeKind('comment');\n/**\n * Kind for folding range representing a import. The value of the kind is 'imports'.\n */\nFoldingRangeKind.Imports = new FoldingRangeKind('imports');\n/**\n * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\n * The value of the kind is 'region'.\n */\nFoldingRangeKind.Region = new FoldingRangeKind('region');\nexport { FoldingRangeKind };\n/**\n * @internal\n */\nexport var Command;\n(function (Command) {\n    /**\n     * @internal\n     */\n    function is(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return false;\n        }\n        return typeof obj.id === 'string' &&\n            typeof obj.title === 'string';\n    }\n    Command.is = is;\n})(Command || (Command = {}));\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\n/**\n * @internal\n */\nexport const TokenizationRegistry = new TokenizationRegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { getScopedLineTokens } from './languageConfigurationRegistry.js';\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n    const languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n    if (lineNumber > 1) {\n        let lastLineNumber;\n        let resultLineNumber = -1;\n        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n            if (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n                return resultLineNumber;\n            }\n            const text = model.getLineContent(lastLineNumber);\n            if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                resultLineNumber = lastLineNumber;\n                continue;\n            }\n            return lastLineNumber;\n        }\n    }\n    return -1;\n}\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber <= 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    // Use no indent if this is the first non-blank line\n    for (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n        if (model.getLineContent(priorLineNumber) !== '') {\n            break;\n        }\n        if (priorLineNumber === 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n    }\n    const precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n    if (precedingUnIgnoredLine < 0) {\n        return null;\n    }\n    else if (precedingUnIgnoredLine < 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: IndentAction.Indent,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: null,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else {\n        // precedingUnIgnoredLine can not be ignored.\n        // it doesn't increase indent of following lines\n        // it doesn't increase just next line\n        // so current line is not affect by precedingUnIgnoredLine\n        // and then we should get a correct inheritted indentation from above lines\n        if (precedingUnIgnoredLine === 1) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        const previousLine = precedingUnIgnoredLine - 1;\n        const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n        if (!(previousLineIndentMetadata & (1 /* IndentConsts.INCREASE_MASK */ | 2 /* IndentConsts.DECREASE_MASK */)) &&\n            (previousLineIndentMetadata & 4 /* IndentConsts.INDENT_NEXTLINE_MASK */)) {\n            let stopLine = 0;\n            for (let i = previousLine - 1; i > 0; i--) {\n                if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                    continue;\n                }\n                stopLine = i;\n                break;\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                action: null,\n                line: stopLine + 1\n            };\n        }\n        if (honorIntentialIndent) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n            for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                const lineContent = model.getLineContent(i);\n                if (indentRulesSupport.shouldIncrease(lineContent)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(lineContent),\n                        action: IndentAction.Indent,\n                        line: i\n                    };\n                }\n                else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                    let stopLine = 0;\n                    for (let j = i - 1; j > 0; j--) {\n                        if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                            continue;\n                        }\n                        stopLine = j;\n                        break;\n                    }\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                        action: null,\n                        line: stopLine + 1\n                    };\n                }\n                else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(lineContent),\n                        action: null,\n                        line: i\n                    };\n                }\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                action: null,\n                line: 1\n            };\n        }\n    }\n}\nexport function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n    const lineContent = virtualModel.getLineContent(lineNumber);\n    if (indent) {\n        const inheritLine = indent.line;\n        if (inheritLine !== undefined) {\n            // Apply enter action as long as there are only whitespace lines between inherited line and this line.\n            let shouldApplyEnterRules = true;\n            for (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n                if (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n                    shouldApplyEnterRules = false;\n                    break;\n                }\n            }\n            if (shouldApplyEnterRules) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n        }\n        if (indentRulesSupport.shouldDecrease(lineContent)) {\n            if (indent.action === IndentAction.Indent) {\n                return indent.indentation;\n            }\n            else {\n                return indentConverter.unshiftIndent(indent.indentation);\n            }\n        }\n        else {\n            if (indent.action === IndentAction.Indent) {\n                return indentConverter.shiftIndent(indent.indentation);\n            }\n            else {\n                return indent.indentation;\n            }\n        }\n    }\n    return null;\n}\nexport function getIndentForEnter(autoIndent, model, range, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    model.tokenization.forceTokenization(range.startLineNumber);\n    const lineTokens = model.tokenization.getLineTokens(range.startLineNumber);\n    const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n    const scopedLineText = scopedLineTokens.getLineContent();\n    let embeddedLanguage = false;\n    let beforeEnterText;\n    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n        // we are in the embeded language content\n        embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n        beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n    }\n    let afterEnterText;\n    if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const beforeEnterResult = beforeEnterText;\n    const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n    const virtualModel = {\n        tokenization: {\n            getLineTokens: (lineNumber) => {\n                return model.tokenization.getLineTokens(lineNumber);\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n        },\n        getLineContent: (lineNumber) => {\n            if (lineNumber === range.startLineNumber) {\n                return beforeEnterResult;\n            }\n            else {\n                return model.getLineContent(lineNumber);\n            }\n        }\n    };\n    const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n    const afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n    if (!afterEnterAction) {\n        const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n        return {\n            beforeEnter: beforeEnter,\n            afterEnter: beforeEnter\n        };\n    }\n    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n    if (afterEnterAction.action === IndentAction.Indent) {\n        afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n    if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n        afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n    return {\n        beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n        afterEnter: afterEnterIndent\n    };\n}\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(autoIndent, model, range, ch, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    if (scopedLineTokens.firstCharOffset) {\n        // this line has mixed languages and indentation rules will not work\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterTypeText;\n    if (range.isEmpty()) {\n        afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n        // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n        // 1. Get inherited indent action\n        const r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n        if (!r) {\n            return null;\n        }\n        let indentation = r.indentation;\n        if (r.action !== IndentAction.Indent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n        }\n        return indentation;\n    }\n    return null;\n}\nexport function getIndentMetadata(model, lineNumber, languageConfigurationService) {\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n        return null;\n    }\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IndentAction } from './languageConfiguration.js';\nimport { getIndentationAtPosition, getScopedLineTokens } from './languageConfigurationRegistry.js';\nexport function getEnterAction(autoIndent, model, range, languageConfigurationService) {\n    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterEnterText;\n    if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    let previousLineText = '';\n    if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n        // This is not the first line and the entire line belongs to this mode\n        const oneLineAboveScopedLineTokens = getScopedLineTokens(model, range.startLineNumber - 1);\n        if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n            // The line above ends with text belonging to the same mode\n            previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n        }\n    }\n    const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    if (!enterResult) {\n        return null;\n    }\n    const indentAction = enterResult.indentAction;\n    let appendText = enterResult.appendText;\n    const removeText = enterResult.removeText || 0;\n    // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n    if (!appendText) {\n        if ((indentAction === IndentAction.Indent) ||\n            (indentAction === IndentAction.IndentOutdent)) {\n            appendText = '\\t';\n        }\n        else {\n            appendText = '';\n        }\n    }\n    else if (indentAction === IndentAction.Indent) {\n        appendText = '\\t' + appendText;\n    }\n    let indentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    if (removeText) {\n        indentation = indentation.substring(0, indentation.length - removeText);\n    }\n    return {\n        indentAction: indentAction,\n        appendText: appendText,\n        removeText: removeText,\n        indentation: indentation\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageService = createDecorator('languageService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nclass CharacterPairSupport {\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t';\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t';\nexport { CharacterPairSupport };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nexport function getScopedLineTokens(model, lineNumber, columnNumber) {\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n    return createScopedLineTokens(lineTokens, column);\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nclass Uint8Matrix {\n    constructor(rows, cols, defaultValue) {\n        const data = new Uint8Array(rows * cols);\n        for (let i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    get(row, col) {\n        return this._data[row * this.cols + col];\n    }\n    set(row, col, value) {\n        this._data[row * this.cols + col] = value;\n    }\n}\nexport class StateMachine {\n    constructor(edges) {\n        let maxCharCode = 0;\n        let maxState = 0 /* State.Invalid */;\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* State.Invalid */);\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    nextState(currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* State.Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    }\n}\n// State machine for http:// or https:// or file://\nlet _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* State.Start */, 104 /* CharCode.h */, 2 /* State.H */],\n            [1 /* State.Start */, 72 /* CharCode.H */, 2 /* State.H */],\n            [1 /* State.Start */, 102 /* CharCode.f */, 6 /* State.F */],\n            [1 /* State.Start */, 70 /* CharCode.F */, 6 /* State.F */],\n            [2 /* State.H */, 116 /* CharCode.t */, 3 /* State.HT */],\n            [2 /* State.H */, 84 /* CharCode.T */, 3 /* State.HT */],\n            [3 /* State.HT */, 116 /* CharCode.t */, 4 /* State.HTT */],\n            [3 /* State.HT */, 84 /* CharCode.T */, 4 /* State.HTT */],\n            [4 /* State.HTT */, 112 /* CharCode.p */, 5 /* State.HTTP */],\n            [4 /* State.HTT */, 80 /* CharCode.P */, 5 /* State.HTTP */],\n            [5 /* State.HTTP */, 115 /* CharCode.s */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 83 /* CharCode.S */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [6 /* State.F */, 105 /* CharCode.i */, 7 /* State.FI */],\n            [6 /* State.F */, 73 /* CharCode.I */, 7 /* State.FI */],\n            [7 /* State.FI */, 108 /* CharCode.l */, 8 /* State.FIL */],\n            [7 /* State.FI */, 76 /* CharCode.L */, 8 /* State.FIL */],\n            [8 /* State.FIL */, 101 /* CharCode.e */, 9 /* State.BeforeColon */],\n            [8 /* State.FIL */, 69 /* CharCode.E */, 9 /* State.BeforeColon */],\n            [9 /* State.BeforeColon */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [10 /* State.AfterColon */, 47 /* CharCode.Slash */, 11 /* State.AlmostThere */],\n            [11 /* State.AlmostThere */, 47 /* CharCode.Slash */, 12 /* State.End */],\n        ]);\n    }\n    return _stateMachine;\n}\nlet _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new CharacterClassifier(0 /* CharacterClass.None */);\n        // allow-any-unicode-next-line\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"';\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* CharacterClass.ForceTermination */);\n        }\n        const CANNOT_END_WITH_CHARACTERS = '.,;:';\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CharacterClass.CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nexport class LinkComputer {\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        let lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\n            const chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CharacterClass.CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* CharCode.OpenParen */ && lastCharCodeInLink === 41 /* CharCode.CloseParen */)\n                || (charCodeBeforeLink === 91 /* CharCode.OpenSquareBracket */ && lastCharCodeInLink === 93 /* CharCode.CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* CharCode.OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CharCode.CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    }\n    static computeLinks(model, stateMachine = getStateMachine()) {\n        const classifier = getClassifier();\n        const result = [];\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            const line = model.getLineContent(i);\n            const len = line.length;\n            let j = 0;\n            let linkBeginIndex = 0;\n            let linkBeginChCode = 0;\n            let state = 1 /* State.Start */;\n            let hasOpenParens = false;\n            let hasOpenSquareBracket = false;\n            let inSquareBrackets = false;\n            let hasOpenCurlyBracket = false;\n            while (j < len) {\n                let resetStateMachine = false;\n                const chCode = line.charCodeAt(j);\n                if (state === 13 /* State.Accept */) {\n                    let chClass;\n                    switch (chCode) {\n                        case 40 /* CharCode.OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 41 /* CharCode.CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 91 /* CharCode.OpenSquareBracket */:\n                            inSquareBrackets = true;\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 93 /* CharCode.CloseSquareBracket */:\n                            inSquareBrackets = false;\n                            chClass = (hasOpenSquareBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 123 /* CharCode.OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 125 /* CharCode.CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        // The following three rules make it that ' or \" or ` are allowed inside links\n                        // only if the link is wrapped by some other quote character\n                        case 39 /* CharCode.SingleQuote */:\n                        case 34 /* CharCode.DoubleQuote */:\n                        case 96 /* CharCode.BackTick */:\n                            if (linkBeginChCode === chCode) {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            else if (linkBeginChCode === 39 /* CharCode.SingleQuote */ || linkBeginChCode === 34 /* CharCode.DoubleQuote */ || linkBeginChCode === 96 /* CharCode.BackTick */) {\n                                chClass = 0 /* CharacterClass.None */;\n                            }\n                            else {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            break;\n                        case 42 /* CharCode.Asterisk */:\n                            // `*` terminates a link if the link began with `*`\n                            chClass = (linkBeginChCode === 42 /* CharCode.Asterisk */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 124 /* CharCode.Pipe */:\n                            // `|` terminates a link if the link began with `|`\n                            chClass = (linkBeginChCode === 124 /* CharCode.Pipe */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 32 /* CharCode.Space */:\n                            // ` ` allow space in between [ and ]\n                            chClass = (inSquareBrackets ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* State.End */) {\n                    let chClass;\n                    if (chCode === 91 /* CharCode.OpenSquareBracket */) {\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                        hasOpenSquareBracket = true;\n                        chClass = 0 /* CharacterClass.None */;\n                    }\n                    else {\n                        chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* State.Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* State.Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* State.Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* State.Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    }\n}\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Extensions as ConfigurationExtensions } from '../../../platform/configuration/common/configurationRegistry.js';\n// Define extension point ids\nexport const Extensions = {\n    ModesRegistry: 'editor.modesRegistry'\n};\nexport class EditorModesRegistry {\n    constructor() {\n        this._onDidChangeLanguages = new Emitter();\n        this.onDidChangeLanguages = this._onDidChangeLanguages.event;\n        this._languages = [];\n    }\n    registerLanguage(def) {\n        this._languages.push(def);\n        this._onDidChangeLanguages.fire(undefined);\n        return {\n            dispose: () => {\n                for (let i = 0, len = this._languages.length; i < len; i++) {\n                    if (this._languages[i] === def) {\n                        this._languages.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    getLanguages() {\n        return this._languages;\n    }\n}\nexport const ModesRegistry = new EditorModesRegistry();\nRegistry.add(Extensions.ModesRegistry, ModesRegistry);\nexport const PLAINTEXT_LANGUAGE_ID = 'plaintext';\nexport const PLAINTEXT_EXTENSION = '.txt';\nModesRegistry.registerLanguage({\n    id: PLAINTEXT_LANGUAGE_ID,\n    extensions: [PLAINTEXT_EXTENSION],\n    aliases: [nls.localize('plainText.alias', \"Plain Text\"), 'text'],\n    mimetypes: [Mimes.text]\n});\nRegistry.as(ConfigurationExtensions.Configuration)\n    .registerDefaultConfigurations([{\n        overrides: {\n            '[plaintext]': {\n                'editor.unicodeHighlight.ambiguousCharacters': false,\n                'editor.unicodeHighlight.invisibleCharacters': false\n            }\n        }\n    }]);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            const result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            const result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        const numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        const n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\nexport { BasicInplaceReplace };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* FontStyle.None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* FontStyle.None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (const color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* StandardTokenType.Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* StandardTokenType.Comment */;\n        case 'string':\n            return 2 /* StandardTokenType.String */;\n        case 'regex':\n            return 3 /* StandardTokenType.RegEx */;\n        case 'regexp':\n            return 3 /* StandardTokenType.RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* ColorId.None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* ColorId.None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullTokenize.js';\nconst fallback = {\n    getInitialState: () => NullState,\n    tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* LanguageId.Null */, state)\n};\nexport function tokenizeToString(languageService, text, languageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!languageId) {\n            return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n        }\n        const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);\n        return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n    });\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    let prevIsSpace = true;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* CharCode.Tab */: {\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        if (useNbsp && prevIsSpace) {\n                            partContent += '&#160;';\n                            prevIsSpace = false;\n                        }\n                        else {\n                            partContent += ' ';\n                            prevIsSpace = true;\n                        }\n                        insertSpacesCount--;\n                    }\n                    break;\n                }\n                case 60 /* CharCode.LessThan */:\n                    partContent += '&lt;';\n                    prevIsSpace = false;\n                    break;\n                case 62 /* CharCode.GreaterThan */:\n                    partContent += '&gt;';\n                    prevIsSpace = false;\n                    break;\n                case 38 /* CharCode.Ampersand */:\n                    partContent += '&amp;';\n                    prevIsSpace = false;\n                    break;\n                case 0 /* CharCode.Null */:\n                    partContent += '&#00;';\n                    prevIsSpace = false;\n                    break;\n                case 65279 /* CharCode.UTF8_BOM */:\n                case 8232 /* CharCode.LINE_SEPARATOR */:\n                case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                case 133 /* CharCode.NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    prevIsSpace = false;\n                    break;\n                case 13 /* CharCode.CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    prevIsSpace = false;\n                    break;\n                case 32 /* CharCode.Space */:\n                    if (useNbsp && prevIsSpace) {\n                        partContent += '&#160;';\n                        prevIsSpace = false;\n                    }\n                    else {\n                        partContent += ' ';\n                        prevIsSpace = true;\n                    }\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n                    prevIsSpace = false;\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    const lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n        const viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../base/common/objects.js';\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport var OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\n/**\n * Position in the minimap to render the decoration.\n */\nexport var MinimapPosition;\n(function (MinimapPosition) {\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {}));\nexport var InjectedTextCursorStops;\n(function (InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nexport class TextModelResolvedOptions {\n    get originalIndentSize() {\n        return this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\n    }\n    /**\n     * @internal\n     */\n    constructor(src) {\n        this._textModelResolvedOptionsBrand = undefined;\n        this.tabSize = Math.max(1, src.tabSize | 0);\n        if (src.indentSize === 'tabSize') {\n            this.indentSize = this.tabSize;\n            this._indentSizeIsTabSize = true;\n        }\n        else {\n            this.indentSize = Math.max(1, src.indentSize | 0);\n            this._indentSizeIsTabSize = false;\n        }\n        this.insertSpaces = Boolean(src.insertSpaces);\n        this.defaultEOL = src.defaultEOL | 0;\n        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.tabSize === other.tabSize\n            && this._indentSizeIsTabSize === other._indentSizeIsTabSize\n            && this.indentSize === other.indentSize\n            && this.insertSpaces === other.insertSpaces\n            && this.defaultEOL === other.defaultEOL\n            && this.trimAutoWhitespace === other.trimAutoWhitespace\n            && equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));\n    }\n    /**\n     * @internal\n     */\n    createChangeEvent(newOpts) {\n        return {\n            tabSize: this.tabSize !== newOpts.tabSize,\n            indentSize: this.indentSize !== newOpts.indentSize,\n            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n        };\n    }\n}\nexport class FindMatch {\n    /**\n     * @internal\n     */\n    constructor(range, matches) {\n        this._findMatchBrand = undefined;\n        this.range = range;\n        this.matches = matches;\n    }\n}\n/**\n * @internal\n */\nexport function isITextSnapshot(obj) {\n    return (obj && typeof obj.read === 'function');\n}\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation {\n    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {\n        this.identifier = identifier;\n        this.range = range;\n        this.text = text;\n        this.forceMoveMarkers = forceMoveMarkers;\n        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;\n        this._isTracked = _isTracked;\n    }\n}\n/**\n * @internal\n */\nexport class SearchData {\n    constructor(regex, wordSeparators, simpleSearch) {\n        this.regex = regex;\n        this.wordSeparators = wordSeparators;\n        this.simpleSearch = simpleSearch;\n    }\n}\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {\n        this.reverseEdits = reverseEdits;\n        this.changes = changes;\n        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;\n    }\n}\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model) {\n    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthLessThanEqual, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    // s0: State before any edits\n    const firstMap = new ArrayQueue(toTextMap(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const secondMap = toTextMap(textEditInfoSecond);\n    // s2: State after both edits\n    // If set, we are in an edit\n    let remainingS0Length = undefined;\n    let remainingS1Length = lengthZero;\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function readPartialS0Map(s1Length) {\n        const result = [];\n        while (true) {\n            if ((remainingS0Length !== undefined && !lengthIsZero(remainingS0Length)) || !lengthIsZero(remainingS1Length)) {\n                let readS1Length;\n                if (s1Length !== undefined && lengthLessThanEqual(s1Length, remainingS1Length)) {\n                    // remaining satisfies request\n                    readS1Length = s1Length;\n                    remainingS1Length = lengthDiffNonNegative(s1Length, remainingS1Length);\n                    s1Length = lengthZero;\n                }\n                else {\n                    // Read all of remaining, potentially even more\n                    readS1Length = remainingS1Length;\n                    if (s1Length !== undefined) {\n                        s1Length = lengthDiffNonNegative(remainingS1Length, s1Length);\n                    }\n                    remainingS1Length = lengthZero;\n                }\n                if (remainingS0Length === undefined) {\n                    // unchanged area\n                    result.push({\n                        oldLength: readS1Length,\n                        newLength: undefined\n                    });\n                }\n                else {\n                    // We eagerly consume all of the old length, even if\n                    // we are in an edit and only consume it partially.\n                    result.push({\n                        oldLength: remainingS0Length,\n                        newLength: readS1Length\n                    });\n                    remainingS0Length = lengthZero;\n                }\n            }\n            if (s1Length !== undefined && lengthIsZero(s1Length)) {\n                break;\n            }\n            const item = firstMap.dequeue();\n            if (!item) {\n                if (s1Length !== undefined) {\n                    result.push({\n                        oldLength: s1Length,\n                        newLength: undefined,\n                    });\n                }\n                break;\n            }\n            if (item.newLength === undefined) {\n                remainingS1Length = item.oldLength;\n                remainingS0Length = undefined;\n            }\n            else {\n                remainingS0Length = item.oldLength;\n                remainingS1Length = item.newLength;\n            }\n        }\n        return result;\n    }\n    const result = [];\n    function push(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s2 of secondMap) {\n        const s0ToS1Map = readPartialS0Map(s2.oldLength);\n        if (s2.newLength !== undefined) {\n            // This is an edit\n            const s0Length = sumLengths(s0ToS1Map, s => s.oldLength);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            push(s0offset, s0EndOffset, s2.newLength);\n            s0offset = s0EndOffset;\n        }\n        else {\n            // We are in an unchanged area\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.oldLength);\n                if (s1.newLength !== undefined) {\n                    push(s0startOffset, s0offset, s1.newLength);\n                }\n            }\n        }\n    }\n    const s0ToS1Map = readPartialS0Map(undefined);\n    for (const s1 of s0ToS1Map) {\n        const s0startOffset = s0offset;\n        s0offset = lengthAdd(s0offset, s1.oldLength);\n        if (s1.newLength !== undefined) {\n            push(s0startOffset, s0offset, s1.newLength);\n        }\n    }\n    return result;\n}\nfunction toTextMap(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push({ oldLength: spaceLength });\n        }\n        const oldLength = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push({ oldLength, newLength: textEditInfo.newLength });\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthOfString, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        // Must be sorted in ascending order\n        const edits = change.changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    var _a;\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.bracketPairsTree.clear();\n                this.updateBracketPairsTree();\n            }\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range, onlyColorizedBrackets)) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthToObj, toLength } from './length.js';\nexport class TextEditInfo {\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\n/**\n * Represents a non-negative length in terms of line and column count.\n * Prefer using {@link Length} for performance reasons.\n*/\nclass LengthObj {\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\nLengthObj.zero = new LengthObj(0, 0);\nexport { LengthObj };\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = Math.pow(2, 26);\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new LengthObj(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty());\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nclass SmallImmutableSet {\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport { SmallImmutableSet };\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageAgnosticBracketTokens } from './bracketPairsTree/brackets.js';\nimport { lengthAdd, lengthGetColumnCountIfZeroLineCount, lengthZero } from './bracketPairsTree/length.js';\nimport { parseDocument } from './bracketPairsTree/parser.js';\nimport { DenseKeyProvider } from './bracketPairsTree/smallImmutableSet.js';\nimport { TextBufferTokenizer } from './bracketPairsTree/tokenizer.js';\nexport function fixBracketsInLine(tokens, languageConfigurationService) {\n    const denseKeyProvider = new DenseKeyProvider();\n    const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));\n    const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);\n    const node = parseDocument(tokenizer, [], undefined, true);\n    let str = '';\n    const line = tokens.getLineContent();\n    function processNode(node, offset) {\n        if (node.kind === 2 /* AstNodeKind.Pair */) {\n            processNode(node.openingBracket, offset);\n            offset = lengthAdd(offset, node.openingBracket.length);\n            if (node.child) {\n                processNode(node.child, offset);\n                offset = lengthAdd(offset, node.child.length);\n            }\n            if (node.closingBracket) {\n                processNode(node.closingBracket, offset);\n                offset = lengthAdd(offset, node.closingBracket.length);\n            }\n            else {\n                const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node.openingBracket.languageId);\n                const closingTokenText = singleLangBracketTokens.findClosingTokenText(node.openingBracket.bracketIds);\n                str += closingTokenText;\n            }\n        }\n        else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n            // remove the bracket\n        }\n        else if (node.kind === 0 /* AstNodeKind.Text */ || node.kind === 1 /* AstNodeKind.Bracket */) {\n            str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node.length)));\n        }\n        else if (node.kind === 4 /* AstNodeKind.List */) {\n            for (const child of node.children) {\n                processNode(child, offset);\n                offset = lengthAdd(offset, child.length);\n            }\n        }\n    }\n    processNode(node, lengthZero);\n    return str;\n}\nclass StaticTokenizerSource {\n    constructor(lines) {\n        this.lines = lines;\n        this.tokenization = {\n            getLineTokens: (lineNumber) => {\n                return this.lines[lineNumber - 1];\n            }\n        };\n    }\n    getLineCount() {\n        return this.lines.length;\n    }\n    getLineLength(lineNumber) {\n        return this.lines[lineNumber - 1].getLineContent().length;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arrays.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        var _a;\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* PositionAffinity.None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* PositionAffinity.None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* PositionAffinity.Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* PositionAffinity.Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* PositionAffinity.None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n"],"names":["TokenMetadata","_classCallCheck","_createClass","key","value","metadata","className","this","getForeground","fontStyle","getFontStyle","colorMap","foreground","result","concat","textDecoration","italic","Boolean","bold","underline","strikethrough","score","selector","candidateUri","candidateLanguage","candidateIsSynchronized","candidateNotebookUri","candidateNotebookType","Array","isArray","_step","ret","_iterator","_createForOfIteratorHelper","s","n","done","err","e","f","language","pattern","scheme","hasAccessToAllModels","notebookType","Math","max","undefined","normalizedPattern","Object","assign","base","normalize","fsPath","matchGlobPattern","isExclusive","every","exclusive","MatchCandidate","uri","languageId","notebookUri","other","_a","_b","toString","LanguageFeatureRegistry","_notebookInfoResolver","_clock","_entries","_onDidChange","Emitter","onDidChange","event","provider","_this","entry","_score","_time","push","_lastCandidate","fire","length","toDisposable","idx","indexOf","splice","model","all","_updateScores","_orderedForEach","lastBucket","lastBucketScore","callback","_step2","_iterator2","notebookInfo","call","candidate","getLanguageId","type","equals","_step3","_iterator3","shouldSynchronizeModel","_step4","_iterator4","sort","_compareByScoreAndTime","a","b","CompletionItemKinds","InlineCompletionTriggerKind","SignatureHelpTriggerKind","DocumentHighlightKind","SymbolKinds","Token","offset","_tokenBrand","TokenizationResult","tokens","endState","_tokenizationResultBrand","EncodedTokenizationResult","_encodedTokenizationResultBrand","isLocationLink","thing","URI","isUri","Range","isIRange","range","originSelectionRange","targetSelectionRange","byKind","Map","set","Codicon","symbolMethod","symbolFunction","symbolConstructor","symbolField","symbolVariable","symbolClass","symbolStruct","symbolInterface","symbolModule","symbolProperty","symbolEvent","symbolOperator","symbolUnit","symbolValue","symbolEnum","symbolConstant","symbolEnumMember","symbolKeyword","symbolSnippet","symbolText","symbolColor","symbolFile","symbolReference","symbolCustomColor","symbolFolder","symbolTypeParameter","account","issues","toIcon","kind","codicon","get","console","info","data","fromString","strict","res","symbolNamespace","symbolPackage","symbolString","symbolNumber","symbolBoolean","symbolArray","symbolObject","symbolKey","symbolNull","icon","Command","InlayHintKind","FoldingRangeKind","Comment","Imports","Region","is","obj","id","title","TokenizationRegistry","TokenizationRegistryImpl","getInheritIndentForLine","autoIndent","lineNumber","honorIntentialIndent","arguments","indentRulesSupport","getLanguageConfiguration","tokenization","indentation","action","priorLineNumber","getLineContent","precedingUnIgnoredLine","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","text","shouldIgnore","test","getPrecedingValidLine","precedingUnIgnoredLineContent","shouldIncrease","shouldIndentNextLine","strings","IndentAction","Indent","line","shouldDecrease","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","i","lineContent","j","getGoodIndentForLine","virtualModel","indentConverter","languageConfigurationService","richEditSupport","indent","inheritLine","shouldApplyEnterRules","inBetweenLine","enterResult","onEnter","removeText","substring","indentAction","IndentOutdent","shiftIndent","Outdent","unshiftIndent","appendText","getIndentForEnter","forceTokenization","startLineNumber","beforeEnterText","afterEnterText","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","startColumn","scopedLineText","embeddedLanguage","firstCharOffset","substr","isEmpty","getScopedLineTokens","endLineNumber","endColumn","beforeEnterResult","beforeEnterIndent","column","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","getIndentActionForType","ch","afterTypeText","beforeTypeText","r","getLineCount","getEnterAction","previousLineText","oneLineAboveScopedLineTokens","getIndentationAtPosition","ILanguageService","createDecorator","StandardAutoClosingPairConditional","source","_neutralCharacter","_neutralCharacterSearched","open","close","_inString","_inComment","_inRegEx","notIn","len","standardToken","context","getTokenCount","tokenIndex","findTokenIndexAtOffset","standardTokenType","getStandardTokenType","isOK","fromCharCode","toCharCode","charCode","character","String","includes","_findNeutralCharacterInRange","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","charAt","target","has","CharacterPairSupport","config","_autoClosingPairs","map","el","brackets","__electricCharacterSupport","docComment","_autoCloseBeforeForQuotes","autoCloseBefore","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES","_autoCloseBeforeForBrackets","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS","_surroundingPairs","surroundingPairs","forQuotes","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","bracket","lastChar","distinct","ignoreBracketsInToken","reversedBracketRegex","reversedRegex","BracketsUtils","findPrevBracketInRange","bracketText","toLowerCase","textIsOpenBracket","textBeforeBracket","getActualLineContentBefore","matchOpenBracket","resetGlobalRegex","reg","global","lastIndex","IndentRulesSupport","indentationRules","_indentationRules","increaseIndentPattern","decreaseIndentPattern","indentNextLinePattern","unIndentedLinePattern","OnEnterSupport","opts","_brackets","forEach","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","rule","beforeText","afterText","str","_safeRegExp","def","RegExp","onUnexpectedError","LanguageBracketsConfiguration","bracketPairs","filterValidBrackets","openingBracketInfos","CachedFunction","closing","Set","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","_step$value","_slicedToArray","add","colorizedBracketPairs","filter","p","_step2$value","_openingBrackets","_toConsumableArray","cachedValues","_ref","_ref2","_closingBrackets","_ref3","_ref4","values","getOpeningBracketInfo","getClosingBracketInfo","_ref5","_ref6","BracketKindBase","_BracketKindBase","_inherits","_super","_createSuper","openedBrackets","_this2","isOpeningBracket","_BracketKindBase2","_super2","openingBrackets","openingColorizedBrackets","_this3","__decorate","decorators","desc","d","c","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","LanguageConfigurationServiceChangeEvent","ILanguageConfigurationService","LanguageConfigurationService","_Disposable","configurationService","languageService","_registry","_register","LanguageConfigurationRegistry","onDidChangeEmitter","configurations","languageConfigKeys","customizedLanguageConfigKeys","onDidChangeConfiguration","globalConfigChanged","change","keys","some","k","localConfigChanged","overrides","clear","isRegisteredLanguageId","delete","configuration","priority","register","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","getValue","overrideIdentifier","validateBracketPairs","getCustomizedLanguageConfig","combineLanguageConfigurations","underlyingConfig","computeConfig","Disposable","IConfigurationService","lineText","columnNumber","getLineMaxColumn","ComposedLanguageConfiguration","_resolved","_order","LanguageConfigurationContribution","_resolve","cmp","configs","comments","wordPattern","folding","order","LanguageConfigurationChangeEvent","_Disposable2","PLAINTEXT_LANGUAGE_ID","offSide","_this4","entries","disposable","dispose","getResolvedConfiguration","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","DEFAULT_WORD_REGEXP","foldingRules","bracketsNew","ensureValidWordDefinition","RichEditBrackets","getAutoClosingPairs","getAutoCloseBeforeSet","getSurroundingPairs","conf","commentRule","lineComment","lineCommentToken","blockComment","_commentRule$blockCom","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","registerSingleton","Uint8Matrix","rows","cols","defaultValue","Uint8Array","_data","row","col","StateMachine","edges","maxCharCode","maxState","_edges$i","from","chCode","to","states","_edges$_i","_states","_maxCharCode","currentState","_stateMachine","_classifier","LinkComputer","classifier","linkBeginIndex","linkEndIndex","lastIncludedCharIndex","charCodeAt","charCodeBeforeLink","lastCharCodeInLink","url","stateMachine","CharacterClassifier","FORCE_TERMINATION_CHARACTERS","CANNOT_END_WITH_CHARACTERS","getClassifier","lineCount","linkBeginChCode","state","hasOpenParens","hasOpenSquareBracket","inSquareBrackets","hasOpenCurlyBracket","resetStateMachine","chClass","_createLink","nextState","computeLinks","ModesRegistry","EditorModesRegistry","_onDidChangeLanguages","onDidChangeLanguages","_languages","Registry","registerLanguage","extensions","aliases","nls","mimetypes","Mimes","as","ConfigurationExtensions","Configuration","registerDefaultConfigurations","NullState","_class","nullTokenize","nullTokenizeEncoded","Uint32Array","tokenCount","getCount","desiredLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","getStartOffset","getEndOffset","actual","lastCharOffset","_scopedLineTokensBrand","_actual","_firstTokenIndex","_lastTokenIndex","_lastCharOffset","BasicInplaceReplace","_defaultValueSet","range1","text1","range2","text2","up","doNavigateValueSet","numberResult","numberReplace","textReplace","precision","pow","lastIndexOf","n1","Number","n2","parseFloat","isNaN","floor","valueSetsReplace","valueSets","valueSetReplace","valueSet","INSTANCE","RichEditBracket","index","forwardRegex","_richEditBracketBrand","_openSet","_toSet","_closeSet","arr","element","_richEditBracketsBrand","N","group","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","min","oldG","g","currentOpen","currentClose","_brackets$_i","groupFuzzyBrackets","currentIndex","pieces","collectSuperstrings","unique","lengthcmp","reverse","createBracketOrRegExp","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","_step8","_iterator8","_step9","_iterator9","_step10","_iterator10","getRegexForBrackets","_step11","_iterator11","_step12","_iterator12","_step13","_iterator13","getReversedRegexForBrackets","textIsBracket","maxBracketLength","dest","_step5","_iterator5","_step6","_iterator6","_step7","seen","_iterator7","prepareBracketForRegExp","insertWordBoundaries","regexStr","join","lastInput","lastOutput","Uint16Array","stringBuilder","decode","reversedText","m","match","matchOffset","matchLength","absoluteMatchOffset","startOffset","endOffset","reversedSubstr","_findPrevBracketInText","bracketRegex","findNextBracketInText","ParsedTokenThemeRule","token","background","_parsedThemeRuleBrand","resolveParsedTokenThemeRules","parsedThemeRules","customTokenColors","strcmp","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","shift","ColorMap","color","getId","foregroundColorId","backgroundColorId","defaults","ThemeTrieElementRule","root","ThemeTrieElement","insert","TokenTheme","colorRegExp","_lastColorId","_id2color","_color2id","Error","toUpperCase","Color","fromHex","slice","_colorMap","_root","_cache","getColorMap","_match","tokenType","STANDARD_TOKEN_TYPE_REGEXP","toStandardTokenType","createFromParsedTokenTheme","resultLen","segments","split","lenJ","parseTokenTheme","_themeTrieElementRuleBrand","_fontStyle","_foreground","_background","mainRule","_themeTrieElementBrand","_mainRule","_children","head","tail","dotIndex","child","clone","acceptOverwrite","generateTokensCSSForColorMap","rules","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","then","apply","fallback","getInitialState","tokenizeEncoded","buffer","hasEOL","tokenizeToString","_regeneratorRuntime","mark","_callee","tokenizationSupport","wrap","_context","prev","abrupt","_tokenizeToString","languageIdCodec","getOrCreate","sent","stop","tokenizeLineToHTML","viewLineTokens","tabSize","useNbsp","charIndex","tabsCharDelta","prevIsSpace","tokenEndIndex","partContent","insertSpacesCount","getInlineStyle","lines","tokenizationResult","LineTokens","convertToEndOffset","inflate","getClassName","endIndex","OverviewRulerLane","MinimapPosition","InjectedTextCursorStops","TextModelResolvedOptions","src","_textModelResolvedOptionsBrand","indentSize","_indentSizeIsTabSize","insertSpaces","defaultEOL","trimAutoWhitespace","bracketPairColorizationOptions","newOpts","FindMatch","matches","_findMatchBrand","isITextSnapshot","read","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","SearchData","regex","wordSeparators","simpleSearch","ApplyEditsResult","reverseEdits","changes","trimAutoWhitespaceLineNumbers","isTooLargeForSyncing","isForSimpleWidget","combineTextEditInfos","textEditInfoFirst","textEditInfoSecond","firstMap","ArrayQueue","toTextMap","secondMap","remainingS0Length","remainingS1Length","lengthZero","readPartialS0Map","s1Length","lengthIsZero","readS1Length","lengthLessThanEqual","lengthDiffNonNegative","oldLength","newLength","item","dequeue","lengthEquals","lastResult","TextEditInfo","lengthAdd","s0offset","s2","s0ToS1Map","s0Length","sumLengths","s0EndOffset","s1","s0startOffset","textEditInfos","lastOffset","textEditInfo","spaceLength","BracketPairsTree","textModel","didChangeEmitter","denseKeyProvider","DenseKeyProvider","LanguageAgnosticBracketTokens","queuedTextEditsForInitialAstWithoutTokens","queuedTextEdits","hasTokens","backgroundTokenizationState","initialAstWithoutTokens","astWithTokens","parseDocumentFromTextBuffer","getSingleLanguageBracketTokens","tokenizer","FastTokenizer","parseDocument","didLanguageChange","wasUndefined","edits","ranges","toLength","fromLineNumber","toLineNumber","handleEdits","lift","positionToLength","getStartPosition","getEndPosition","lengthOfString","tokenChange","previousAst","immutable","previousAstClone","TextBufferTokenizer","onlyColorizedBrackets","flushQueue","CallbackIterable","cb","node","collectBrackets","includeMinIndentation","startLength","endLength","CollectBracketPairsContext","collectBracketPairs","position","getFirstBracketAfter","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","lengths","children","_lengths$i","lengthLessThan","lengthsToRange","bracketInfo","level","nestingLevelOfEqualBracketType","levelPerBracketType","parentPairIsIncomplete","whileLoop","childCount","childrenLength","getChild","lengthGreaterThanEqual","colorize","closingBracket","closesColorized","openingBracket","levelPerBracket","existing","BracketInfo","shouldContinue","openingBracketEnd","minIndentation","computeMinIndentation","BracketPairWithMinIndentationInfo","curOffset","childOffset","BracketPairsTextModelPart","bracketPairsTree","MutableDisposable","bracketsRequested","object","updateBracketPairsTree","getValueLength","handleContentChanged","handleDidChangeBackgroundTokenizationState","handleDidChangeTokens","canBuildAST","store","DisposableStore","getBracketPairsInRange","empty","getBracketsInRange","_bracket","_position","maxDuration","validatePosition","closingBracketInfo","bracketPair","fromPositions","findLast","closes","openingBracketInfo","openingBracketRange","bracketsSupport","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","closingBracketRange","containsPosition","findLastMaxBy","compareBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","modeBrackets","currentLanguageId","searchStartOffset","tokenEndOffset","searchEndOffset","tokenStartOffset","currentModeBrackets","_this$_establishBrack","_establishBracketSearchOffsets","bestResult","foundBracket","findNextBracketInRange","foundBracketText","_matchFoundBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","_this$_establishBrack2","isOpen","matched","_findMatchingBracketDown","count","totalCallCount","searchPrevMatchingBracketInRange","hitText","isClose","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","bracketConfig","tokenLanguageId","_toFoundBracket","strictContainsRange","savedCounts","counts","resetCounts","tmp","searchInRange","getValueInRange","getBracketInfo","startTime","Date","now","_searchCanceledBrand","BaseAstNode","_length","PairAstNode","_BaseAstNode","missingOpeningBracketIds","openBracketIds","intersects","deepClone","MAX_SAFE_INTEGER","SmallImmutableSet","getEmpty","ListAstNode","_BaseAstNode2","listHeight","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","lastChild","mutable","toMutable","setChild","firstChild","lastLength","BugIndicatingError","canBeReused","unopenedBrackets","merge","item1","item2","item3","missingBracketIds","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_ListAstNode","_super3","_item1","_item2","_item3","handleChildrenChanged","_TwoThreeListAstNode","_super4","ArrayListAstNode","_ListAstNode2","_super5","pop","unshift","_ArrayListAstNode","_super6","emptyArray","ImmutableLeafAstNode","_BaseAstNode3","_super7","TextAstNode","_ImmutableLeafAstNode","_super8","_openedBracketIds","start","lengthToObj","columnCount","lengthGetLineCount","firstNonWsColumn","getLineFirstNonWhitespaceColumn","visibleColumn","CursorColumns","visibleColumnFromColumn","getOptions","BracketAstNode","_ImmutableLeafAstNode2","_super9","bracketIds","_this5","InvalidBracketAstNode","_ImmutableLeafAstNode3","_super10","closingBrackets","_this6","openedBracketIds","BeforeEditPositionMapper","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","edit","TextEditInfoCache","adjustNextEdit","translateCurToOld","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","oldOffsetObj","newOffset","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength","BracketTokens","hasRegExp","_regExpGlobal","escaped","escapeRegExpCharacters","regExpStr","getRegExpStr","openingBracketIds","closingText","size","getKey","openingTextId","identityKeyProvider","create","getOpeningBrackets","languageIdToBracketTokens","singleLanguageBracketTokens","createFromLanguage","LengthObj","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","zero","factor","l","lengthGetColumnCountIfZeroLineCount","l1","l2","items","lengthFn","reduce","length1","length2","lineCount1","lineCount2","colCount2","lengthStart","lengthEnd","colCount","splitLines","concat23TreesOfSameHeight","createImmutableLists","create23","heightDiff","node1","node2","abs","list","nodeToAppend","nodeToAppendOfCorrectHeight","curNode","parents","makeLastElementMutable","parent","unappendChild","appendChildOfSameHeight","append","makeFirstElementMutable","nodeToPrependOfCorrectHeight","unprependChild","prependChildOfSameHeight","prepend","NodeReader","nextNodes","offsets","idxs","predicate","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","tryReadChildFromCache","peek","parseChild","readNode","height","first","second","concat23Trees","maxCacheableLength","getDistanceToNextChange","cachedNode","readLongestNodeAt","getOffsetBeforeChange","skip","astNode","nextToken","bracketId","emptyArr","additionalItems","keyProvider","newItem","newItems","merged","cached","cache","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","textBufferLastLineLength","getLineLength","setPosition","lineIdx","lineCharOffset","lineTokenOffset","peekedToken","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","getMetadata","isOther","getTokenType","containsBracketType","containsBalancedBrackets","regexp","regExpGlobal","exec","getToken","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","NotSupportedError","ColorizedBracketPairsDecorationProvider","colorProvider","ColorProvider","colorizationOptions","ownerId","filterOutValidation","onlyMinimapDecorations","enabled","nestingLevel","options","description","inlineClassName","getInlineClassName","independentColorPoolPerBracketType","toArray","getDecorationsInRange","unexpectedClosingBracketClassName","isInvalid","getInlineClassNameOfLevel","registerThemingParticipant","theme","collector","colors","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","addRule","getColor","editorBracketHighlightingUnexpectedBracketForeground","colorValues","isTransparent","fixBracketsInLine","StaticTokenizerSource","processNode","closingTokenText","findClosingTokenText","uriGetComparisonKey","resource","SingleModelEditStackData","beforeVersionId","afterVersionId","beforeEOL","afterEOL","beforeCursorState","afterCursorState","textChanges","compressConsecutiveTextChanges","necessarySize","_writeSelectionsSize","writeSize","_writeSelections","write","alternativeVersionId","getAlternativeVersionId","eol","getModelEOL","selections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","Selection","_readSelections","changeCount","TextChange","SingleModelEditStackElement","label","code","deserialize","serialize","_applyUndo","_applyRedo","byteLength","MultiModelEditStackElement","editStackElements","_isOpen","_editStackElementsArr","_editStackElementsMap","editStackElement","_delegate","prepareUndoRedo","setModel","canAppend","undo","redo","heapSize","basename","getEOL","isEditStackElement","EditStack","undoRedoService","_model","_undoRedoService","lastElement","getLastElement","removeElements","newElement","pushElement","_getOrCreateEditStackElement","setEOL","editOperations","cursorStateComputer","inverseEditOperations","applyEdits","_computeCursorState","op","textChange","oldPosition","GuidesTextModelPart","_TextModelPart","lineIndex","computeIndentLevel","minLineNumber","maxLineNumber","assertNotDisposed","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","_computeIndentLevel","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","activePosition","getBracketPairsInRangeWithMinIndentation","activeBracketPairRange","bracketsContainingActivePosition","bp","strictContainsPosition","BracketPairGuidesClassNames","isActive","equalsRange","includeInactive","highlightActive","activeClassName","end","horizontalGuides","HorizontalGuidesState","Enabled","EnabledForActive","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","IndentGuide","IndentGuideHorizontalLine","_i","_result","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","TextModelPart","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","getLineCharCode","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","left","right","delta","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","versionId","collapseOnReplaceEdit","absoluteStart","absoluteEnd","SENTINEL","IntervalTree","requestNormalizeDelta","filterOwnerId","T","intervalStart","intervalEnd","nodeStart","nodeEnd","setCachedOffsets","include","intervalSearch","search","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","initialNode","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","x","zAbsoluteStart","zAbsoluteEnd","intervalCompare","treeInsert","recomputeMaxEndWalkToRoot","y","leftRotate","rightRotate","leftest","detach","resetSentinel","w","yWasRed","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","ModelLineProjectionData","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","outputLineIndex","lineLength","outputOffset","offsetInInput","content","inputOffset","affinity","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","low","high","mid","midStart","midStop","OutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","getMinOutputOffset","getMaxOutputOffset","getOutputLineCount","injectedText","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","assertNever","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","cursorStop","Right","Both","Left","baseLineNumber","Position"],"sourceRoot":""}