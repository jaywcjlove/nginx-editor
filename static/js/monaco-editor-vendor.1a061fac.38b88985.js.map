{"version":3,"file":"static/js/monaco-editor-vendor.1a061fac.38b88985.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js","../node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","../node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","../node_modules/monaco-editor/esm/vs/editor/common/model/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\nexport class MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    get version() {\n        return this._versionId;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        const insertLines = splitLines(insertText);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        const newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\nexport class PrefixSumComputer {\n    constructor(values) {\n        this.values = values;\n        this.prefixSum = new Uint32Array(values.length);\n        this.prefixSumValidIndex = new Int32Array(1);\n        this.prefixSumValidIndex[0] = -1;\n    }\n    insertValues(insertIndex, insertValues) {\n        insertIndex = toUint32(insertIndex);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        const insertValuesLen = insertValues.length;\n        if (insertValuesLen === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n        this.values.set(insertValues, insertIndex);\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = insertIndex - 1;\n        }\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    setValue(index, value) {\n        index = toUint32(index);\n        value = toUint32(value);\n        if (this.values[index] === value) {\n            return false;\n        }\n        this.values[index] = value;\n        if (index - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = index - 1;\n        }\n        return true;\n    }\n    removeValues(startIndex, count) {\n        startIndex = toUint32(startIndex);\n        count = toUint32(count);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        if (startIndex >= oldValues.length) {\n            return false;\n        }\n        const maxCount = oldValues.length - startIndex;\n        if (count >= maxCount) {\n            count = maxCount;\n        }\n        if (count === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length - count);\n        this.values.set(oldValues.subarray(0, startIndex), 0);\n        this.values.set(oldValues.subarray(startIndex + count), startIndex);\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = startIndex - 1;\n        }\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    getTotalSum() {\n        if (this.values.length === 0) {\n            return 0;\n        }\n        return this._getPrefixSum(this.values.length - 1);\n    }\n    /**\n     * Returns the sum of the first `index + 1` many items.\n     * @returns `SUM(0 <= j <= index, values[j])`.\n     */\n    getPrefixSum(index) {\n        if (index < 0) {\n            return 0;\n        }\n        index = toUint32(index);\n        return this._getPrefixSum(index);\n    }\n    _getPrefixSum(index) {\n        if (index <= this.prefixSumValidIndex[0]) {\n            return this.prefixSum[index];\n        }\n        let startIndex = this.prefixSumValidIndex[0] + 1;\n        if (startIndex === 0) {\n            this.prefixSum[0] = this.values[0];\n            startIndex++;\n        }\n        if (index >= this.values.length) {\n            index = this.values.length - 1;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n        }\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n        return this.prefixSum[index];\n    }\n    getIndexOf(sum) {\n        sum = Math.floor(sum);\n        // Compute all sums (to get a fully valid prefixSum)\n        this.getTotalSum();\n        let low = 0;\n        let high = this.values.length - 1;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStop = this.prefixSum[mid];\n            midStart = midStop - this.values[mid];\n            if (sum < midStart) {\n                high = mid - 1;\n            }\n            else if (sum >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new PrefixSumIndexOfResult(mid, sum - midStart);\n    }\n}\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nexport class ConstantTimePrefixSumComputer {\n    constructor(values) {\n        this._values = values;\n        this._isValid = false;\n        this._validEndIndex = -1;\n        this._prefixSum = [];\n        this._indexBySum = [];\n    }\n    /**\n     * @returns SUM(0 <= j < values.length, values[j])\n     */\n    getTotalSum() {\n        this._ensureValid();\n        return this._indexBySum.length;\n    }\n    /**\n     * Returns the sum of the first `count` many items.\n     * @returns `SUM(0 <= j < count, values[j])`.\n     */\n    getPrefixSum(count) {\n        this._ensureValid();\n        if (count === 0) {\n            return 0;\n        }\n        return this._prefixSum[count - 1];\n    }\n    /**\n     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n     */\n    getIndexOf(sum) {\n        this._ensureValid();\n        const idx = this._indexBySum[sum];\n        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n    }\n    removeValues(start, deleteCount) {\n        this._values.splice(start, deleteCount);\n        this._invalidate(start);\n    }\n    insertValues(insertIndex, insertArr) {\n        this._values = arrayInsert(this._values, insertIndex, insertArr);\n        this._invalidate(insertIndex);\n    }\n    _invalidate(index) {\n        this._isValid = false;\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n    _ensureValid() {\n        if (this._isValid) {\n            return;\n        }\n        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n            const value = this._values[i];\n            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n            this._prefixSum[i] = sumAbove + value;\n            for (let j = 0; j < value; j++) {\n                this._indexBySum[sumAbove + j] = i;\n            }\n        }\n        // trim things\n        this._prefixSum.length = this._values.length;\n        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n        // mark as valid\n        this._isValid = true;\n        this._validEndIndex = this._values.length - 1;\n    }\n    setValue(index, value) {\n        if (this._values[index] === value) {\n            // no change\n            return;\n        }\n        this._values[index] = value;\n        this._invalidate(index);\n    }\n}\nexport class PrefixSumIndexOfResult {\n    constructor(index, remainder) {\n        this.index = index;\n        this.remainder = remainder;\n        this._prefixSumIndexOfResultBrand = undefined;\n        this.index = index;\n        this.remainder = remainder;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        var _a;\n        const firstInvalidLine = (_a = this._tokenizerWithStateStore) === null || _a === void 0 ? void 0 : _a.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = TextModel_1 = class TextModel extends Disposable {\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n            // Delete + Insert due to an overview ruler status change\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB,  // used in tests\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; // 256M characters, usually ~> 512MB memory usage\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService)\n], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        var _a;\n        this.position = (_a = options === null || options === void 0 ? void 0 : options.position) !== null && _a !== void 0 ? _a : model.GlyphMarginLane.Left;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f;\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = (_a = options.blockDoesNotCollapse) !== null && _a !== void 0 ? _a : null;\n        this.blockIsAfterEnd = (_b = options.blockIsAfterEnd) !== null && _b !== void 0 ? _b : null;\n        this.blockPadding = (_c = options.blockPadding) !== null && _c !== void 0 ? _c : null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = (_d = options.shouldFillLineOnLineBreak) !== null && _d !== void 0 ? _d : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = (_e = options.hideInCommentTokens) !== null && _e !== void 0 ? _e : false;\n        this.hideInStringTokens = (_f = options.hideInStringTokens) !== null && _f !== void 0 ? _f : false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        var _a;\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        if (!this._affectsMinimap) {\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n        }\n        if (!this._affectsOverviewRuler) {\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n        }\n        if (!this._affectsGlyphMargin) {\n            this._affectsGlyphMargin = options.glyphMarginClassName ? true : false;\n        }\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableMap, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nexport class TokenizationTextModelPart extends TextModelPart {\n    constructor(_languageService, _languageConfigurationService, _textModel, _bracketPairsTextModelPart, _languageId, _attachedViews) {\n        super();\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this.grammarTokens = this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        this._register(this.grammarTokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._register(this.grammarTokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this.grammarTokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this.grammarTokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this.grammarTokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this.grammarTokens.hasTokens;\n    }\n    resetTokenization() {\n        this.grammarTokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this.grammarTokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this.grammarTokens.forceTokenization(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this.grammarTokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this.grammarTokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this.grammarTokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this.grammarTokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this.grammarTokens.resetTokenization();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n}\nclass GrammarTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId, attachedViews) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        var _a;\n        this._tokens.flush();\n        (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    var _a;\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        (_a = this._tokenizer) === null || _a === void 0 ? void 0 : _a.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if ((tokenizationSupport === null || tokenizationSupport === void 0 ? void 0 : tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        var _a;\n                        (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        var _a;\n                        (_a = this._debugBackgroundStates) === null || _a === void 0 ? void 0 : _a.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        var _a;\n        (_a = this._defaultBackgroundTokenizer) === null || _a === void 0 ? void 0 : _a.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        var _a, _b, _c;\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            (_b = this._debugBackgroundStates) === null || _b === void 0 ? void 0 : _b.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            (_c = this._defaultBackgroundTokenizer) === null || _c === void 0 ? void 0 : _c.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        var _a, _b;\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                (_a = this._backgroundTokenizer.value) === null || _a === void 0 ? void 0 : _a.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 ? void 0 : _b.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        var _a, _b;\n        const builder = new ContiguousMultilineTokensBuilder();\n        (_a = this._tokenizer) === null || _a === void 0 ? void 0 : _a.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 ? void 0 : _b.checkFinished();\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n    getLineTokens(lineNumber) {\n        var _a;\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && ((_a = this._debugBackgroundTokenizer.value) === null || _a === void 0 ? void 0 : _a.reportMismatchingTokens)) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\nclass AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n"],"names":["MirrorTextModel","uri","lines","eol","versionId","_classCallCheck","this","_uri","_lines","_eol","_versionId","_lineStarts","_cachedTextValue","_createClass","key","value","length","get","join","e","_step","changes","_iterator","_createForOfIteratorHelper","s","n","done","change","_acceptDeleteRange","range","_acceptInsertText","Position","startLineNumber","startColumn","text","err","f","eolLength","linesLength","lineStartValues","Uint32Array","i","PrefixSumComputer","lineIndex","newValue","setValue","endLineNumber","_setLineText","substring","endColumn","splice","removeValues","position","insertText","insertLines","splitLines","lineNumber","column","newLengths","insertValues","values","prefixSum","prefixSumValidIndex","Int32Array","insertIndex","toUint32","oldValues","oldPrefixSum","insertValuesLen","set","subarray","index","startIndex","count","maxCount","_getPrefixSum","Math","max","sum","floor","getTotalSum","low","high","mid","midStop","midStart","PrefixSumIndexOfResult","ConstantTimePrefixSumComputer","_values","_isValid","_validEndIndex","_prefixSum","_indexBySum","_ensureValid","idx","viewLinesAbove","start","deleteCount","_invalidate","insertArr","arrayInsert","min","len","sumAbove","j","remainder","_prefixSumIndexOfResultBrand","undefined","TreeNode","piece","color","size_left","lf_left","parent","left","right","SENTINEL","leftest","node","righttest","calculateSize","calculateLF","lineFeedCnt","resetSentinel","leftRotate","tree","x","y","root","rightRotate","rbDelete","z","detach","yWasRed","recomputeTreeMetadata","newSizeLeft","newLFLeft","delta","lf_delta","updateTreeMetadata","w","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","arr","r","Uint16Array","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","str","readonly","arguments","rLength","chr","charCodeAt","Piece","bufferIndex","end","StringBuffer","buffer","PieceTreeSnapshot","BOM","_this","_pieces","_tree","_BOM","_index","iterate","push","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","offset","nodePos","nodeStartOffset","nodeStartLineNumber","nodePosition","shift","hasInvalidVal","tmp","newArr","entry","PieceTreeBase","chunks","eolNormalized","create","_buffers","_lastChangeBufferPos","line","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","_this2","averageBufferSize","tempChunk","tempChunkLen","getNodeContent","replace","newEOL","normalizeEOL","leftLen","getAccumulatedValue","lfCnt","originalOffset","out","getIndexOf","getOffsetAt","startPosition","nodeAt2","endPosition","getValueInRange2","getEOL","startOffset","offsetInBuffer","ret","next","substr","_this3","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLineRawContent","matchingNode","targetOffset","_getCharCode","getLineCount","getLength","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","resultLen","result","m","searchText","startOffsetInBuffer","_wordSeparators","reset","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","createFindMatch","Range","searchRange","Searcher","wordSeparators","regex","findMatchesInNode","currentNode","lineBreakCnt","nextLineStartOffset","getLineContent","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","textLength","lastMatchIndex","indexOf","isValidMatch","FindMatch","_this$nodeAt","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","validate","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","nodeCharCodeAt","newStart","startWithLF","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","prev","nPiece","newNode","adjustCarriageReturnFromNext","endOffset","previousCharOffset","cursor","nodes","lastChar","splitText","concat","slice","endIndex","endPos","newPiece","cache","get2","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","size_delta","newLength","originalStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","prevAccumualtedValue","offsetOfNode","newOffset","val","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","p","prevNode","PieceTreeTextBuffer","_Disposable","_inherits","_super","_createSuper","containsRTL","containsUnusualLineTerminators","call","_onDidChangeContent","_register","Emitter","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","preserveBOM","createSnapshot","getPositionAt","isEmpty","lineEnding","_getEndOfLine","getValueInRange","eolOffsetCompensation","desiredEOL","actualEOL","fromLineNumber","toLineNumber","lineContent","fromOffset","toOffset","strings","getValueLengthInRange","getLinesContent","getLineCharCode","getLineLength","Error","setEOL","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","mightContainRTL","mightContainUnusualLineTerminators","mightContainNonBasicASCII","canReduceOperations","operations","op","_isTracked","validatedRange","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","_countEOL","countEOL","_countEOL2","_slicedToArray","bufferEOL","sortIndex","identifier","rangeOffset","rangeLength","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","TextChange","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","prevContent","fire","ApplyEditsResult","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","_countEOL3","_countEOL4","_sortOpsDescending","delete","insert","contentChangeRange","findMatchesLineByLine","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","compareRangesUsingEnds","Disposable","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","defaultEOL","totalEOLCount","totalCRCount","_getEOL","newLineStart","textBuffer","disposable","PieceTreeTextBufferBuilder","_hasPreviousChar","_previousChar","_tmpLineStarts","chunk","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","createLineStarts","_finish","lastChunk","newLineStarts","TokenizerWithStateStoreAndTextModel","_TokenizerWithStateSt","tokenizationSupport","_textModel","_languageIdCodec","builder","languageId","getLanguageId","lineToTokenize","getFirstInvalidLine","safeTokenize","startState","add","tokens","store","setEndState","endState","character","lineStartState","getStartState","lineTokens","LineTokens","getCount","tokenIndex","findTokenIndexAtOffset","getStandardTokenType","newText","curLineContent","newLineContent","getLanguageIdAtPosition","firstInvalidLineNumber","getFirstInvalidEndStateLineNumberOrMax","heuristicTokens","updateTokensUntilLine","state","guessStartState","nonWhitespaceColumn","getLineFirstNonWhitespaceColumn","likelyRelevantLines","initialState","newNonWhitespaceIndex","getInitialState","reverse","_i","_likelyRelevantLines","TokenizerWithStateStore","TrackingTokenizationStateStore","_tokenizationStateStore","TokenizationStateStore","_invalidEndStatesLineNumbers","RangePriorityQueueImpl","addRange","OffsetRange","getEndState","BugIndicatingError","newLineCount","acceptChange","addRangeAndResize","endLineNumberExclusive","c","LineRange","getFirstInvalidEndStateLineNumber","Number","MAX_SAFE_INTEGER","_lineEndStates","FixedArray","oldState","equals","_ranges","findIndex","contains","endExclusive","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","map","toString","languageIdCodec","hasEOL","tokenizeEncoded","clone","onUnexpectedError","nullTokenizeEncoded","encodeLanguageId","convertToEndOffset","TextModel_1","DefaultBackgroundTokenizer","_tokenizerWithStateStore","_backgroundTokenStore","_isDisposed","_isScheduled","_beginBackgroundTokenization","isAttachedToEditor","_hasLinesToTokenize","runWhenIdle","deadline","_backgroundTokenizeWithDeadline","endTime","Date","now","timeRemaining","execute","_backgroundTokenizeForAtLeast1ms","setTimeout0","ContiguousMultilineTokensBuilder","sw","StopWatch","elapsed","_tokenizeOneInvalidLine","setTokens","finalize","checkFinished","allStatesValid","_a","firstInvalidLine","backgroundTokenizationFinished","invalidateEndStateRange","TokenizationTextModelPart","_TextModelPart","_languageService","_languageConfigurationService","_bracketPairsTextModelPart","_languageId","_attachedViews","_semanticTokens","SparseTokensStore","_onDidChangeLanguage","onDidChangeLanguage","event","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","grammarTokens","GrammarTokens","onDidChange","affects","_emitModelTokensChangedEvent","onDidChangeBackgroundTokenizationState","handleDidChangeBackgroundTokenizationState","isFlush","flush","isEolChange","acceptEdit","handleDidChangeContent","handleDidChangeAttached","validateLineNumber","syntacticTokens","getLineTokens","addSparseTokens","_isDisposing","handleDidChangeTokens","hasTokens","resetTokenization","backgroundTokenizationState","forceTokenization","isCheapToTokenize","tokenizeIfCheap","getTokenTypeIfInsertingCharacter","tokenizeLineWithEdit","isComplete","semanticTokensApplied","ranges","hasCompleteSemanticTokens","changedRange","validateRange","setPartial","_position","assertNotDisposed","validatePosition","_TokenizationTextMode","_findLanguageBoundaries","_TokenizationTextMode2","rbStartOffset","rbEndOffset","rightBiasedWord","getWordAtText","getLanguageConfiguration","getWordDefinition","_TokenizationTextMode3","_TokenizationTextMode4","lbStartOffset","lbEndOffset","leftBiasedWord","wordAtPosition","getWordAtPosition","word","source","oldLanguage","newLanguage","handleDidChangeLanguage","getStartOffset","tokenCount","getEndOffset","TextModelPart","_super2","attachedViews","_tokenizer","_defaultBackgroundTokenizer","_backgroundTokenizer","MutableDisposable","_tokens","ContiguousTokensStore","_debugBackgroundTokenizer","_backgroundTokenizationState","_onDidChangeBackgroundTokenizationState","_attachedViewStates","DisposableMap","TokenizationRegistry","changedLanguages","onDidChangeVisibleRanges","_ref","view","existing","AttachedViewHandler","refreshRanges","lineRanges","handleStateChange","deleteAndDispose","fireTokenChangeEvent","_debugBackgroundTokens","_debugBackgroundStates","_initializeTokenizati","isTooLargeForTokenization","initializeTokenization","_initializeTokenizati2","clear","firstInvalidEndStateLineNumber","createBackgroundTokenizer","backgroundTokenizerShouldOnlyVerifyTokens","handleChanges","setMultilineTokens","refreshAllVisibleLineTokens","_b","_c","_step2","_iterator2","acceptChanges","joinMany","_toConsumableArray","_ref2","_ref3","_step3","_iterator3","refreshRange","tokenizeHeuristically","changedTokens","_step4","_iterator4","requestTokens","lineText","getTokens","backgroundResult","reportMismatchingTokens","validatedPosition","_Disposable2","_super3","_refreshTokens","_this4","runner","RunOnceScheduler","update","_computedLineRanges","_lineRanges","visibleLineRanges","stabilized","cancel","schedule","__decorate","decorators","target","desc","d","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","createTextBuffer","acceptChunk","finish","createTextBufferFactory","model","snapshot","read","createTextBufferFactoryFromSnapshot","MODEL_ID","TextModelSnapshot","_source","_eos","resultCnt","resultLength","invalidFunc","TextModel","languageIdOrSelection","creationOptions","associatedResource","_undoRedoService","_onWillDispose","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","_onDidChangeInjectedText","_eventEmitter","DidChangeContentEmitter","_languageSelectionListener","_deltaDecorationCallCnt","AttachedViews","id","isForSimpleWidget","_associatedResource","URI","parse","_attachedEditorCount","_createTextBuffer","_buffer","_bufferDisposable","_options","resolveOptions","_setLanguage","_bracketPairs","BracketPairsTextModelPart","_assertThisInitialized","_guidesTextModelPart","GuidesTextModelPart","_decorationProvider","ColorizedBracketPairsDecorationProvider","_tokenizationTextModelPart","bufferLineCount","bufferTextLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForHeapOperation","LARGE_FILE_HEAP_OPERATION_THRESHOLD","_isTooLargeForSyncing","_MODEL_SYNC_LIMIT","_alternativeVersionId","_initialUndoRedoSnapshot","__isDisposing","_instanceId","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","EditStack","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","endDeferredEmit","requestRichLanguageFeatures","listener","slowEvent","contentChangedEvent","combinedDisposable","fastEvent","dispose","_get","_getPrototypeOf","prototype","emptyDisposedTextBuffer","None","rawChange","InternalModelContentChangeEvent","_assertNotDisposed","illegalArgument","_createTextBuffer2","_setValueFromTextBuffer","isUndoing","isRedoing","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","getLineMaxColumn","_increaseVersionId","_emitContentChangedEvent","ModelRawContentChangedEvent","ModelRawFlush","_createContentChanged2","getValue","_onBeforeEOLChange","_onAfterEOLChange","ModelRawEOLChanged","ensureAllNodesHaveRanges","allDecorations","collectNodesPostOrder","cachedAbsoluteStart","cachedAbsoluteEnd","cachedVersionId","recomputeMaxEnd","attachView","detachView","smallLineCharCount","longLineCharCount","lineLength","tabSize","indentSize","insertSpaces","_newOpts","originalIndentSize","trimAutoWhitespace","bracketPairColorizationOptions","bracketColorizationOptions","newOpts","createChangeEvent","handleDidChangeOptions","defaultInsertSpaces","defaultTabSize","guessedIndentation","guessIndentation","updateOptions","normalizeIndentation","selections","matches","findMatches","resetMightContainUnusualLineTerminators","pushEditOperations","rawPosition","_validatePosition","rawOffset","newAlternativeVersionId","newInitialUndoRedoSnapshot","isTooLargeForHeapOperation","fullModelRange","fullModelValue","getBOM","rawRange","getCharacterCountInRange","getLineLastNonWhitespaceColumn","linesCount","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","Selection","validationType","charCodeBefore","_lineNumber","_column","_isValidPosition","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","_isValidRange","candidate","rawSearchScope","isRegex","matchCase","searchRanges","Array","isArray","every","searchScope","isIRange","d1","d2","matchMapper","uniqueSearchRanges","reduce","curr","areIntersecting","plusRange","SearchParams","parseSearchRequest","TextModelSearch","rawSearchStart","searchStart","findNextMatch","findPreviousMatch","pushStackElement","popStackElement","pushEOL","rawOperation","_validateEditOperation","beforeCursorState","editOperations","cursorStateComputer","group","_pushEditOperations","_validateEditOperations","incomingEdits","editsAreNearCursors","sel","foundEditNearSel","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","charAt","trimRange","pushEditOperation","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","oldText","_applyUndoRedoEdits","_this5","oldPosition","oldEnd","applyEdits","_overwriteAlternativeVersionId","_this6","oldLineCount","acceptReplace","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","LineInjectedText","fromDecorations","injectedTextInEditedRangeQueue","ArrayQueue","_loop","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","ModelRawLineChanged","spliceStartLineNumber","ModelRawLinesDeleted","spliceLineNumber","injectedTexts","newLines","_loop2","takeWhile","ModelRawLinesInserted","reverseEdits","undo","canUndo","redo","canRedo","_this7","size","lineChangeEvents","from","_getInjectedTextInLine","ModelInjectedTextChangedEvent","ownerId","_changeDecorations","_this8","changeAccessor","addDecoration","options","_deltaDecorationsImpl","changeDecoration","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","getDecorationRange","newStickiness","TRACKED_RANGE_OPTIONS","_validateRangeRelaxedNoAllocations","setOptions","collectNodesFromOwner","decorationId","getNodeRange","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","onlyMarginDecorations","decorations","_getDecorationsInRange","pushMany","getDecorationsInRange","onlyMinimapDecorations","getAll","getAllInjectedText","filter","t","getAllDecorations","filterRange","filterOwnerId","getAllInInterval","getRangeAt","after","oldRange","recordLineAffectedByInjectedText","before","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","nodeIsInOverviewRuler","nodeRange","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","IntervalNode","newDecoration","tokenization","_this9","setLanguageId","getWordUntilPosition","affinity","indent","indentOfLine","detectIndentation","isNodeInOverviewRuler","isNodeInjectedText","DEFAULT_CREATION_OPTIONS","EDITOR_MODEL_DEFAULTS","IUndoRedoService","ILanguageService","ILanguageConfigurationService","_decorationsTree0","IntervalTree","_decorationsTree1","_injectedTextDecorationsTree","host","_intervalSearch","_ensureNodesHaveRanges","r0","intervalSearch","r1","r2","showIfCollapsed","search","overviewRulerOnly","_search","_resolveNode","resolveNode","cleanClassName","className","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_DecorationOptions","_this10","_resolvedColor","Center","theme","type","_resolveColor","getColor","ModelDecorationGlyphMarginOptions","Left","ModelDecorationMinimapOptions","_DecorationOptions2","_this11","Color","fromHex","ModelDecorationInjectedTextOptions","content","inlineClassName","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","_d","_e","_f","description","blockClassName","blockDoesNotCollapse","blockIsAfterEnd","blockPadding","stickiness","zIndex","shouldFillLineOnLineBreak","hoverMessage","glyphMarginHoverMessage","isWholeLine","collapseOnReplaceEdit","minimap","glyphMargin","glyphMarginClassName","linesDecorationsClassName","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","register","createDynamic","_super4","handleBeforeFire","_this12","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFireDeferred","_affectsMinimap","_affectsOverviewRuler","_affectsGlyphMargin","doFire","Set","tryFire","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","_Disposable3","_super5","_this13","_fastEmitter","_slowEmitter","_deferredEvent","rawContentChangedEvent","merge","_onDidChangeVisibleRanges","_views","_this14","AttachedViewImpl","visibleLines","apply","multiline","chCode","nextChCode","isMultilineRegexSource","wholeWord","global","unicode","canUseSimpleSearch","toLowerCase","toUpperCase","SearchData","getMapForWordSeparators","rawMatches","LineFeedCounter","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","searchParams","_doFindMatchesMultiline","_doFindMatchesLineByLine","lfCounter","matchIndex","match0","lineFeedCountBeforeMatch","findLineFeedCountBeforeOffset","lineFeedCountInMatch","counter","_getMultilineMatchRange","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","_findFirstMatchInLine","fromColumn","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","bestResult","matchStartIndex","matchLength","charBefore","firstCharInMatch","leftIsWordBounday","charAfter","lastCharInMatch","rightIsWordBounday","searchRegex","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec","computeIndentLevel"],"sourceRoot":""}