{"version":3,"file":"static/js/monaco-editor-vendor.1a061fac.a81fc22a.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js","../node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","../node_modules/monaco-editor/esm/vs/editor/common/model/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\nexport class MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    get version() {\n        return this._versionId;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        const insertLines = splitLines(insertText);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        const newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\nexport class PrefixSumComputer {\n    constructor(values) {\n        this.values = values;\n        this.prefixSum = new Uint32Array(values.length);\n        this.prefixSumValidIndex = new Int32Array(1);\n        this.prefixSumValidIndex[0] = -1;\n    }\n    insertValues(insertIndex, insertValues) {\n        insertIndex = toUint32(insertIndex);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        const insertValuesLen = insertValues.length;\n        if (insertValuesLen === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n        this.values.set(insertValues, insertIndex);\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = insertIndex - 1;\n        }\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    setValue(index, value) {\n        index = toUint32(index);\n        value = toUint32(value);\n        if (this.values[index] === value) {\n            return false;\n        }\n        this.values[index] = value;\n        if (index - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = index - 1;\n        }\n        return true;\n    }\n    removeValues(startIndex, count) {\n        startIndex = toUint32(startIndex);\n        count = toUint32(count);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        if (startIndex >= oldValues.length) {\n            return false;\n        }\n        const maxCount = oldValues.length - startIndex;\n        if (count >= maxCount) {\n            count = maxCount;\n        }\n        if (count === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length - count);\n        this.values.set(oldValues.subarray(0, startIndex), 0);\n        this.values.set(oldValues.subarray(startIndex + count), startIndex);\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = startIndex - 1;\n        }\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    getTotalSum() {\n        if (this.values.length === 0) {\n            return 0;\n        }\n        return this._getPrefixSum(this.values.length - 1);\n    }\n    /**\n     * Returns the sum of the first `index + 1` many items.\n     * @returns `SUM(0 <= j <= index, values[j])`.\n     */\n    getPrefixSum(index) {\n        if (index < 0) {\n            return 0;\n        }\n        index = toUint32(index);\n        return this._getPrefixSum(index);\n    }\n    _getPrefixSum(index) {\n        if (index <= this.prefixSumValidIndex[0]) {\n            return this.prefixSum[index];\n        }\n        let startIndex = this.prefixSumValidIndex[0] + 1;\n        if (startIndex === 0) {\n            this.prefixSum[0] = this.values[0];\n            startIndex++;\n        }\n        if (index >= this.values.length) {\n            index = this.values.length - 1;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n        }\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n        return this.prefixSum[index];\n    }\n    getIndexOf(sum) {\n        sum = Math.floor(sum);\n        // Compute all sums (to get a fully valid prefixSum)\n        this.getTotalSum();\n        let low = 0;\n        let high = this.values.length - 1;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStop = this.prefixSum[mid];\n            midStart = midStop - this.values[mid];\n            if (sum < midStart) {\n                high = mid - 1;\n            }\n            else if (sum >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new PrefixSumIndexOfResult(mid, sum - midStart);\n    }\n}\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nexport class ConstantTimePrefixSumComputer {\n    constructor(values) {\n        this._values = values;\n        this._isValid = false;\n        this._validEndIndex = -1;\n        this._prefixSum = [];\n        this._indexBySum = [];\n    }\n    /**\n     * @returns SUM(0 <= j < values.length, values[j])\n     */\n    getTotalSum() {\n        this._ensureValid();\n        return this._indexBySum.length;\n    }\n    /**\n     * Returns the sum of the first `count` many items.\n     * @returns `SUM(0 <= j < count, values[j])`.\n     */\n    getPrefixSum(count) {\n        this._ensureValid();\n        if (count === 0) {\n            return 0;\n        }\n        return this._prefixSum[count - 1];\n    }\n    /**\n     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n     */\n    getIndexOf(sum) {\n        this._ensureValid();\n        const idx = this._indexBySum[sum];\n        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n    }\n    removeValues(start, deleteCount) {\n        this._values.splice(start, deleteCount);\n        this._invalidate(start);\n    }\n    insertValues(insertIndex, insertArr) {\n        this._values = arrayInsert(this._values, insertIndex, insertArr);\n        this._invalidate(insertIndex);\n    }\n    _invalidate(index) {\n        this._isValid = false;\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n    _ensureValid() {\n        if (this._isValid) {\n            return;\n        }\n        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n            const value = this._values[i];\n            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n            this._prefixSum[i] = sumAbove + value;\n            for (let j = 0; j < value; j++) {\n                this._indexBySum[sumAbove + j] = i;\n            }\n        }\n        // trim things\n        this._prefixSum.length = this._values.length;\n        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n        // mark as valid\n        this._isValid = true;\n        this._validEndIndex = this._values.length - 1;\n    }\n    setValue(index, value) {\n        if (this._values[index] === value) {\n            // no change\n            return;\n        }\n        this._values[index] = value;\n        this._invalidate(index);\n    }\n}\nexport class PrefixSumIndexOfResult {\n    constructor(index, remainder) {\n        this.index = index;\n        this.remainder = remainder;\n        this._prefixSumIndexOfResultBrand = undefined;\n        this.index = index;\n        this.remainder = remainder;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nexport function calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nexport function calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nexport function resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* Red */) {\n                w.color = 0 /* Black */;\n                x.parent.color = 1 /* Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {\n                w.color = 1 /* Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* Black */) {\n                    w.left.color = 0 /* Black */;\n                    w.color = 1 /* Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* Black */;\n                w.right.color = 0 /* Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* Red */) {\n                w.color = 0 /* Black */;\n                x.parent.color = 1 /* Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {\n                w.color = 1 /* Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* Black */) {\n                    w.right.color = 0 /* Black */;\n                    w.color = 1 /* Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* Black */;\n                w.left.color = 0 /* Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* Red */) {\n                x.parent.color = 0 /* Black */;\n                y.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* Red */) {\n                x.parent.color = 0 /* Black */;\n                y.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nexport const AverageBufferSize = 65535;\nexport function createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nexport class LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        let currentContent;\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        return endOffset - startOffset;\n    }\n    getCharacterCountInRange(range, eol = 0 /* TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* LF */:\n                return '\\n';\n            case 2 /* CRLF */:\n                return '\\r\\n';\n            case 0 /* TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* CRLF */ : 1 /* LF */);\n                if (strEOL === 0 /* Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nexport class PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (this.isBasicASCII) {\n            this.isBasicASCII = lineStarts.isBasicASCII;\n        }\n        if (!this.isBasicASCII && !this.containsRTL) {\n            // No need to check if it is basic ASCII\n            this.containsRTL = strings.containsRTL(chunk);\n        }\n        if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\n            // No need to check if it is basic ASCII\n            this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { runWhenIdle } from '../../../base/common/async.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nclass ContiguousGrowingArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrays.arrayInsert(this._store, insertIndex, arr);\n    }\n}\n/**\n * Stores the states at the start of each line and keeps track of which lines\n * must be retokenized. Also uses state equality to quickly validate lines\n * that don't need to be retokenized.\n *\n * For example, when typing on a line, the line gets marked as needing to be tokenized.\n * Once the line is tokenized, the end state is checked for equality against the begin\n * state of the next line. If the states are equal, tokenization doesn't need to run\n * again over the rest of the file. If the states are not equal, the next line gets marked\n * as needing to be tokenized.\n */\nexport class TokenizationStateStore {\n    constructor(tokenizationSupport, initialState) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = initialState;\n        /**\n         * `lineBeginState[i]` contains the begin state used to tokenize line number `i + 1`.\n         */\n        this._lineBeginState = new ContiguousGrowingArray(null);\n        /**\n         * `lineNeedsTokenization[i]` describes if line number `i + 1` needs to be tokenized.\n         */\n        this._lineNeedsTokenization = new ContiguousGrowingArray(true);\n        this._firstLineNeedsTokenization = 0;\n        this._lineBeginState.set(0, this.initialState);\n    }\n    get invalidLineStartIndex() {\n        return this._firstLineNeedsTokenization;\n    }\n    markMustBeTokenized(lineIndex) {\n        this._lineNeedsTokenization.set(lineIndex, true);\n        this._firstLineNeedsTokenization = Math.min(this._firstLineNeedsTokenization, lineIndex);\n    }\n    getBeginState(lineIndex) {\n        return this._lineBeginState.get(lineIndex);\n    }\n    setEndState(linesLength, lineIndex, endState) {\n        this._lineNeedsTokenization.set(lineIndex, false);\n        this._firstLineNeedsTokenization = lineIndex + 1;\n        // Check if this was the last line\n        if (lineIndex === linesLength - 1) {\n            return;\n        }\n        // Check if the end state has changed\n        const previousEndState = this._lineBeginState.get(lineIndex + 1);\n        if (previousEndState === null || !endState.equals(previousEndState)) {\n            this._lineBeginState.set(lineIndex + 1, endState);\n            this.markMustBeTokenized(lineIndex + 1);\n            return;\n        }\n        // Perhaps we can skip tokenizing some lines...\n        let i = lineIndex + 1;\n        while (i < linesLength) {\n            if (this._lineNeedsTokenization.get(i)) {\n                break;\n            }\n            i++;\n        }\n        this._firstLineNeedsTokenization = i;\n    }\n    //#region Editing\n    applyEdits(range, eolCount) {\n        this.markMustBeTokenized(range.startLineNumber - 1);\n        this._lineBeginState.delete(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        this._lineNeedsTokenization.delete(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        this._lineBeginState.insert(range.startLineNumber, eolCount);\n        this._lineNeedsTokenization.insert(range.startLineNumber, eolCount);\n    }\n}\nexport class TextModelTokenization extends Disposable {\n    constructor(_textModel, _languageIdCodec) {\n        super();\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n        this._isScheduled = false;\n        this._isDisposed = false;\n        this._tokenizationStateStore = null;\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this._textModel.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this._resetTokenizationState();\n            this._textModel.clearTokens();\n        }));\n        this._resetTokenizationState();\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    //#region TextModel events\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._resetTokenizationState();\n            return;\n        }\n        if (this._tokenizationStateStore) {\n            for (let i = 0, len = e.changes.length; i < len; i++) {\n                const change = e.changes[i];\n                const [eolCount] = countEOL(change.text);\n                this._tokenizationStateStore.applyEdits(change.range, eolCount);\n            }\n        }\n        this._beginBackgroundTokenization();\n    }\n    handleDidChangeAttached() {\n        this._beginBackgroundTokenization();\n    }\n    handleDidChangeLanguage(e) {\n        this._resetTokenizationState();\n        this._textModel.clearTokens();\n    }\n    //#endregion\n    _resetTokenizationState() {\n        const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);\n        if (tokenizationSupport && initialState) {\n            this._tokenizationStateStore = new TokenizationStateStore(tokenizationSupport, initialState);\n        }\n        else {\n            this._tokenizationStateStore = null;\n        }\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizeViewport(builder, startLineNumber, endLineNumber);\n        this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());\n    }\n    reset() {\n        this._resetTokenizationState();\n        this._textModel.clearTokens();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._updateTokensUntilLine(builder, lineNumber);\n        this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());\n    }\n    getTokenTypeIfInsertingCharacter(position, character) {\n        if (!this._tokenizationStateStore) {\n            return 0 /* Other */;\n        }\n        this.forceTokenization(position.lineNumber);\n        const lineStartState = this._tokenizationStateStore.getBeginState(position.lineNumber - 1);\n        if (!lineStartState) {\n            return 0 /* Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        if (!this._tokenizationStateStore) {\n            return null;\n        }\n        this.forceTokenization(lineNumber);\n        const lineStartState = this._tokenizationStateStore.getBeginState(lineNumber - 1);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizationStateStore) {\n            return true;\n        }\n        const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n        if (lineNumber > firstInvalidLineNumber) {\n            return false;\n        }\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (this._textModel.getLineLength(lineNumber) < 2048 /* CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizationStateStore) {\n            return false;\n        }\n        return (this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount());\n    }\n    _tokenizeOneInvalidLine(builder) {\n        if (!this._tokenizationStateStore || !this._hasLinesToTokenize()) {\n            return this._textModel.getLineCount() + 1;\n        }\n        const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n        this._updateTokensUntilLine(builder, lineNumber);\n        return lineNumber;\n    }\n    _updateTokensUntilLine(builder, lineNumber) {\n        if (!this._tokenizationStateStore) {\n            return;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const linesLength = this._textModel.getLineCount();\n        const endLineIndex = lineNumber - 1;\n        // Validate all states up to and including endLineIndex\n        for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n            const text = this._textModel.getLineContent(lineIndex + 1);\n            const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);\n            builder.add(lineIndex + 1, r.tokens);\n            this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\n            lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n        }\n    }\n    _tokenizeViewport(builder, startLineNumber, endLineNumber) {\n        if (!this._tokenizationStateStore) {\n            // nothing to do\n            return;\n        }\n        if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n            // nothing to do\n            return;\n        }\n        if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n            // tokenization has reached the viewport start...\n            this._updateTokensUntilLine(builder, endLineNumber);\n            return;\n        }\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\n        const fakeLines = [];\n        let initialState = null;\n        for (let i = startLineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                initialState = this._tokenizationStateStore.getBeginState(i - 1);\n                if (initialState) {\n                    break;\n                }\n                fakeLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n            }\n        }\n        if (!initialState) {\n            initialState = this._tokenizationStateStore.initialState;\n        }\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (let i = fakeLines.length - 1; i >= 0; i--) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, fakeLines[i], false, state);\n            state = r.endState;\n        }\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            this._tokenizationStateStore.markMustBeTokenized(lineNumber - 1);\n            state = r.endState;\n        }\n    }\n}\nfunction initializeTokenization(textModel) {\n    if (textModel.isTooLargeForTokenization()) {\n        return [null, null];\n    }\n    const tokenizationSupport = TokenizationRegistry.get(textModel.getLanguageId());\n    if (!tokenizationSupport) {\n        return [null, null];\n    }\n    let initialState;\n    try {\n        initialState = tokenizationSupport.getInitialState();\n    }\n    catch (e) {\n        onUnexpectedError(e);\n        return [null, null];\n    }\n    return [tokenizationSupport, initialState];\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { combinedDisposable, Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nfunction createTextBufferBuilder() {\n    return new PieceTreeTextBufferBuilder();\n}\nexport function createTextBufferFactory(text) {\n    const builder = createTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    const factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    constructor(source, languageId, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._backgroundTokenizationState = 0 /* Uninitialized */;\n        this._onBackgroundTokenizationStateChanged = this._register(new Emitter());\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this._isDisposing = false;\n        this._languageId = languageId;\n        this._languageRegistryListener = this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        });\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._tokens = new ContiguousTokensStore(this._languageService.languageIdCodec);\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._tokenization = new TextModelTokenization(this, this._languageService.languageIdCodec);\n        this._bracketPairColorizer = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n    }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: guessedIndentation.tabSize,\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions({\n            tabSize: options.tabSize,\n            indentSize: options.indentSize,\n            insertSpaces: options.insertSpaces,\n            trimAutoWhitespace: options.trimAutoWhitespace,\n            defaultEOL: options.defaultEOL,\n            bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n        });\n    }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e.rawContentChangedEvent)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    get bracketPairs() { return this._bracketPairColorizer; }\n    get guides() { return this._guidesTextModelPart; }\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    handleTokenizationProgress(completed) {\n        if (this._backgroundTokenizationState === 2 /* Completed */) {\n            // We already did a full tokenization and don't go back to progressing.\n            return;\n        }\n        const newState = completed ? 2 /* Completed */ : 1 /* InProgress */;\n        if (this._backgroundTokenizationState !== newState) {\n            this._backgroundTokenizationState = newState;\n            this._bracketPairColorizer.handleDidChangeBackgroundTokenizationState();\n            this._onBackgroundTokenizationStateChanged.fire();\n        }\n    }\n    dispose() {\n        this._isDisposing = true;\n        this._onWillDispose.fire();\n        this._languageRegistryListener.dispose();\n        this._tokenization.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this._isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this._isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._bracketPairColorizer.handleDidChangeContent(change);\n        this._tokenization.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null) {\n            // There's nothing to do\n            return;\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Flush all tokens\n        this._tokens.flush();\n        this._semanticTokens.flush();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenization.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    onBeforeDetached() {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenization.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairColorizer.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* LF */\n            : 1 /* CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* LF */ : 1 /* CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update tokens and decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n                this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\n                this._semanticTokens.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0 /* Null */);\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = [...affectedInjectedTextLines];\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation);\n        decorations.push(...this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n        decorations.push(...this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n            // Delete + Insert due to an overview ruler status change\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        const result = new Array(newDecorationsLen);\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n            let node = null;\n            if (oldDecorationIndex < oldDecorationsLen) {\n                // (1) get ourselves an old node\n                do {\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\n                // (2) remove the node from the tree (if it exists)\n                if (node) {\n                    if (node.options.after) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                    }\n                    this._decorationsTree.delete(node);\n                    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                }\n            }\n            if (newDecorationIndex < newDecorationsLen) {\n                // (3) create a new node if necessary\n                if (!node) {\n                    const internalDecorationId = (++this._lastDecorationId);\n                    const decorationId = `${this._instanceId};${internalDecorationId}`;\n                    node = new IntervalNode(decorationId, 0, 0);\n                    this._decorations[decorationId] = node;\n                }\n                // (4) initialize node\n                const newDecoration = newDecorations[newDecorationIndex];\n                const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                const options = _normalizeOptions(newDecoration.options);\n                const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                node.ownerId = ownerId;\n                node.reset(versionId, startOffset, endOffset, range);\n                node.setOptions(options);\n                if (node.options.after) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                }\n                if (node.options.before) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                }\n                this._onDidChangeDecorations.checkAffectedAndFire(options);\n                this._decorationsTree.insert(node);\n                result[newDecorationIndex] = node.id;\n                newDecorationIndex++;\n            }\n            else {\n                if (node) {\n                    delete this._decorations[node.id];\n                }\n            }\n        }\n        return result;\n    }\n    setTokens(tokens, backgroundTokenizationCompleted = false) {\n        if (tokens.length !== 0) {\n            const ranges = [];\n            for (let i = 0, len = tokens.length; i < len; i++) {\n                const element = tokens[i];\n                let minChangedLineNumber = 0;\n                let maxChangedLineNumber = 0;\n                let hasChange = false;\n                for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                    if (hasChange) {\n                        this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                        maxChangedLineNumber = lineNumber;\n                    }\n                    else {\n                        const lineHasChange = this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                        if (lineHasChange) {\n                            hasChange = true;\n                            minChangedLineNumber = lineNumber;\n                            maxChangedLineNumber = lineNumber;\n                        }\n                    }\n                }\n                if (hasChange) {\n                    ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber });\n                }\n            }\n            if (ranges.length > 0) {\n                this._emitModelTokensChangedEvent({\n                    tokenizationSupportChanged: false,\n                    semanticTokensApplied: false,\n                    ranges: ranges\n                });\n            }\n        }\n        this.handleTokenizationProgress(backgroundTokenizationCompleted);\n    }\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: true,\n            ranges: [{ fromLineNumber: changedRange.startLineNumber, toLineNumber: changedRange.endLineNumber }]\n        });\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        startLineNumber = Math.max(1, startLineNumber);\n        endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\n        this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n    }\n    clearTokens() {\n        this._tokens.flush();\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: true,\n            semanticTokensApplied: false,\n            ranges: [{\n                    fromLineNumber: 1,\n                    toLineNumber: this._buffer.getLineCount()\n                }]\n        });\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._isDisposing) {\n            this._bracketPairColorizer.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    resetTokenization() {\n        this._tokenization.reset();\n    }\n    forceTokenization(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        this._tokenization.forceTokenization(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        return this._tokenization.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n    getLineTokens(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._getLineTokens(lineNumber);\n    }\n    _getLineTokens(lineNumber) {\n        const lineText = this.getLineContent(lineNumber);\n        const syntacticTokens = this._tokens.getTokens(this._languageId, lineNumber - 1, lineText);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    getLanguageId() {\n        return this._languageId;\n    }\n    setMode(languageId) {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId\n        };\n        this._languageId = languageId;\n        this._bracketPairColorizer.handleDidChangeLanguage(e);\n        this._tokenization.handleDidChangeLanguage(e);\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        const position = this.validatePosition(new Position(lineNumber, column));\n        return this._tokenization.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        const validatedPosition = this.validatePosition(position);\n        return this._tokenization.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    // Having tokens allows implementing additional helper methods\n    getWordAtPosition(_position) {\n        this._assertNotDisposed();\n        const position = this.validatePosition(_position);\n        const lineContent = this.getLineContent(position.lineNumber);\n        const lineTokens = this._getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return {\n                word: '',\n                startColumn: position.column,\n                endColumn: position.column\n            };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column\n        };\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n};\nTextModel = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService)\n], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n}\nexport class ModelDecorationOptions {\n    constructor(options) {\n        var _a, _b;\n        this.description = options.description;\n        this.stickiness = options.stickiness || 0 /* AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = (_a = options.hideInCommentTokens) !== null && _a !== void 0 ? _a : false;\n        this.hideInStringTokens = (_b = options.hideInStringTokens) !== null && _b !== void 0 ? _b : false;\n    }\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nexport class DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        var _a;\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFire) {\n                this.handleBeforeFire(this._affectedInjectedTextLines);\n                const event = {\n                    affectsMinimap: this._affectsMinimap,\n                    affectsOverviewRuler: this._affectsOverviewRuler\n                };\n                this._shouldFire = false;\n                this._affectsMinimap = false;\n                this._affectsOverviewRuler = false;\n                this._actual.fire(event);\n            }\n            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        if (!this._affectsMinimap) {\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n        }\n        if (!this._affectsOverviewRuler) {\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n        }\n        this._shouldFire = true;\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._shouldFire = true;\n    }\n}\n//#endregion\nexport class DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TextModelPart {\n    constructor() {\n        this._isDisposed = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 92 /* Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */ || nextChCode === 87 /* W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        let m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n"],"names":["MirrorTextModel","uri","lines","eol","versionId","this","_uri","_lines","_eol","_versionId","_lineStarts","_cachedTextValue","length","join","e","changes","change","_acceptDeleteRange","range","_acceptInsertText","Position","startLineNumber","startColumn","text","eolLength","linesLength","lineStartValues","Uint32Array","i","PrefixSumComputer","lineIndex","newValue","setValue","endLineNumber","_setLineText","substring","endColumn","splice","removeValues","position","insertText","insertLines","splitLines","lineNumber","column","newLengths","insertValues","values","prefixSum","prefixSumValidIndex","Int32Array","insertIndex","toUint32","oldValues","oldPrefixSum","insertValuesLen","set","subarray","index","value","startIndex","count","maxCount","_getPrefixSum","Math","max","sum","floor","getTotalSum","low","high","mid","midStop","midStart","PrefixSumIndexOfResult","ConstantTimePrefixSumComputer","_values","_isValid","_validEndIndex","_prefixSum","_indexBySum","_ensureValid","idx","viewLinesAbove","start","deleteCount","_invalidate","insertArr","arrayInsert","min","len","sumAbove","j","remainder","_prefixSumIndexOfResultBrand","undefined","TreeNode","piece","color","size_left","lf_left","parent","left","right","SENTINEL","leftest","node","righttest","calculateSize","calculateLF","lineFeedCnt","resetSentinel","leftRotate","tree","x","y","root","rightRotate","rbDelete","z","detach","yWasRed","recomputeTreeMetadata","newSizeLeft","newLFLeft","delta","lf_delta","updateTreeMetadata","w","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","arr","r","Uint16Array","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","str","readonly","rLength","chr","charCodeAt","Piece","bufferIndex","end","StringBuffer","buffer","PieceTreeSnapshot","BOM","_pieces","_tree","_BOM","_index","iterate","push","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","offset","nodePos","nodeStartOffset","nodeStartLineNumber","nodePosition","shift","hasInvalidVal","tmp","newArr","entry","PieceTreeBase","chunks","eolNormalized","create","_buffers","_lastChangeBufferPos","line","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","averageBufferSize","tempChunk","tempChunkLen","getNodeContent","replace","newEOL","normalizeEOL","leftLen","getAccumulatedValue","lfCnt","originalOffset","out","getIndexOf","getOffsetAt","startPosition","nodeAt2","endPosition","getValueInRange2","getEOL","startOffset","offsetInBuffer","ret","next","substr","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLineRawContent","matchingNode","targetOffset","_getCharCode","getLineCount","getLength","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","resultLen","result","m","searchText","startOffsetInBuffer","_wordSeparators","reset","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","createFindMatch","Range","searchRange","Searcher","wordSeparators","regex","findMatchesInNode","currentNode","lineBreakCnt","nextLineStartOffset","getLineContent","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","textLength","lastMatchIndex","indexOf","isValidMatch","FindMatch","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","validate","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","headOfRight","nodeCharCodeAt","newStart","startWithLF","tailOfLeft","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","prev","nPiece","newNode","adjustCarriageReturnFromNext","endOffset","previousCharOffset","cursor","nodes","lastChar","splitText","concat","slice","endIndex","endPos","newPiece","cache","get2","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","size_delta","newLength","originalStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","get","prevAccumualtedValue","offsetOfNode","newOffset","val","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","p","prevNode","PieceTreeTextBuffer","containsRTL","containsUnusualLineTerminators","_onDidChangeContent","_register","Emitter","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","preserveBOM","createSnapshot","getPositionAt","isEmpty","lineEnding","_getEndOfLine","getValueInRange","fromLineNumber","toLineNumber","lineContent","fromOffset","toOffset","strings","getValueLengthInRange","getLinesContent","getLineCharCode","getLineLength","Error","setEOL","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","mightContainRTL","mightContainUnusualLineTerminators","mightContainNonBasicASCII","canReduceOperations","operations","op","_isTracked","validatedRange","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","countEOL","bufferEOL","sortIndex","identifier","rangeOffset","rangeLength","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","TextChange","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","prevContent","fire","ApplyEditsResult","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","_sortOpsDescending","delete","insert","contentChangeRange","findMatchesLineByLine","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","Disposable","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","defaultEOL","totalEOLCount","totalCRCount","_getEOL","newLineStart","textBuffer","disposable","PieceTreeTextBufferBuilder","_hasPreviousChar","_previousChar","_tmpLineStarts","chunk","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","createLineStarts","_finish","lastChunk","newLineStarts","ContiguousGrowingArray","_default","_store","deleteIndex","insertCount","arrays","TokenizationStateStore","tokenizationSupport","initialState","_lineBeginState","_lineNeedsTokenization","_firstLineNeedsTokenization","endState","previousEndState","equals","markMustBeTokenized","TextModelTokenization","_textModel","_languageIdCodec","_isScheduled","_isDisposed","_tokenizationStateStore","TokenizationRegistry","languageId","getLanguageId","changedLanguages","_resetTokenizationState","clearTokens","isFlush","applyEdits","_beginBackgroundTokenization","textModel","isTooLargeForTokenization","getInitialState","onUnexpectedError","initializeTokenization","isAttachedToEditor","_hasLinesToTokenize","runWhenIdle","deadline","_backgroundTokenizeWithDeadline","endTime","Date","now","timeRemaining","execute","_backgroundTokenizeForAtLeast1ms","setTimeout0","builder","ContiguousMultilineTokensBuilder","sw","StopWatch","elapsed","_tokenizeOneInvalidLine","setTokens","finalize","_tokenizeViewport","_updateTokensUntilLine","character","forceTokenization","lineStartState","getBeginState","safeTokenize","lineTokens","LineTokens","tokens","getCount","tokenIndex","findTokenIndexAtOffset","getStandardTokenType","newText","curLineContent","newLineContent","getLanguageIdAtPosition","firstInvalidLineNumber","invalidLineStartIndex","endLineIndex","add","setEndState","nonWhitespaceColumn","getLineFirstNonWhitespaceColumn","fakeLines","newNonWhitespaceIndex","state","languageIdCodec","hasEOL","tokenizeEncoded","clone","nullTokenizeEncoded","encodeLanguageId","__decorate","decorators","target","key","desc","d","c","arguments","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","createTextBufferFactory","acceptChunk","finish","createTextBuffer","MODEL_ID","TextModelSnapshot","source","_source","_eos","resultCnt","resultLength","read","invalidFunc","TextModel","creationOptions","associatedResource","_undoRedoService","_languageService","_languageConfigurationService","_onWillDispose","onWillDispose","event","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeLanguage","onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","_onDidChangeInjectedText","_eventEmitter","DidChangeContentEmitter","_backgroundTokenizationState","_onBackgroundTokenizationStateChanged","id","isForSimpleWidget","_associatedResource","URI","_attachedEditorCount","_buffer","_bufferDisposable","_options","resolveOptions","bufferLineCount","bufferTextLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForSyncing","MODEL_SYNC_LIMIT","_alternativeVersionId","_initialUndoRedoSnapshot","_isDisposing","_languageId","_languageRegistryListener","onDidChange","affects","_instanceId","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","EditStack","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","_tokens","ContiguousTokensStore","_semanticTokens","SparseTokensStore","_tokenization","_bracketPairColorizer","BracketPairsTextModelPart","_guidesTextModelPart","GuidesTextModelPart","_decorationProvider","ColorizedBracketPairsDecorationProvider","beginDeferredEmit","endDeferredEmit","listener","slowEvent","contentChangedEvent","combinedDisposable","fastEvent","rawContentChangedEvent","completed","newState","handleDidChangeBackgroundTokenizationState","dispose","emptyDisposedTextBuffer","rawChange","handleDidChangeContent","InternalModelContentChangeEvent","_assertNotDisposed","_setValueFromTextBuffer","isUndoing","isRedoing","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","getLineMaxColumn","_increaseVersionId","flush","clear","_emitContentChangedEvent","ModelRawContentChangedEvent","ModelRawFlush","_createContentChanged2","getValue","_onBeforeEOLChange","_onAfterEOLChange","ModelRawEOLChanged","ensureAllNodesHaveRanges","allDecorations","collectNodesPostOrder","cachedAbsoluteStart","cachedAbsoluteEnd","cachedVersionId","recomputeMaxEnd","handleDidChangeAttached","smallLineCharCount","longLineCharCount","lineLength","tabSize","indentSize","insertSpaces","_newOpts","trimAutoWhitespace","bracketPairColorizationOptions","bracketColorizationOptions","newOpts","model","createChangeEvent","handleDidChangeOptions","defaultInsertSpaces","defaultTabSize","guessedIndentation","guessIndentation","updateOptions","normalizeIndentation","selections","matches","findMatches","resetMightContainUnusualLineTerminators","pushEditOperations","map","rawPosition","_validatePosition","rawOffset","newAlternativeVersionId","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","getBOM","rawRange","validateRange","getCharacterCountInRange","getLineLastNonWhitespaceColumn","linesCount","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","Selection","validationType","charCodeBefore","_lineNumber","_column","_isValidPosition","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","_isValidRange","candidate","rawSearchScope","isRegex","matchCase","searchRanges","Array","isArray","every","searchScope","d1","d2","matchMapper","uniqueSearchRanges","reduce","curr","plusRange","searchParams","SearchParams","parseSearchRequest","TextModelSearch","rawSearchStart","searchStart","validatePosition","pushStackElement","popStackElement","pushEOL","rawOperation","_validateEditOperation","beforeCursorState","editOperations","cursorStateComputer","_pushEditOperations","_validateEditOperations","incomingEdits","editsAreNearCursors","sel","foundEditNearSel","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","charAt","trimRange","pushEditOperation","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","oldText","_applyUndoRedoEdits","oldPosition","oldEnd","_overwriteAlternativeVersionId","oldLineCount","newLineCount","acceptEdit","acceptReplace","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","LineInjectedText","injectedTextInEditedRangeQueue","ArrayQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","ModelRawLineChanged","spliceStartLineNumber","ModelRawLinesDeleted","spliceLineNumber","injectedTexts","newLines","takeWhile","ModelRawLinesInserted","reverseEdits","undo","canUndo","redo","canRedo","size","lineChangeEvents","_getInjectedTextInLine","ModelInjectedTextChangedEvent","ownerId","_changeDecorations","changeAccessor","addDecoration","options","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","getDecorationRange","newStickiness","TRACKED_RANGE_OPTIONS","_validateRangeRelaxedNoAllocations","setOptions","collectNodesFromOwner","decorationId","getNodeRange","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","decorations","_getDecorationsInRange","getDecorationsInRange","getAll","getAllInjectedText","filter","t","getAllDecorations","filterRange","filterOwnerId","getAllInInterval","getRangeAt","after","oldRange","recordLineAffectedByInjectedText","before","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","nodeIsInOverviewRuler","nodeRange","oldDecorationsIds","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","IntervalNode","newDecoration","backgroundTokenizationCompleted","ranges","element","minChangedLineNumber","maxChangedLineNumber","hasChange","getLineTokens","lineHasChange","_emitModelTokensChangedEvent","tokenizationSupportChanged","semanticTokensApplied","handleTokenizationProgress","isComplete","hasCompleteSemanticTokens","changedRange","setPartial","tokenizeViewport","handleDidChangeTokens","isCheapToTokenize","_getLineTokens","lineText","syntacticTokens","getTokens","addSparseTokens","oldLanguage","newLanguage","handleDidChangeLanguage","getTokenTypeIfInsertingCharacter","validatedPosition","tokenizeLineWithEdit","getLanguageConfiguration","_position","_findLanguageBoundaries","rbStartOffset","rbEndOffset","rightBiasedWord","getWordAtText","getWordDefinition","lbStartOffset","lbEndOffset","leftBiasedWord","wordAtPosition","getWordAtPosition","word","affinity","indent","indentOfLine","detectIndentation","getStartOffset","tokenCount","getEndOffset","isNodeInOverviewRuler","isNodeInjectedText","DEFAULT_CREATION_OPTIONS","EDITOR_MODEL_DEFAULTS","IUndoRedoService","ILanguageService","ILanguageConfigurationService","_decorationsTree0","IntervalTree","_decorationsTree1","_injectedTextDecorationsTree","host","_intervalSearch","_ensureNodesHaveRanges","r0","intervalSearch","r1","r2","showIfCollapsed","search","overviewRulerOnly","_search","_resolveNode","resolveNode","cleanClassName","className","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","theme","type","_resolveColor","getColor","toString","ModelDecorationMinimapOptions","Color","ModelDecorationInjectedTextOptions","content","inlineClassName","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","_a","_b","description","stickiness","zIndex","hoverMessage","glyphMarginHoverMessage","isWholeLine","collapseOnReplaceEdit","minimap","glyphMarginClassName","linesDecorationsClassName","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","from","hideInCommentTokens","hideInStringTokens","EMPTY","register","createDynamic","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFire","_affectsMinimap","_affectsOverviewRuler","affectsMinimap","affectsOverviewRuler","Set","_fastEmitter","_slowEmitter","_deferredEvent","merge","TextModelPart","multiline","nextChCode","isMultilineRegexSource","wholeWord","global","unicode","err","canUseSimpleSearch","toLowerCase","toUpperCase","SearchData","getMapForWordSeparators","rawMatches","LineFeedCounter","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","_doFindMatchesMultiline","_doFindMatchesLineByLine","lfCounter","matchIndex","match0","lineFeedCountBeforeMatch","findLineFeedCountBeforeOffset","lineFeedCountInMatch","counter","_getMultilineMatchRange","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","_findFirstMatchInLine","fromColumn","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","bestResult","matchStartIndex","matchLength","charBefore","firstCharInMatch","leftIsWordBounday","charAfter","lastCharInMatch","rightIsWordBounday","searchRegex","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec","computeIndentLevel","chCode"],"sourceRoot":""}