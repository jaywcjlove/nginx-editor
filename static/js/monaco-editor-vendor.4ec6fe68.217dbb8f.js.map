{"version":3,"file":"static/js/monaco-editor-vendor.4ec6fe68.217dbb8f.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/position.js","../node_modules/monaco-editor/esm/vs/editor/common/core/range.js","../node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js","../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursorCommon.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        asciiMap.fill(defaultValue);\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n    clear() {\n        this._asciiMap.fill(this._defaultValue);\n        this._map.clear();\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n    clear() {\n        return this._actual.clear();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight, editorWarningBackground } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'));\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'));\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorPrimaryForeground = registerColor('editorMultiCursor.primary.foreground', { dark: editorCursorForeground, light: editorCursorForeground, hcDark: editorCursorForeground, hcLight: editorCursorForeground }, nls.localize('editorMultiCursorPrimaryForeground', 'Color of the primary editor cursor when multiple cursors are present.'));\nexport const editorMultiCursorPrimaryBackground = registerColor('editorMultiCursor.primary.background', { dark: editorCursorBackground, light: editorCursorBackground, hcDark: editorCursorBackground, hcLight: editorCursorBackground }, nls.localize('editorMultiCursorPrimaryBackground', 'The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorSecondaryForeground = registerColor('editorMultiCursor.secondary.foreground', { dark: editorCursorForeground, light: editorCursorForeground, hcDark: editorCursorForeground, hcLight: editorCursorForeground }, nls.localize('editorMultiCursorSecondaryForeground', 'Color of secondary editor cursors when multiple cursors are present.'));\nexport const editorMultiCursorSecondaryBackground = registerColor('editorMultiCursor.secondary.background', { dark: editorCursorBackground, light: editorCursorBackground, hcDark: editorCursorBackground, hcLight: editorCursorBackground }, nls.localize('editorMultiCursorSecondaryBackground', 'The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nexport const deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'), false, nls.localize('deprecatedEditorIndentGuides', '\\'editorIndentGuide.background\\' is deprecated. Use \\'editorIndentGuide.background1\\' instead.'));\nexport const deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'), false, nls.localize('deprecatedEditorActiveIndentGuide', '\\'editorIndentGuide.activeBackground\\' is deprecated. Use \\'editorIndentGuide.activeBackground1\\' instead.'));\nexport const editorIndentGuide1 = registerColor('editorIndentGuide.background1', { dark: deprecatedEditorIndentGuides, light: deprecatedEditorIndentGuides, hcDark: deprecatedEditorIndentGuides, hcLight: deprecatedEditorIndentGuides }, nls.localize('editorIndentGuides1', 'Color of the editor indentation guides (1).'));\nexport const editorIndentGuide2 = registerColor('editorIndentGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides2', 'Color of the editor indentation guides (2).'));\nexport const editorIndentGuide3 = registerColor('editorIndentGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides3', 'Color of the editor indentation guides (3).'));\nexport const editorIndentGuide4 = registerColor('editorIndentGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides4', 'Color of the editor indentation guides (4).'));\nexport const editorIndentGuide5 = registerColor('editorIndentGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides5', 'Color of the editor indentation guides (5).'));\nexport const editorIndentGuide6 = registerColor('editorIndentGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides6', 'Color of the editor indentation guides (6).'));\nexport const editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', { dark: deprecatedEditorActiveIndentGuides, light: deprecatedEditorActiveIndentGuides, hcDark: deprecatedEditorActiveIndentGuides, hcLight: deprecatedEditorActiveIndentGuides }, nls.localize('editorActiveIndentGuide1', 'Color of the active editor indentation guides (1).'));\nexport const editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide2', 'Color of the active editor indentation guides (2).'));\nexport const editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide3', 'Color of the active editor indentation guides (3).'));\nexport const editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide4', 'Color of the active editor indentation guides (4).'));\nexport const editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide5', 'Color of the active editor indentation guides (5).'));\nexport const editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide6', 'Color of the active editor indentation guides (6).'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hcDark: deprecatedEditorActiveLineNumber, hcLight: deprecatedEditorActiveLineNumber }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\nexport const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hcDark: rulerRangeDefault, hcLight: rulerRangeDefault }, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningForeground, hcLight: editorWarningForeground }, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', { dark: editorWarningBackground, light: editorWarningBackground, hcDark: editorWarningBackground, hcLight: editorWarningBackground }, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRangeInclusive(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = new LineRangeSet(lineRanges[0].slice());\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n        }\n        return result.ranges;\n    }\n    static join(lineRanges) {\n        if (lineRanges.length === 0) {\n            throw new BugIndicatingError('lineRanges cannot be empty');\n        }\n        let startLineNumber = lineRanges[0].startLineNumber;\n        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n        for (let i = 1; i < lineRanges.length; i++) {\n            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n        }\n        return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    deltaLength(offset) {\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    /**\n     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n    */\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n    toOffsetRange() {\n        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n}\nexport class LineRangeSet {\n    constructor(\n    /**\n     * Sorted by start line number.\n     * No two line ranges are touching or intersecting.\n     */\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        // Idea: Find joinRange such that:\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            // First and last element are different - we need to replace the entire range\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    intersects(range) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n    subtractFrom(range) {\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return new LineRangeSet([range]);\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n        }\n        return new LineRangeSet(result);\n    }\n    toString() {\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return new LineRangeSet(result);\n    }\n    getWithDelta(value) {\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange {\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return new OffsetRange(start, endExclusive);\n    }\n    static ofLength(length) {\n        return new OffsetRange(0, length);\n    }\n    static ofStartAndLength(start, length) {\n        return new OffsetRange(start, start + length);\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    deltaStart(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive);\n    }\n    deltaEnd(offset) {\n        return new OffsetRange(this.start, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    contains(offset) {\n        return this.start <= offset && offset < this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return new OffsetRange(start, end);\n        }\n        return undefined;\n    }\n    intersects(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        return start < end;\n    }\n    isBefore(other) {\n        return this.endExclusive <= other.start;\n    }\n    isAfter(other) {\n        return this.start >= other.endExclusive;\n    }\n    slice(arr) {\n        return arr.slice(this.start, this.endExclusive);\n    }\n    substring(str) {\n        return str.substring(this.start, this.endExclusive);\n    }\n    /**\n     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n     * The range must not be empty.\n     */\n    clip(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n    }\n    /**\n     * Returns `r := value + k * length` such that `r` is contained in this range.\n     * The range must not be empty.\n     *\n     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n     */\n    clipCyclic(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        if (value < this.start) {\n            return this.endExclusive - ((this.start - value) % this.length);\n        }\n        if (value >= this.endExclusive) {\n            return this.start + ((value - this.start) % this.length);\n        }\n        return value;\n    }\n    forEach(f) {\n        for (let i = this.start; i < this.endExclusive; i++) {\n            f(i);\n        }\n    }\n}\nexport class OffsetRangeSet {\n    constructor() {\n        this._sortedRanges = [];\n    }\n    addRange(range) {\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            this._sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, this._sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n            this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    toString() {\n        return this._sortedRanges.map(r => r.toString()).join(', ');\n    }\n    /**\n     * Returns of there is a value that is contained in this instance and the given range.\n     */\n    intersectsStrict(other) {\n        // TODO use binary search\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n            i++;\n        }\n        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n    }\n    intersectWithRange(other) {\n        // TODO use binary search + slice\n        const result = new OffsetRangeSet();\n        for (const range of this._sortedRanges) {\n            const intersection = range.intersect(other);\n            if (intersection) {\n                result.addRange(intersection);\n            }\n        }\n        return result;\n    }\n    intersectWithRangeLength(other) {\n        return this.intersectWithRange(other).length;\n    }\n    get length() {\n        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n    toJSON() {\n        return {\n            lineNumber: this.lineNumber,\n            column: this.column\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\nRGBA8.Empty = new RGBA8(0, 0, 0, 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","import { OffsetRange } from './offsetRange.js';\nimport { TextLength } from './textLength.js';\nexport class PositionOffsetTransformer {\n    constructor(text) {\n        this.text = text;\n        this.lineStartOffsetByLineIdx = [];\n        this.lineStartOffsetByLineIdx.push(0);\n        for (let i = 0; i < text.length; i++) {\n            if (text.charAt(i) === '\\n') {\n                this.lineStartOffsetByLineIdx.push(i + 1);\n            }\n        }\n    }\n    getOffset(position) {\n        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n    }\n    getOffsetRange(range) {\n        return new OffsetRange(this.getOffset(range.getStartPosition()), this.getOffset(range.getEndPosition()));\n    }\n    get textLength() {\n        const lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n        return new TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Position } from './position.js';\nimport { PositionOffsetTransformer } from './positionToOffset.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\nexport class TextEdit {\n    constructor(edits) {\n        this.edits = edits;\n        assertFn(() => checkAdjacentItems(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n    }\n    apply(text) {\n        let result = '';\n        let lastEditEnd = new Position(1, 1);\n        for (const edit of this.edits) {\n            const editRange = edit.range;\n            const editStart = editRange.getStartPosition();\n            const editEnd = editRange.getEndPosition();\n            const r = rangeFromPositions(lastEditEnd, editStart);\n            if (!r.isEmpty()) {\n                result += text.getValueOfRange(r);\n            }\n            result += edit.text;\n            lastEditEnd = editEnd;\n        }\n        const r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n        if (!r.isEmpty()) {\n            result += text.getValueOfRange(r);\n        }\n        return result;\n    }\n    applyToString(str) {\n        const strText = new StringText(str);\n        return this.apply(strText);\n    }\n    getNewRanges() {\n        const newRanges = [];\n        let previousEditEndLineNumber = 0;\n        let lineOffset = 0;\n        let columnOffset = 0;\n        for (const edit of this.edits) {\n            const textLength = TextLength.ofText(edit.text);\n            const newRangeStart = Position.lift({\n                lineNumber: edit.range.startLineNumber + lineOffset,\n                column: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n            });\n            const newRange = textLength.createRange(newRangeStart);\n            newRanges.push(newRange);\n            lineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n            columnOffset = newRange.endColumn - edit.range.endColumn;\n            previousEditEndLineNumber = edit.range.endLineNumber;\n        }\n        return newRanges;\n    }\n}\nexport class SingleTextEdit {\n    constructor(range, text) {\n        this.range = range;\n        this.text = text;\n    }\n}\nfunction rangeFromPositions(start, end) {\n    if (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n        return Range.fromPositions(end, end);\n    }\n    else if (!start.isBeforeOrEqual(end)) {\n        throw new BugIndicatingError('start must be before end');\n    }\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\nexport class AbstractText {\n    get endPositionExclusive() {\n        return this.length.addToPosition(new Position(1, 1));\n    }\n}\nexport class StringText extends AbstractText {\n    constructor(value) {\n        super();\n        this.value = value;\n        this._t = new PositionOffsetTransformer(this.value);\n    }\n    getValueOfRange(range) {\n        return this._t.getOffsetRange(range).substring(this.value);\n    }\n    get length() {\n        return this._t.textLength;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nexport class TextLength {\n    static betweenPositions(position1, position2) {\n        if (position1.lineNumber === position2.lineNumber) {\n            return new TextLength(0, position2.column - position1.column);\n        }\n        else {\n            return new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n        }\n    }\n    static ofRange(range) {\n        return TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n    }\n    static ofText(text) {\n        let line = 0;\n        let column = 0;\n        for (const c of text) {\n            if (c === '\\n') {\n                line++;\n                column = 0;\n            }\n            else {\n                column++;\n            }\n        }\n        return new TextLength(line, column);\n    }\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    isGreaterThanOrEqualTo(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount > other.lineCount;\n        }\n        return this.columnCount >= other.columnCount;\n    }\n    createRange(startPosition) {\n        if (this.lineCount === 0) {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n        }\n        else {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    addToPosition(position) {\n        if (this.lineCount === 0) {\n            return new Position(position.lineNumber, position.column + this.columnCount);\n        }\n        else {\n            return new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\nTextLength.zero = new TextLength(0, 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators, intlSegmenterLocales) {\n        super(0 /* WordCharacterClass.Regular */);\n        this._segmenter = null;\n        this._cachedLine = null;\n        this._cachedSegments = [];\n        this.intlSegmenterLocales = intlSegmenterLocales;\n        if (this.intlSegmenterLocales.length > 0) {\n            this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n        }\n        else {\n            this._segmenter = null;\n        }\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n    findPrevIntlWordBeforeOrAtOffset(line, offset) {\n        let candidate = null;\n        for (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n            if (segment.index > offset) {\n                break;\n            }\n            candidate = segment;\n        }\n        return candidate;\n    }\n    findNextIntlWordAtOrAfterOffset(lineContent, offset) {\n        for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n            if (segment.index < offset) {\n                continue;\n            }\n            return segment;\n        }\n        return null;\n    }\n    _getIntlSegmenterWordsOnLine(line) {\n        if (!this._segmenter) {\n            return [];\n        }\n        // Check if the line has changed from the previous call\n        if (this._cachedLine === line) {\n            return this._cachedSegments;\n        }\n        // Update the cache with the new line\n        this._cachedLine = line;\n        this._cachedSegments = this._filterWordSegments(this._segmenter.segment(line));\n        return this._cachedSegments;\n    }\n    _filterWordSegments(segments) {\n        const result = [];\n        for (const segment of segments) {\n            if (this._isWordLike(segment)) {\n                result.push(segment);\n            }\n        }\n        return result;\n    }\n    _isWordLike(segment) {\n        if (segment.isWordLike) {\n            return true;\n        }\n        return false;\n    }\n}\nconst wordClassifierCache = new LRUCache(10);\nexport function getMapForWordSeparators(wordSeparators, intlSegmenterLocales) {\n    const key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n    let result = wordClassifierCache.get(key);\n    if (!result) {\n        result = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n        wordClassifierCache.set(key, result);\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    // Ensure the regex has the 'g' flag, otherwise this will loop forever\n    wordDefinition = ensureValidWordDefinition(wordDefinition);\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        if (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n            // Avoid selecting text when recovering from markers\n            return Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n        }\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy } from '../../../base/common/arrays.js';\nimport { findLastMax, findFirstMin } from '../../../base/common/arraysFind.js';\nimport { CursorState } from '../cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findFirstMin(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMax(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CursorContext {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        this._cursorContextBrand = undefined;\n        this.model = model;\n        this.viewModel = viewModel;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealAll(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const revealViewSelections = [primaryCursor.viewState.selection];\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, null, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealAll(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealAll(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealAll(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../core/cursorColumns.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Direction.Left */:\n                left = true;\n                break;\n            case 1 /* Direction.Right */:\n                left = false;\n                break;\n            case 2 /* Direction.Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* CharCode.Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* CharCode.Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 2 /* SelectionStartKind.Line */, 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(true, viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(true, selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(true, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        if (inSelectionMode) {\n            if (cursor.modelState.selectionStartKind === 1 /* SelectionStartKind.Word */) {\n                return this.word(viewModel, cursor, inSelectionMode, _position);\n            }\n            if (cursor.modelState.selectionStartKind === 2 /* SelectionStartKind.Line */) {\n                return this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n            }\n        }\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.metadata = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let i = 0;\n        let r;\n        do {\n            r = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n            const np = model.normalizePosition(new Position(r.lineNumber, r.column), 2 /* PositionAffinity.None */);\n            if (np.lineNumber > lineNumber) {\n                break;\n            }\n        } while (i++ < 10 && lineNumber + i < model.getLineCount());\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n            if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        let autoCloseConfig;\n        let shouldAutoCloseBefore;\n        const chIsQuote = isQuote(ch);\n        if (chIsQuote) {\n            autoCloseConfig = config.autoClosingQuotes;\n            shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n        }\n        else {\n            const pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n            if (pairIsForComments) {\n                autoCloseConfig = config.autoClosingComments;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n            }\n            else {\n                autoCloseConfig = config.autoClosingBrackets;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n            }\n        }\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _createIntlWord(intlWord, nextCharClass) {\n        // console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n        return { start: intlWord.index, end: intlWord.index + intlWord.segment.length, wordType: 1 /* WordType.Regular */, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (previousIntlWord && chIndex === previousIntlWord.index) {\n                return this._createIntlWord(previousIntlWord, chClass);\n            }\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n                return chIndex;\n            }\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (nextIntlWord && chIndex === nextIntlWord.index) {\n                return this._createIntlWord(nextIntlWord, chClass);\n            }\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (previousIntlWord && chIndex === previousIntlWord.index) {\n                return chIndex;\n            }\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, _intlSegmenterLocales, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './core/position.js';\nimport { Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { createScopedLineTokens } from './languages/supports.js';\nimport { CursorColumns } from './core/cursorColumns.js';\nimport { normalizeIndentation } from './core/indentation.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    static shouldRecreate(e) {\n        return (e.hasChanged(145 /* EditorOption.layoutInfo */)\n            || e.hasChanged(131 /* EditorOption.wordSeparators */)\n            || e.hasChanged(37 /* EditorOption.emptySelectionClipboard */)\n            || e.hasChanged(77 /* EditorOption.multiCursorMergeOverlapping */)\n            || e.hasChanged(79 /* EditorOption.multiCursorPaste */)\n            || e.hasChanged(80 /* EditorOption.multiCursorLimit */)\n            || e.hasChanged(6 /* EditorOption.autoClosingBrackets */)\n            || e.hasChanged(7 /* EditorOption.autoClosingComments */)\n            || e.hasChanged(11 /* EditorOption.autoClosingQuotes */)\n            || e.hasChanged(9 /* EditorOption.autoClosingDelete */)\n            || e.hasChanged(10 /* EditorOption.autoClosingOvertype */)\n            || e.hasChanged(14 /* EditorOption.autoSurround */)\n            || e.hasChanged(128 /* EditorOption.useTabStops */)\n            || e.hasChanged(50 /* EditorOption.fontInfo */)\n            || e.hasChanged(91 /* EditorOption.readOnly */)\n            || e.hasChanged(130 /* EditorOption.wordSegmenterLocales */));\n    }\n    constructor(languageId, modelOptions, configuration, languageConfigurationService) {\n        var _a;\n        this.languageConfigurationService = languageConfigurationService;\n        this._cursorMoveConfigurationBrand = undefined;\n        this._languageId = languageId;\n        const options = configuration.options;\n        const layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        this.readOnly = options.get(91 /* EditorOption.readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(116 /* EditorOption.stickyTabStops */);\n        this.lineHeight = fontInfo.lineHeight;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(128 /* EditorOption.useTabStops */);\n        this.wordSeparators = options.get(131 /* EditorOption.wordSeparators */);\n        this.emptySelectionClipboard = options.get(37 /* EditorOption.emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(25 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(77 /* EditorOption.multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(79 /* EditorOption.multiCursorPaste */);\n        this.multiCursorLimit = options.get(80 /* EditorOption.multiCursorLimit */);\n        this.autoClosingBrackets = options.get(6 /* EditorOption.autoClosingBrackets */);\n        this.autoClosingComments = options.get(7 /* EditorOption.autoClosingComments */);\n        this.autoClosingQuotes = options.get(11 /* EditorOption.autoClosingQuotes */);\n        this.autoClosingDelete = options.get(9 /* EditorOption.autoClosingDelete */);\n        this.autoClosingOvertype = options.get(10 /* EditorOption.autoClosingOvertype */);\n        this.autoSurround = options.get(14 /* EditorOption.autoSurround */);\n        this.autoIndent = options.get(12 /* EditorOption.autoIndent */);\n        this.wordSegmenterLocales = options.get(130 /* EditorOption.wordSegmenterLocales */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: this._getShouldAutoClose(languageId, this.autoClosingQuotes, true),\n            comment: this._getShouldAutoClose(languageId, this.autoClosingComments, false),\n            bracket: this._getShouldAutoClose(languageId, this.autoClosingBrackets, false),\n        };\n        this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoClosingPairs();\n        const surroundingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getSurroundingPairs();\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n        const commentsConfiguration = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        this.blockCommentStartToken = (_a = commentsConfiguration === null || commentsConfiguration === void 0 ? void 0 : commentsConfiguration.blockCommentStartToken) !== null && _a !== void 0 ? _a : null;\n    }\n    get electricChars() {\n        var _a;\n        if (!this._electricChars) {\n            this._electricChars = {};\n            const electricChars = (_a = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || _a === void 0 ? void 0 : _a.getElectricCharacters();\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        const electricCharacterSupport = this.languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).electricCharacter;\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    normalizeIndentation(str) {\n        return normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    _getShouldAutoClose(languageId, autoCloseConfig, forQuotes) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return this._getLanguageDefinedShouldAutoClose(languageId, forQuotes);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    _getLanguageDefinedShouldAutoClose(languageId, forQuotes) {\n        const autoCloseBeforeSet = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoCloseBeforeSet(forQuotes);\n        return c => autoCloseBeforeSet.indexOf(c) !== -1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    visibleColumnFromColumn(model, position) {\n        return CursorColumns.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, this.tabSize);\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    columnFromVisibleColumn(model, lineNumber, visibleColumn) {\n        const result = CursorColumns.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, this.tabSize);\n        const minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n}\nexport class CursorState {\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selection = Selection.liftSelection(modelSelection);\n        const modelState = new SingleCursorState(Range.fromPositions(selection.getSelectionStart()), 0 /* SelectionStartKind.Simple */, 0, selection.getPosition(), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        const states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    constructor(modelState, viewState) {\n        this._cursorStateBrand = undefined;\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this.selectionStart = selectionStart;\n        this.selectionStartKind = selectionStartKind;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this._singleCursorStateBrand = undefined;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.selectionStartKind === other.selectionStartKind\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        if (selectionStart.isEmpty() || !position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n            return Selection.fromPositions(selectionStart.getStartPosition(), position);\n        }\n        else {\n            return Selection.fromPositions(selectionStart.getEndPosition(), position);\n        }\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this._editOperationResultBrand = undefined;\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n"],"names":["CharacterClassifier","constructor","_defaultValue","defaultValue","toUint8","this","_asciiMap","_createAsciiMap","_map","Map","asciiMap","Uint8Array","fill","set","charCode","_value","value","get","clear","CharacterSet","_actual","add","has","CursorColumns","_nextVisibleColumn","codePoint","visibleColumn","tabSize","nextRenderTabStop","strings","visibleColumnFromColumn","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","offset","nextGraphemeLength","columnFromVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","nextIndentTabStop","indentSize","prevRenderTabStop","max","prevIndentTabStop","EditOperation","insert","position","range","Range","lineNumber","forceMoveMarkers","delete","replace","replaceMove","editorLineHighlight","registerColor","dark","light","hcDark","hcLight","nls","editorLineHighlightBorder","contrastBorder","editorCursorForeground","activeContrastBorder","editorFindMatchHighlight","Color","black","white","editorCursorBackground","editorMultiCursorPrimaryForeground","editorMultiCursorPrimaryBackground","editorMultiCursorSecondaryForeground","editorMultiCursorSecondaryBackground","editorWhitespaces","editorLineNumbers","deprecatedEditorIndentGuides","deprecatedEditorActiveIndentGuides","editorIndentGuide1","editorIndentGuide2","editorIndentGuide3","editorIndentGuide4","editorIndentGuide5","editorIndentGuide6","editorActiveIndentGuide1","editorActiveIndentGuide2","editorActiveIndentGuide3","editorActiveIndentGuide4","editorActiveIndentGuide5","editorActiveIndentGuide6","deprecatedEditorActiveLineNumber","editorDimmedLineNumber","editorOverviewRulerBorder","lightgrey","editorOverviewRulerBackground","editorUnnecessaryCodeOpacity","editorBackground","fromHex","transparent","rulerRangeDefault","RGBA","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","editorWarningForeground","editorWarningBorder","overviewRulerInfo","editorInfoForeground","editorInfoBorder","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","editorWarningBackground","registerThemingParticipant","theme","collector","background","getColor","lineHighlight","imeBackground","isTransparent","addRule","concat","countEOL","eolCount","firstLineLength","lastLineStart","i","len","chr","charCodeAt","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","spacesCnt","charAt","tabsCnt","floor","_normalizeIndentationFromWhitespace","LineRange","fromRangeInclusive","startLineNumber","endLineNumber","joinMany","lineRanges","LineRangeSet","slice","getUnion","ranges","join","BugIndicatingError","endLineNumberExclusive","ofLength","deserialize","lineRange","contains","isEmpty","delta","deltaLength","other","toString","intersect","intersectsStrict","overlapOrTouch","equals","b","toInclusiveRange","Number","MAX_SAFE_INTEGER","toExclusiveRange","mapToLineArray","f","push","forEach","serialize","includes","toOffsetRange","OffsetRange","_normalizedRanges","arguments","undefined","addRange","joinRangeStartIdx","findFirstIdxMonotonousOrArrLen","r","joinRangeEndIdxExclusive","findLastIdxMonotonous","splice","joinRange","rangeThatStartsBeforeEnd","findLastMonotonous","intersects","i1","i2","current","next","lineRange1","lineRange2","subtractFrom","map","getIntersection","r1","r2","getWithDelta","sortedRanges","endExclusive","start","j","end","tryCreate","ofStartAndLength","deltaStart","deltaEnd","isBefore","isAfter","arr","clip","clipCyclic","OffsetRangeSet","_sortedRanges","intersectWithRange","intersection","intersectWithRangeLength","reduce","prev","cur","Position","with","newLineNumber","newColumn","deltaLineNumber","deltaColumn","a","isBeforeOrEqual","compare","aLineNumber","bLineNumber","clone","lift","pos","isIPosition","obj","toJSON","startColumn","endColumn","containsPosition","strictContainsPosition","containsRange","otherRange","strictContainsRange","plusRange","intersectRanges","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","equalsRange","getEndPosition","getStartPosition","setEndPosition","setStartPosition","collapseToStart","collapseToEnd","lineCount","fromPositions","isIRange","areIntersectingOrTouching","areIntersecting","compareRangesUsingStarts","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","compareRangesUsingEnds","spansMultipleLines","RGBA8","g","_rgba8Brand","_clamp","c","Empty","Selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","super","equalsSelection","selectionsEqual","getDirection","getPosition","getSelectionStart","fromRange","direction","liftSelection","sel","selectionsArrEqual","isISelection","createWithDirection","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","platform","decodeUTF16LE","source","view","Uint16Array","buffer","resultLen","String","fromCharCode","compatDecodeUTF16LE","decode","StringBuilder","capacity","_capacity","_buffer","_completedStrings","_bufferLength","reset","build","_flushBuffer","_buildBuffer","bufferString","appendCharCode","remainingSpace","appendASCIICharCode","appendString","strLen","escapeNewLine","TextChange","oldLength","oldText","oldEnd","oldPosition","newLength","newText","newEnd","newPosition","_writeStringSize","_writeString","_readString","writeSize","write","read","dest","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","_acceptCurr","_acceptPrev","e1","e2","_splitCurr","_splitPrev","mergePrev","mergeCurr","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","curr","PositionOffsetTransformer","lineStartOffsetByLineIdx","getOffset","getOffsetRange","textLength","lineIdx","TextLength","TextEdit","assertFn","checkAdjacentItems","apply","lastEditEnd","editRange","editStart","editEnd","rangeFromPositions","getValueOfRange","endPositionExclusive","applyToString","strText","StringText","getNewRanges","newRanges","previousEditEndLineNumber","lineOffset","columnOffset","ofText","newRangeStart","newRange","createRange","SingleTextEdit","AbstractText","addToPosition","_t","betweenPositions","position1","position2","ofRange","line","columnCount","isGreaterThanOrEqualTo","startPosition","zero","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","independentColorPoolPerBracketType","WordCharacterClassifier","wordSeparators","intlSegmenterLocales","_segmenter","_cachedLine","_cachedSegments","Intl","Segmenter","granularity","findPrevIntlWordBeforeOrAtOffset","candidate","segment","_getIntlSegmenterWordsOnLine","index","findNextIntlWordAtOrAfterOffset","_filterWordSegments","segments","_isWordLike","isWordLike","wordClassifierCache","LRUCache","getMapForWordSeparators","key","USUAL_WORD_SEPARATORS","DEFAULT_WORD_REGEXP","allowInWords","sep","indexOf","RegExp","createWordRegExp","ensureValidWordDefinition","wordDefinition","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","LinkedList","getWordAtText","textOffset","config","Iterable","first","maxLen","t1","Date","now","prevRegexIndex","match","timeBudget","regexIndex","windowSize","thisMatch","_findRegexMatchEnclosingPosition","word","stopPos","exec","matchIndex","unshift","Cursor","context","_selTrackedRange","_trackSelection","_setState","SingleCursorState","dispose","_removeTrackedRange","startTrackingSelection","_updateTrackedRange","stopTrackingSelection","model","_setTrackedRange","modelState","selection","asCursorState","CursorState","viewState","readSelectionFromMarkers","_getTrackedRange","ensureValidState","setState","_validatePositionWithCache","viewModel","cacheInput","cacheOutput","normalizePosition","_validateViewState","sStartPosition","selectionStart","sEndPosition","validPosition","validSStartPosition","validSEndPosition","selectionStartKind","selectionStartLeftoverVisibleColumns","leftoverVisibleColumns","validateRange","validatePosition","coordinatesConverter","convertViewRangeToModelRange","convertViewPositionToModelPosition","viewSelectionStart","validateViewRange","viewPosition","validateViewPosition","viewSelectionStart1","convertModelPositionToViewPosition","viewSelectionStart2","CursorCollection","cursors","lastAddedCursorIndex","cursor","startTrackingSelections","stopTrackingSelections","updateContext","getAll","getViewPositions","getTopMostViewPosition","findFirstMin","compareBy","getBottomMostViewPosition","findLastMax","getSelections","getViewSelections","setSelections","selections","setStates","fromModelSelections","getPrimaryCursor","states","_setSecondaryStates","secondaryStates","secondaryCursorsLength","secondaryStatesLength","createCnt","_addSecondaryCursor","removeCnt","_removeSecondaryCursor","killSecondaryCursors","getLastAddedCursorIndex","removeIndex","normalize","sortedCursors","sort","s","sortedCursorIndex","currentSelection","nextSelection","cursorConfig","multiCursorMergeOverlapping","shouldMergeCursors","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","resultingRange","looserSelectionIsLTR","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingSelection","resultingState","fromModelSelection","sortedCursor","CursorContext","_cursorContextBrand","CursorsController","Disposable","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","_cursors","_hasFocus","_isHandling","_compositionState","_columnSelectData","_autoClosedActions","_prevEditOperationType","updateConfiguration","onLineMappingChanged","eventsCollector","getCursorStates","setHasFocus","hasFocus","_validateAutoClosedActions","autoClosedAction","isValid","getPrimaryCursorState","reason","reachedMaxCursorCount","multiCursorLimit","oldState","CursorModelState","from","_emitStateChangedIfNecessary","setCursorColumnSelectData","columnSelectData","revealAll","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","revealViewRange","revealViewSelections","emitViewEvent","ViewRevealRangeRequestEvent","revealPrimary","saveState","inSelectionMode","restoreState","desiredSelections","state","onModelContentChanged","event","ModelInjectedTextChangedEvent","e","rawContentChangedEvent","versionId","hadFlushEvent","containsEvent","cursorState","isUndoing","isRedoing","selectionsFromMarkers","getSelection","getCursorColumnSelectData","primaryCursor","isReal","fromViewLineNumber","fromViewVisualColumn","toViewLineNumber","toViewVisualColumn","getPrevEditOperationType","setPrevEditOperationType","type","_pushAutoClosedAction","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","_executeEditOperation","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","TypeWithAutoClosingCommand","enclosingRange","closeCharacterRange","shouldPushStackElementAfter","newState","viewSelections","ViewCursorStateChangedEvent","some","newCursorState","oldSelections","oldModelVersionId","modelVersionId","emitOutgoingEvent","CursorStateChangedEvent","_findAutoClosingPairs","indices","m","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","executeEdits","cursorStateComputer","autoClosingIndices","_isTracked","pushEditOperations","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","_executeEdit","callback","cursorChangeReason","readOnly","err","onUnexpectedError","getAutoClosedCharacters","getAllAutoClosedCharacters","startComposition","CompositionState","endComposition","compositionOutcome","deduceOutcome","TypeOperations","compositionEndWithInterceptors","charLength","typeWithInterceptors","typeWithoutInterceptors","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","newSelections","paste","pasteOnNewLine","multicursorText","cut","DeleteOperations","executeCommand","EditOperationResult","autoClosedActions","autoClosedCharacters","getAutoClosedCharactersRanges","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","decorationRange","getDecorationRange","enclosingRanges","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","hasOwnProperty","console","warn","filteredOperations","identifier","major","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","minor","cursorSelections","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","losingCursors","losingCursorIndex","losingCursor","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","isAutoWhitespaceEdit","insertsAutoWhitespace","editOperationBuilder","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","maxLineColumn","getLineMaxColumn","l","getEditOperations","previousOp","currentOp","loserMajor","CompositionLineState","startSelection","endSelection","_capture","textModel","getLineContent","_original","_deduceOutcome","original","commonPrefix","commonSuffix","deletedText","insertedText","CompositionOutcome","AtomicTabMoveOperations","whitespaceVisibleColumn","lineLength","prevTabStopPosition","prevTabStopVisibleColumn","atomicPosition","left","currentVisibleColumn","targetVisibleColumn","ColumnSelection","columnSelect","fromLineNumber","fromVisibleColumn","toLineNumber","toVisibleColumn","abs","reversed","isRTL","isLTR","visibleStartColumn","visibleEndColumn","maxColumn","viewStates","fromVisualColumn","toVisualColumn","columnSelectLeft","prevColumnSelectData","columnSelectRight","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","columnSelectUp","isPaged","linesCount","pageSize","columnSelectDown","getLineCount","deleteRight","prevEditOperationType","deleteSelection","rightOfPosition","MoveOperations","right","ReplaceCommand","isAutoClosingPairDelete","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","lineText","character","autoClosingPairCandidates","isQuote","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","close","found","lenJ","autoClosedCharacter","_runAutoClosingPairDelete","deleteLeft","autoClosingPairsOpenByEnd","deleteRange","getDeleteRange","useTabStops","lastIndentationColumn","toColumn","getPositionAfterDeleteLeft","newLine","lastCutRange","emptySelectionClipboard","CursorMove","CursorMoveCommands","addCursorDown","useLogicalLine","fromModelState","translateDown","fromViewState","addCursorUp","translateUp","moveToBeginningOfLine","_moveToLineStart","currentViewStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","firstNonBlankColumn","getLineFirstNonWhitespaceColumn","_moveToLineStartByModel","_moveToLineStartByView","moveToEndOfLine","sticky","_moveToLineEnd","viewStatePosition","viewModelMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_moveToLineEndByModel","_moveToLineEndByView","expandLineSelection","moveToBeginningOfBuffer","moveToEndOfBuffer","selectAll","_position","_viewPosition","selectToLineNumber","selectToColumn","enteringLineNumber","move","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","WordOperations","cancelSelection","hasSelection","moveTo","simpleMove","unit","_moveHalfLineLeft","_moveLeft","_moveHalfLineRight","_moveRight","_moveUpByViewLines","_moveUpByModelLines","_moveDownByViewLines","_moveDownByModelLines","moveToPrevBlankLine","moveToNextBlankLine","_moveToViewMinColumn","_moveToViewFirstNonWhitespaceColumn","_moveToViewCenterColumn","_moveToViewMaxColumn","_moveToViewLastNonWhitespaceColumn","viewportMove","visibleViewRange","getCompletelyVisibleViewRange","visibleModelRange","modelLineNumber","_firstLineNumberInRange","modelColumn","_moveToModelPosition","_lastLineNumberInRange","round","findPositionInViewportIfOutside","viewLineNumber","newViewLineNumber","vertical","count","getLineMinColumn","noOfColumns","moveLeft","halfLine","getLineLength","moveRight","moveDown","moveUp","_moveToViewPosition","toViewColumn","toModelLineNumber","toModelColumn","viewColumn","getLineLastNonWhitespaceColumn","metadata","args","name","constraint","arg","types","cursorMoveArg","to","select","by","schema","RawDirection","Left","Right","Up","Down","PrevBlankLine","NextBlankLine","WrappedLineStart","WrappedLineFirstNonWhitespaceCharacter","WrappedLineColumnCenter","WrappedLineEnd","WrappedLineLastNonWhitespaceCharacter","ViewPortTop","ViewPortCenter","ViewPortBottom","ViewPortIfOutside","RawUnit","Line","WrappedLine","Character","HalfLine","parse","CursorPosition","_cursorPositionBrand","leftPosition","leftPositionAtomicSoftTabs","getLineIndentColumn","minColumn","stickyTabStops","normalizedPos","clipPositionColumn","p","clipRange","rightPosition","rightPositionAtomicSoftTabs","allowMoveOnEdgeLine","normalizationAffinity","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","down","allowMoveOnLastLine","up","allowMoveOnFirstLine","_isBlankLine","lastLineNumber","lastColumn","indent","ShiftCommand","isUnshift","autoIndent","languageConfigurationService","outdent","shiftIndent","indentation","unshiftIndent","_distributedPaste","_simplePaste","typeSelection","ReplaceCommandThatPreservesSelection","_distributePasteToCursors","multiCursorPaste","lines","distributedPaste","_goodIndentForLine","action","expectedIndentAction","getInheritIndentForLine","expectedEnterAction","getEnterAction","appendText","IndentAction","Indent","Outdent","_replaceJumpToNextIndent","typeText","tab","test","tokenization","isCheapToTokenize","goodIndent","possibleTypeText","startsWith","lineMaxColumn","_compositionType","shouldPushStackElementBetween","getValueInRange","ReplaceCommandWithOffsetCursorState","_typeCommand","keepPosition","ReplaceCommandWithoutChangingPosition","_enter","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","oldEndViewColumn","oldEndColumn","newLineContent","firstNonWhitespace","afterEnter","ceil","_isAutoIndentType","_runAutoIndentType","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","_isAutoClosingOvertype","autoClosingOvertype","chIsQuote","_runAutoClosingOvertype","_isBeforeClosingBrace","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","x","isBeforeClosingBrace","_findAutoClosingPairOpen","positions","candidates","candidateIsMatch","_findContainedAutoClosingPair","pair","lastChar","autoClosingPairsCloseByEnd","endsWith","_getAutoClosingPairClose","chIsAlreadyTyped","autoCloseConfig","shouldAutoCloseBefore","quote","blockCommentStartToken","autoClosingComments","comment","bracket","containedPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","_runAutoClosingOpenCharType","autoClosingPairClose","_shouldSurroundChar","autoSurround","_isSurroundSelectionType","surroundingPairs","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","_runSurroundSelectionType","closeCharacter","SurroundSelectionCommand","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","electricChars","electricAction","onElectricCharacter","matchOpenBracket","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","getTypingOperation","compositions","composition","hasDeletion","deletedSelectionStart","deletedSelectionEnd","CompositionSurroundSelectionCommand","isDoingComposition","autoIndentFails","opType","lineInsertBefore","lineInsertAfter","lineBreakInsert","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","helper","insertedSelectionStart","insertedSelectionEnd","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","_createWord","wordType","nextCharClass","_createIntlWord","intlWord","_findPreviousWordOnLine","_doFindPreviousWordOnLine","previousIntlWord","chIndex","chCode","chClass","_findEndOfWord","nextIntlWord","_findNextWordOnLine","_doFindNextWordOnLine","_findStartOfWord","moveWordLeft","wordNavigationType","prevWordOnLine","_moveWordPartLeft","rightRight","moveWordRight","movedDown","nextWordOnLine","_moveWordPartRight","_deleteWordLeftWhitespace","lastNonWhitespace","deleteWordLeft","whitespaceHeuristics","deleteInsideWord","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","_charAtIsWhitespace","leftIndex","rightIndex","touchesWord","createRangeWithPosition","deleteWordAndAdjacentWhitespace","expandedToTheRight","_deleteWordPartLeft","toPosition","_findFirstNonWhitespaceChar","_deleteWordRightWhitespace","deleteWordRight","_deleteWordPartRight","_createWordAtPosition","getWordAtPosition","_wordSeparators","_intlSegmenterLocales","prevWord","nextWord","wordSegmenterLocales","possiblePosition","WordPartOperations","deleteWordPartLeft","enforceDefined","deleteWordPartRight","moveWordPartLeft","moveWordPartRight","filter","el","Boolean","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","CursorConfiguration","shouldRecreate","hasChanged","languageId","modelOptions","configuration","_a","_cursorMoveConfigurationBrand","_languageId","layoutInfo","fontInfo","lineHeight","typicalHalfwidthCharacterWidth","height","copyWithSyntaxHighlighting","_electricChars","_getShouldAutoClose","getLanguageConfiguration","getAutoClosingPairs","getSurroundingPairs","commentsConfiguration","comments","electricCharacter","getElectricCharacters","char","electricCharacterSupport","forQuotes","_getLanguageDefinedShouldAutoClose","autoCloseBeforeSet","getAutoCloseBeforeSet","PartialModelCursorState","PartialViewCursorState","modelSelection","modelSelections","_cursorStateBrand","_singleCursorStateBrand","_computeSelection","opts","_editOperationResultBrand"],"sourceRoot":""}