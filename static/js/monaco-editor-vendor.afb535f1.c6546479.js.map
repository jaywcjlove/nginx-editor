{"version":3,"file":"static/js/monaco-editor-vendor.afb535f1.c6546479.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js","../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js","../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/offsetRange.js';\nexport class DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class SequenceDiff {\n    static invert(sequenceDiffs, doc1Length) {\n        const result = [];\n        forEachAdjacent(sequenceDiffs, (a, b) => {\n            result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));\n        });\n        return result;\n    }\n    static fromOffsetPairs(start, endExclusive) {\n        return new SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));\n    }\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    swap() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n    }\n    deltaStart(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n    }\n    deltaEnd(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n    }\n    intersect(other) {\n        const i1 = this.seq1Range.intersect(other.seq1Range);\n        const i2 = this.seq2Range.intersect(other.seq2Range);\n        if (!i1 || !i2) {\n            return undefined;\n        }\n        return new SequenceDiff(i1, i2);\n    }\n    getStarts() {\n        return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n    }\n    getEndExclusives() {\n        return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n    }\n}\nexport class OffsetPair {\n    constructor(offset1, offset2) {\n        this.offset1 = offset1;\n        this.offset2 = offset2;\n    }\n    toString() {\n        return `${this.offset1} <-> ${this.offset2}`;\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n    }\n    equals(other) {\n        return this.offset1 === other.offset1 && this.offset2 === other.offset2;\n    }\n}\nOffsetPair.zero = new OffsetPair(0, 0);\nOffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\nexport class InfiniteTimeout {\n    isValid() {\n        return true;\n    }\n}\nInfiniteTimeout.instance = new InfiniteTimeout();\nexport class DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\nexport function isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\nexport class LineRangeFragment {\n    static getKey(chr) {\n        let key = this.chrKeys.get(chr);\n        if (key === undefined) {\n            key = this.chrKeys.size;\n            this.chrKeys.set(chr, key);\n        }\n        return key;\n    }\n    constructor(range, lines, source) {\n        this.range = range;\n        this.lines = lines;\n        this.source = source;\n        this.histogram = [];\n        let counter = 0;\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n            const line = lines[i];\n            for (let j = 0; j < line.length; j++) {\n                counter++;\n                const chr = line[j];\n                const key = LineRangeFragment.getKey(chr);\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\n            }\n            counter++;\n            const key = LineRangeFragment.getKey('\\n');\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\n        }\n        this.totalCount = counter;\n    }\n    computeSimilarity(other) {\n        var _a, _b;\n        let sumDifferences = 0;\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\n        for (let i = 0; i < maxLength; i++) {\n            sumDifferences += Math.abs(((_a = this.histogram[i]) !== null && _a !== void 0 ? _a : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));\n        }\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\n    }\n}\nLineRangeFragment.chrKeys = new Map();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        const seqX = seq1; // Text on the x axis\n        const seqY = seq2; // Text on the y axis\n        function getXAfterSnake(x, y) {\n            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        // k=1 -> (1,0),(2,1)\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n            }\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n            const lowerBound = -Math.min(d, seqY.length + (d % 2));\n            const upperBound = Math.min(d, seqX.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                let step = 0;\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n                step++;\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n                const y = x - k;\n                step++;\n                if (x > seqX.length || y > seqY.length) {\n                    // This diagonal is irrelevant for the result.\n                    // TODO: Don't pay the cost for this in the next iteration.\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seqX.length;\n        let lastAligningPosS2 = seqY.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nexport class LinesSliceCharSequence {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLine = [];\n        // To account for trimming\n        this.additionalOffsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        this.firstCharOffsetByLine[0] = 0;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.additionalOffsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.additionalOffsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        if (prevCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // prefer the linebreak before the change\n            return 150;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new Position(this.lineRange.start + 1, 1);\n        }\n        const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);\n        return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.elements[offset1] === this.elements[offset2];\n    }\n    extendToFullLines(range) {\n        var _a, _b;\n        const start = (_a = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start)) !== null && _a !== void 0 ? _a : 0;\n        const end = (_b = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Separator */]: 30,\n    [6 /* CharBoundaryCategory.Space */]: 3,\n    [7 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [8 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 8 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 7 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 6 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {\n        return 5 /* CharBoundaryCategory.Separator */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    // Ignore too short moves\n    moves = moves.filter(current => {\n        const lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n        const originalText = lines.join('\\n');\n        return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction countWhere(arr, predicate) {\n    let count = 0;\n    for (const t of arr) {\n        if (predicate(t)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => new LineRangeFragment(d.original, originalLines, d));\n    const insertions = new Set(changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n    const excludedChanges = new Set();\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(new LineRangeMapping(deletion.range, best.range));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = new SetMap();\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = new LineRange(i, i + 3);\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    // does this match extend some last match?\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n                        lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = new LineRangeSet();\n    const originalSet = new LineRangeSet();\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = new MonotonousArray(changes);\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n            modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n            modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = new MonotonousArray(changes);\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n            || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n    getText(range) {\n        return this.lines.slice(range.start, range.endExclusive).join('\\n');\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.lines[offset1] === this.lines[offset2];\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals, groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Range } from '../../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, RangeMapping } from '../rangeMapping.js';\nexport class DefaultLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n            return new LinesDiff([], [], false);\n        }\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return new LinesDiff([\n                new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n                    new RangeMapping(new Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))\n                ])\n            ], [], false);\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(originalLinesHashes, originalLines);\n        const sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1700) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        let moves = [];\n        if (options.computeMoves) {\n            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n        }\n        // Make sure all ranges are valid\n        assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return new LinesDiff(changes, moves, hitTimeout);\n    }\n    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n        const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n        const movesWithDiffs = moves.map(m => {\n            const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n            return new MovedText(m, mappings);\n        });\n        return movesWithDiffs;\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\n        const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n        diffs = removeShortMatches(slice1, slice2, diffs);\n        diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n        const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of groupAdjacentBy(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original)\n        || a1.modified.overlapOrTouch(a2.modified))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        if (!dontAssertStartLine && changes.length > 0) {\n            if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n                return false;\n            }\n            if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\n                return false;\n            }\n        }\n        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        // We can only do this if the range is not empty yet\n        lineEndDelta = -1;\n    }\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        // We can only do this if the range is not empty yet\n        lineStartDelta = 1;\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    // Sometimes, calling this function twice improves the result.\n    // Uncomment the second invocation and run the tests to see the difference.\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\nexport function removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nexport function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n    const additional = [];\n    let lastPoint = new OffsetPair(0, 0);\n    function scanWord(pair, equalMapping) {\n        if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n            return;\n        }\n        const w1 = sequence1.findWordContaining(pair.offset1);\n        const w2 = sequence2.findWordContaining(pair.offset2);\n        if (!w1 || !w2) {\n            return;\n        }\n        let w = new SequenceDiff(w1, w2);\n        const equalPart = w.intersect(equalMapping);\n        let equalChars1 = equalPart.seq1Range.length;\n        let equalChars2 = equalPart.seq2Range.length;\n        // The words do not touch previous equals mappings, as we would have processed them already.\n        // But they might touch the next ones.\n        while (equalMappings.length > 0) {\n            const next = equalMappings[0];\n            const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n            if (!intersects) {\n                break;\n            }\n            const v1 = sequence1.findWordContaining(next.seq1Range.start);\n            const v2 = sequence2.findWordContaining(next.seq2Range.start);\n            // Because there is an intersection, we know that the words are not empty.\n            const v = new SequenceDiff(v1, v2);\n            const equalPart = v.intersect(next);\n            equalChars1 += equalPart.seq1Range.length;\n            equalChars2 += equalPart.seq2Range.length;\n            w = w.join(v);\n            if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n                // The word extends beyond the next equal mapping.\n                equalMappings.shift();\n            }\n            else {\n                break;\n            }\n        }\n        if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n            additional.push(w);\n        }\n        lastPoint = w.getEndExclusives();\n    }\n    while (equalMappings.length > 0) {\n        const next = equalMappings.shift();\n        if (next.seq1Range.isEmpty) {\n            continue;\n        }\n        scanWord(next.getStarts(), next);\n        // The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n        scanWord(next.getEndExclusives().delta(-1), next);\n    }\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedText = sequence1.getText(unchangedRange);\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n                if (unchangedTextWithoutWs.length <= 4\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    const newDiffs = [];\n    // Remove short suffixes/prefixes\n    forEachWithNeighbors(diffs, (prev, cur, next) => {\n        let newDiff = cur;\n        function shouldMarkAsChanged(text) {\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n        }\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n        const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n        if (shouldMarkAsChanged(prefix)) {\n            newDiff = newDiff.deltaStart(-prefix.length);\n        }\n        const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n        if (shouldMarkAsChanged(suffix)) {\n            newDiff = newDiff.deltaEnd(suffix.length);\n        }\n        const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n        const result = newDiff.intersect(availableSpace);\n        if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n            newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n        }\n        else {\n            newDiffs.push(result);\n        }\n    });\n    return newDiffs;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LinesDiff {\n    constructor(changes, \n    /**\n     * Sorted by original line ranges.\n     * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n     */\n    moves, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.moves = moves;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class MovedText {\n    constructor(lineRangeMapping, changes) {\n        this.lineRangeMapping = lineRangeMapping;\n        this.changes = changes;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class LegacyLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n        });\n        return new LinesDiff(changes, [], result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    getLegacy: () => new LegacyLinesDiffComputer(),\n    getDefault: () => new DefaultLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Range } from '../core/range.js';\nimport { SingleTextEdit } from '../core/textEdit.js';\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\n            if (!r.modified.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\n        if (!r.modified.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    static clip(mapping, originalRange, modifiedRange) {\n        const result = [];\n        for (const m of mapping) {\n            const original = m.original.intersect(originalRange);\n            const modified = m.modified.intersect(modifiedRange);\n            if (original && !original.isEmpty && modified && !modified.isEmpty) {\n                result.push(new LineRangeMapping(original, modified));\n            }\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange) {\n        this.original = originalRange;\n        this.modified = modifiedRange;\n    }\n    toString() {\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\n    }\n    flip() {\n        return new LineRangeMapping(this.modified, this.original);\n    }\n    join(other) {\n        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping() {\n        const origInclusiveRange = this.original.toInclusiveRange();\n        const modInclusiveRange = this.modified.toInclusiveRange();\n        if (origInclusiveRange && modInclusiveRange) {\n            return new RangeMapping(origInclusiveRange, modInclusiveRange);\n        }\n        else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n                // If one line range starts at 1, the other one must start at 1 as well.\n                throw new BugIndicatingError('not a valid diff');\n            }\n            // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n            // Thus, `endLineNumberExclusive` is a valid line number.\n            return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        else {\n            // We can assume here that both startLineNumbers are greater than 1.\n            return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n        }\n    }\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n    static fromRangeMappings(rangeMappings) {\n        const originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n        const modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n        return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        super(originalRange, modifiedRange);\n        this.innerChanges = innerChanges;\n    }\n    flip() {\n        var _a;\n        return new DetailedLineRangeMapping(this.modified, this.original, (_a = this.innerChanges) === null || _a === void 0 ? void 0 : _a.map(c => c.flip()));\n    }\n    withInnerChangesFromLineRanges() {\n        return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    flip() {\n        return new RangeMapping(this.modifiedRange, this.originalRange);\n    }\n    /**\n     * Creates a single text edit that describes the change from the original to the modified text.\n    */\n    toTextEdit(modified) {\n        const newText = modified.getValueOfRange(this.modifiedRange);\n        return new SingleTextEdit(this.originalRange, newText);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, metadata, _precondition, _run, _contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this.metadata = metadata;\n        this._precondition = _precondition;\n        this._run = _run;\n        this._contextKeyService = _contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run(args) {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run(args);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read-only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.isEmbeddedDiffEditor = new RawContextKey('isEmbeddedDiffEditor', false, nls.localize('isEmbeddedDiffEditor', \"Whether the context is an embedded diff editor\"));\n    EditorContextKeys.inMultiDiffEditor = new RawContextKey('inMultiDiffEditor', false, nls.localize('inMultiDiffEditor', \"Whether the context is a multi diff editor\"));\n    EditorContextKeys.multiDiffEditorAllCollapsed = new RawContextKey('multiDiffEditorAllCollapsed', undefined, nls.localize('multiDiffEditorAllCollapsed', \"Whether all files in multi diff editor are collapsed\"));\n    EditorContextKeys.hasChanges = new RawContextKey('diffEditorHasChanges', false, nls.localize('diffEditorHasChanges', \"Whether the diff editor has changes\"));\n    EditorContextKeys.comparingMovedCode = new RawContextKey('comparingMovedCode', false, nls.localize('comparingMovedCode', \"Whether a moved code block is selected for comparison\"));\n    EditorContextKeys.accessibleDiffViewerVisible = new RawContextKey('accessibleDiffViewerVisible', false, nls.localize('accessibleDiffViewerVisible', \"Whether the accessible diff viewer is visible\"));\n    EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached = new RawContextKey('diffEditorRenderSideBySideInlineBreakpointReached', false, nls.localize('diffEditorRenderSideBySideInlineBreakpointReached', \"Whether the diff editor render side by side inline breakpoint is reached\"));\n    EditorContextKeys.diffEditorInlineMode = new RawContextKey('diffEditorInlineMode', false, nls.localize('diffEditorInlineMode', \"Whether inline mode is active\"));\n    EditorContextKeys.diffEditorOriginalWritable = new RawContextKey('diffEditorOriginalWritable', false, nls.localize('diffEditorOriginalWritable', \"Whether modified is writable in the diff editor\"));\n    EditorContextKeys.diffEditorModifiedWritable = new RawContextKey('diffEditorModifiedWritable', false, nls.localize('diffEditorModifiedWritable', \"Whether modified is writable in the diff editor\"));\n    EditorContextKeys.diffEditorOriginalUri = new RawContextKey('diffEditorOriginalUri', '', nls.localize('diffEditorOriginalUri', \"The uri of the original document\"));\n    EditorContextKeys.diffEditorModifiedUri = new RawContextKey('diffEditorModifiedUri', '', nls.localize('diffEditorModifiedUri', \"The uri of the modified document\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInEmbeddedEditor = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    EditorContextKeys.hoverFocused = new RawContextKey('editorHoverFocused', false, nls.localize('editorHoverFocused', \"Whether the editor hover is focused\"));\n    EditorContextKeys.stickyScrollFocused = new RawContextKey('stickyScrollFocused', false, nls.localize('stickyScrollFocused', \"Whether the sticky scroll is focused\"));\n    EditorContextKeys.stickyScrollVisible = new RawContextKey('stickyScrollVisible', false, nls.localize('stickyScrollVisible', \"Whether the sticky scroll is visible\"));\n    EditorContextKeys.standaloneColorPickerVisible = new RawContextKey('standaloneColorPickerVisible', false, nls.localize('standaloneColorPickerVisible', \"Whether the standalone color picker is visible\"));\n    EditorContextKeys.standaloneColorPickerFocused = new RawContextKey('standaloneColorPickerFocused', false, nls.localize('standaloneColorPickerFocused', \"Whether the standalone color picker is focused\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst editorFeatures = [];\n/**\n * Registers an editor feature. Editor features will be instantiated only once, as soon as\n * the first code editor is instantiated.\n */\nexport function registerEditorFeature(ctor) {\n    editorFeatures.push(ctor);\n}\nexport function getEditorFeatures() {\n    return editorFeatures.slice(0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    constructor(theme) {\n        this._theme = theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n"],"names":["DiffAlgorithmResult","trivial","seq1","seq2","SequenceDiff","OffsetRange","ofLength","length","trivialTimedOut","constructor","diffs","hitTimeout","this","invert","sequenceDiffs","doc1Length","result","forEachAdjacent","a","b","push","fromOffsetPairs","getEndExclusives","OffsetPair","zero","getStarts","seq2Range","endExclusive","seq1Range","start","offset1","offset2","swap","toString","concat","join","other","delta","offset","deltaStart","deltaEnd","intersect","i1","i2","equals","max","Number","MAX_SAFE_INTEGER","InfiniteTimeout","isValid","instance","DateTimeout","timeout","startTime","Date","now","valid","BugIndicatingError","Array2D","width","height","array","Array","get","x","y","set","value","isSpace","charCode","LineRangeFragment","getKey","chr","key","chrKeys","undefined","size","range","lines","source","histogram","counter","i","startLineNumber","endLineNumberExclusive","line","j","totalCount","computeSimilarity","_a","_b","sumDifferences","maxLength","Math","abs","Map","DynamicProgrammingDiffing","compute","sequence1","sequence2","arguments","equalityScore","lcsLengths","directions","lengths","s1","s2","horizontalLen","verticalLen","extendedSeqScore","getElement","newValue","prevLen","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","reverse","MyersDiffAlgorithm","seqX","seqY","getXAfterSnake","d","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","k","loop","lowerBound","min","upperBound","step","maxXofDLineTop","maxXofDLineLeft","newMaxX","lastPath","path","endX","endY","prev","positiveArr","Int32Array","negativeArr","idx","arr","LinesSliceCharSequence","lineRange","considerWhitespaceChanges","elements","firstCharOffsetByLine","additionalOffsetByLine","trimFirstLineFully","trimmedStartLine","trimStart","trimEnd","charCodeAt","text","getText","slice","map","e","String","fromCharCode","getBoundaryScore","prevCategory","getCategory","nextCategory","score","getCategoryBoundaryScore","translateOffset","isEmpty","Position","findLastIdxMonotonous","translateRange","Range","fromPositions","findWordContaining","isWordChar","end","countLinesIn","lineNumber","isStronglyEqual","extendToFullLines","findLastMonotonous","findFirstMonotonous","category","computeMovedLines","changes","originalLines","modifiedLines","hashedOriginalLines","hashedModifiedLines","moves","excludedChanges","deletions","filter","c","modified","original","insertions","Set","deletion","best","highestSimilarity","insertion","similarity","delete","LineRangeMapping","add","computeMovesFromSimpleDeletionsToSimpleInsertions","unchangedMoves","original3LineHashes","SetMap","change","LineRange","possibleMappings","sort","compareBy","numberComparator","lastMappings","currentModifiedRange","nextMappings","forEach","_ref","lastMapping","originalLineRange","modifiedLineRange","mapping","reverseOrder","m","modifiedSet","LineRangeSet","originalSet","diffOrigToMod","modifiedSections","subtractFrom","originalTranslatedSections","getWithDelta","modifiedIntersectedSections","getIntersection","s","ranges","addRange","monotonousChanges","MonotonousArray","move","firstTouchingChangeOrig","firstTouchingChangeMod","linesAbove","lastTouchingChangeOrig","lastTouchingChangeMod","linesBelow","extendToTop","extendToBottom","origLine","modLine","contains","areLinesSimilar","computeUnchangedMoves","has","pushMany","last","current","originalDist","modifiedDist","joinCloseConsecutiveMoves","toOffsetRange","l","trim","predicate","count","t","countWhere","changesMonotonous","removeMovesInSameDiff","line1","line2","commonNonSpaceCharCount","inverted","seq","longerLineLength","str","countNonWsChars","LineSequence","trimmedHash","getIndentation","DefaultLinesDiffComputer","dynamicProgrammingDiffing","myersDiffingAlgorithm","computeDiff","options","LinesDiff","DetailedLineRangeMapping","RangeMapping","maxComputationTimeMs","ignoreTrimWhitespace","perfectHashes","getOrCreateHash","hash","originalLinesHashes","modifiedLinesHashes","lineAlignmentResult","log","lineAlignments","optimizeSequenceDiffs","removeVeryShortMatchingLinesBetweenDiffs","alignments","scanForWhitespaceChanges","equalLinesCount","seq1Offset","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","mappings","diff","assertFn","lineRangeMappingFromRangeMappings","computeMoves","validatePosition","pos","column","validateRange","innerChanges","ic","modifiedRange","getStartPosition","getEndPosition","originalRange","MovedText","slice1","slice2","diffResult","extendDiffsToEntireWordIfAppropriate","removeShortMatches","removeVeryShortMatchingTextBetweenLongDiffs","dontAssertStartLine","g","groupAdjacentBy","rangeMapping","lineStartDelta","lineEndDelta","endColumn","endLineNumber","startColumn","getLineRangeMapping","a1","a2","overlapOrTouch","first","checkAdjacentItems","m1","m2","joinSequenceDiffsByShifting","prevDiff","nextDiff","seq1ValidRange","seq2ValidRange","shiftDiffToBetterPosition","shiftSequenceDiffs","prevResult","cur","result2","nextResult","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","equalMappings","additional","lastPoint","scanWord","pair","equalMapping","w1","w2","w","equalPart","equalChars1","equalChars2","next","intersects","v1","v2","v","shift","sequenceDiffs1","sequenceDiffs2","sd1","sd2","mergeSequenceDiffs","_sequence2","shouldRepeat","lastResult","shouldJoinDiffs","before","after","unchangedRange","replace","unchangedText","split","beforeLineCount1","beforeSeq1Length","beforeLineCount2","beforeSeq2Length","afterLineCount1","afterSeq1Length","afterLineCount2","afterSeq2Length","cap","pow","newDiffs","forEachWithNeighbors","newDiff","shouldMarkAsChanged","fullRange1","prefix","suffix","availableSpace","lineRangeMapping","LegacyLinesDiffComputer","DiffComputer","maxComputationTime","shouldIgnoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","lastChange","originalEndLineNumber","originalStartLineNumber","modifiedEndLineNumber","modifiedStartLineNumber","charChanges","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","pop","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","getElements","len","substring","getStrictElement","index","getStartLineNumber","getEndLineNumber","createCharSequence","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","col","CharSequence","_charCodes","_lineNumbers","_columns","_assertIndex","Error","getStartColumn","getEndColumn","CharChange","createFromDiffChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","LineChange","createFromDiffResult","originalLineSequence","modifiedLineSequence","continueCharDiff","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","postProcessCharChanges","opts","continueLineDiff","createContinueProcessingPredicate","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","strings","maximumRuntime","linesDiffComputers","getLegacy","getDefault","inverse","originalLineCount","modifiedLineCount","lastOriginalEndLineNumber","lastModifiedEndLineNumber","clip","flip","toRangeMapping","origInclusiveRange","toInclusiveRange","modInclusiveRange","fromRangeMappings","rangeMappings","fromRangeInclusive","super","withInnerChangesFromLineRanges","toTextEdit","newText","getValueOfRange","SingleTextEdit","InternalEditorAction","id","label","alias","metadata","_precondition","_run","_contextKeyService","isSupported","contextMatchesRules","run","args","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","nls","focus","textInputFocus","readOnly","inDiffEditor","isEmbeddedDiffEditor","inMultiDiffEditor","multiDiffEditorAllCollapsed","hasChanges","comparingMovedCode","accessibleDiffViewerVisible","diffEditorRenderSideBySideInlineBreakpointReached","diffEditorInlineMode","diffEditorOriginalWritable","diffEditorModifiedWritable","diffEditorOriginalUri","diffEditorModifiedUri","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInEmbeddedEditor","canUndo","canRedo","hoverVisible","hoverFocused","stickyScrollFocused","stickyScrollVisible","standaloneColorPickerVisible","standaloneColorPickerFocused","inCompositeEditor","notInCompositeEditor","languageId","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","editorFeatures","registerEditorFeature","ctor","getEditorFeatures","EditorTheme","type","_theme","theme","update","getColor","color"],"sourceRoot":""}