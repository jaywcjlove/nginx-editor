{"version":3,"file":"static/js/monaco-editor-vendor.4ec6fe68.2e4134a9.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/position.js","../node_modules/monaco-editor/esm/vs/editor/common/core/range.js","../node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js","../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursorCommon.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        asciiMap.fill(defaultValue);\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n    clear() {\n        this._asciiMap.fill(this._defaultValue);\n        this._map.clear();\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n    clear() {\n        return this._actual.clear();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'), true);\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nexport const deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'), false, nls.localize('deprecatedEditorIndentGuides', '\\'editorIndentGuide.background\\' is deprecated. Use \\'editorIndentGuide.background1\\' instead.'));\nexport const deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'), false, nls.localize('deprecatedEditorActiveIndentGuide', '\\'editorIndentGuide.activeBackground\\' is deprecated. Use \\'editorIndentGuide.activeBackground1\\' instead.'));\nexport const editorIndentGuide1 = registerColor('editorIndentGuide.background1', { dark: deprecatedEditorIndentGuides, light: deprecatedEditorIndentGuides, hcDark: deprecatedEditorIndentGuides, hcLight: deprecatedEditorIndentGuides }, nls.localize('editorIndentGuides1', 'Color of the editor indentation guides (1).'));\nexport const editorIndentGuide2 = registerColor('editorIndentGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides2', 'Color of the editor indentation guides (2).'));\nexport const editorIndentGuide3 = registerColor('editorIndentGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides3', 'Color of the editor indentation guides (3).'));\nexport const editorIndentGuide4 = registerColor('editorIndentGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides4', 'Color of the editor indentation guides (4).'));\nexport const editorIndentGuide5 = registerColor('editorIndentGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides5', 'Color of the editor indentation guides (5).'));\nexport const editorIndentGuide6 = registerColor('editorIndentGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorIndentGuides6', 'Color of the editor indentation guides (6).'));\nexport const editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', { dark: deprecatedEditorActiveIndentGuides, light: deprecatedEditorActiveIndentGuides, hcDark: deprecatedEditorActiveIndentGuides, hcLight: deprecatedEditorActiveIndentGuides }, nls.localize('editorActiveIndentGuide1', 'Color of the active editor indentation guides (1).'));\nexport const editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide2', 'Color of the active editor indentation guides (2).'));\nexport const editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide3', 'Color of the active editor indentation guides (3).'));\nexport const editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide4', 'Color of the active editor indentation guides (4).'));\nexport const editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide5', 'Color of the active editor indentation guides (5).'));\nexport const editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorActiveIndentGuide6', 'Color of the active editor indentation guides (6).'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hcDark: deprecatedEditorActiveLineNumber, hcLight: deprecatedEditorActiveLineNumber }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\nexport const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hcDark: rulerRangeDefault, hcLight: rulerRangeDefault }, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', { dark: '#BD9B03', light: '#CEA33D', hcDark: '#ff0000', hcLight: '#CEA33D' }, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', { dark: '#bd9b0326', light: '#cea33d14', hcDark: '#00000000', hcLight: '#cea33d14' }, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Range } from './range.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRange(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber);\n    }\n    static subtract(a, b) {\n        if (!b) {\n            return [a];\n        }\n        if (a.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a.endLineNumberExclusive) {\n            return [\n                new LineRange(a.startLineNumber, b.startLineNumber),\n                new LineRange(b.endLineNumberExclusive, a.endLineNumberExclusive)\n            ];\n        }\n        else if (b.startLineNumber <= a.startLineNumber && a.endLineNumberExclusive <= b.endLineNumberExclusive) {\n            return [];\n        }\n        else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {\n            return [new LineRange(Math.max(b.endLineNumberExclusive, a.startLineNumber), a.endLineNumberExclusive)];\n        }\n        else {\n            return [new LineRange(a.startLineNumber, Math.min(b.startLineNumber, a.endLineNumberExclusive))];\n        }\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = lineRanges[0];\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = this.join(result, lineRanges[i]);\n        }\n        return result;\n    }\n    /**\n     * @param lineRanges1 Must be sorted.\n     * @param lineRanges2 Must be sorted.\n     */\n    static join(lineRanges1, lineRanges2) {\n        if (lineRanges1.length === 0) {\n            return lineRanges2;\n        }\n        if (lineRanges2.length === 0) {\n            return lineRanges1;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < lineRanges1.length || i2 < lineRanges2.length) {\n            let next = null;\n            if (i1 < lineRanges1.length && i2 < lineRanges2.length) {\n                const lineRange1 = lineRanges1[i1];\n                const lineRange2 = lineRanges2[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < lineRanges1.length) {\n                next = lineRanges1[i1];\n                i1++;\n            }\n            else {\n                next = lineRanges2[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return result;\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange {\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return new OffsetRange(start, endExclusive);\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    equals(other) {\n        return this.start === other.start && this.endExclusive === other.endExclusive;\n    }\n    containsRange(other) {\n        return this.start <= other.start && other.endExclusive <= this.endExclusive;\n    }\n    contains(offset) {\n        return this.start <= offset && offset < this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return new OffsetRange(start, end);\n        }\n        return undefined;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\nRGBA8.Empty = new RGBA8(0, 0, 0, 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators) {\n        super(0 /* WordCharacterClass.Regular */);\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n}\nfunction once(computeFn) {\n    const cache = {}; // TODO@Alex unbounded cache\n    return (input) => {\n        if (!cache.hasOwnProperty(input)) {\n            cache[input] = computeFn(input);\n        }\n        return cache[input];\n    };\n}\nexport const getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        if (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n            // Avoid selecting text when recovering from markers\n            return Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n        }\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy, findLastMaxBy, findMinBy } from '../../../base/common/arrays.js';\nimport { CursorState } from '../cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findMinBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMaxBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CursorContext {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        this._cursorContextBrand = undefined;\n        this.model = model;\n        this.viewModel = viewModel;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealPrimary(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../core/cursorColumns.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Direction.Left */:\n                left = true;\n                break;\n            case 1 /* Direction.Right */:\n                left = false;\n                break;\n            case 2 /* Direction.Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* CharCode.Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* CharCode.Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 2 /* SelectionStartKind.Line */, 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(true, viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(true, selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(true, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        if (inSelectionMode) {\n            if (cursor.modelState.selectionStartKind === 1 /* SelectionStartKind.Word */) {\n                return this.word(viewModel, cursor, inSelectionMode, _position);\n            }\n            if (cursor.modelState.selectionStartKind === 2 /* SelectionStartKind.Line */) {\n                return this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n            }\n        }\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.description = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let i = 0;\n        let r;\n        do {\n            r = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n            const np = model.normalizePosition(new Position(r.lineNumber, r.column), 2 /* PositionAffinity.None */);\n            if (np.lineNumber > lineNumber) {\n                break;\n            }\n        } while (i++ < 10 && lineNumber + i < model.getLineCount());\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n            if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        const chIsQuote = isQuote(ch);\n        const autoCloseConfig = (chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets);\n        const shouldAutoCloseBefore = (chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket);\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './core/position.js';\nimport { Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { createScopedLineTokens } from './languages/supports.js';\nimport { CursorColumns } from './core/cursorColumns.js';\nimport { normalizeIndentation } from './core/indentation.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    static shouldRecreate(e) {\n        return (e.hasChanged(142 /* EditorOption.layoutInfo */)\n            || e.hasChanged(128 /* EditorOption.wordSeparators */)\n            || e.hasChanged(36 /* EditorOption.emptySelectionClipboard */)\n            || e.hasChanged(75 /* EditorOption.multiCursorMergeOverlapping */)\n            || e.hasChanged(77 /* EditorOption.multiCursorPaste */)\n            || e.hasChanged(78 /* EditorOption.multiCursorLimit */)\n            || e.hasChanged(6 /* EditorOption.autoClosingBrackets */)\n            || e.hasChanged(10 /* EditorOption.autoClosingQuotes */)\n            || e.hasChanged(8 /* EditorOption.autoClosingDelete */)\n            || e.hasChanged(9 /* EditorOption.autoClosingOvertype */)\n            || e.hasChanged(13 /* EditorOption.autoSurround */)\n            || e.hasChanged(126 /* EditorOption.useTabStops */)\n            || e.hasChanged(49 /* EditorOption.fontInfo */)\n            || e.hasChanged(89 /* EditorOption.readOnly */));\n    }\n    constructor(languageId, modelOptions, configuration, languageConfigurationService) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._cursorMoveConfigurationBrand = undefined;\n        this._languageId = languageId;\n        const options = configuration.options;\n        const layoutInfo = options.get(142 /* EditorOption.layoutInfo */);\n        const fontInfo = options.get(49 /* EditorOption.fontInfo */);\n        this.readOnly = options.get(89 /* EditorOption.readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(114 /* EditorOption.stickyTabStops */);\n        this.lineHeight = fontInfo.lineHeight;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(126 /* EditorOption.useTabStops */);\n        this.wordSeparators = options.get(128 /* EditorOption.wordSeparators */);\n        this.emptySelectionClipboard = options.get(36 /* EditorOption.emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(24 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(75 /* EditorOption.multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(77 /* EditorOption.multiCursorPaste */);\n        this.multiCursorLimit = options.get(78 /* EditorOption.multiCursorLimit */);\n        this.autoClosingBrackets = options.get(6 /* EditorOption.autoClosingBrackets */);\n        this.autoClosingQuotes = options.get(10 /* EditorOption.autoClosingQuotes */);\n        this.autoClosingDelete = options.get(8 /* EditorOption.autoClosingDelete */);\n        this.autoClosingOvertype = options.get(9 /* EditorOption.autoClosingOvertype */);\n        this.autoSurround = options.get(13 /* EditorOption.autoSurround */);\n        this.autoIndent = options.get(11 /* EditorOption.autoIndent */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: this._getShouldAutoClose(languageId, this.autoClosingQuotes, true),\n            bracket: this._getShouldAutoClose(languageId, this.autoClosingBrackets, false)\n        };\n        this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoClosingPairs();\n        const surroundingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getSurroundingPairs();\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n    }\n    get electricChars() {\n        var _a;\n        if (!this._electricChars) {\n            this._electricChars = {};\n            const electricChars = (_a = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || _a === void 0 ? void 0 : _a.getElectricCharacters();\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        const electricCharacterSupport = this.languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).electricCharacter;\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    normalizeIndentation(str) {\n        return normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    _getShouldAutoClose(languageId, autoCloseConfig, forQuotes) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return this._getLanguageDefinedShouldAutoClose(languageId, forQuotes);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    _getLanguageDefinedShouldAutoClose(languageId, forQuotes) {\n        const autoCloseBeforeSet = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoCloseBeforeSet(forQuotes);\n        return c => autoCloseBeforeSet.indexOf(c) !== -1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    visibleColumnFromColumn(model, position) {\n        return CursorColumns.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, this.tabSize);\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    columnFromVisibleColumn(model, lineNumber, visibleColumn) {\n        const result = CursorColumns.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, this.tabSize);\n        const minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n}\nexport class CursorState {\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selection = Selection.liftSelection(modelSelection);\n        const modelState = new SingleCursorState(Range.fromPositions(selection.getSelectionStart()), 0 /* SelectionStartKind.Simple */, 0, selection.getPosition(), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        const states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    constructor(modelState, viewState) {\n        this._cursorStateBrand = undefined;\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this.selectionStart = selectionStart;\n        this.selectionStartKind = selectionStartKind;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this._singleCursorStateBrand = undefined;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.selectionStartKind === other.selectionStartKind\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        if (selectionStart.isEmpty() || !position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n            return Selection.fromPositions(selectionStart.getStartPosition(), position);\n        }\n        else {\n            return Selection.fromPositions(selectionStart.getEndPosition(), position);\n        }\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this._editOperationResultBrand = undefined;\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n"],"names":["CharacterClassifier","_defaultValue","_classCallCheck","defaultValue","toUint8","this","_asciiMap","_createAsciiMap","_map","Map","_createClass","key","value","charCode","_value","set","get","fill","clear","asciiMap","Uint8Array","CharacterSet","_actual","CursorColumns","codePoint","visibleColumn","tabSize","nextRenderTabStop","strings","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","offset","nextGraphemeLength","_nextVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","indentSize","max","EditOperation","position","range","Range","lineNumber","forceMoveMarkers","editorLineHighlight","registerColor","dark","light","hcDark","hcLight","nls","editorLineHighlightBorder","contrastBorder","editorCursorForeground","activeContrastBorder","editorFindMatchHighlight","Color","black","white","editorCursorBackground","editorWhitespaces","editorLineNumbers","deprecatedEditorIndentGuides","deprecatedEditorActiveIndentGuides","editorIndentGuide1","editorIndentGuide2","editorIndentGuide3","editorIndentGuide4","editorIndentGuide5","editorIndentGuide6","editorActiveIndentGuide1","editorActiveIndentGuide2","editorActiveIndentGuide3","editorActiveIndentGuide4","editorActiveIndentGuide5","editorActiveIndentGuide6","deprecatedEditorActiveLineNumber","editorDimmedLineNumber","editorOverviewRulerBorder","lightgrey","editorOverviewRulerBackground","editorUnnecessaryCodeOpacity","editorBackground","fromHex","transparent","rulerRangeDefault","RGBA","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","editorWarningForeground","editorWarningBorder","overviewRulerInfo","editorInfoForeground","editorInfoBorder","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","registerThemingParticipant","theme","collector","background","getColor","lineHighlight","imeBackground","isTransparent","addRule","concat","countEOL","eolCount","firstLineLength","lastLineStart","i","len","chr","charCodeAt","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","spacesCnt","charAt","nextIndentTabStop","tabsCnt","floor","_normalizeIndentationFromWhitespace","LineRange","startLineNumber","endLineNumberExclusive","BugIndicatingError","other","b","isEmpty","Number","MAX_SAFE_INTEGER","f","push","endLineNumber","a","lineRanges","join","lineRanges1","lineRanges2","i1","i2","current","next","lineRange1","lineRange2","lineRange","OffsetRange","start","endExclusive","toString","end","sortedRanges","j","splice","Position","newLineNumber","arguments","undefined","newColumn","deltaLineNumber","deltaColumn","with","equals","isBefore","isBeforeOrEqual","aLineNumber","bLineNumber","pos","obj","startColumn","endColumn","containsPosition","containsRange","strictContainsRange","plusRange","intersectRanges","equalsRange","getEndPosition","getStartPosition","collapseToStart","collapseToEnd","lineCount","otherRange","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","RGBA8","r","g","_rgba8Brand","_clamp","c","Empty","Selection","_Range","_inherits","_super","_createSuper","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_this","call","selectionsEqual","getDirection","direction","sel","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","platform","decodeUTF16LE","source","view","Uint16Array","buffer","resultLen","String","fromCharCode","compatDecodeUTF16LE","decode","StringBuilder","capacity","_capacity","_buffer","_completedStrings","_bufferLength","_flushBuffer","_buildBuffer","bufferString","remainingSpace","strLen","escapeNewLine","replace","TextChange","oldPosition","oldText","newPosition","newText","_writeStringSize","_writeString","dest","_readString","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","oldEnd","_acceptCurr","newEnd","_acceptPrev","_TextChangeCompressor","_splitCurr","_TextChangeCompressor2","_slicedToArray","e1","e2","_TextChangeCompressor3","_splitPrev","_TextChangeCompressor4","mergePrev","mergeCurr","_TextChangeCompressor5","oldLength","_TextChangeCompressor6","_TextChangeCompressor7","newLength","_TextChangeCompressor8","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","prev","curr","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","independentColorPoolPerBracketType","WordCharacterClassifier","_CharacterClassifier","wordSeparators","getMapForWordSeparators","computeFn","cache","input","hasOwnProperty","once","USUAL_WORD_SEPARATORS","DEFAULT_WORD_REGEXP","_step","allowInWords","_iterator","_createForOfIteratorHelper","s","n","done","sep","indexOf","err","e","RegExp","createWordRegExp","ensureValidWordDefinition","wordDefinition","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","LinkedList","getWordAtText","textOffset","config","Iterable","first","maxLen","t1","Date","now","prevRegexIndex","match","timeBudget","regexIndex","windowSize","thisMatch","_findRegexMatchEnclosingPosition","word","index","stopPos","exec","matchIndex","unshift","Cursor","context","_selTrackedRange","_trackSelection","_setState","SingleCursorState","_removeTrackedRange","_updateTrackedRange","model","_setTrackedRange","modelState","selection","CursorState","viewState","_getTrackedRange","fromRange","_validateViewState","viewModel","selectionStart","validateRange","selectionStartLeftoverVisibleColumns","validatePosition","leftoverVisibleColumns","selectionStartKind","coordinatesConverter","convertViewRangeToModelRange","convertViewPositionToModelPosition","viewSelectionStart","validateViewRange","viewPosition","validateViewPosition","viewSelectionStart1","convertModelPositionToViewPosition","viewSelectionStart2","cacheInput","cacheOutput","normalizePosition","sStartPosition","sEndPosition","validPosition","validSStartPosition","_validatePositionWithCache","validSEndPosition","fromPositions","CursorCollection","cursors","lastAddedCursorIndex","dispose","_step2","_iterator2","startTrackingSelection","_step3","_iterator3","stopTrackingSelection","_step4","_iterator4","ensureValidState","map","readSelectionFromMarkers","asCursorState","findMinBy","compareBy","compare","findLastMaxBy","selections","setStates","fromModelSelections","states","setState","_setSecondaryStates","slice","secondaryStates","secondaryCursorsLength","secondaryStatesLength","createCnt","_addSecondaryCursor","removeCnt","_removeSecondaryCursor","removeIndex","sortedCursors","sort","compareRangesUsingStarts","sortedCursorIndex","currentSelection","nextSelection","cursorConfig","multiCursorMergeOverlapping","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","equalsSelection","resultingRange","looserSelectionIsLTR","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingSelection","resultingState","fromModelSelection","_step5","_iterator5","sortedCursor","CursorContext","_cursorContextBrand","CursorsController","_Disposable","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","_cursors","_hasFocus","_isHandling","_compositionState","_columnSelectData","_autoClosedActions","_prevEditOperationType","_get","_getPrototypeOf","prototype","updateContext","eventsCollector","getCursorStates","hasFocus","getSelections","autoClosedAction","isValid","getPrimaryCursor","getLastAddedCursorIndex","getAll","reason","reachedMaxCursorCount","multiCursorLimit","oldState","CursorModelState","from","normalize","_validateAutoClosedActions","_emitStateChangedIfNecessary","columnSelectData","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","emitViewEvent","ViewRevealRangeRequestEvent","inSelectionMode","desiredSelections","state","revealPrimary","event","ModelInjectedTextChangedEvent","rawContentChangedEvent","versionId","hadFlushEvent","containsEvent","cursorState","isUndoing","isRedoing","selectionsFromMarkers","getTopMostViewPosition","getBottomMostViewPosition","primaryCursor","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","type","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","TypeWithAutoClosingCommand","enclosingRange","closeCharacterRange","_pushAutoClosedAction","shouldPushStackElementAfter","setSelections","newState","viewSelections","ViewCursorStateChangedEvent","some","newCursorState","oldSelections","oldModelVersionId","modelVersionId","emitOutgoingEvent","CursorStateChangedEvent","indices","m","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","cursorStateComputer","_this2","autoClosingIndices","_findAutoClosingPairs","_isTracked","pushEditOperations","undoEdits","_autoClosingIndices$i","openCharInnerIndex","closeCharInnerIndex","undoEdit","callback","cursorChangeReason","readOnly","stopTrackingSelections","onUnexpectedError","startTrackingSelections","getAllAutoClosedCharacters","CompositionState","_this3","compositionOutcome","deduceOutcome","_executeEdit","_executeEditOperation","TypeOperations","compositionEndWithInterceptors","getAutoClosedCharacters","_this4","charLength","typeWithInterceptors","typeWithoutInterceptors","replacePrevCharCnt","replaceNextCharCnt","positionDelta","_this5","compositionType","newSelections","getPosition","pasteOnNewLine","multicursorText","_this6","paste","_this7","DeleteOperations","cut","_this8","killSecondaryCursors","EditOperationResult","_this9","Disposable","cursor","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","decorationRange","getDecorationRange","enclosingRanges","autoClosedActions","autoClosedCharacters","getAutoClosedCharactersRanges","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","console","warn","filteredOperations","identifier","major","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","minor","cursorSelections","_loop","_i3","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","losingCursors","losingCursorIndex","_i4","_losingCursors","losingCursor","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","isAutoWhitespaceEdit","insertsAutoWhitespace","editOperationBuilder","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","loserMajor","CompositionLineState","startSelection","endSelection","textModel","_original","_capture","_deduceOutcome","getLineContent","original","commonPrefix","commonSuffix","deletedText","insertedText","CompositionOutcome","AtomicTabMoveOperations","lineLength","prevTabStopPosition","prevTabStopVisibleColumn","left","_AtomicTabMoveOperati","whitespaceVisibleColumn","_AtomicTabMoveOperati2","currentVisibleColumn","targetVisibleColumn","ColumnSelection","fromLineNumber","fromVisibleColumn","toLineNumber","toVisibleColumn","abs","reversed","isRTL","isLTR","columnFromVisibleColumn","visibleStartColumn","visibleEndColumn","maxColumn","viewStates","fromVisualColumn","toVisualColumn","prevColumnSelectData","columnSelect","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","isPaged","linesCount","pageSize","getLineCount","prevEditOperationType","deleteSelection","rightOfPosition","MoveOperations","right","ReplaceCommand","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","lineText","character","autoClosingPairCandidates","isQuote","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","close","found","lenJ","autoClosedCharacter","isAutoClosingPairDelete","autoClosingPairsOpenByEnd","_runAutoClosingPairDelete","deleteRange","getDeleteRange","useTabStops","lastIndentationColumn","prevIndentTabStop","toColumn","getPositionAfterDeleteLeft","newLine","lastCutRange","emptySelectionClipboard","CursorMove","CursorMoveCommands","useLogicalLine","fromModelState","translateDown","fromViewState","translateUp","_moveToLineStart","currentViewStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","firstNonBlankColumn","getLineFirstNonWhitespaceColumn","_moveToLineStartByModel","_moveToLineStartByView","moveToBeginningOfLine","sticky","_moveToLineEnd","viewStatePosition","viewModelMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_moveToLineEndByModel","_moveToLineEndByView","moveToEndOfLine","moveToBeginningOfBuffer","moveToEndOfBuffer","_position","_viewPosition","selectToLineNumber","selectToColumn","enteringLineNumber","move","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","WordOperations","hasSelection","line","unit","_moveHalfLineLeft","_moveLeft","_moveHalfLineRight","_moveRight","_moveUpByViewLines","_moveUpByModelLines","_moveDownByViewLines","_moveDownByModelLines","moveToPrevBlankLine","moveToNextBlankLine","_moveToViewMinColumn","_moveToViewFirstNonWhitespaceColumn","_moveToViewCenterColumn","_moveToViewMaxColumn","_moveToViewLastNonWhitespaceColumn","visibleViewRange","getCompletelyVisibleViewRange","visibleModelRange","modelLineNumber","_firstLineNumberInRange","modelColumn","_moveToModelPosition","_lastLineNumberInRange","round","findPositionInViewportIfOutside","newViewLineNumber","viewLineNumber","vertical","count","getLineMinColumn","noOfColumns","moveLeft","halfLine","moveRight","moveDown","moveUp","toViewColumn","toModelLineNumber","toModelColumn","viewColumn","_moveToViewPosition","getLineLastNonWhitespaceColumn","args","name","constraint","arg","types","cursorMoveArg","to","select","by","schema","RawDirection","Left","Right","Up","Down","PrevBlankLine","NextBlankLine","WrappedLineStart","WrappedLineFirstNonWhitespaceCharacter","WrappedLineColumnCenter","WrappedLineEnd","WrappedLineLastNonWhitespaceCharacter","ViewPortTop","ViewPortCenter","ViewPortBottom","ViewPortIfOutside","RawUnit","Line","WrappedLine","Character","HalfLine","parse","CursorPosition","_cursorPositionBrand","delta","getLineIndentColumn","minColumn","atomicPosition","leftPosition","stickyTabStops","leftPositionAtomicSoftTabs","normalizedPos","clipPositionColumn","p","clipRange","rightPosition","rightPositionAtomicSoftTabs","allowMoveOnEdgeLine","normalizationAffinity","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","allowMoveOnLastLine","down","allowMoveOnFirstLine","up","_isBlankLine","lastLineNumber","lastColumn","ShiftCommand","isUnshift","autoIndent","languageConfigurationService","indentation","shiftIndent","unshiftIndent","typeSelection","ReplaceCommandThatPreservesSelection","multiCursorPaste","lines","distributedPaste","_distributePasteToCursors","_distributedPaste","_simplePaste","action","expectedIndentAction","getInheritIndentForLine","expectedEnterAction","getEnterAction","appendText","IndentAction","Indent","Outdent","typeText","test","tokenization","isCheapToTokenize","goodIndent","_goodIndentForLine","possibleTypeText","startsWith","_replaceJumpToNextIndent","lineMaxColumn","_compositionType","shouldPushStackElementBetween","getValueInRange","ReplaceCommandWithOffsetCursorState","keepPosition","ReplaceCommandWithoutChangingPosition","_typeCommand","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","indent","oldEndViewColumn","oldEndColumn","newLineContent","firstNonWhitespace","setEndPosition","afterEnter","ceil","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","autoClosingOvertype","has","chIsQuote","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","x","isBeforeClosingBrace","positions","candidates","candidate","candidateIsMatch","pair","lastChar","autoClosingPairsCloseByEnd","includes","endsWith","chIsAlreadyTyped","autoCloseConfig","shouldAutoCloseBefore","quote","bracket","_findAutoClosingPairOpen","containedPair","_findContainedAutoClosingPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","_isBeforeClosingBrace","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","autoClosingPairClose","autoSurround","_shouldSurroundChar","surroundingPairs","_step6","isTypingAQuoteCharacter","_iterator6","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","closeCharacter","SurroundSelectionCommand","electricChars","electricAction","onElectricCharacter","matchOpenBracket","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","getTypingOperation","compositions","_step7","_iterator7","composition","_step8","hasDeletion","_iterator8","_step9","_iterator9","deletedSelectionStart","deletedSelectionEnd","_step10","_iterator10","CompositionSurroundSelectionCommand","_isAutoClosingOvertype","_getAutoClosingPairClose","_runAutoClosingOpenCharType","isDoingComposition","_enter","_isAutoIndentType","autoIndentFails","_runAutoIndentType","_runAutoClosingOvertype","_isSurroundSelectionType","_runSurroundSelectionType","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","opType","_ReplaceCommandWithOf","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","helper","insertedSelectionStart","insertedSelectionEnd","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","wordType","nextCharClass","_doFindPreviousWordOnLine","chIndex","chCode","chClass","_createWord","_findEndOfWord","_doFindNextWordOnLine","_findStartOfWord","wordNavigationType","prevWordOnLine","_findPreviousWordOnLine","rightRight","movedDown","nextWordOnLine","_findNextWordOnLine","lastNonWhitespace","whitespaceHeuristics","_deleteWordLeftWhitespace","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","leftIndex","_charAtIsWhitespace","rightIndex","touchesWord","createRangeWithPosition","deleteWordAndAdjacentWhitespace","expandedToTheRight","toPosition","_moveWordPartLeft","_findFirstNonWhitespaceChar","_deleteWordRightWhitespace","_moveWordPartRight","_wordSeparators","prevWord","_createWordAtPosition","nextWord","possiblePosition","WordPartOperations","_WordOperations","apply","enforceDefined","deleteWordLeft","_deleteWordPartLeft","deleteWordRight","_deleteWordPartRight","moveWordLeft","moveWordRight","arr","filter","el","Boolean","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","CursorConfiguration","languageId","modelOptions","configuration","_cursorMoveConfigurationBrand","_languageId","layoutInfo","fontInfo","lineHeight","typicalHalfwidthCharacterWidth","height","copyWithSyntaxHighlighting","_electricChars","_getShouldAutoClose","getLanguageConfiguration","getAutoClosingPairs","getSurroundingPairs","_a","electricCharacter","getElectricCharacters","char","electricCharacterSupport","forQuotes","_getLanguageDefinedShouldAutoClose","autoCloseBeforeSet","getAutoCloseBeforeSet","hasChanged","_cursorStateBrand","PartialModelCursorState","PartialViewCursorState","modelSelection","getSelectionStart","modelSelections","_singleCursorStateBrand","_computeSelection","opts","_editOperationResultBrand"],"sourceRoot":""}