{"version":3,"file":"static/js/monaco-editor-vendor.ffbeb0f7.60710ea5.js","mappings":"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","sources":["../../node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js","../../node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/common/languageSelector.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/autoIndent.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/enterAction.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/language.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/textToHtmlTokenizer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","../../node_modules/monaco-editor/esm/vs/editor/common/modelLineProjectionData.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* MetadataConsts.LANGUAGEID_MASK */) >>> 0 /* MetadataConsts.LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 768 /* MetadataConsts.TOKEN_TYPE_MASK */) >>> 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */;\n    }\n    static containsBalancedBrackets(metadata) {\n        return (metadata & 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 30720 /* MetadataConsts.FONT_STYLE_MASK */) >>> 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 16744448 /* MetadataConsts.FOREGROUND_MASK */) >>> 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4278190080 /* MetadataConsts.BACKGROUND_MASK */) >>> 24 /* MetadataConsts.BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        const fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            className += ' mtku';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            className += ' mtks';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            result += 'font-weight: bold;';\n        }\n        let textDecoration = '';\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            textDecoration += ' underline';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            textDecoration += ' line-through';\n        }\n        if (textDecoration) {\n            result += `text-decoration:${textDecoration};`;\n        }\n        return result;\n    }\n    static getPresentationFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */),\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nclass MatchCandidate {\n    constructor(uri, languageId, notebookUri, notebookType) {\n        this.uri = uri;\n        this.languageId = languageId;\n        this.notebookUri = notebookUri;\n        this.notebookType = notebookType;\n    }\n    equals(other) {\n        var _a, _b;\n        return this.notebookType === other.notebookType\n            && this.languageId === other.languageId\n            && this.uri.toString() === other.uri.toString()\n            && ((_a = this.notebookUri) === null || _a === void 0 ? void 0 : _a.toString()) === ((_b = other.notebookUri) === null || _b === void 0 ? void 0 : _b.toString());\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor(_notebookInfoResolver) {\n        this._notebookInfoResolver = _notebookInfoResolver;\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model);\n        const result = [];\n        // from registry\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model) {\n        const result = [];\n        this._orderedForEach(model, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, callback) {\n        this._updateScores(model);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model) {\n        var _a, _b;\n        const notebookInfo = (_a = this._notebookInfoResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);\n        // use the uri (scheme, pattern) of the notebook info iff we have one\n        // otherwise it's the model's/document's uri\n        const candidate = notebookInfo\n            ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type)\n            : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined);\n        if ((_b = this._lastCandidate) === null || _b === void 0 ? void 0 : _b.equals(candidate)) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (const entry of this._entries) {\n            entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                // support for one exclusive selector that overwrites\n                // any other selector\n                for (const entry of this._entries) {\n                    entry._score = 0;\n                }\n                entry._score = 1000;\n                break;\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        // De-prioritize built-in providers\n        if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {\n            return 1;\n        }\n        else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {\n            return -1;\n        }\n        if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nfunction isBuiltinSelector(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    if (Array.isArray(selector)) {\n        return selector.some(isBuiltinSelector);\n    }\n    return Boolean(selector.isBuiltin);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { match as matchGlobPattern } from '../../base/common/glob.js';\nimport { normalize } from '../../base/common/path.js';\nexport function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector; // TODO: microsoft/TypeScript#42768\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        // selector targets a notebook -> use the notebook uri instead\n        // of the \"normal\" document uri.\n        if (notebookType && candidateNotebookUri) {\n            candidateUri = candidateNotebookUri;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (notebookType) {\n            if (notebookType === candidateNotebookType) {\n                ret = 10;\n            }\n            else if (notebookType === '*' && candidateNotebookType !== undefined) {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                // Since this pattern has a `base` property, we need\n                // to normalize this path first before passing it on\n                // because we will compare it against `Uri.fsPath`\n                // which uses platform specific separators.\n                // Refs: https://github.com/microsoft/vscode/issues/99938\n                normalizedPattern = { ...pattern, base: normalize(pattern.base) };\n            }\n            if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\n","import { Codicon } from '../../base/common/codicons.js';\nimport { URI } from '../../base/common/uri.js';\nimport { Range } from './core/range.js';\nimport { TokenizationRegistry as TokenizationRegistryImpl } from './tokenizationRegistry.js';\nimport { localize } from '../../nls.js';\nexport class Token {\n    constructor(offset, type, language) {\n        this.offset = offset;\n        this.type = type;\n        this.language = language;\n        this._tokenBrand = undefined;\n    }\n    toString() {\n        return '(' + this.offset + ', ' + this.type + ')';\n    }\n}\n/**\n * @internal\n */\nexport class TokenizationResult {\n    constructor(tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._tokenizationResultBrand = undefined;\n    }\n}\n/**\n * @internal\n */\nexport class EncodedTokenizationResult {\n    constructor(\n    /**\n     * The tokens in binary format. Each token occupies two array indices. For token i:\n     *  - at offset 2*i => startIndex\n     *  - at offset 2*i + 1 => metadata\n     *\n     */\n    tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._encodedTokenizationResultBrand = undefined;\n    }\n}\nexport var HoverVerbosityAction;\n(function (HoverVerbosityAction) {\n    /**\n     * Increase the verbosity of the hover\n     */\n    HoverVerbosityAction[HoverVerbosityAction[\"Increase\"] = 0] = \"Increase\";\n    /**\n     * Decrease the verbosity of the hover\n     */\n    HoverVerbosityAction[HoverVerbosityAction[\"Decrease\"] = 1] = \"Decrease\";\n})(HoverVerbosityAction || (HoverVerbosityAction = {}));\n/**\n * @internal\n */\nexport var CompletionItemKinds;\n(function (CompletionItemKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* CompletionItemKind.Method */, Codicon.symbolMethod);\n    byKind.set(1 /* CompletionItemKind.Function */, Codicon.symbolFunction);\n    byKind.set(2 /* CompletionItemKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(3 /* CompletionItemKind.Field */, Codicon.symbolField);\n    byKind.set(4 /* CompletionItemKind.Variable */, Codicon.symbolVariable);\n    byKind.set(5 /* CompletionItemKind.Class */, Codicon.symbolClass);\n    byKind.set(6 /* CompletionItemKind.Struct */, Codicon.symbolStruct);\n    byKind.set(7 /* CompletionItemKind.Interface */, Codicon.symbolInterface);\n    byKind.set(8 /* CompletionItemKind.Module */, Codicon.symbolModule);\n    byKind.set(9 /* CompletionItemKind.Property */, Codicon.symbolProperty);\n    byKind.set(10 /* CompletionItemKind.Event */, Codicon.symbolEvent);\n    byKind.set(11 /* CompletionItemKind.Operator */, Codicon.symbolOperator);\n    byKind.set(12 /* CompletionItemKind.Unit */, Codicon.symbolUnit);\n    byKind.set(13 /* CompletionItemKind.Value */, Codicon.symbolValue);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(14 /* CompletionItemKind.Constant */, Codicon.symbolConstant);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(16 /* CompletionItemKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(17 /* CompletionItemKind.Keyword */, Codicon.symbolKeyword);\n    byKind.set(27 /* CompletionItemKind.Snippet */, Codicon.symbolSnippet);\n    byKind.set(18 /* CompletionItemKind.Text */, Codicon.symbolText);\n    byKind.set(19 /* CompletionItemKind.Color */, Codicon.symbolColor);\n    byKind.set(20 /* CompletionItemKind.File */, Codicon.symbolFile);\n    byKind.set(21 /* CompletionItemKind.Reference */, Codicon.symbolReference);\n    byKind.set(22 /* CompletionItemKind.Customcolor */, Codicon.symbolCustomColor);\n    byKind.set(23 /* CompletionItemKind.Folder */, Codicon.symbolFolder);\n    byKind.set(24 /* CompletionItemKind.TypeParameter */, Codicon.symbolTypeParameter);\n    byKind.set(25 /* CompletionItemKind.User */, Codicon.account);\n    byKind.set(26 /* CompletionItemKind.Issue */, Codicon.issues);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let codicon = byKind.get(kind);\n        if (!codicon) {\n            console.info('No codicon found for CompletionItemKind ' + kind);\n            codicon = Codicon.symbolProperty;\n        }\n        return codicon;\n    }\n    CompletionItemKinds.toIcon = toIcon;\n    const data = new Map();\n    data.set('method', 0 /* CompletionItemKind.Method */);\n    data.set('function', 1 /* CompletionItemKind.Function */);\n    data.set('constructor', 2 /* CompletionItemKind.Constructor */);\n    data.set('field', 3 /* CompletionItemKind.Field */);\n    data.set('variable', 4 /* CompletionItemKind.Variable */);\n    data.set('class', 5 /* CompletionItemKind.Class */);\n    data.set('struct', 6 /* CompletionItemKind.Struct */);\n    data.set('interface', 7 /* CompletionItemKind.Interface */);\n    data.set('module', 8 /* CompletionItemKind.Module */);\n    data.set('property', 9 /* CompletionItemKind.Property */);\n    data.set('event', 10 /* CompletionItemKind.Event */);\n    data.set('operator', 11 /* CompletionItemKind.Operator */);\n    data.set('unit', 12 /* CompletionItemKind.Unit */);\n    data.set('value', 13 /* CompletionItemKind.Value */);\n    data.set('constant', 14 /* CompletionItemKind.Constant */);\n    data.set('enum', 15 /* CompletionItemKind.Enum */);\n    data.set('enum-member', 16 /* CompletionItemKind.EnumMember */);\n    data.set('enumMember', 16 /* CompletionItemKind.EnumMember */);\n    data.set('keyword', 17 /* CompletionItemKind.Keyword */);\n    data.set('snippet', 27 /* CompletionItemKind.Snippet */);\n    data.set('text', 18 /* CompletionItemKind.Text */);\n    data.set('color', 19 /* CompletionItemKind.Color */);\n    data.set('file', 20 /* CompletionItemKind.File */);\n    data.set('reference', 21 /* CompletionItemKind.Reference */);\n    data.set('customcolor', 22 /* CompletionItemKind.Customcolor */);\n    data.set('folder', 23 /* CompletionItemKind.Folder */);\n    data.set('type-parameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('typeParameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('account', 25 /* CompletionItemKind.User */);\n    data.set('issue', 26 /* CompletionItemKind.Issue */);\n    /**\n     * @internal\n     */\n    function fromString(value, strict) {\n        let res = data.get(value);\n        if (typeof res === 'undefined' && !strict) {\n            res = 9 /* CompletionItemKind.Property */;\n        }\n        return res;\n    }\n    CompletionItemKinds.fromString = fromString;\n})(CompletionItemKinds || (CompletionItemKinds = {}));\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport class SelectedSuggestionInfo {\n    constructor(range, text, completionKind, isSnippetText) {\n        this.range = range;\n        this.text = text;\n        this.completionKind = completionKind;\n        this.isSnippetText = isSnippetText;\n    }\n    equals(other) {\n        return Range.lift(this.range).equalsRange(other.range)\n            && this.text === other.text\n            && this.completionKind === other.completionKind\n            && this.isSnippetText === other.isSnippetText;\n    }\n}\n/**\n * @internal\n */\nexport var DocumentPasteTriggerKind;\n(function (DocumentPasteTriggerKind) {\n    DocumentPasteTriggerKind[DocumentPasteTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    DocumentPasteTriggerKind[DocumentPasteTriggerKind[\"PasteAs\"] = 1] = \"PasteAs\";\n})(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));\nexport var SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * @internal\n */\nexport function isLocationLink(thing) {\n    return thing\n        && URI.isUri(thing.uri)\n        && Range.isIRange(thing.range)\n        && (Range.isIRange(thing.originSelectionRange) || Range.isIRange(thing.targetSelectionRange));\n}\n/**\n * @internal\n */\nexport const symbolKindNames = {\n    [17 /* SymbolKind.Array */]: localize('Array', \"array\"),\n    [16 /* SymbolKind.Boolean */]: localize('Boolean', \"boolean\"),\n    [4 /* SymbolKind.Class */]: localize('Class', \"class\"),\n    [13 /* SymbolKind.Constant */]: localize('Constant', \"constant\"),\n    [8 /* SymbolKind.Constructor */]: localize('Constructor', \"constructor\"),\n    [9 /* SymbolKind.Enum */]: localize('Enum', \"enumeration\"),\n    [21 /* SymbolKind.EnumMember */]: localize('EnumMember', \"enumeration member\"),\n    [23 /* SymbolKind.Event */]: localize('Event', \"event\"),\n    [7 /* SymbolKind.Field */]: localize('Field', \"field\"),\n    [0 /* SymbolKind.File */]: localize('File', \"file\"),\n    [11 /* SymbolKind.Function */]: localize('Function', \"function\"),\n    [10 /* SymbolKind.Interface */]: localize('Interface', \"interface\"),\n    [19 /* SymbolKind.Key */]: localize('Key', \"key\"),\n    [5 /* SymbolKind.Method */]: localize('Method', \"method\"),\n    [1 /* SymbolKind.Module */]: localize('Module', \"module\"),\n    [2 /* SymbolKind.Namespace */]: localize('Namespace', \"namespace\"),\n    [20 /* SymbolKind.Null */]: localize('Null', \"null\"),\n    [15 /* SymbolKind.Number */]: localize('Number', \"number\"),\n    [18 /* SymbolKind.Object */]: localize('Object', \"object\"),\n    [24 /* SymbolKind.Operator */]: localize('Operator', \"operator\"),\n    [3 /* SymbolKind.Package */]: localize('Package', \"package\"),\n    [6 /* SymbolKind.Property */]: localize('Property', \"property\"),\n    [14 /* SymbolKind.String */]: localize('String', \"string\"),\n    [22 /* SymbolKind.Struct */]: localize('Struct', \"struct\"),\n    [25 /* SymbolKind.TypeParameter */]: localize('TypeParameter', \"type parameter\"),\n    [12 /* SymbolKind.Variable */]: localize('Variable', \"variable\"),\n};\n/**\n * @internal\n */\nexport function getAriaLabelForSymbol(symbolName, kind) {\n    return localize('symbolAriaLabel', '{0} ({1})', symbolName, symbolKindNames[kind]);\n}\n/**\n * @internal\n */\nexport var SymbolKinds;\n(function (SymbolKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* SymbolKind.File */, Codicon.symbolFile);\n    byKind.set(1 /* SymbolKind.Module */, Codicon.symbolModule);\n    byKind.set(2 /* SymbolKind.Namespace */, Codicon.symbolNamespace);\n    byKind.set(3 /* SymbolKind.Package */, Codicon.symbolPackage);\n    byKind.set(4 /* SymbolKind.Class */, Codicon.symbolClass);\n    byKind.set(5 /* SymbolKind.Method */, Codicon.symbolMethod);\n    byKind.set(6 /* SymbolKind.Property */, Codicon.symbolProperty);\n    byKind.set(7 /* SymbolKind.Field */, Codicon.symbolField);\n    byKind.set(8 /* SymbolKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(9 /* SymbolKind.Enum */, Codicon.symbolEnum);\n    byKind.set(10 /* SymbolKind.Interface */, Codicon.symbolInterface);\n    byKind.set(11 /* SymbolKind.Function */, Codicon.symbolFunction);\n    byKind.set(12 /* SymbolKind.Variable */, Codicon.symbolVariable);\n    byKind.set(13 /* SymbolKind.Constant */, Codicon.symbolConstant);\n    byKind.set(14 /* SymbolKind.String */, Codicon.symbolString);\n    byKind.set(15 /* SymbolKind.Number */, Codicon.symbolNumber);\n    byKind.set(16 /* SymbolKind.Boolean */, Codicon.symbolBoolean);\n    byKind.set(17 /* SymbolKind.Array */, Codicon.symbolArray);\n    byKind.set(18 /* SymbolKind.Object */, Codicon.symbolObject);\n    byKind.set(19 /* SymbolKind.Key */, Codicon.symbolKey);\n    byKind.set(20 /* SymbolKind.Null */, Codicon.symbolNull);\n    byKind.set(21 /* SymbolKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(22 /* SymbolKind.Struct */, Codicon.symbolStruct);\n    byKind.set(23 /* SymbolKind.Event */, Codicon.symbolEvent);\n    byKind.set(24 /* SymbolKind.Operator */, Codicon.symbolOperator);\n    byKind.set(25 /* SymbolKind.TypeParameter */, Codicon.symbolTypeParameter);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let icon = byKind.get(kind);\n        if (!icon) {\n            console.info('No codicon found for SymbolKind ' + kind);\n            icon = Codicon.symbolProperty;\n        }\n        return icon;\n    }\n    SymbolKinds.toIcon = toIcon;\n})(SymbolKinds || (SymbolKinds = {}));\n/** @internal */\nexport class TextEdit {\n}\nexport class FoldingRangeKind {\n    /**\n     * Returns a {@link FoldingRangeKind} for the given value.\n     *\n     * @param value of the kind.\n     */\n    static fromValue(value) {\n        switch (value) {\n            case 'comment': return FoldingRangeKind.Comment;\n            case 'imports': return FoldingRangeKind.Imports;\n            case 'region': return FoldingRangeKind.Region;\n        }\n        return new FoldingRangeKind(value);\n    }\n    /**\n     * Creates a new {@link FoldingRangeKind}.\n     *\n     * @param value of the kind.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Kind for folding range representing a comment. The value of the kind is 'comment'.\n */\nFoldingRangeKind.Comment = new FoldingRangeKind('comment');\n/**\n * Kind for folding range representing a import. The value of the kind is 'imports'.\n */\nFoldingRangeKind.Imports = new FoldingRangeKind('imports');\n/**\n * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\n * The value of the kind is 'region'.\n */\nFoldingRangeKind.Region = new FoldingRangeKind('region');\nexport var NewSymbolNameTag;\n(function (NewSymbolNameTag) {\n    NewSymbolNameTag[NewSymbolNameTag[\"AIGenerated\"] = 1] = \"AIGenerated\";\n})(NewSymbolNameTag || (NewSymbolNameTag = {}));\nexport var NewSymbolNameTriggerKind;\n(function (NewSymbolNameTriggerKind) {\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));\n/**\n * @internal\n */\nexport var Command;\n(function (Command) {\n    /**\n     * @internal\n     */\n    function is(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return false;\n        }\n        return typeof obj.id === 'string' &&\n            typeof obj.title === 'string';\n    }\n    Command.is = is;\n})(Command || (Command = {}));\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\n/**\n * @internal\n */\nexport class LazyTokenizationSupport {\n    constructor(createSupport) {\n        this.createSupport = createSupport;\n        this._tokenizationSupport = null;\n    }\n    dispose() {\n        if (this._tokenizationSupport) {\n            this._tokenizationSupport.then((support) => {\n                if (support) {\n                    support.dispose();\n                }\n            });\n        }\n    }\n    get tokenizationSupport() {\n        if (!this._tokenizationSupport) {\n            this._tokenizationSupport = this.createSupport();\n        }\n        return this._tokenizationSupport;\n    }\n}\n/**\n * @internal\n */\nexport const TokenizationRegistry = new TokenizationRegistryImpl();\nexport var InlineEditTriggerKind;\n(function (InlineEditTriggerKind) {\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(InlineEditTriggerKind || (InlineEditTriggerKind = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { getScopedLineTokens } from './languageConfigurationRegistry.js';\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n    const languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n    if (lineNumber > 1) {\n        let lastLineNumber;\n        let resultLineNumber = -1;\n        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n            if (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n                return resultLineNumber;\n            }\n            const text = model.getLineContent(lastLineNumber);\n            if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                resultLineNumber = lastLineNumber;\n                continue;\n            }\n            return lastLineNumber;\n        }\n    }\n    return -1;\n}\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber <= 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    // Use no indent if this is the first non-blank line\n    for (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n        if (model.getLineContent(priorLineNumber) !== '') {\n            break;\n        }\n        if (priorLineNumber === 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n    }\n    const precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n    if (precedingUnIgnoredLine < 0) {\n        return null;\n    }\n    else if (precedingUnIgnoredLine < 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: IndentAction.Indent,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: null,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else {\n        // precedingUnIgnoredLine can not be ignored.\n        // it doesn't increase indent of following lines\n        // it doesn't increase just next line\n        // so current line is not affect by precedingUnIgnoredLine\n        // and then we should get a correct inheritted indentation from above lines\n        if (precedingUnIgnoredLine === 1) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        const previousLine = precedingUnIgnoredLine - 1;\n        const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n        if (!(previousLineIndentMetadata & (1 /* IndentConsts.INCREASE_MASK */ | 2 /* IndentConsts.DECREASE_MASK */)) &&\n            (previousLineIndentMetadata & 4 /* IndentConsts.INDENT_NEXTLINE_MASK */)) {\n            let stopLine = 0;\n            for (let i = previousLine - 1; i > 0; i--) {\n                if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                    continue;\n                }\n                stopLine = i;\n                break;\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                action: null,\n                line: stopLine + 1\n            };\n        }\n        if (honorIntentialIndent) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n            for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                const lineContent = model.getLineContent(i);\n                if (indentRulesSupport.shouldIncrease(lineContent)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(lineContent),\n                        action: IndentAction.Indent,\n                        line: i\n                    };\n                }\n                else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                    let stopLine = 0;\n                    for (let j = i - 1; j > 0; j--) {\n                        if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                            continue;\n                        }\n                        stopLine = j;\n                        break;\n                    }\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                        action: null,\n                        line: stopLine + 1\n                    };\n                }\n                else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(lineContent),\n                        action: null,\n                        line: i\n                    };\n                }\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                action: null,\n                line: 1\n            };\n        }\n    }\n}\nexport function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n    const lineContent = virtualModel.getLineContent(lineNumber);\n    if (indent) {\n        const inheritLine = indent.line;\n        if (inheritLine !== undefined) {\n            // Apply enter action as long as there are only whitespace lines between inherited line and this line.\n            let shouldApplyEnterRules = true;\n            for (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n                if (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n                    shouldApplyEnterRules = false;\n                    break;\n                }\n            }\n            if (shouldApplyEnterRules) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n        }\n        if (indentRulesSupport.shouldDecrease(lineContent)) {\n            if (indent.action === IndentAction.Indent) {\n                return indent.indentation;\n            }\n            else {\n                return indentConverter.unshiftIndent(indent.indentation);\n            }\n        }\n        else {\n            if (indent.action === IndentAction.Indent) {\n                return indentConverter.shiftIndent(indent.indentation);\n            }\n            else {\n                return indent.indentation;\n            }\n        }\n    }\n    return null;\n}\nexport function getIndentForEnter(autoIndent, model, range, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    model.tokenization.forceTokenization(range.startLineNumber);\n    const lineTokens = model.tokenization.getLineTokens(range.startLineNumber);\n    const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n    const scopedLineText = scopedLineTokens.getLineContent();\n    let embeddedLanguage = false;\n    let beforeEnterText;\n    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n        // we are in the embeded language content\n        embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n        beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n    }\n    let afterEnterText;\n    if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const beforeEnterResult = beforeEnterText;\n    const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n    const virtualModel = {\n        tokenization: {\n            getLineTokens: (lineNumber) => {\n                return model.tokenization.getLineTokens(lineNumber);\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n        },\n        getLineContent: (lineNumber) => {\n            if (lineNumber === range.startLineNumber) {\n                return beforeEnterResult;\n            }\n            else {\n                return model.getLineContent(lineNumber);\n            }\n        }\n    };\n    const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n    const afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n    if (!afterEnterAction) {\n        const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n        return {\n            beforeEnter: beforeEnter,\n            afterEnter: beforeEnter\n        };\n    }\n    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n    if (afterEnterAction.action === IndentAction.Indent) {\n        afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n    if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n        afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n    return {\n        beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n        afterEnter: afterEnterIndent\n    };\n}\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(autoIndent, model, range, ch, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    if (scopedLineTokens.firstCharOffset) {\n        // this line has mixed languages and indentation rules will not work\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterTypeText;\n    if (range.isEmpty()) {\n        afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n        // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n        // 1. Get inherited indent action\n        const r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n        if (!r) {\n            return null;\n        }\n        let indentation = r.indentation;\n        if (r.action !== IndentAction.Indent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n        }\n        return indentation;\n    }\n    return null;\n}\nexport function getIndentMetadata(model, lineNumber, languageConfigurationService) {\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n        return null;\n    }\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color, HSLA } from '../../../base/common/color.js';\nfunction _parseCaptureGroups(captureGroups) {\n    const values = [];\n    for (const captureGroup of captureGroups) {\n        const parsedNumber = Number(captureGroup);\n        if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\\s/g, '') !== '') {\n            values.push(parsedNumber);\n        }\n    }\n    return values;\n}\nfunction _toIColor(r, g, b, a) {\n    return {\n        red: r / 255,\n        blue: b / 255,\n        green: g / 255,\n        alpha: a\n    };\n}\nfunction _findRange(model, match) {\n    const index = match.index;\n    const length = match[0].length;\n    if (!index) {\n        return;\n    }\n    const startPosition = model.positionAt(index);\n    const range = {\n        startLineNumber: startPosition.lineNumber,\n        startColumn: startPosition.column,\n        endLineNumber: startPosition.lineNumber,\n        endColumn: startPosition.column + length\n    };\n    return range;\n}\nfunction _findHexColorInformation(range, hexValue) {\n    if (!range) {\n        return;\n    }\n    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n    if (!parsedHexColor) {\n        return;\n    }\n    return {\n        range: range,\n        color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n    };\n}\nfunction _findRGBColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    return {\n        range: range,\n        color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n    };\n}\nfunction _findHSLColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\n    return {\n        range: range,\n        color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n    };\n}\nfunction _findMatches(model, regex) {\n    if (typeof model === 'string') {\n        return [...model.matchAll(regex)];\n    }\n    else {\n        return model.findMatches(regex);\n    }\n}\nfunction computeColors(model) {\n    const result = [];\n    // Early validation for RGB and HSL\n    const initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|(#)([A-Fa-f0-9]{3})\\b|(#)([A-Fa-f0-9]{4})\\b|(#)([A-Fa-f0-9]{6})\\b|(#)([A-Fa-f0-9]{8})\\b/gm;\n    const initialValidationMatches = _findMatches(model, initialValidationRegex);\n    // Potential colors have been found, validate the parameters\n    if (initialValidationMatches.length > 0) {\n        for (const initialMatch of initialValidationMatches) {\n            const initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);\n            const colorScheme = initialCaptureGroups[1];\n            const colorParameters = initialCaptureGroups[2];\n            if (!colorParameters) {\n                continue;\n            }\n            let colorInformation;\n            if (colorScheme === 'rgb') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'rgba') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === 'hsl') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'hsla') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === '#') {\n                colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n            }\n            if (colorInformation) {\n                result.push(colorInformation);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Returns an array of all default document colors in the provided document\n */\nexport function computeDefaultDocumentColors(model) {\n    if (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return computeColors(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IndentAction } from './languageConfiguration.js';\nimport { getIndentationAtPosition, getScopedLineTokens } from './languageConfigurationRegistry.js';\nexport function getEnterAction(autoIndent, model, range, languageConfigurationService) {\n    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterEnterText;\n    if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    let previousLineText = '';\n    if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n        // This is not the first line and the entire line belongs to this mode\n        const oneLineAboveScopedLineTokens = getScopedLineTokens(model, range.startLineNumber - 1);\n        if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n            // The line above ends with text belonging to the same mode\n            previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n        }\n    }\n    const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    if (!enterResult) {\n        return null;\n    }\n    const indentAction = enterResult.indentAction;\n    let appendText = enterResult.appendText;\n    const removeText = enterResult.removeText || 0;\n    // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n    if (!appendText) {\n        if ((indentAction === IndentAction.Indent) ||\n            (indentAction === IndentAction.IndentOutdent)) {\n            appendText = '\\t';\n        }\n        else {\n            appendText = '';\n        }\n    }\n    else if (indentAction === IndentAction.Indent) {\n        appendText = '\\t' + appendText;\n    }\n    let indentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    if (removeText) {\n        indentation = indentation.substring(0, indentation.length - removeText);\n    }\n    return {\n        indentAction: indentAction,\n        appendText: appendText,\n        removeText: removeText,\n        indentation: indentation\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageService = createDecorator('languageService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t';\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t';\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nexport function getScopedLineTokens(model, lineNumber, columnNumber) {\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n    return createScopedLineTokens(lineTokens, column);\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nclass Uint8Matrix {\n    constructor(rows, cols, defaultValue) {\n        const data = new Uint8Array(rows * cols);\n        for (let i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    get(row, col) {\n        return this._data[row * this.cols + col];\n    }\n    set(row, col, value) {\n        this._data[row * this.cols + col] = value;\n    }\n}\nexport class StateMachine {\n    constructor(edges) {\n        let maxCharCode = 0;\n        let maxState = 0 /* State.Invalid */;\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* State.Invalid */);\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    nextState(currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* State.Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    }\n}\n// State machine for http:// or https:// or file://\nlet _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* State.Start */, 104 /* CharCode.h */, 2 /* State.H */],\n            [1 /* State.Start */, 72 /* CharCode.H */, 2 /* State.H */],\n            [1 /* State.Start */, 102 /* CharCode.f */, 6 /* State.F */],\n            [1 /* State.Start */, 70 /* CharCode.F */, 6 /* State.F */],\n            [2 /* State.H */, 116 /* CharCode.t */, 3 /* State.HT */],\n            [2 /* State.H */, 84 /* CharCode.T */, 3 /* State.HT */],\n            [3 /* State.HT */, 116 /* CharCode.t */, 4 /* State.HTT */],\n            [3 /* State.HT */, 84 /* CharCode.T */, 4 /* State.HTT */],\n            [4 /* State.HTT */, 112 /* CharCode.p */, 5 /* State.HTTP */],\n            [4 /* State.HTT */, 80 /* CharCode.P */, 5 /* State.HTTP */],\n            [5 /* State.HTTP */, 115 /* CharCode.s */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 83 /* CharCode.S */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [6 /* State.F */, 105 /* CharCode.i */, 7 /* State.FI */],\n            [6 /* State.F */, 73 /* CharCode.I */, 7 /* State.FI */],\n            [7 /* State.FI */, 108 /* CharCode.l */, 8 /* State.FIL */],\n            [7 /* State.FI */, 76 /* CharCode.L */, 8 /* State.FIL */],\n            [8 /* State.FIL */, 101 /* CharCode.e */, 9 /* State.BeforeColon */],\n            [8 /* State.FIL */, 69 /* CharCode.E */, 9 /* State.BeforeColon */],\n            [9 /* State.BeforeColon */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [10 /* State.AfterColon */, 47 /* CharCode.Slash */, 11 /* State.AlmostThere */],\n            [11 /* State.AlmostThere */, 47 /* CharCode.Slash */, 12 /* State.End */],\n        ]);\n    }\n    return _stateMachine;\n}\nlet _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new CharacterClassifier(0 /* CharacterClass.None */);\n        // allow-any-unicode-next-line\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…';\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* CharacterClass.ForceTermination */);\n        }\n        const CANNOT_END_WITH_CHARACTERS = '.,;:';\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CharacterClass.CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nexport class LinkComputer {\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        let lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\n            const chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CharacterClass.CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* CharCode.OpenParen */ && lastCharCodeInLink === 41 /* CharCode.CloseParen */)\n                || (charCodeBeforeLink === 91 /* CharCode.OpenSquareBracket */ && lastCharCodeInLink === 93 /* CharCode.CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* CharCode.OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CharCode.CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    }\n    static computeLinks(model, stateMachine = getStateMachine()) {\n        const classifier = getClassifier();\n        const result = [];\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            const line = model.getLineContent(i);\n            const len = line.length;\n            let j = 0;\n            let linkBeginIndex = 0;\n            let linkBeginChCode = 0;\n            let state = 1 /* State.Start */;\n            let hasOpenParens = false;\n            let hasOpenSquareBracket = false;\n            let inSquareBrackets = false;\n            let hasOpenCurlyBracket = false;\n            while (j < len) {\n                let resetStateMachine = false;\n                const chCode = line.charCodeAt(j);\n                if (state === 13 /* State.Accept */) {\n                    let chClass;\n                    switch (chCode) {\n                        case 40 /* CharCode.OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 41 /* CharCode.CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 91 /* CharCode.OpenSquareBracket */:\n                            inSquareBrackets = true;\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 93 /* CharCode.CloseSquareBracket */:\n                            inSquareBrackets = false;\n                            chClass = (hasOpenSquareBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 123 /* CharCode.OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 125 /* CharCode.CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        // The following three rules make it that ' or \" or ` are allowed inside links\n                        // only if the link is wrapped by some other quote character\n                        case 39 /* CharCode.SingleQuote */:\n                        case 34 /* CharCode.DoubleQuote */:\n                        case 96 /* CharCode.BackTick */:\n                            if (linkBeginChCode === chCode) {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            else if (linkBeginChCode === 39 /* CharCode.SingleQuote */ || linkBeginChCode === 34 /* CharCode.DoubleQuote */ || linkBeginChCode === 96 /* CharCode.BackTick */) {\n                                chClass = 0 /* CharacterClass.None */;\n                            }\n                            else {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            break;\n                        case 42 /* CharCode.Asterisk */:\n                            // `*` terminates a link if the link began with `*`\n                            chClass = (linkBeginChCode === 42 /* CharCode.Asterisk */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 124 /* CharCode.Pipe */:\n                            // `|` terminates a link if the link began with `|`\n                            chClass = (linkBeginChCode === 124 /* CharCode.Pipe */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 32 /* CharCode.Space */:\n                            // ` ` allow space in between [ and ]\n                            chClass = (inSquareBrackets ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* State.End */) {\n                    let chClass;\n                    if (chCode === 91 /* CharCode.OpenSquareBracket */) {\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                        hasOpenSquareBracket = true;\n                        chClass = 0 /* CharacterClass.None */;\n                    }\n                    else {\n                        chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* State.Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* State.Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* State.Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* State.Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    }\n}\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Extensions as ConfigurationExtensions } from '../../../platform/configuration/common/configurationRegistry.js';\n// Define extension point ids\nexport const Extensions = {\n    ModesRegistry: 'editor.modesRegistry'\n};\nexport class EditorModesRegistry {\n    constructor() {\n        this._onDidChangeLanguages = new Emitter();\n        this.onDidChangeLanguages = this._onDidChangeLanguages.event;\n        this._languages = [];\n    }\n    registerLanguage(def) {\n        this._languages.push(def);\n        this._onDidChangeLanguages.fire(undefined);\n        return {\n            dispose: () => {\n                for (let i = 0, len = this._languages.length; i < len; i++) {\n                    if (this._languages[i] === def) {\n                        this._languages.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    getLanguages() {\n        return this._languages;\n    }\n}\nexport const ModesRegistry = new EditorModesRegistry();\nRegistry.add(Extensions.ModesRegistry, ModesRegistry);\nexport const PLAINTEXT_LANGUAGE_ID = 'plaintext';\nexport const PLAINTEXT_EXTENSION = '.txt';\nModesRegistry.registerLanguage({\n    id: PLAINTEXT_LANGUAGE_ID,\n    extensions: [PLAINTEXT_EXTENSION],\n    aliases: [nls.localize('plainText.alias', \"Plain Text\"), 'text'],\n    mimetypes: [Mimes.text]\n});\nRegistry.as(ConfigurationExtensions.Configuration)\n    .registerDefaultConfigurations([{\n        overrides: {\n            '[plaintext]': {\n                'editor.unicodeHighlight.ambiguousCharacters': false,\n                'editor.unicodeHighlight.invisibleCharacters': false\n            }\n        }\n    }]);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            const result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            const result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        const numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        const n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* FontStyle.None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* FontStyle.None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (const color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* StandardTokenType.Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* StandardTokenType.Comment */;\n        case 'string':\n            return 2 /* StandardTokenType.String */;\n        case 'regex':\n            return 3 /* StandardTokenType.RegEx */;\n        case 'regexp':\n            return 3 /* StandardTokenType.RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* ColorId.None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* ColorId.None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullTokenize.js';\nconst fallback = {\n    getInitialState: () => NullState,\n    tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* LanguageId.Null */, state)\n};\nexport async function tokenizeToString(languageService, text, languageId) {\n    if (!languageId) {\n        return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n    }\n    const tokenizationSupport = await TokenizationRegistry.getOrCreate(languageId);\n    return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    let prevIsSpace = true;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* CharCode.Tab */: {\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        if (useNbsp && prevIsSpace) {\n                            partContent += '&#160;';\n                            prevIsSpace = false;\n                        }\n                        else {\n                            partContent += ' ';\n                            prevIsSpace = true;\n                        }\n                        insertSpacesCount--;\n                    }\n                    break;\n                }\n                case 60 /* CharCode.LessThan */:\n                    partContent += '&lt;';\n                    prevIsSpace = false;\n                    break;\n                case 62 /* CharCode.GreaterThan */:\n                    partContent += '&gt;';\n                    prevIsSpace = false;\n                    break;\n                case 38 /* CharCode.Ampersand */:\n                    partContent += '&amp;';\n                    prevIsSpace = false;\n                    break;\n                case 0 /* CharCode.Null */:\n                    partContent += '&#00;';\n                    prevIsSpace = false;\n                    break;\n                case 65279 /* CharCode.UTF8_BOM */:\n                case 8232 /* CharCode.LINE_SEPARATOR */:\n                case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                case 133 /* CharCode.NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    prevIsSpace = false;\n                    break;\n                case 13 /* CharCode.CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    prevIsSpace = false;\n                    break;\n                case 32 /* CharCode.Space */:\n                    if (useNbsp && prevIsSpace) {\n                        partContent += '&#160;';\n                        prevIsSpace = false;\n                    }\n                    else {\n                        partContent += ' ';\n                        prevIsSpace = true;\n                    }\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n                    prevIsSpace = false;\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    const lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n        const viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../base/common/objects.js';\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport var OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport var GlyphMarginLane;\n(function (GlyphMarginLane) {\n    GlyphMarginLane[GlyphMarginLane[\"Left\"] = 1] = \"Left\";\n    GlyphMarginLane[GlyphMarginLane[\"Center\"] = 2] = \"Center\";\n    GlyphMarginLane[GlyphMarginLane[\"Right\"] = 3] = \"Right\";\n})(GlyphMarginLane || (GlyphMarginLane = {}));\nexport var InjectedTextCursorStops;\n(function (InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nexport class TextModelResolvedOptions {\n    get originalIndentSize() {\n        return this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\n    }\n    /**\n     * @internal\n     */\n    constructor(src) {\n        this._textModelResolvedOptionsBrand = undefined;\n        this.tabSize = Math.max(1, src.tabSize | 0);\n        if (src.indentSize === 'tabSize') {\n            this.indentSize = this.tabSize;\n            this._indentSizeIsTabSize = true;\n        }\n        else {\n            this.indentSize = Math.max(1, src.indentSize | 0);\n            this._indentSizeIsTabSize = false;\n        }\n        this.insertSpaces = Boolean(src.insertSpaces);\n        this.defaultEOL = src.defaultEOL | 0;\n        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.tabSize === other.tabSize\n            && this._indentSizeIsTabSize === other._indentSizeIsTabSize\n            && this.indentSize === other.indentSize\n            && this.insertSpaces === other.insertSpaces\n            && this.defaultEOL === other.defaultEOL\n            && this.trimAutoWhitespace === other.trimAutoWhitespace\n            && equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));\n    }\n    /**\n     * @internal\n     */\n    createChangeEvent(newOpts) {\n        return {\n            tabSize: this.tabSize !== newOpts.tabSize,\n            indentSize: this.indentSize !== newOpts.indentSize,\n            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n        };\n    }\n}\nexport class FindMatch {\n    /**\n     * @internal\n     */\n    constructor(range, matches) {\n        this._findMatchBrand = undefined;\n        this.range = range;\n        this.matches = matches;\n    }\n}\n/**\n * @internal\n */\nexport function isITextSnapshot(obj) {\n    return (obj && typeof obj.read === 'function');\n}\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation {\n    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {\n        this.identifier = identifier;\n        this.range = range;\n        this.text = text;\n        this.forceMoveMarkers = forceMoveMarkers;\n        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;\n        this._isTracked = _isTracked;\n    }\n}\n/**\n * @internal\n */\nexport class SearchData {\n    constructor(regex, wordSeparators, simpleSearch) {\n        this.regex = regex;\n        this.wordSeparators = wordSeparators;\n        this.simpleSearch = simpleSearch;\n    }\n}\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {\n        this.reverseEdits = reverseEdits;\n        this.changes = changes;\n        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;\n    }\n}\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model) {\n    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    var _a;\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.bracketPairsTree.clear();\n                this.updateBracketPairsTree();\n            }\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range, onlyColorizedBrackets)) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem !== null && remainingItem !== void 0 ? remainingItem : s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/textLength.js';\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageAgnosticBracketTokens } from './bracketPairsTree/brackets.js';\nimport { lengthAdd, lengthGetColumnCountIfZeroLineCount, lengthZero } from './bracketPairsTree/length.js';\nimport { parseDocument } from './bracketPairsTree/parser.js';\nimport { DenseKeyProvider } from './bracketPairsTree/smallImmutableSet.js';\nimport { TextBufferTokenizer } from './bracketPairsTree/tokenizer.js';\nexport function fixBracketsInLine(tokens, languageConfigurationService) {\n    const denseKeyProvider = new DenseKeyProvider();\n    const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));\n    const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);\n    const node = parseDocument(tokenizer, [], undefined, true);\n    let str = '';\n    const line = tokens.getLineContent();\n    function processNode(node, offset) {\n        if (node.kind === 2 /* AstNodeKind.Pair */) {\n            processNode(node.openingBracket, offset);\n            offset = lengthAdd(offset, node.openingBracket.length);\n            if (node.child) {\n                processNode(node.child, offset);\n                offset = lengthAdd(offset, node.child.length);\n            }\n            if (node.closingBracket) {\n                processNode(node.closingBracket, offset);\n                offset = lengthAdd(offset, node.closingBracket.length);\n            }\n            else {\n                const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node.openingBracket.languageId);\n                const closingTokenText = singleLangBracketTokens.findClosingTokenText(node.openingBracket.bracketIds);\n                str += closingTokenText;\n            }\n        }\n        else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n            // remove the bracket\n        }\n        else if (node.kind === 0 /* AstNodeKind.Text */ || node.kind === 1 /* AstNodeKind.Bracket */) {\n            str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node.length)));\n        }\n        else if (node.kind === 4 /* AstNodeKind.List */) {\n            for (const child of node.children) {\n                processNode(child, offset);\n                offset = lengthAdd(offset, child.length);\n            }\n        }\n    }\n    processNode(node, lengthZero);\n    return str;\n}\nclass StaticTokenizerSource {\n    constructor(lines) {\n        this.lines = lines;\n        this.tokenization = {\n            getLineTokens: (lineNumber) => {\n                return this.lines[lineNumber - 1];\n            }\n        };\n    }\n    getLineCount() {\n        return this.lines.length;\n    }\n    getLineLength(lineNumber) {\n        return this.lines[lineNumber - 1].getLineContent().length;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        var _a;\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* PositionAffinity.None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* PositionAffinity.None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* PositionAffinity.Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* PositionAffinity.Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* PositionAffinity.None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n"],"names":["TokenMetadata","getLanguageId","metadata","getTokenType","containsBalancedBrackets","getFontStyle","getForeground","getBackground","getClassNameFromMetadata","className","this","fontStyle","getInlineStyleFromMetadata","colorMap","foreground","result","concat","textDecoration","getPresentationFromMetadata","italic","Boolean","bold","underline","strikethrough","isExclusive","selector","Array","isArray","every","exclusive","MatchCandidate","constructor","uri","languageId","notebookUri","notebookType","equals","other","_a","_b","toString","LanguageFeatureRegistry","_notebookInfoResolver","_clock","_entries","_onDidChange","Emitter","onDidChange","event","register","provider","entry","_score","_time","push","_lastCandidate","undefined","fire","length","toDisposable","idx","indexOf","splice","has","model","all","_updateScores","ordered","_orderedForEach","orderedGroups","lastBucket","lastBucketScore","callback","notebookInfo","call","candidate","type","score","shouldSynchronizeModel","sort","_compareByScoreAndTime","a","b","isBuiltinSelector","some","isBuiltin","candidateUri","candidateLanguage","candidateIsSynchronized","candidateNotebookUri","candidateNotebookType","ret","filter","value","language","pattern","scheme","hasAccessToAllModels","Math","max","normalizedPattern","base","normalize","fsPath","matchGlobPattern","HoverVerbosityAction","CompletionItemKinds","InlineCompletionTriggerKind","DocumentPasteTriggerKind","SignatureHelpTriggerKind","DocumentHighlightKind","Token","offset","_tokenBrand","TokenizationResult","tokens","endState","_tokenizationResultBrand","EncodedTokenizationResult","_encodedTokenizationResultBrand","byKind","Map","set","Codicon","symbolMethod","symbolFunction","symbolConstructor","symbolField","symbolVariable","symbolClass","symbolStruct","symbolInterface","symbolModule","symbolProperty","symbolEvent","symbolOperator","symbolUnit","symbolValue","symbolEnum","symbolConstant","symbolEnumMember","symbolKeyword","symbolSnippet","symbolText","symbolColor","symbolFile","symbolReference","symbolCustomColor","symbolFolder","symbolTypeParameter","account","issues","toIcon","kind","codicon","get","console","info","data","fromString","strict","res","SelectedSuggestionInfo","range","text","completionKind","isSnippetText","Range","lift","equalsRange","isLocationLink","thing","URI","isUri","isIRange","originSelectionRange","targetSelectionRange","symbolKindNames","localize","getAriaLabelForSymbol","symbolName","SymbolKinds","NewSymbolNameTag","NewSymbolNameTriggerKind","Command","InlayHintKind","symbolNamespace","symbolPackage","symbolString","symbolNumber","symbolBoolean","symbolArray","symbolObject","symbolKey","symbolNull","icon","FoldingRangeKind","fromValue","Comment","Imports","Region","is","obj","id","title","LazyTokenizationSupport","createSupport","_tokenizationSupport","dispose","then","support","tokenizationSupport","TokenizationRegistry","TokenizationRegistryImpl","InlineEditTriggerKind","getInheritIndentForLine","autoIndent","lineNumber","honorIntentialIndent","arguments","indentRulesSupport","getLanguageConfiguration","tokenization","indentation","action","priorLineNumber","getLineContent","precedingUnIgnoredLine","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","shouldIgnore","test","getPrecedingValidLine","precedingUnIgnoredLineContent","shouldIncrease","shouldIndentNextLine","strings","IndentAction","Indent","line","shouldDecrease","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","i","lineContent","j","getGoodIndentForLine","virtualModel","indentConverter","languageConfigurationService","richEditSupport","indent","inheritLine","shouldApplyEnterRules","inBetweenLine","enterResult","onEnter","removeText","substring","indentAction","IndentOutdent","shiftIndent","Outdent","unshiftIndent","appendText","getIndentForEnter","forceTokenization","startLineNumber","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","startColumn","scopedLineText","beforeEnterText","afterEnterText","embeddedLanguage","firstCharOffset","substr","isEmpty","getScopedLineTokens","endLineNumber","endColumn","beforeEnterResult","beforeEnterIndent","column","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","getIndentActionForType","ch","beforeTypeText","afterTypeText","r","getLineCount","_parseCaptureGroups","captureGroups","values","captureGroup","parsedNumber","Number","replace","_toIColor","g","red","blue","green","alpha","_findRange","match","index","startPosition","positionAt","_findHexColorInformation","hexValue","parsedHexColor","Color","Format","CSS","parseHex","color","rgba","_findRGBColorInformation","matches","isAlpha","parsedRegex","_findHSLColorInformation","colorEquivalent","HSLA","_findMatches","regex","matchAll","findMatches","computeDefaultDocumentColors","getValue","initialValidationMatches","initialMatch","initialCaptureGroups","colorScheme","colorParameters","colorInformation","regexParameters","computeColors","getEnterAction","previousLineText","oneLineAboveScopedLineTokens","getIndentationAtPosition","ILanguageService","createDecorator","StandardAutoClosingPairConditional","source","_neutralCharacter","_neutralCharacterSearched","open","close","_inString","_inComment","_inRegEx","notIn","len","isOK","standardToken","shouldAutoClose","context","getTokenCount","tokenIndex","findTokenIndexAtOffset","standardTokenType","getStandardTokenType","_findNeutralCharacterInRange","fromCharCode","toCharCode","charCode","character","String","includes","findNeutralCharacter","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","charAt","target","key","CharacterPairSupport","config","_autoClosingPairs","map","el","brackets","__electricCharacterSupport","docComment","_autoCloseBeforeForQuotes","autoCloseBefore","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES","_autoCloseBeforeForBrackets","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS","_surroundingPairs","surroundingPairs","getAutoClosingPairs","getAutoCloseBeforeSet","forQuotes","getSurroundingPairs","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","getElectricCharacters","bracket","lastChar","distinct","onElectricCharacter","ignoreBracketsInToken","reversedBracketRegex","reversedRegex","BracketsUtils","findPrevBracketInRange","bracketText","toLowerCase","textIsOpenBracket","textBeforeBracket","getActualLineContentBefore","matchOpenBracket","resetGlobalRegex","reg","global","lastIndex","IndentRulesSupport","indentationRules","_indentationRules","increaseIndentPattern","decreaseIndentPattern","indentNextLinePattern","unIndentedLinePattern","OnEnterSupport","opts","_brackets","forEach","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","rule","beforeText","afterText","str","_safeRegExp","def","RegExp","err","onUnexpectedError","LanguageBracketsConfiguration","bracketPairs","filterValidBrackets","openingBracketInfos","CachedFunction","closing","Set","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","add","colorizedBracketPairs","p","_openingBrackets","cachedValues","_ref","k","v","_closingBrackets","_ref2","openingBrackets","closingBrackets","getOpeningBracketInfo","getClosingBracketInfo","getBracketInfo","_ref3","BracketKindBase","openedBrackets","super","isOpeningBracket","openingColorizedBrackets","closes","closesColorized","getOpeningBrackets","__decorate","decorators","desc","d","c","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","LanguageConfigurationServiceChangeEvent","affects","ILanguageConfigurationService","LanguageConfigurationService","Disposable","configurationService","languageService","_registry","_register","LanguageConfigurationRegistry","onDidChangeEmitter","configurations","languageConfigKeys","customizedLanguageConfigKeys","onDidChangeConfiguration","e","globalConfigChanged","change","keys","localConfigChanged","overrides","overrideLangName","clear","isRegisteredLanguageId","delete","configuration","priority","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","overrideIdentifier","validateBracketPairs","getCustomizedLanguageConfig","combineLanguageConfigurations","underlyingConfig","computeConfig","IConfigurationService","lineText","columnNumber","getLineMaxColumn","ComposedLanguageConfiguration","_resolved","_order","LanguageConfigurationContribution","getResolvedConfiguration","_resolve","cmp","configs","comments","wordPattern","folding","order","LanguageConfigurationChangeEvent","PLAINTEXT_LANGUAGE_ID","offSide","entries","disposable","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","DEFAULT_WORD_REGEXP","foldingRules","bracketsNew","getWordDefinition","ensureValidWordDefinition","RichEditBrackets","electricCharacter","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","registerSingleton","Uint8Matrix","rows","cols","defaultValue","Uint8Array","_data","row","col","StateMachine","edges","maxCharCode","maxState","from","chCode","to","states","_states","_maxCharCode","nextState","currentState","_stateMachine","_classifier","LinkComputer","_createLink","classifier","linkBeginIndex","linkEndIndex","lastIncludedCharIndex","charCodeAt","charCodeBeforeLink","lastCharCodeInLink","url","computeLinks","stateMachine","CharacterClassifier","FORCE_TERMINATION_CHARACTERS","CANNOT_END_WITH_CHARACTERS","getClassifier","lineCount","linkBeginChCode","state","hasOpenParens","hasOpenSquareBracket","inSquareBrackets","hasOpenCurlyBracket","resetStateMachine","chClass","ModesRegistry","_onDidChangeLanguages","onDidChangeLanguages","_languages","registerLanguage","getLanguages","Registry","extensions","aliases","nls","mimetypes","Mimes","as","ConfigurationExtensions","Configuration","registerDefaultConfigurations","NullState","clone","nullTokenize","nullTokenizeEncoded","Uint32Array","tokenCount","getCount","desiredLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","getStartOffset","getEndOffset","actual","lastCharOffset","_scopedLineTokensBrand","_actual","_firstTokenIndex","_lastTokenIndex","_lastCharOffset","BasicInplaceReplace","_defaultValueSet","navigateValueSet","range1","text1","range2","text2","up","doNavigateValueSet","numberResult","numberReplace","textReplace","precision","pow","lastIndexOf","n1","n2","parseFloat","isNaN","floor","valueSetsReplace","valueSets","valueSetReplace","valueSet","INSTANCE","RichEditBracket","forwardRegex","_richEditBracketBrand","_openSet","_toSet","_closeSet","isOpen","isClose","arr","element","_richEditBracketsBrand","N","group","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","min","oldG","currentOpen","currentClose","groupFuzzyBrackets","currentIndex","pieces","collectSuperstrings","unique","lengthcmp","reverse","createBracketOrRegExp","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","maxBracketLength","dest","seen","prepareBracketForRegExp","insertWordBoundaries","regexStr","join","lastInput","lastOutput","Uint16Array","stringBuilder","decode","_findPrevBracketInText","reversedText","m","matchOffset","matchLength","absoluteMatchOffset","startOffset","endOffset","reversedSubstr","findNextBracketInText","bracketRegex","findNextBracketInRange","ParsedTokenThemeRule","token","background","_parsedThemeRuleBrand","colorRegExp","ColorMap","_lastColorId","_id2color","_color2id","getId","Error","toUpperCase","fromHex","getColorMap","slice","TokenTheme","createFromRawTokenTheme","customTokenColors","createFromParsedTokenTheme","resultLen","segments","split","lenJ","parseTokenTheme","parsedThemeRules","strcmp","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","shift","foregroundColorId","backgroundColorId","defaults","ThemeTrieElementRule","root","ThemeTrieElement","insert","resolveParsedTokenThemeRules","_colorMap","_root","_cache","_match","tokenType","STANDARD_TOKEN_TYPE_REGEXP","toStandardTokenType","_themeTrieElementRuleBrand","_fontStyle","_foreground","_background","acceptOverwrite","mainRule","_themeTrieElementBrand","_mainRule","_children","dotIndex","head","tail","child","generateTokensCSSForColorMap","rules","fallback","getInitialState","tokenizeEncoded","buffer","hasEOL","async","tokenizeToString","_tokenizeToString","languageIdCodec","getOrCreate","tokenizeLineToHTML","viewLineTokens","tabSize","useNbsp","charIndex","tabsCharDelta","prevIsSpace","tokenEndIndex","partContent","insertSpacesCount","getInlineStyle","lines","tokenizationResult","LineTokens","convertToEndOffset","inflate","getClassName","endIndex","OverviewRulerLane","GlyphMarginLane","InjectedTextCursorStops","TextModelResolvedOptions","originalIndentSize","_indentSizeIsTabSize","indentSize","src","_textModelResolvedOptionsBrand","insertSpaces","defaultEOL","trimAutoWhitespace","bracketPairColorizationOptions","createChangeEvent","newOpts","FindMatch","_findMatchBrand","isITextSnapshot","read","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","SearchData","wordSeparators","simpleSearch","ApplyEditsResult","reverseEdits","changes","trimAutoWhitespaceLineNumbers","isTooLargeForSyncing","isForSimpleWidget","BracketPairsTree","didLanguageChange","textModel","didChangeEmitter","denseKeyProvider","DenseKeyProvider","LanguageAgnosticBracketTokens","queuedTextEditsForInitialAstWithoutTokens","queuedTextEdits","hasTokens","backgroundTokenizationState","initialAstWithoutTokens","astWithTokens","parseDocumentFromTextBuffer","getSingleLanguageBracketTokens","tokenizer","FastTokenizer","parseDocument","handleDidChangeBackgroundTokenizationState","wasUndefined","handleDidChangeTokens","ranges","edits","TextEditInfo","toLength","fromLineNumber","toLineNumber","handleEdits","handleContentChanged","fromModelContentChanges","tokenChange","combineTextEditInfos","flushQueue","previousAst","immutable","previousAstClone","TextBufferTokenizer","getBracketsInRange","onlyColorizedBrackets","CallbackIterable","cb","node","collectBrackets","lengthZero","getBracketPairsInRange","includeMinIndentation","startLength","positionToLength","getStartPosition","endLength","getEndPosition","CollectBracketPairsContext","collectBracketPairs","getFirstBracketAfter","position","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","lengths","children","lengthAdd","lengthLessThan","lengthsToRange","bracketInfo","level","nestingLevelOfEqualBracketType","levelPerBracketType","parentPairIsIncomplete","whileLoop","childCount","childrenLength","getChild","lengthLessThanEqual","lengthGreaterThanEqual","colorize","closingBracket","openingBracket","levelPerBracket","existing","BracketInfo","shouldContinue","openingBracketEnd","minIndentation","computeMinIndentation","BracketPairWithMinIndentationInfo","curOffset","childOffset","BracketPairsTextModelPart","canBuildAST","getValueLength","bracketPairsTree","MutableDisposable","bracketsRequested","object","updateBracketPairsTree","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","store","DisposableStore","empty","getBracketPairsInRangeWithMinIndentation","findMatchingBracketUp","_bracket","_position","maxDuration","validatePosition","closingBracketInfo","bracketPair","fromPositions","findLast","openingBracketInfo","openingBracketRange","bracketsSupport","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","item","closingBracketRange","containsPosition","findLastMaxBy","compareBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","modeBrackets","currentLanguageId","searchStartOffset","tokenEndOffset","searchEndOffset","tokenStartOffset","currentModeBrackets","bestResult","foundBracket","foundBracketText","_matchFoundBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","matched","_findMatchingBracketDown","count","totalCallCount","searchPrevMatchingBracketInRange","hitText","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","findPrevBracket","bracketConfig","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","strictContainsRange","savedCounts","counts","resetCounts","tmp","searchInRange","getValueInRange","startTime","Date","now","_searchCanceledBrand","BaseAstNode","_length","PairAstNode","create","missingOpeningBracketIds","SmallImmutableSet","getEmpty","listHeight","canBeReused","openBracketIds","intersects","deepClone","MAX_SAFE_INTEGER","ListAstNode","create23","item1","item2","item3","missingBracketIds","merge","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","makeLastElementMutable","lastChild","mutable","toMutable","setChild","makeFirstElementMutable","firstChild","lastLength","BugIndicatingError","handleChildrenChanged","unopenedBrackets","_item3","_item1","_item2","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","pop","unshift","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","start","lengthToObj","columnCount","lengthGetLineCount","firstNonWsColumn","getLineFirstNonWhitespaceColumn","visibleColumn","CursorColumns","visibleColumnFromColumn","getOptions","BracketAstNode","bracketIds","InvalidBracketAstNode","openedBracketIds","lengthOfString","newLength","BeforeEditPositionMapper","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","edit","TextEditInfoCache","getOffsetBeforeChange","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","lengthDiffNonNegative","oldOffsetObj","newOffset","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength","BracketTokens","createFromLanguage","getKey","openingTextId","identityKeyProvider","hasRegExp","_regExpGlobal","getRegExpStr","escaped","escapeRegExpCharacters","regExpGlobal","regExpStr","getToken","findClosingTokenText","openingBracketIds","closingText","size","languageIdToBracketTokens","singleLanguageBracketTokens","textEditInfoFirst","textEditInfoSecond","s0ToS1Map","ArrayQueue","toLengthMapping","s1ToS2Map","modified","lengthBefore","lengthAfter","curItem","dequeue","nextS0ToS1MapWithS1LengthOf","s1Length","takeWhile","lengthIsZero","remainingItem","splitAt","LengthMapping","pushEdit","lengthEquals","lastResult","s0offset","s1ToS2","s0Length","sumLengths","s","s0EndOffset","s1","s0startOffset","remainingLengthAfter","textEditInfos","lastOffset","textEditInfo","spaceLength","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","factor","l","TextLength","lengthGetColumnCountIfZeroLineCount","l1","l2","items","lengthFn","reduce","length1","length2","lineCount1","lineCount2","colCount2","lengthStart","lengthEnd","colCount","splitLines","concat23TreesOfSameHeight","createImmutableLists","heightDiff","node1","node2","abs","list","nodeToAppend","curNode","parents","nodeToAppendOfCorrectHeight","parent","append","nodeToPrependOfCorrectHeight","prepend","NodeReader","nextNodes","offsets","idxs","readLongestNodeAt","predicate","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","tryReadChildFromCache","peek","parseChild","readNode","height","first","second","concat23Trees","maxCacheableLength","cachedNode","skip","astNode","nextToken","bracketId","emptyArr","additionalItems","cached","cache","keyProvider","newItem","newItems","merged","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","textBufferLastLineLength","getLineLength","setPosition","lineIdx","lineCharOffset","lineTokenOffset","peekedToken","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","getMetadata","isOther","containsBracketType","regexp","exec","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","NotSupportedError","ColorizedBracketPairsDecorationProvider","colorProvider","ColorProvider","colorizationOptions","getDecorationsInRange","ownerId","filterOutValidation","onlyMinimapDecorations","enabled","nestingLevel","options","description","inlineClassName","getInlineClassName","independentColorPoolPerBracketType","toArray","getAllDecorations","unexpectedClosingBracketClassName","isInvalid","getInlineClassNameOfLevel","registerThemingParticipant","theme","collector","colors","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","addRule","getColor","editorBracketHighlightingUnexpectedBracketForeground","colorValues","isTransparent","fixBracketsInLine","StaticTokenizerSource","processNode","closingTokenText","uriGetComparisonKey","resource","SingleModelEditStackData","beforeCursorState","alternativeVersionId","getAlternativeVersionId","eol","getModelEOL","beforeVersionId","afterVersionId","beforeEOL","afterEOL","afterCursorState","textChanges","compressConsecutiveTextChanges","_writeSelectionsSize","selections","_writeSelections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_readSelections","Selection","serialize","necessarySize","writeSize","write","deserialize","changeCount","TextChange","SingleModelEditStackElement","label","code","matchesResource","setModel","canAppend","undo","_applyUndo","redo","_applyRedo","heapSize","byteLength","MultiModelEditStackElement","resources","_editStackElementsArr","editStackElement","editStackElements","_isOpen","_editStackElementsMap","_delegate","prepareUndoRedo","basename","getEOL","isEditStackElement","EditStack","undoRedoService","_model","_undoRedoService","pushStackElement","lastElement","getLastElement","popStackElement","removeElements","_getOrCreateEditStackElement","newElement","pushElement","pushEOL","setEOL","pushEditOperation","editOperations","cursorStateComputer","inverseEditOperations","applyEdits","_computeCursorState","op","textChange","oldPosition","FixedArray","_default","_store","oldLength","before","after","insertArr","arrayFill","deleteIndex","deleteCount","insertIndex","insertCount","arrayInsert","GuidesTextModelPart","TextModelPart","_computeIndentLevel","lineIndex","computeIndentLevel","getActiveIndentGuide","minLineNumber","maxLineNumber","assertNotDisposed","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","includeSingleLinePairs","activeBracketPairRange","bracketsContainingActivePosition","bp","strictContainsPosition","BracketPairGuidesClassNames","isActive","includeInactive","highlightActive","activeClassName","end","horizontalGuides","HorizontalGuidesState","Enabled","EnabledForActive","IndentGuide","IndentGuideHorizontalLine","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","guides","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","getLineCharCode","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","left","right","delta","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","reset","versionId","setOptions","glyphMarginClassName","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","requestNormalizeDelta","intervalSearch","filterOwnerId","onlyMarginDecorations","T","intervalStart","intervalEnd","nodeMaxEnd","nodeStart","nodeEnd","include","search","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","resolveNode","initialNode","acceptReplace","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","x","zAbsoluteStart","zAbsoluteEnd","intervalCompare","treeInsert","recomputeMaxEndWalkToRoot","y","leftRotate","rightRotate","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","ModelLineProjectionData","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","getOutputLineCount","getMinOutputOffset","outputLineIndex","lineLength","getMaxOutputOffset","translateToInputOffset","outputOffset","offsetInInput","content","translateToOutputPosition","inputOffset","affinity","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","low","high","mid","midStart","midStop","OutputPosition","normalizeOutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","injectedText","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","assertNever","getInjectedText","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","cursorStop","Right","Both","Left","toPosition","baseLineNumber","Position"],"sourceRoot":""}