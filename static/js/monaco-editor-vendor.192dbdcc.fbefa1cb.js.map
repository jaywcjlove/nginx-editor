{"version":3,"file":"static/js/monaco-editor-vendor.192dbdcc.fbefa1cb.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","../node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/viewEventHandler.js","../node_modules/monaco-editor/esm/vs/editor/common/viewEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linePart.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLinesViewportData.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/minimapTokensColorTracker.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/overviewZoneManager.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewContext.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelDecorations.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLayout.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjection.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/glyphLanesModel.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModelEventDispatcher.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits\n        return {\n            changes: changes,\n            eol: eol,\n            isEolChange: isEolChange,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../base/common/lifecycle.js';\nexport class TokenizationRegistry {\n    constructor() {\n        this._tokenizationSupports = new Map();\n        this._factories = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._colorMap = null;\n    }\n    handleChange(languageIds) {\n        this._onDidChange.fire({\n            changedLanguages: languageIds,\n            changedColorMap: false\n        });\n    }\n    register(languageId, support) {\n        this._tokenizationSupports.set(languageId, support);\n        this.handleChange([languageId]);\n        return toDisposable(() => {\n            if (this._tokenizationSupports.get(languageId) !== support) {\n                return;\n            }\n            this._tokenizationSupports.delete(languageId);\n            this.handleChange([languageId]);\n        });\n    }\n    get(languageId) {\n        return this._tokenizationSupports.get(languageId) || null;\n    }\n    registerFactory(languageId, factory) {\n        var _a;\n        (_a = this._factories.get(languageId)) === null || _a === void 0 ? void 0 : _a.dispose();\n        const myData = new TokenizationSupportFactoryData(this, languageId, factory);\n        this._factories.set(languageId, myData);\n        return toDisposable(() => {\n            const v = this._factories.get(languageId);\n            if (!v || v !== myData) {\n                return;\n            }\n            this._factories.delete(languageId);\n            v.dispose();\n        });\n    }\n    async getOrCreate(languageId) {\n        // check first if the support is already set\n        const tokenizationSupport = this.get(languageId);\n        if (tokenizationSupport) {\n            return tokenizationSupport;\n        }\n        const factory = this._factories.get(languageId);\n        if (!factory || factory.isResolved) {\n            // no factory or factory.resolve already finished\n            return null;\n        }\n        await factory.resolve();\n        return this.get(languageId);\n    }\n    isResolved(languageId) {\n        const tokenizationSupport = this.get(languageId);\n        if (tokenizationSupport) {\n            return true;\n        }\n        const factory = this._factories.get(languageId);\n        if (!factory || factory.isResolved) {\n            return true;\n        }\n        return false;\n    }\n    setColorMap(colorMap) {\n        this._colorMap = colorMap;\n        this._onDidChange.fire({\n            changedLanguages: Array.from(this._tokenizationSupports.keys()),\n            changedColorMap: true\n        });\n    }\n    getColorMap() {\n        return this._colorMap;\n    }\n    getDefaultBackground() {\n        if (this._colorMap && this._colorMap.length > 2 /* ColorId.DefaultBackground */) {\n            return this._colorMap[2 /* ColorId.DefaultBackground */];\n        }\n        return null;\n    }\n}\nclass TokenizationSupportFactoryData extends Disposable {\n    get isResolved() {\n        return this._isResolved;\n    }\n    constructor(_registry, _languageId, _factory) {\n        super();\n        this._registry = _registry;\n        this._languageId = _languageId;\n        this._factory = _factory;\n        this._isDisposed = false;\n        this._resolvePromise = null;\n        this._isResolved = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    async resolve() {\n        if (!this._resolvePromise) {\n            this._resolvePromise = this._create();\n        }\n        return this._resolvePromise;\n    }\n    async _create() {\n        const value = await this._factory.tokenizationSupport;\n        this._isResolved = true;\n        if (value && !this._isDisposed) {\n            this._register(this._registry.register(this._languageId, value));\n        }\n    }\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this._languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this._languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n    }\n}\nLineTokens.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n    | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n    | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n    static create(startLineNumber, tokens) {\n        return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._endLineNumber;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    toString() {\n        return this._tokens.toString(this._startLineNumber);\n    }\n    _updateEndLineNumber() {\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    isEmpty() {\n        return this._tokens.isEmpty();\n    }\n    getLineTokens(lineNumber) {\n        if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n            return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n        }\n        return null;\n    }\n    getRange() {\n        const deltaRange = this._tokens.getRange();\n        if (!deltaRange) {\n            return deltaRange;\n        }\n        return new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n    removeTokens(range) {\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        this._updateEndLineNumber();\n    }\n    split(range) {\n        // split tokens to two:\n        // a) all the tokens before `range`\n        // b) all the tokens after `range`\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n    }\n    applyEdit(range, text) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* CharCode.Null */);\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n        this._updateEndLineNumber();\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            // Nothing to delete\n            return;\n        }\n        const firstLineIndex = range.startLineNumber - this._startLineNumber;\n        const lastLineIndex = range.endLineNumber - this._startLineNumber;\n        if (lastLineIndex < 0) {\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\n            this._startLineNumber -= deletedLinesCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion occurs entirely after this block, so there is nothing to do\n            return;\n        }\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion completely encompasses this block\n            this._startLineNumber = 0;\n            this._tokens.clear();\n            return;\n        }\n        if (firstLineIndex < 0) {\n            const deletedBefore = -firstLineIndex;\n            this._startLineNumber -= deletedBefore;\n            this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n        }\n        else {\n            this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n        }\n    }\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - this._startLineNumber;\n        if (lineIndex < 0) {\n            // this insertion occurs before this block, so we only need to adjust line numbers\n            this._startLineNumber += eolCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\n            // this insertion occurs after this block, so there is nothing to do\n            return;\n        }\n        this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n}\nclass SparseMultilineTokensStorage {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._tokenCount = tokens.length / 4;\n    }\n    toString(startLineNumber) {\n        const pieces = [];\n        for (let i = 0; i < this._tokenCount; i++) {\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n        }\n        return `[${pieces.join(',')}]`;\n    }\n    getMaxDeltaLine() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return -1;\n        }\n        return this._getDeltaLine(tokenCount - 1);\n    }\n    getRange() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return null;\n        }\n        const startChar = this._getStartCharacter(0);\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n        const endChar = this._getEndCharacter(tokenCount - 1);\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n    _getTokenCount() {\n        return this._tokenCount;\n    }\n    _getDeltaLine(tokenIndex) {\n        return this._tokens[4 * tokenIndex];\n    }\n    _getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    _getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    isEmpty() {\n        return (this._getTokenCount() === 0);\n    }\n    getLineTokens(deltaLine) {\n        let low = 0;\n        let high = this._getTokenCount() - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const midDeltaLine = this._getDeltaLine(mid);\n            if (midDeltaLine < deltaLine) {\n                low = mid + 1;\n            }\n            else if (midDeltaLine > deltaLine) {\n                high = mid - 1;\n            }\n            else {\n                let min = mid;\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n                    min--;\n                }\n                let max = mid;\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n                    max++;\n                }\n                return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n            }\n        }\n        if (this._getDeltaLine(low) === deltaLine) {\n            return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n        }\n        return null;\n    }\n    clear() {\n        this._tokenCount = 0;\n    }\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        let firstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                hasDeletedTokens = true;\n            }\n            else {\n                if (newTokenCount === 0) {\n                    firstDeltaLine = tokenDeltaLine;\n                }\n                if (hasDeletedTokens) {\n                    // must move the token to the left\n                    const destOffset = 4 * newTokenCount;\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n                    tokens[destOffset + 1] = tokenStartCharacter;\n                    tokens[destOffset + 2] = tokenEndCharacter;\n                    tokens[destOffset + 3] = tokenMetadata;\n                }\n                newTokenCount++;\n            }\n        }\n        this._tokenCount = newTokenCount;\n        return firstDeltaLine;\n    }\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const aTokens = [];\n        const bTokens = [];\n        let destTokens = aTokens;\n        let destOffset = 0;\n        let destFirstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                    // this token is touching the range\n                    continue;\n                }\n                else {\n                    // this token is after the range\n                    if (destTokens !== bTokens) {\n                        // this token is the first token after the range\n                        destTokens = bTokens;\n                        destOffset = 0;\n                        destFirstDeltaLine = tokenDeltaLine;\n                    }\n                }\n            }\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n            destTokens[destOffset++] = tokenStartCharacter;\n            destTokens[destOffset++] = tokenEndCharacter;\n            destTokens[destOffset++] = tokenMetadata;\n        }\n        return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n        // This is a bit complex, here are the cases I used to think about this:\n        //\n        // 1. The token starts before the deletion range\n        // 1a. The token is completely before the deletion range\n        //               -----------\n        //                          xxxxxxxxxxx\n        // 1b. The token starts before, the deletion range ends after the token\n        //               -----------\n        //                      xxxxxxxxxxx\n        // 1c. The token starts before, the deletion range ends precisely with the token\n        //               ---------------\n        //                      xxxxxxxx\n        // 1d. The token starts before, the deletion range is inside the token\n        //               ---------------\n        //                    xxxxx\n        //\n        // 2. The token starts at the same position with the deletion range\n        // 2a. The token starts at the same position, and ends inside the deletion range\n        //               -------\n        //               xxxxxxxxxxx\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\n        //               ----------\n        //               xxxxxxxxxx\n        // 2c. The token starts at the same position, and ends after the deletion range\n        //               -------------\n        //               xxxxxxx\n        //\n        // 3. The token starts inside the deletion range\n        // 3a. The token is inside the deletion range\n        //                -------\n        //             xxxxxxxxxxxxx\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n        //                ----------\n        //             xxxxxxxxxxxxx\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\n        //                ------------\n        //             xxxxxxxxxxx\n        //\n        // 4. The token starts after the deletion range\n        //                  -----------\n        //          xxxxxxxx\n        //\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            let tokenDeltaLine = tokens[srcOffset];\n            let tokenStartCharacter = tokens[srcOffset + 1];\n            let tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n                // 1a. The token is completely before the deletion range\n                // => nothing to do\n                newTokenCount++;\n                continue;\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n                // 1b, 1c, 1d\n                // => the token survives, but it needs to shrink\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 1d. The token starts before, the deletion range is inside the token\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 1b. The token starts before, the deletion range ends after the token\n                    // 1c. The token starts before, the deletion range ends precisely with the token\n                    // => the token shrinks its ending to the deletion start\n                    tokenEndCharacter = startCharacter;\n                }\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n                // 2a, 2b, 2c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 2c. The token starts at the same position, and ends after the deletion range\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 2a. The token starts at the same position, and ends inside the deletion range\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n                // 3a, 3b, 3c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\n                    // => the token moves to continue right after the deletion\n                    tokenDeltaLine = startDeltaLine;\n                    tokenStartCharacter = startCharacter;\n                    tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                }\n                else {\n                    // 3a. The token is inside the deletion range\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine > endDeltaLine) {\n                // 4. (partial) The token starts after the deletion range, on a line below...\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\n                    // early stop, there is no need to walk all the tokens and do nothing...\n                    newTokenCount = tokenCount;\n                    break;\n                }\n                tokenDeltaLine -= deletedLineCount;\n            }\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\n                }\n                tokenDeltaLine -= deletedLineCount;\n                tokenStartCharacter -= (endCharacter - startCharacter);\n                tokenEndCharacter -= (endCharacter - startCharacter);\n            }\n            else {\n                throw new Error(`Not possible!`);\n            }\n            const destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n            newTokenCount++;\n        }\n        this._tokenCount = newTokenCount;\n    }\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        // Here are the cases I used to think about this:\n        //\n        // 1. The token is completely before the insertion point\n        //            -----------   |\n        // 2. The token ends precisely at the insertion point\n        //            -----------|\n        // 3. The token contains the insertion point\n        //            -----|------\n        // 4. The token starts precisely at the insertion point\n        //            |-----------\n        // 5. The token is completely after the insertion point\n        //            |   -----------\n        //\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\n            && firstLineLength === 1\n            && ((firstCharCode >= 48 /* CharCode.Digit0 */ && firstCharCode <= 57 /* CharCode.Digit9 */)\n                || (firstCharCode >= 65 /* CharCode.A */ && firstCharCode <= 90 /* CharCode.Z */)\n                || (firstCharCode >= 97 /* CharCode.a */ && firstCharCode <= 122 /* CharCode.z */)));\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        for (let i = 0; i < tokenCount; i++) {\n            const offset = 4 * i;\n            let tokenDeltaLine = tokens[offset];\n            let tokenStartCharacter = tokens[offset + 1];\n            let tokenEndCharacter = tokens[offset + 2];\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n                // 1. The token is completely before the insertion point\n                // => nothing to do\n                continue;\n            }\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n                // 2. The token ends precisely at the insertion point\n                // => expand the end character only if inserting precisely one character that is a word character\n                if (isInsertingPreciselyOneWordCharacter) {\n                    tokenEndCharacter += 1;\n                }\n                else {\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n                // 3. The token contains the insertion point\n                if (eolCount === 0) {\n                    // => just expand the end character\n                    tokenEndCharacter += firstLineLength;\n                }\n                else {\n                    // => cut off the token\n                    tokenEndCharacter = character;\n                }\n            }\n            else {\n                // 4. or 5.\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n                    // 4. The token starts precisely at the insertion point\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n                    // => otherwise behave as in case 5.\n                    if (isInsertingPreciselyOneWordCharacter) {\n                        continue;\n                    }\n                }\n                // => the token must move and keep its size constant\n                if (tokenDeltaLine === deltaLine) {\n                    tokenDeltaLine += eolCount;\n                    // this token is on the line where the insertion is taking place\n                    if (eolCount === 0) {\n                        tokenStartCharacter += firstLineLength;\n                        tokenEndCharacter += firstLineLength;\n                    }\n                    else {\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\n                    }\n                }\n                else {\n                    tokenDeltaLine += eolCount;\n                }\n            }\n            tokens[offset] = tokenDeltaLine;\n            tokens[offset + 1] = tokenStartCharacter;\n            tokens[offset + 2] = tokenEndCharacter;\n        }\n    }\n}\nexport class SparseLineTokens {\n    constructor(tokens) {\n        this._tokens = tokens;\n    }\n    getCount() {\n        return this._tokens.length / 4;\n    }\n    getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    getMetadata(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 3];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../base/common/lifecycle.js';\nexport class ViewEventHandler extends Disposable {\n    constructor() {\n        super();\n        this._shouldRender = true;\n    }\n    shouldRender() {\n        return this._shouldRender;\n    }\n    forceShouldRender() {\n        this._shouldRender = true;\n    }\n    setShouldRender() {\n        this._shouldRender = true;\n    }\n    onDidRender() {\n        this._shouldRender = false;\n    }\n    // --- begin event handlers\n    onCompositionStart(e) {\n        return false;\n    }\n    onCompositionEnd(e) {\n        return false;\n    }\n    onConfigurationChanged(e) {\n        return false;\n    }\n    onCursorStateChanged(e) {\n        return false;\n    }\n    onDecorationsChanged(e) {\n        return false;\n    }\n    onFlushed(e) {\n        return false;\n    }\n    onFocusChanged(e) {\n        return false;\n    }\n    onLanguageConfigurationChanged(e) {\n        return false;\n    }\n    onLineMappingChanged(e) {\n        return false;\n    }\n    onLinesChanged(e) {\n        return false;\n    }\n    onLinesDeleted(e) {\n        return false;\n    }\n    onLinesInserted(e) {\n        return false;\n    }\n    onRevealRangeRequest(e) {\n        return false;\n    }\n    onScrollChanged(e) {\n        return false;\n    }\n    onThemeChanged(e) {\n        return false;\n    }\n    onTokensChanged(e) {\n        return false;\n    }\n    onTokensColorsChanged(e) {\n        return false;\n    }\n    onZonesChanged(e) {\n        return false;\n    }\n    // --- end event handlers\n    handleEvents(events) {\n        let shouldRender = false;\n        for (let i = 0, len = events.length; i < len; i++) {\n            const e = events[i];\n            switch (e.type) {\n                case 0 /* viewEvents.ViewEventType.ViewCompositionStart */:\n                    if (this.onCompositionStart(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 1 /* viewEvents.ViewEventType.ViewCompositionEnd */:\n                    if (this.onCompositionEnd(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 2 /* viewEvents.ViewEventType.ViewConfigurationChanged */:\n                    if (this.onConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 3 /* viewEvents.ViewEventType.ViewCursorStateChanged */:\n                    if (this.onCursorStateChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 4 /* viewEvents.ViewEventType.ViewDecorationsChanged */:\n                    if (this.onDecorationsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 5 /* viewEvents.ViewEventType.ViewFlushed */:\n                    if (this.onFlushed(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 6 /* viewEvents.ViewEventType.ViewFocusChanged */:\n                    if (this.onFocusChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 7 /* viewEvents.ViewEventType.ViewLanguageConfigurationChanged */:\n                    if (this.onLanguageConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 8 /* viewEvents.ViewEventType.ViewLineMappingChanged */:\n                    if (this.onLineMappingChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 9 /* viewEvents.ViewEventType.ViewLinesChanged */:\n                    if (this.onLinesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 10 /* viewEvents.ViewEventType.ViewLinesDeleted */:\n                    if (this.onLinesDeleted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 11 /* viewEvents.ViewEventType.ViewLinesInserted */:\n                    if (this.onLinesInserted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 12 /* viewEvents.ViewEventType.ViewRevealRangeRequest */:\n                    if (this.onRevealRangeRequest(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 13 /* viewEvents.ViewEventType.ViewScrollChanged */:\n                    if (this.onScrollChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 15 /* viewEvents.ViewEventType.ViewTokensChanged */:\n                    if (this.onTokensChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 14 /* viewEvents.ViewEventType.ViewThemeChanged */:\n                    if (this.onThemeChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 16 /* viewEvents.ViewEventType.ViewTokensColorsChanged */:\n                    if (this.onTokensColorsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 17 /* viewEvents.ViewEventType.ViewZonesChanged */:\n                    if (this.onZonesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                default:\n                    console.info('View received unknown event: ');\n                    console.info(e);\n            }\n        }\n        if (shouldRender) {\n            this._shouldRender = true;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ViewCompositionStartEvent {\n    constructor() {\n        this.type = 0 /* ViewEventType.ViewCompositionStart */;\n    }\n}\nexport class ViewCompositionEndEvent {\n    constructor() {\n        this.type = 1 /* ViewEventType.ViewCompositionEnd */;\n    }\n}\nexport class ViewConfigurationChangedEvent {\n    constructor(source) {\n        this.type = 2 /* ViewEventType.ViewConfigurationChanged */;\n        this._source = source;\n    }\n    hasChanged(id) {\n        return this._source.hasChanged(id);\n    }\n}\nexport class ViewCursorStateChangedEvent {\n    constructor(selections, modelSelections, reason) {\n        this.selections = selections;\n        this.modelSelections = modelSelections;\n        this.reason = reason;\n        this.type = 3 /* ViewEventType.ViewCursorStateChanged */;\n    }\n}\nexport class ViewDecorationsChangedEvent {\n    constructor(source) {\n        this.type = 4 /* ViewEventType.ViewDecorationsChanged */;\n        if (source) {\n            this.affectsMinimap = source.affectsMinimap;\n            this.affectsOverviewRuler = source.affectsOverviewRuler;\n            this.affectsGlyphMargin = source.affectsGlyphMargin;\n            this.affectsLineNumber = source.affectsLineNumber;\n        }\n        else {\n            this.affectsMinimap = true;\n            this.affectsOverviewRuler = true;\n            this.affectsGlyphMargin = true;\n            this.affectsLineNumber = true;\n        }\n    }\n}\nexport class ViewFlushedEvent {\n    constructor() {\n        this.type = 5 /* ViewEventType.ViewFlushed */;\n        // Nothing to do\n    }\n}\nexport class ViewFocusChangedEvent {\n    constructor(isFocused) {\n        this.type = 6 /* ViewEventType.ViewFocusChanged */;\n        this.isFocused = isFocused;\n    }\n}\nexport class ViewLanguageConfigurationEvent {\n    constructor() {\n        this.type = 7 /* ViewEventType.ViewLanguageConfigurationChanged */;\n    }\n}\nexport class ViewLineMappingChangedEvent {\n    constructor() {\n        this.type = 8 /* ViewEventType.ViewLineMappingChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewLinesChangedEvent {\n    constructor(\n    /**\n     * The first line that has changed.\n     */\n    fromLineNumber, \n    /**\n     * The number of lines that have changed.\n     */\n    count) {\n        this.fromLineNumber = fromLineNumber;\n        this.count = count;\n        this.type = 9 /* ViewEventType.ViewLinesChanged */;\n    }\n}\nexport class ViewLinesDeletedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 10 /* ViewEventType.ViewLinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewLinesInsertedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 11 /* ViewEventType.ViewLinesInserted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewRevealRangeRequestEvent {\n    constructor(\n    /**\n     * Source of the call that caused the event.\n     */\n    source, \n    /**\n     * Reduce the revealing to a minimum (e.g. avoid scrolling if the bounding box is visible and near the viewport edge).\n     */\n    minimalReveal, \n    /**\n     * Range to be reavealed.\n     */\n    range, \n    /**\n     * Selections to be revealed.\n     */\n    selections, \n    /**\n     * The vertical reveal strategy.\n     */\n    verticalType, \n    /**\n     * If true: there should be a horizontal & vertical revealing.\n     * If false: there should be just a vertical revealing.\n     */\n    revealHorizontal, \n    /**\n     * The scroll type.\n     */\n    scrollType) {\n        this.source = source;\n        this.minimalReveal = minimalReveal;\n        this.range = range;\n        this.selections = selections;\n        this.verticalType = verticalType;\n        this.revealHorizontal = revealHorizontal;\n        this.scrollType = scrollType;\n        this.type = 12 /* ViewEventType.ViewRevealRangeRequest */;\n    }\n}\nexport class ViewScrollChangedEvent {\n    constructor(source) {\n        this.type = 13 /* ViewEventType.ViewScrollChanged */;\n        this.scrollWidth = source.scrollWidth;\n        this.scrollLeft = source.scrollLeft;\n        this.scrollHeight = source.scrollHeight;\n        this.scrollTop = source.scrollTop;\n        this.scrollWidthChanged = source.scrollWidthChanged;\n        this.scrollLeftChanged = source.scrollLeftChanged;\n        this.scrollHeightChanged = source.scrollHeightChanged;\n        this.scrollTopChanged = source.scrollTopChanged;\n    }\n}\nexport class ViewThemeChangedEvent {\n    constructor(theme) {\n        this.theme = theme;\n        this.type = 14 /* ViewEventType.ViewThemeChanged */;\n    }\n}\nexport class ViewTokensChangedEvent {\n    constructor(ranges) {\n        this.type = 15 /* ViewEventType.ViewTokensChanged */;\n        this.ranges = ranges;\n    }\n}\nexport class ViewTokensColorsChangedEvent {\n    constructor() {\n        this.type = 16 /* ViewEventType.ViewTokensColorsChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.type = 17 /* ViewEventType.ViewZonesChanged */;\n        // Nothing to do\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n    constructor(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n        this._lineDecorationBrand = undefined;\n    }\n    static _equals(a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    }\n    static equalsArr(a, b) {\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static extractWrapped(arr, startOffset, endOffset) {\n        if (arr.length === 0) {\n            return arr;\n        }\n        const startColumn = startOffset + 1;\n        const endColumn = endOffset + 1;\n        const lineLength = endOffset - startOffset;\n        const r = [];\n        let rLength = 0;\n        for (const dec of arr) {\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n                continue;\n            }\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n        return r;\n    }\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            const range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === 0 /* InlineDecorationType.Regular */ || d.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    }\n    static _typeCompare(a, b) {\n        const ORDER = [2, 0, 1, 3];\n        return ORDER[a] - ORDER[b];\n    }\n    static compare(a, b) {\n        if (a.startColumn !== b.startColumn) {\n            return a.startColumn - b.startColumn;\n        }\n        if (a.endColumn !== b.endColumn) {\n            return a.endColumn - b.endColumn;\n        }\n        const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n        if (typeCmp !== 0) {\n            return typeCmp;\n        }\n        if (a.className !== b.className) {\n            return a.className < b.className ? -1 : 1;\n        }\n        return 0;\n    }\n}\nexport class DecorationSegment {\n    constructor(startOffset, endOffset, className, metadata) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n        this.metadata = metadata;\n    }\n}\nclass Stack {\n    constructor() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.metadata = [];\n        this.count = 0;\n    }\n    static _metadata(metadata) {\n        let result = 0;\n        for (let i = 0, len = metadata.length; i < len; i++) {\n            result |= metadata[i];\n        }\n        return result;\n    }\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            let i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.metadata.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    }\n    insert(stopOffset, className, metadata) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n            this.metadata.push(metadata);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (let i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    this.metadata.splice(i, 0, metadata);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    }\n}\nexport class LineDecorationsNormalizer {\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    static normalize(lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        const stack = new Stack();\n        let nextStartOffset = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            let startColumn = d.startColumn;\n            let endColumn = d.endColumn;\n            const className = d.className;\n            const metadata = (d.type === 1 /* InlineDecorationType.Before */\n                ? 2 /* LinePartMetadata.PSEUDO_BEFORE */\n                : d.type === 2 /* InlineDecorationType.After */\n                    ? 4 /* LinePartMetadata.PSEUDO_AFTER */\n                    : 0);\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            const currentStartOffset = startColumn - 1;\n            const currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className, metadata);\n        }\n        stack.consumeLowerThan(1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LinePart {\n    constructor(\n    /**\n     * last char index of this token (not inclusive).\n     */\n    endIndex, type, metadata, containsRTL) {\n        this.endIndex = endIndex;\n        this.type = type;\n        this.metadata = metadata;\n        this.containsRTL = containsRTL;\n        this._linePartBrand = undefined;\n    }\n    isWhitespace() {\n        return (this.metadata & 1 /* LinePartMetadata.IS_WHITESPACE_MASK */ ? true : false);\n    }\n    isPseudoAfter() {\n        return (this.metadata & 4 /* LinePartMetadata.PSEUDO_AFTER_MASK */ ? true : false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { StringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart } from './linePart.js';\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* RenderWhitespace.All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* RenderWhitespace.Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* RenderWhitespace.Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* RenderWhitespace.Trailing */\n                        : 0 /* RenderWhitespace.None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\nexport class DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* CharacterMappingConstants.PART_INDEX_MASK */) >>> 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CharacterMappingConstants.CHAR_INDEX_MASK */) >>> 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */;\n    }\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._horizontalOffset = new Uint32Array(this.length);\n    }\n    setColumnInfo(column, partIndex, charIndex, horizontalOffset) {\n        const partData = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._horizontalOffset[column - 1] = horizontalOffset;\n    }\n    getHorizontalOffset(column) {\n        if (this._horizontalOffset.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._horizontalOffset[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* ForeignElementType.None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* InlineDecorationType.Before */ || lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                    sb.appendString(`<span class=\"`);\n                    sb.appendString(lineDecoration.className);\n                    sb.appendString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                        containsForeignElements |= 1 /* ForeignElementType.Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                        containsForeignElements |= 2 /* ForeignElementType.After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* ForeignElementType.None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    const sb = new StringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.overflowingCharCount = overflowingCharCount;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let overflowingCharCount;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        overflowingCharCount = lineContent.length - input.stopRenderingLineAfter;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        overflowingCharCount = 0;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* RenderWhitespace.All */ ||\n        input.renderWhitespace === 1 /* RenderWhitespace.Boundary */ ||\n        (input.renderWhitespace === 2 /* RenderWhitespace.Selection */ && !!input.selectionsOnLine) ||\n        (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */ && !input.continuesWithWrappedLine)) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* ForeignElementType.None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                containsForeignElements |= 2 /* ForeignElementType.After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent, lineContainsRTL, tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n    }\n    let startOffset = fauxIndentLength;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false);\n            result[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n            break;\n        }\n        const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false);\n        result[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n        startOffset = endIndex;\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* Constants.LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* CharCode.Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* Constants.LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* Constants.LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                const piecesCount = Math.ceil(diff / 50 /* Constants.LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* Constants.LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* CharCode.Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0, false);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* RenderWhitespace.Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenContainsRTL = tokens[tokenIndex].containsRTL;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* CharCode.Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */);\n                    isInWhitespace = (nextChCode === 32 /* CharCode.Space */ || nextChCode === 9 /* CharCode.Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (isInWhitespace && tokenContainsRTL) {\n            // If the token contains RTL text, breaking it up into multiple line parts\n            // to render whitespace might affect the browser's bidi layout.\n            //\n            // We render whitespace in such tokens only if the whitespace\n            // is the leading or the trailing whitespace of the line,\n            // which doesn't affect the browser's bidi layout.\n            if (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n                isInWhitespace = false;\n            }\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* CharCode.Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenContainsRTL = tokens[tokenIndex].containsRTL;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* CharCode.Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* CharCode.Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* CharCode.Space */ && (prevCharCode !== 32 /* CharCode.Space */ && prevCharCode !== 9 /* CharCode.Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const tokenContainsRTL = token.containsRTL;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const overflowingCharCount = input.overflowingCharCount;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0; // the character offset in the current part\n    let charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n    let partDisplacement = 0;\n    if (containsRTL) {\n        sb.appendString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partContainsRTL = part.containsRTL;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* RenderWhitespace.None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendString('<span ');\n        if (partContainsRTL) {\n            sb.appendString('style=\"unicode-bidi:isolate\" ');\n        }\n        sb.appendString('class=\"');\n        sb.appendString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCIICharCode(34 /* CharCode.DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partWidth = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* CharCode.Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partWidth += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendString(' style=\"width:');\n                sb.appendString(String(spaceWidth * partWidth));\n                sb.appendString('px\"');\n            }\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters;\n                let charWidth;\n                if (charCode === 9 /* CharCode.Tab */) {\n                    producedCharacters = (tabSize - (visibleColumn % tabSize)) | 0;\n                    charWidth = producedCharacters;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.appendCharCode(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.appendCharCode(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.appendCharCode(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    producedCharacters = 2;\n                    charWidth = 1;\n                    sb.appendCharCode(renderSpaceCharCode); // &middot; or word separator middle dot\n                    sb.appendCharCode(0x200C); // ZERO WIDTH NON-JOINER\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        else {\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* CharCode.Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.appendCharCode(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* CharCode.Space */:\n                        sb.appendCharCode(0xA0); // &nbsp;\n                        break;\n                    case 60 /* CharCode.LessThan */:\n                        sb.appendString('&lt;');\n                        break;\n                    case 62 /* CharCode.GreaterThan */:\n                        sb.appendString('&gt;');\n                        break;\n                    case 38 /* CharCode.Ampersand */:\n                        sb.appendString('&amp;');\n                        break;\n                    case 0 /* CharCode.Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.appendCharCode(9216);\n                        }\n                        else {\n                            sb.appendString('&#00;');\n                        }\n                        break;\n                    case 65279 /* CharCode.UTF8_BOM */:\n                    case 8232 /* CharCode.LINE_SEPARATOR */:\n                    case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                    case 133 /* CharCode.NEXT_LINE */:\n                        sb.appendCharCode(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.appendCharCode(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.appendCharCode(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendString('[U+');\n                            sb.appendString(to4CharHex(charCode));\n                            sb.appendString(']');\n                            producedCharacters = 8;\n                            charWidth = producedCharacters;\n                        }\n                        else {\n                            sb.appendCharCode(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n        }\n        sb.appendString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n    }\n    if (isOverflowing) {\n        sb.appendString('<span class=\"mtkoverflow\">');\n        sb.appendString(nls.localize('showMore', \"Show more ({0})\", renderOverflowingCharCount(overflowingCharCount)));\n        sb.appendString('</span>');\n    }\n    sb.appendString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\nfunction renderOverflowingCharCount(n) {\n    if (n < 1024) {\n        return nls.localize('overflow.chars', \"{0} chars\", n);\n    }\n    if (n < 1024 * 1024) {\n        return `${(n / 1024).toFixed(1)} KB`;\n    }\n    return `${(n / 1024 / 1024).toFixed(1)} MB`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\n/**\n * Contains all data needed to render at a specific viewport.\n */\nexport class ViewportData {\n    constructor(selections, partialData, whitespaceViewportData, model) {\n        this.selections = selections;\n        this.startLineNumber = partialData.startLineNumber | 0;\n        this.endLineNumber = partialData.endLineNumber | 0;\n        this.relativeVerticalOffset = partialData.relativeVerticalOffset;\n        this.bigNumbersDelta = partialData.bigNumbersDelta | 0;\n        this.lineHeight = partialData.lineHeight | 0;\n        this.whitespaceViewportData = whitespaceViewportData;\n        this._model = model;\n        this.visibleRange = new Range(partialData.startLineNumber, this._model.getLineMinColumn(partialData.startLineNumber), partialData.endLineNumber, this._model.getLineMaxColumn(partialData.endLineNumber));\n    }\n    getViewLineRenderingData(lineNumber) {\n        return this._model.getViewportViewLineRenderingData(this.visibleRange, lineNumber);\n    }\n    getDecorationsInViewport() {\n        return this._model.getDecorationsInViewport(this.visibleRange);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../base/common/arrays.js';\nimport * as strings from '../../base/common/strings.js';\nimport { Range } from './core/range.js';\nexport class Viewport {\n    constructor(top, left, width, height) {\n        this._viewportBrand = undefined;\n        this.top = top | 0;\n        this.left = left | 0;\n        this.width = width | 0;\n        this.height = height | 0;\n    }\n}\nexport class MinimapLinesRenderingData {\n    constructor(tabSize, data) {\n        this.tabSize = tabSize;\n        this.data = data;\n    }\n}\nexport class ViewLineData {\n    constructor(content, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations) {\n        this._viewLineDataBrand = undefined;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.startVisibleColumn = startVisibleColumn;\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n    }\n}\nexport class ViewLineRenderingData {\n    constructor(minColumn, maxColumn, content, continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize, startVisibleColumn) {\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n        this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n    }\n    static isBasicASCII(lineContent, mightContainNonBasicASCII) {\n        if (mightContainNonBasicASCII) {\n            return strings.isBasicASCII(lineContent);\n        }\n        return true;\n    }\n    static containsRTL(lineContent, isBasicASCII, mightContainRTL) {\n        if (!isBasicASCII && mightContainRTL) {\n            return strings.containsRTL(lineContent);\n        }\n        return false;\n    }\n}\nexport class InlineDecoration {\n    constructor(range, inlineClassName, type) {\n        this.range = range;\n        this.inlineClassName = inlineClassName;\n        this.type = type;\n    }\n}\nexport class SingleLineInlineDecoration {\n    constructor(startOffset, endOffset, inlineClassName, inlineClassNameAffectsLetterSpacing) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.inlineClassName = inlineClassName;\n        this.inlineClassNameAffectsLetterSpacing = inlineClassNameAffectsLetterSpacing;\n    }\n    toInlineDecoration(lineNumber) {\n        return new InlineDecoration(new Range(lineNumber, this.startOffset + 1, lineNumber, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n    }\n}\nexport class ViewModelDecoration {\n    constructor(range, options) {\n        this._viewModelDecorationBrand = undefined;\n        this.range = range;\n        this.options = options;\n    }\n}\nexport class OverviewRulerDecorationsGroup {\n    constructor(color, zIndex, \n    /**\n     * Decorations are encoded in a number array using the following scheme:\n     *  - 3*i = lane\n     *  - 3*i+1 = startLineNumber\n     *  - 3*i+2 = endLineNumber\n     */\n    data) {\n        this.color = color;\n        this.zIndex = zIndex;\n        this.data = data;\n    }\n    static compareByRenderingProps(a, b) {\n        if (a.zIndex === b.zIndex) {\n            if (a.color < b.color) {\n                return -1;\n            }\n            if (a.color > b.color) {\n                return 1;\n            }\n            return 0;\n        }\n        return a.zIndex - b.zIndex;\n    }\n    static equals(a, b) {\n        return (a.color === b.color\n            && a.zIndex === b.zIndex\n            && arrays.equals(a.data, b.data));\n    }\n    static equalsArr(a, b) {\n        return arrays.equals(a, b, OverviewRulerDecorationsGroup.equals);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, markAsSingleton } from '../../../base/common/lifecycle.js';\nimport { RGBA8 } from '../core/rgba.js';\nimport { TokenizationRegistry } from '../languages.js';\nexport class MinimapTokensColorTracker extends Disposable {\n    static getInstance() {\n        if (!this._INSTANCE) {\n            this._INSTANCE = markAsSingleton(new MinimapTokensColorTracker());\n        }\n        return this._INSTANCE;\n    }\n    constructor() {\n        super();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._updateColorMap();\n        this._register(TokenizationRegistry.onDidChange(e => {\n            if (e.changedColorMap) {\n                this._updateColorMap();\n            }\n        }));\n    }\n    _updateColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        if (!colorMap) {\n            this._colors = [RGBA8.Empty];\n            this._backgroundIsLight = true;\n            return;\n        }\n        this._colors = [RGBA8.Empty];\n        for (let colorId = 1; colorId < colorMap.length; colorId++) {\n            const source = colorMap[colorId].rgba;\n            // Use a VM friendly data-type\n            this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));\n        }\n        const backgroundLuminosity = colorMap[2 /* ColorId.DefaultBackground */].getRelativeLuminance();\n        this._backgroundIsLight = backgroundLuminosity >= 0.5;\n        this._onDidChange.fire(undefined);\n    }\n    getColor(colorId) {\n        if (colorId < 1 || colorId >= this._colors.length) {\n            // background color (basically invisible)\n            colorId = 2 /* ColorId.DefaultBackground */;\n        }\n        return this._colors[colorId];\n    }\n    backgroundIsLight() {\n        return this._backgroundIsLight;\n    }\n}\nMinimapTokensColorTracker._INSTANCE = null;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from '../modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(134 /* EditorOption.wordWrapBreakBeforeCharacters */), options.get(133 /* EditorOption.wordWrapBreakAfterCharacters */));\n    }\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n        const requests = [];\n        const injectedTexts = [];\n        const previousBreakingData = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n                const result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const injectedText = injectedTexts[i];\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* CharacterClass.NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* CharacterClass.BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* CharacterClass.BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* CharacterClass.BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const isKeepAll = (wordBreak === 'keepAll');\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = arrPool1;\n    const breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* CharCode.Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* CharacterClass.NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* CharacterClass.NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* CharCode.Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* CharacterClass.NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n    const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n    let injectionOptions;\n    let injectionOffsets;\n    if (injectedTexts && injectedTexts.length > 0) {\n        injectionOptions = injectedTexts.map(t => t.options);\n        injectionOffsets = injectedTexts.map(text => text.column - 1);\n    }\n    else {\n        injectionOptions = null;\n        injectionOffsets = null;\n    }\n    if (firstLineBreakColumn === -1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const isKeepAll = (wordBreak === 'keepAll');\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = [];\n    const breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* CharacterClass.NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* CharCode.Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll) {\n    return (charCode !== 32 /* CharCode.Space */\n        && ((prevCharCodeClass === 2 /* CharacterClass.BREAK_AFTER */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */) // break at the end of multiple BREAK_AFTER\n            || (prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */ && charCodeClass === 1 /* CharacterClass.BREAK_BEFORE */) // break at the start of multiple BREAK_BEFORE\n            || (!isKeepAll && prevCharCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */)\n            || (!isKeepAll && charCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* CharCode.Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ColorZone {\n    constructor(from, to, colorId) {\n        this._colorZoneBrand = undefined;\n        this.from = from | 0;\n        this.to = to | 0;\n        this.colorId = colorId | 0;\n    }\n    static compare(a, b) {\n        if (a.colorId === b.colorId) {\n            if (a.from === b.from) {\n                return a.to - b.to;\n            }\n            return a.from - b.from;\n        }\n        return a.colorId - b.colorId;\n    }\n}\n/**\n * A zone in the overview ruler\n */\nexport class OverviewRulerZone {\n    constructor(startLineNumber, endLineNumber, heightInLines, color) {\n        this._overviewRulerZoneBrand = undefined;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n        this.heightInLines = heightInLines;\n        this.color = color;\n        this._colorZone = null;\n    }\n    static compare(a, b) {\n        if (a.color === b.color) {\n            if (a.startLineNumber === b.startLineNumber) {\n                if (a.heightInLines === b.heightInLines) {\n                    return a.endLineNumber - b.endLineNumber;\n                }\n                return a.heightInLines - b.heightInLines;\n            }\n            return a.startLineNumber - b.startLineNumber;\n        }\n        return a.color < b.color ? -1 : 1;\n    }\n    setColorZone(colorZone) {\n        this._colorZone = colorZone;\n    }\n    getColorZones() {\n        return this._colorZone;\n    }\n}\nexport class OverviewZoneManager {\n    constructor(getVerticalOffsetForLine) {\n        this._getVerticalOffsetForLine = getVerticalOffsetForLine;\n        this._zones = [];\n        this._colorZonesInvalid = false;\n        this._lineHeight = 0;\n        this._domWidth = 0;\n        this._domHeight = 0;\n        this._outerHeight = 0;\n        this._pixelRatio = 1;\n        this._lastAssignedId = 0;\n        this._color2Id = Object.create(null);\n        this._id2Color = [];\n    }\n    getId2Color() {\n        return this._id2Color;\n    }\n    setZones(newZones) {\n        this._zones = newZones;\n        this._zones.sort(OverviewRulerZone.compare);\n    }\n    setLineHeight(lineHeight) {\n        if (this._lineHeight === lineHeight) {\n            return false;\n        }\n        this._lineHeight = lineHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    setPixelRatio(pixelRatio) {\n        this._pixelRatio = pixelRatio;\n        this._colorZonesInvalid = true;\n    }\n    getDOMWidth() {\n        return this._domWidth;\n    }\n    getCanvasWidth() {\n        return this._domWidth * this._pixelRatio;\n    }\n    setDOMWidth(width) {\n        if (this._domWidth === width) {\n            return false;\n        }\n        this._domWidth = width;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getDOMHeight() {\n        return this._domHeight;\n    }\n    getCanvasHeight() {\n        return this._domHeight * this._pixelRatio;\n    }\n    setDOMHeight(height) {\n        if (this._domHeight === height) {\n            return false;\n        }\n        this._domHeight = height;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getOuterHeight() {\n        return this._outerHeight;\n    }\n    setOuterHeight(outerHeight) {\n        if (this._outerHeight === outerHeight) {\n            return false;\n        }\n        this._outerHeight = outerHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    resolveColorZones() {\n        const colorZonesInvalid = this._colorZonesInvalid;\n        const lineHeight = Math.floor(this._lineHeight);\n        const totalHeight = Math.floor(this.getCanvasHeight());\n        const outerHeight = Math.floor(this._outerHeight);\n        const heightRatio = totalHeight / outerHeight;\n        const halfMinimumHeight = Math.floor(4 /* Constants.MINIMUM_HEIGHT */ * this._pixelRatio / 2);\n        const allColorZones = [];\n        for (let i = 0, len = this._zones.length; i < len; i++) {\n            const zone = this._zones[i];\n            if (!colorZonesInvalid) {\n                const colorZone = zone.getColorZones();\n                if (colorZone) {\n                    allColorZones.push(colorZone);\n                    continue;\n                }\n            }\n            const offset1 = this._getVerticalOffsetForLine(zone.startLineNumber);\n            const offset2 = (zone.heightInLines === 0\n                ? this._getVerticalOffsetForLine(zone.endLineNumber) + lineHeight\n                : offset1 + zone.heightInLines * lineHeight);\n            const y1 = Math.floor(heightRatio * offset1);\n            const y2 = Math.floor(heightRatio * offset2);\n            let ycenter = Math.floor((y1 + y2) / 2);\n            let halfHeight = (y2 - ycenter);\n            if (halfHeight < halfMinimumHeight) {\n                halfHeight = halfMinimumHeight;\n            }\n            if (ycenter - halfHeight < 0) {\n                ycenter = halfHeight;\n            }\n            if (ycenter + halfHeight > totalHeight) {\n                ycenter = totalHeight - halfHeight;\n            }\n            const color = zone.color;\n            let colorId = this._color2Id[color];\n            if (!colorId) {\n                colorId = (++this._lastAssignedId);\n                this._color2Id[color] = colorId;\n                this._id2Color[colorId] = color;\n            }\n            const colorZone = new ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId);\n            zone.setColorZone(colorZone);\n            allColorZones.push(colorZone);\n        }\n        this._colorZonesInvalid = false;\n        allColorZones.sort(ColorZone.compare);\n        return allColorZones;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorTheme } from '../editorTheme.js';\nexport class ViewContext {\n    constructor(configuration, theme, model) {\n        this.configuration = configuration;\n        this.theme = new EditorTheme(theme);\n        this.viewModel = model;\n        this.viewLayout = model.viewLayout;\n    }\n    addEventHandler(eventHandler) {\n        this.viewModel.addViewEventHandler(eventHandler);\n    }\n    removeEventHandler(eventHandler) {\n        this.viewModel.removeViewEventHandler(eventHandler);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { InlineDecoration, ViewModelDecoration } from '../viewModel.js';\nimport { filterValidationDecorations } from '../config/editorOptions.js';\nexport class ViewModelDecorations {\n    constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n        this.editorId = editorId;\n        this.model = model;\n        this.configuration = configuration;\n        this._linesCollection = linesCollection;\n        this._coordinatesConverter = coordinatesConverter;\n        this._decorationsCache = Object.create(null);\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    _clearCachedModelDecorationsResolver() {\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    dispose() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    reset() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onModelDecorationsChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onLineMappingChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    _getOrCreateViewModelDecoration(modelDecoration) {\n        const id = modelDecoration.id;\n        let r = this._decorationsCache[id];\n        if (!r) {\n            const modelRange = modelDecoration.range;\n            const options = modelDecoration.options;\n            let viewRange;\n            if (options.isWholeLine) {\n                const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1), 0 /* PositionAffinity.Left */, false, true);\n                const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)), 1 /* PositionAffinity.Right */);\n                viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n            }\n            else {\n                // For backwards compatibility reasons, we want injected text before any decoration.\n                // Thus, move decorations to the right.\n                viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange, 1 /* PositionAffinity.Right */);\n            }\n            r = new ViewModelDecoration(viewRange, options);\n            this._decorationsCache[id] = r;\n        }\n        return r;\n    }\n    getMinimapDecorationsInRange(range) {\n        return this._getDecorationsInRange(range, true, false).decorations;\n    }\n    getDecorationsViewportData(viewRange) {\n        let cacheIsValid = (this._cachedModelDecorationsResolver !== null);\n        cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));\n        if (!cacheIsValid) {\n            this._cachedModelDecorationsResolver = this._getDecorationsInRange(viewRange, false, false);\n            this._cachedModelDecorationsResolverViewRange = viewRange;\n        }\n        return this._cachedModelDecorationsResolver;\n    }\n    getInlineDecorationsOnLine(lineNumber, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const range = new Range(lineNumber, this._linesCollection.getViewLineMinColumn(lineNumber), lineNumber, this._linesCollection.getViewLineMaxColumn(lineNumber));\n        return this._getDecorationsInRange(range, onlyMinimapDecorations, onlyMarginDecorations).inlineDecorations[0];\n    }\n    _getDecorationsInRange(viewRange, onlyMinimapDecorations, onlyMarginDecorations) {\n        const modelDecorations = this._linesCollection.getDecorationsInRange(viewRange, this.editorId, filterValidationDecorations(this.configuration.options), onlyMinimapDecorations, onlyMarginDecorations);\n        const startLineNumber = viewRange.startLineNumber;\n        const endLineNumber = viewRange.endLineNumber;\n        const decorationsInViewport = [];\n        let decorationsInViewportLen = 0;\n        const inlineDecorations = [];\n        for (let j = startLineNumber; j <= endLineNumber; j++) {\n            inlineDecorations[j - startLineNumber] = [];\n        }\n        for (let i = 0, len = modelDecorations.length; i < len; i++) {\n            const modelDecoration = modelDecorations[i];\n            const decorationOptions = modelDecoration.options;\n            if (!isModelDecorationVisible(this.model, modelDecoration)) {\n                continue;\n            }\n            const viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n            const viewRange = viewModelDecoration.range;\n            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n            if (decorationOptions.inlineClassName) {\n                const inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n                const intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n                const intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n                for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n                    inlineDecorations[j - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.beforeContentClassName) {\n                if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* InlineDecorationType.Before */);\n                    inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.afterContentClassName) {\n                if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* InlineDecorationType.After */);\n                    inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n        }\n        return {\n            decorations: decorationsInViewport,\n            inlineDecorations: inlineDecorations\n        };\n    }\n}\nexport function isModelDecorationVisible(model, decoration) {\n    if (decoration.options.hideInCommentTokens && isModelDecorationInComment(model, decoration)) {\n        return false;\n    }\n    if (decoration.options.hideInStringTokens && isModelDecorationInString(model, decoration)) {\n        return false;\n    }\n    return true;\n}\nexport function isModelDecorationInComment(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 1 /* StandardTokenType.Comment */);\n}\nexport function isModelDecorationInString(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 2 /* StandardTokenType.String */);\n}\n/**\n * Calls the callback for every token that intersects the range.\n * If the callback returns `false`, iteration stops and `false` is returned.\n * Otherwise, `true` is returned.\n */\nfunction testTokensInRange(model, range, callback) {\n    for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n        const lineTokens = model.tokenization.getLineTokens(lineNumber);\n        const isFirstLine = lineNumber === range.startLineNumber;\n        const isEndLine = lineNumber === range.endLineNumber;\n        let tokenIdx = isFirstLine ? lineTokens.findTokenIndexAtOffset(range.startColumn - 1) : 0;\n        while (tokenIdx < lineTokens.getCount()) {\n            if (isEndLine) {\n                const startOffset = lineTokens.getStartOffset(tokenIdx);\n                if (startOffset > range.endColumn - 1) {\n                    break;\n                }\n            }\n            const callbackResult = callback(lineTokens.getStandardTokenType(tokenIdx));\n            if (!callbackResult) {\n                return false;\n            }\n            tokenIdx++;\n        }\n    }\n    return true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    mustCommit() {\n        return this._hasPending;\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nexport class EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setLineHeight(lineHeight) {\n        this._checkPendingChanges();\n        this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount) {\n        this._checkPendingChanges();\n        this._lineCount = lineCount;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            const result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _checkPendingChanges() {\n        if (this._pendingChanges.mustCommit()) {\n            this._pendingChanges.commit(this);\n        }\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        this._checkPendingChanges();\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        this._checkPendingChanges();\n        const linesHeight = this._lineHeight * this._lineCount;\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const previousLinesHeight = this._lineHeight * lineNumber;\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        this._checkPendingChanges();\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        const lineHeight = this._lineHeight;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber,\n            lineHeight: this._lineHeight,\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        this._checkPendingChanges();\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        const result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        this._checkPendingChanges();\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        this._checkPendingChanges();\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\nLinesLayout.INSTANCE_COUNT = 0;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Scrollable } from '../../../base/common/scrollable.js';\nimport { LinesLayout } from './linesLayout.js';\nimport { Viewport } from '../viewModel.js';\nimport { ContentSizeChangedEvent } from '../viewModelEventDispatcher.js';\nconst SMOOTH_SCROLLING_TIME = 125;\nclass EditorScrollDimensions {\n    constructor(width, contentWidth, height, contentHeight) {\n        width = width | 0;\n        contentWidth = contentWidth | 0;\n        height = height | 0;\n        contentHeight = contentHeight | 0;\n        if (width < 0) {\n            width = 0;\n        }\n        if (contentWidth < 0) {\n            contentWidth = 0;\n        }\n        if (height < 0) {\n            height = 0;\n        }\n        if (contentHeight < 0) {\n            contentHeight = 0;\n        }\n        this.width = width;\n        this.contentWidth = contentWidth;\n        this.scrollWidth = Math.max(width, contentWidth);\n        this.height = height;\n        this.contentHeight = contentHeight;\n        this.scrollHeight = Math.max(height, contentHeight);\n    }\n    equals(other) {\n        return (this.width === other.width\n            && this.contentWidth === other.contentWidth\n            && this.height === other.height\n            && this.contentHeight === other.contentHeight);\n    }\n}\nclass EditorScrollable extends Disposable {\n    constructor(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n        super();\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._dimensions = new EditorScrollDimensions(0, 0, 0, 0);\n        this._scrollable = this._register(new Scrollable({\n            forceIntegerValues: true,\n            smoothScrollDuration,\n            scheduleAtNextAnimationFrame\n        }));\n        this.onDidScroll = this._scrollable.onScroll;\n    }\n    getScrollable() {\n        return this._scrollable;\n    }\n    setSmoothScrollDuration(smoothScrollDuration) {\n        this._scrollable.setSmoothScrollDuration(smoothScrollDuration);\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    getScrollDimensions() {\n        return this._dimensions;\n    }\n    setScrollDimensions(dimensions) {\n        if (this._dimensions.equals(dimensions)) {\n            return;\n        }\n        const oldDimensions = this._dimensions;\n        this._dimensions = dimensions;\n        this._scrollable.setScrollDimensions({\n            width: dimensions.width,\n            scrollWidth: dimensions.scrollWidth,\n            height: dimensions.height,\n            scrollHeight: dimensions.scrollHeight\n        }, true);\n        const contentWidthChanged = (oldDimensions.contentWidth !== dimensions.contentWidth);\n        const contentHeightChanged = (oldDimensions.contentHeight !== dimensions.contentHeight);\n        if (contentWidthChanged || contentHeightChanged) {\n            this._onDidContentSizeChange.fire(new ContentSizeChangedEvent(oldDimensions.contentWidth, oldDimensions.contentHeight, dimensions.contentWidth, dimensions.contentHeight));\n        }\n    }\n    getFutureScrollPosition() {\n        return this._scrollable.getFutureScrollPosition();\n    }\n    getCurrentScrollPosition() {\n        return this._scrollable.getCurrentScrollPosition();\n    }\n    setScrollPositionNow(update) {\n        this._scrollable.setScrollPositionNow(update);\n    }\n    setScrollPositionSmooth(update) {\n        this._scrollable.setScrollPositionSmooth(update);\n    }\n    hasPendingScrollAnimation() {\n        return this._scrollable.hasPendingScrollAnimation();\n    }\n}\nexport class ViewLayout extends Disposable {\n    constructor(configuration, lineCount, scheduleAtNextAnimationFrame) {\n        super();\n        this._configuration = configuration;\n        const options = this._configuration.options;\n        const layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n        const padding = options.get(84 /* EditorOption.padding */);\n        this._linesLayout = new LinesLayout(lineCount, options.get(67 /* EditorOption.lineHeight */), padding.top, padding.bottom);\n        this._maxLineWidth = 0;\n        this._overlayWidgetsMinWidth = 0;\n        this._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame));\n        this._configureSmoothScrollDuration();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(layoutInfo.contentWidth, 0, layoutInfo.height, 0));\n        this.onDidScroll = this._scrollable.onDidScroll;\n        this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;\n        this._updateHeight();\n    }\n    dispose() {\n        super.dispose();\n    }\n    getScrollable() {\n        return this._scrollable.getScrollable();\n    }\n    onHeightMaybeChanged() {\n        this._updateHeight();\n    }\n    _configureSmoothScrollDuration() {\n        this._scrollable.setSmoothScrollDuration(this._configuration.options.get(114 /* EditorOption.smoothScrolling */) ? SMOOTH_SCROLLING_TIME : 0);\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        const options = this._configuration.options;\n        if (e.hasChanged(67 /* EditorOption.lineHeight */)) {\n            this._linesLayout.setLineHeight(options.get(67 /* EditorOption.lineHeight */));\n        }\n        if (e.hasChanged(84 /* EditorOption.padding */)) {\n            const padding = options.get(84 /* EditorOption.padding */);\n            this._linesLayout.setPadding(padding.top, padding.bottom);\n        }\n        if (e.hasChanged(145 /* EditorOption.layoutInfo */)) {\n            const layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n            const width = layoutInfo.contentWidth;\n            const height = layoutInfo.height;\n            const scrollDimensions = this._scrollable.getScrollDimensions();\n            const contentWidth = scrollDimensions.contentWidth;\n            this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n        }\n        else {\n            this._updateHeight();\n        }\n        if (e.hasChanged(114 /* EditorOption.smoothScrolling */)) {\n            this._configureSmoothScrollDuration();\n        }\n    }\n    onFlushed(lineCount) {\n        this._linesLayout.onFlushed(lineCount);\n    }\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n    }\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n    }\n    // ---- end view event handlers\n    _getHorizontalScrollbarHeight(width, scrollWidth) {\n        const options = this._configuration.options;\n        const scrollbar = options.get(103 /* EditorOption.scrollbar */);\n        if (scrollbar.horizontal === 2 /* ScrollbarVisibility.Hidden */) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        if (width >= scrollWidth) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        return scrollbar.horizontalScrollbarSize;\n    }\n    _getContentHeight(width, height, contentWidth) {\n        const options = this._configuration.options;\n        let result = this._linesLayout.getLinesTotalHeight();\n        if (options.get(105 /* EditorOption.scrollBeyondLastLine */)) {\n            result += Math.max(0, height - options.get(67 /* EditorOption.lineHeight */) - options.get(84 /* EditorOption.padding */).bottom);\n        }\n        else if (!options.get(103 /* EditorOption.scrollbar */).ignoreHorizontalScrollbarInContentHeight) {\n            result += this._getHorizontalScrollbarHeight(width, contentWidth);\n        }\n        return result;\n    }\n    _updateHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const width = scrollDimensions.width;\n        const height = scrollDimensions.height;\n        const contentWidth = scrollDimensions.contentWidth;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n    }\n    // ---- Layouting logic\n    getCurrentViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    getFutureViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    _computeContentWidth() {\n        const options = this._configuration.options;\n        const maxLineWidth = this._maxLineWidth;\n        const wrappingInfo = options.get(146 /* EditorOption.wrappingInfo */);\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n        if (wrappingInfo.isViewportWrapping) {\n            const minimap = options.get(73 /* EditorOption.minimap */);\n            if (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {\n                // This is a case where viewport wrapping is on, but the line extends above the viewport\n                if (minimap.enabled && minimap.side === 'right') {\n                    // We need to accomodate the scrollbar width\n                    return maxLineWidth + layoutInfo.verticalScrollbarWidth;\n                }\n            }\n            return maxLineWidth;\n        }\n        else {\n            const extraHorizontalSpace = options.get(104 /* EditorOption.scrollBeyondLastColumn */) * fontInfo.typicalHalfwidthCharacterWidth;\n            const whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n            return Math.max(maxLineWidth + extraHorizontalSpace + layoutInfo.verticalScrollbarWidth, whitespaceMinWidth, this._overlayWidgetsMinWidth);\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        this._maxLineWidth = maxLineWidth;\n        this._updateContentWidth();\n    }\n    setOverlayWidgetsMinWidth(maxMinWidth) {\n        this._overlayWidgetsMinWidth = maxMinWidth;\n        this._updateContentWidth();\n    }\n    _updateContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(scrollDimensions.width, this._computeContentWidth(), scrollDimensions.height, scrollDimensions.contentHeight));\n        // The height might depend on the fact that there is a horizontal scrollbar or not\n        this._updateHeight();\n    }\n    // ---- view state\n    saveState() {\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        const scrollTop = currentScrollPosition.scrollTop;\n        const firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n        const whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n        return {\n            scrollTop: scrollTop,\n            scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n            scrollLeft: currentScrollPosition.scrollLeft\n        };\n    }\n    // ----\n    changeWhitespace(callback) {\n        const hadAChange = this._linesLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this.onHeightMaybeChanged();\n        }\n        return hadAChange;\n    }\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber, includeViewZones);\n    }\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        return this._linesLayout.getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones);\n    }\n    isAfterLines(verticalOffset) {\n        return this._linesLayout.isAfterLines(verticalOffset);\n    }\n    isInTopPadding(verticalOffset) {\n        return this._linesLayout.isInTopPadding(verticalOffset);\n    }\n    isInBottomPadding(verticalOffset) {\n        return this._linesLayout.isInBottomPadding(verticalOffset);\n    }\n    getLineNumberAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n    }\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n    }\n    getLinesViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getLinesViewportDataAtScrollTop(scrollTop) {\n        // do some minimal validations on scrollTop\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n            scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n        }\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n    }\n    getWhitespaceViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getWhitespaces() {\n        return this._linesLayout.getWhitespaces();\n    }\n    // ----\n    getContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentWidth;\n    }\n    getScrollWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollWidth;\n    }\n    getContentHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentHeight;\n    }\n    getScrollHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollHeight;\n    }\n    getCurrentScrollLeft() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollLeft;\n    }\n    getCurrentScrollTop() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollTop;\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    setScrollPosition(position, type) {\n        if (type === 1 /* ScrollType.Immediate */) {\n            this._scrollable.setScrollPositionNow(position);\n        }\n        else {\n            this._scrollable.setScrollPositionSmooth(position);\n        }\n    }\n    hasPendingScrollAnimation() {\n        return this._scrollable.hasPendingScrollAnimation();\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        this._scrollable.setScrollPositionNow({\n            scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n            scrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from '../viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return IdentityModelLineProjection.INSTANCE;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    else {\n        return new ModelLineProjection(lineBreakData, isVisible);\n    }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection {\n    constructor(lineBreakData, isVisible) {\n        this._projectionData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getProjectionData() {\n        return this._projectionData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._projectionData.getOutputLineCount();\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n        let r;\n        if (this._projectionData.injectionOffsets !== null) {\n            const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));\n            const lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n            r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n        }\n        else {\n            r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffsetInInputWithInjections + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffsetInInputWithInjections + 1\n            });\n        }\n        if (outputLineIndex > 0) {\n            r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getLineLength(outputLineIndex);\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n    }\n    /**\n     * Try using {@link getViewLinesData} instead.\n    */\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        const arr = new Array();\n        this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n        return arr[0];\n    }\n    getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const injectionOffsets = lineBreakData.injectionOffsets;\n        const injectionOptions = lineBreakData.injectionOptions;\n        let inlineDecorationsPerOutputLine = null;\n        if (injectionOffsets) {\n            inlineDecorationsPerOutputLine = [];\n            let totalInjectedTextLengthBefore = 0;\n            let currentInjectedOffset = 0;\n            for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n                const inlineDecorations = new Array();\n                inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n                const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n                const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n                while (currentInjectedOffset < injectionOffsets.length) {\n                    const length = injectionOptions[currentInjectedOffset].content.length;\n                    const injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n                    const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n                    if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n                        // Injected text only starts in later wrapped lines.\n                        break;\n                    }\n                    if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n                        // Injected text ends after or in this line (but also starts in or before this line).\n                        const options = injectionOptions[currentInjectedOffset];\n                        if (options.inlineClassName) {\n                            const offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n                            const start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n                            const end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections);\n                            if (start !== end) {\n                                inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                            }\n                        }\n                    }\n                    if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n                        totalInjectedTextLengthBefore += length;\n                        currentInjectedOffset++;\n                    }\n                    else {\n                        // injected text breaks into next line, process it again\n                        break;\n                    }\n                }\n            }\n        }\n        let lineWithInjections;\n        if (injectionOffsets) {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n                offset,\n                text: injectionOptions[idx].content,\n                tokenMetadata: LineTokens.defaultTokenMetadata\n            })));\n        }\n        else {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber);\n        }\n        for (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n            const globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n        }\n    }\n    _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n        const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n        const tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n        let lineContent = tokens.getLineContent();\n        if (outputLineIndex > 0) {\n            lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n        const maxColumn = lineContent.length + 1;\n        const continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        this._assertVisible();\n        return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2 /* PositionAffinity.None */) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n        return r.toPosition(deltaLineNumber);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n        return deltaLineNumber + r.outputLineIndex;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n        const normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n        const result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n        return result;\n    }\n    getInjectedTextAt(outputLineIndex, outputColumn) {\n        return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n    _assertVisible() {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n    }\n}\n/**\n * This projection does not change the model line.\n*/\nclass IdentityModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        const lineTokens = model.tokenization.getLineTokens(modelLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        return outputPosition;\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        return null;\n    }\n}\nIdentityModelLineProjection.INSTANCE = new IdentityModelLineProjection();\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return IdentityModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        throw new Error('Not supported');\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n}\nHiddenModelLineProjection.INSTANCE = new HiddenModelLineProjection();\nconst _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        const equalWordBreak = (this.wordBreak === wordBreak);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getMaxColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                const bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                // model-columns must be converted to view-model columns.\n                const result = bracketGuides.map(g => {\n                    if (g.forWrappedLinesAfterColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n                        if (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n                        if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (!g.horizontalLine) {\n                        return g;\n                    }\n                    let column = -1;\n                    if (g.column !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n                        if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                            column = p.column;\n                        }\n                        else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            column = this.getMinColumnOfViewLine(viewLineInfo);\n                        }\n                        else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    const viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n                    const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n                    if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n                    }\n                    else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                        return undefined;\n                    }\n                    else {\n                        if (g.visibleColumn !== -1) {\n                            // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n                            return undefined;\n                        }\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n                    }\n                });\n                resultPerViewLine.push(result.filter((r) => !!r));\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* IndentGuideRepeatOption.BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* PositionAffinity.None */, allowZeroLineNumber = false, belowHiddenRanges = false) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        if (belowHiddenRanges) {\n            while (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex++;\n                lineIndexChanged = true;\n            }\n        }\n        else {\n            while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex--;\n                lineIndexChanged = true;\n            }\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            // TODO@alexdima@hediet this isn't soo pretty\n            return new Position(allowZeroLineNumber ? 0 : 1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            if (belowHiddenRanges) {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n            }\n            else {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n            }\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* PositionAffinity.Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, onlyMinimapDecorations));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        const finalResult = [];\n        let finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity, allowZero, belowHiddenRanges) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlyphMarginLane } from '../model.js';\nconst MAX_LANE = GlyphMarginLane.Right;\nexport class GlyphMarginLanesModel {\n    constructor(maxLine) {\n        this.persist = 0;\n        this._requiredLanes = 1; // always render at least one lane\n        this.lanes = new Uint8Array(Math.ceil(((maxLine + 1) * MAX_LANE) / 8));\n    }\n    reset(maxLine) {\n        const bytes = Math.ceil(((maxLine + 1) * MAX_LANE) / 8);\n        if (this.lanes.length < bytes) {\n            this.lanes = new Uint8Array(bytes);\n        }\n        else {\n            this.lanes.fill(0);\n        }\n        this._requiredLanes = 1;\n    }\n    get requiredLanes() {\n        return this._requiredLanes;\n    }\n    push(lane, range, persist) {\n        if (persist) {\n            this.persist |= (1 << (lane - 1));\n        }\n        for (let i = range.startLineNumber; i <= range.endLineNumber; i++) {\n            const bit = (MAX_LANE * i) + (lane - 1);\n            this.lanes[bit >>> 3] |= (1 << (bit % 8));\n            this._requiredLanes = Math.max(this._requiredLanes, this.countAtLine(i));\n        }\n    }\n    getLanesAtLine(lineNumber) {\n        const lanes = [];\n        let bit = MAX_LANE * lineNumber;\n        for (let i = 0; i < MAX_LANE; i++) {\n            if (this.persist & (1 << i) || this.lanes[bit >>> 3] & (1 << (bit % 8))) {\n                lanes.push(i + 1);\n            }\n            bit++;\n        }\n        return lanes.length ? lanes : [GlyphMarginLane.Center];\n    }\n    countAtLine(lineNumber) {\n        let bit = MAX_LANE * lineNumber;\n        let count = 0;\n        for (let i = 0; i < MAX_LANE; i++) {\n            if (this.persist & (1 << i) || this.lanes[bit >>> 3] & (1 << (bit % 8))) {\n                count++;\n            }\n            bit++;\n        }\n        return count;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nimport { GlyphMarginLanesModel } from './glyphLanesModel.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService, _attachedView) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._themeService = _themeService;\n        this._attachedView = _attachedView;\n        this.hiddenAreasModel = new HiddenAreasModel();\n        this.previousHiddenAreas = [];\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStart = ViewportStart.create(this.model);\n        this.glyphLanes = new GlyphMarginLanesModel(0);\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n            const wrappingStrategy = options.get(139 /* EditorOption.wrappingStrategy */);\n            const wrappingInfo = options.get(146 /* EditorOption.wrappingInfo */);\n            const wrappingIndent = options.get(138 /* EditorOption.wrappingIndent */);\n            const wordBreak = options.get(129 /* EditorOption.wordBreak */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._handleVisibleLinesChanged();\n            }\n            if (e.scrollTopChanged) {\n                this._viewportStart.invalidate();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._register(this._themeService.onDidColorThemeChange((theme) => {\n            this._invalidateDecorationsColorCache();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this._viewportStart.dispose();\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    getModelVisibleRanges() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        return modelVisibleRanges;\n    }\n    visibleLinesStabilized() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, true);\n    }\n    _handleVisibleLinesChanged() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, false);\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    _captureStableViewport() {\n        // We might need to restore the current start view range, so save it (if available)\n        // But only if the scroll position is not at the top of the file\n        if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {\n            const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n            const previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n            return new StableViewport(previousViewportStartModelPosition, this._viewportStart.startLineDelta);\n        }\n        return new StableViewport(null, 0);\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        const stableViewport = this._captureStableViewport();\n        const options = this._configuration.options;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const wrappingStrategy = options.get(139 /* EditorOption.wrappingStrategy */);\n        const wrappingInfo = options.get(146 /* EditorOption.wrappingInfo */);\n        const wrappingIndent = options.get(138 /* EditorOption.wrappingIndent */);\n        const wordBreak = options.get(129 /* EditorOption.wordBreak */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(91 /* EditorOption.readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        if (e.hasChanged(98 /* EditorOption.renderValidationDecorations */)) {\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes);\n                const versionId = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* textModelEvents.RawContentChangedType.Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* textModelEvents.RawContentChangedType.EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            const viewportStartWasValid = this._viewportStart.isValid;\n            this._viewportStart.invalidate();\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n                const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n                    eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n                }\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._handleVisibleLinesChanged();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges, source) {\n        var _a;\n        this.hiddenAreasModel.setHiddenAreas(source, ranges);\n        const mergedRanges = this.hiddenAreasModel.getMergedRanges();\n        if (mergedRanges === this.previousHiddenAreas) {\n            return;\n        }\n        this.previousHiddenAreas = mergedRanges;\n        const stableViewport = this._captureStableViewport();\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(mergedRanges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n            const firstModelLineInViewPort = (_a = stableViewport.viewportStartModelPosition) === null || _a === void 0 ? void 0 : _a.lineNumber;\n            const firstModelLineIsHidden = firstModelLineInViewPort && mergedRanges.some(range => range.startLineNumber <= firstModelLineInViewPort && firstModelLineInViewPort <= range.endLineNumber);\n            if (!firstModelLineIsHidden) {\n                stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(145 /* EditorOption.layoutInfo */);\n        const lineHeight = this._configuration.options.get(67 /* EditorOption.lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    getHiddenAreas() {\n        return this._lines.getHiddenAreas();\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStart.update(this, startLineNumber);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getMinimapDecorationsInRange(range) {\n        return this._decorations.getMinimapDecorationsInRange(range);\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewportViewLineRenderingData(visibleRange, lineNumber) {\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    getViewLineRenderingData(lineNumber) {\n        const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    _getViewLineRenderingData(lineNumber, inlineDecorations) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    _invalidateDecorationsColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts1 = decoration.options.overviewRuler;\n            opts1 === null || opts1 === void 0 ? void 0 : opts1.invalidateCachedColor();\n            const opts2 = decoration.options.minimap;\n            opts2 === null || opts2 === void 0 ? void 0 : opts2.invalidateCachedColor();\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    getValueLengthInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueLengthInRange(modelRange, eol);\n    }\n    modifyPosition(position, offset) {\n        const modelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(position);\n        const resultModelPosition = this.model.modifyPosition(modelPosition, offset);\n        return this.coordinatesConverter.convertModelPositionToViewPosition(resultModelPosition);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(50 /* EditorOption.fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* CursorChangeReason.NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealAllCursors(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealAll(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            return callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n    batchEvents(callback) {\n        this._withViewEventsCollector(() => { callback(); });\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass ViewportStart {\n    static create(model) {\n        const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n    }\n    get viewLineNumber() {\n        return this._viewLineNumber;\n    }\n    get isValid() {\n        return this._isValid;\n    }\n    get modelTrackedRange() {\n        return this._modelTrackedRange;\n    }\n    get startLineDelta() {\n        return this._startLineDelta;\n    }\n    constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n        this._model = _model;\n        this._viewLineNumber = _viewLineNumber;\n        this._isValid = _isValid;\n        this._modelTrackedRange = _modelTrackedRange;\n        this._startLineDelta = _startLineDelta;\n    }\n    dispose() {\n        this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    }\n    update(viewModel, startLineNumber) {\n        const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n        const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n        this._viewLineNumber = startLineNumber;\n        this._isValid = true;\n        this._modelTrackedRange = viewportStartLineTrackedRange;\n        this._startLineDelta = scrollTop - viewportStartLineTop;\n    }\n    invalidate() {\n        this._isValid = false;\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\nclass HiddenAreasModel {\n    constructor() {\n        this.hiddenAreas = new Map();\n        this.shouldRecompute = false;\n        this.ranges = [];\n    }\n    setHiddenAreas(source, ranges) {\n        const existing = this.hiddenAreas.get(source);\n        if (existing && rangeArraysEqual(existing, ranges)) {\n            return;\n        }\n        this.hiddenAreas.set(source, ranges);\n        this.shouldRecompute = true;\n    }\n    /**\n     * The returned array is immutable.\n    */\n    getMergedRanges() {\n        if (!this.shouldRecompute) {\n            return this.ranges;\n        }\n        this.shouldRecompute = false;\n        const newRanges = Array.from(this.hiddenAreas.values()).reduce((r, hiddenAreas) => mergeLineRangeArray(r, hiddenAreas), []);\n        if (rangeArraysEqual(this.ranges, newRanges)) {\n            return this.ranges;\n        }\n        this.ranges = newRanges;\n        return this.ranges;\n    }\n}\nfunction mergeLineRangeArray(arr1, arr2) {\n    const result = [];\n    let i = 0;\n    let j = 0;\n    while (i < arr1.length && j < arr2.length) {\n        const item1 = arr1[i];\n        const item2 = arr2[j];\n        if (item1.endLineNumber < item2.startLineNumber - 1) {\n            result.push(arr1[i++]);\n        }\n        else if (item2.endLineNumber < item1.startLineNumber - 1) {\n            result.push(arr2[j++]);\n        }\n        else {\n            const startLineNumber = Math.min(item1.startLineNumber, item2.startLineNumber);\n            const endLineNumber = Math.max(item1.endLineNumber, item2.endLineNumber);\n            result.push(new Range(startLineNumber, 1, endLineNumber, 1));\n            i++;\n            j++;\n        }\n    }\n    while (i < arr1.length) {\n        result.push(arr1[i++]);\n    }\n    while (j < arr2.length) {\n        result.push(arr2[j++]);\n    }\n    return result;\n}\nfunction rangeArraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (!arr1[i].equalsRange(arr2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Maintain a stable viewport by trying to keep the first line in the viewport constant.\n */\nclass StableViewport {\n    constructor(viewportStartModelPosition, startLineDelta) {\n        this.viewportStartModelPosition = viewportStartModelPosition;\n        this.startLineDelta = startLineDelta;\n    }\n    recoverViewportStart(coordinatesConverter, viewLayout) {\n        if (!this.viewportStartModelPosition) {\n            return;\n        }\n        const viewPosition = coordinatesConverter.convertModelPositionToViewPosition(this.viewportStartModelPosition);\n        const viewPositionTop = viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n        viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this.startLineDelta }, 1 /* ScrollType.Immediate */);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable } from '../../base/common/lifecycle.js';\nexport class ViewModelEventDispatcher extends Disposable {\n    constructor() {\n        super();\n        this._onEvent = this._register(new Emitter());\n        this.onEvent = this._onEvent.event;\n        this._eventHandlers = [];\n        this._viewEventQueue = null;\n        this._isConsumingViewEventQueue = false;\n        this._collector = null;\n        this._collectorCnt = 0;\n        this._outgoingEvents = [];\n    }\n    emitOutgoingEvent(e) {\n        this._addOutgoingEvent(e);\n        this._emitOutgoingEvents();\n    }\n    _addOutgoingEvent(e) {\n        for (let i = 0, len = this._outgoingEvents.length; i < len; i++) {\n            const mergeResult = (this._outgoingEvents[i].kind === e.kind ? this._outgoingEvents[i].attemptToMerge(e) : null);\n            if (mergeResult) {\n                this._outgoingEvents[i] = mergeResult;\n                return;\n            }\n        }\n        // not merged\n        this._outgoingEvents.push(e);\n    }\n    _emitOutgoingEvents() {\n        while (this._outgoingEvents.length > 0) {\n            if (this._collector || this._isConsumingViewEventQueue) {\n                // right now collecting or emitting view events, so let's postpone emitting\n                return;\n            }\n            const event = this._outgoingEvents.shift();\n            if (event.isNoOp()) {\n                continue;\n            }\n            this._onEvent.fire(event);\n        }\n    }\n    addViewEventHandler(eventHandler) {\n        for (let i = 0, len = this._eventHandlers.length; i < len; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                console.warn('Detected duplicate listener in ViewEventDispatcher', eventHandler);\n            }\n        }\n        this._eventHandlers.push(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        for (let i = 0; i < this._eventHandlers.length; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                this._eventHandlers.splice(i, 1);\n                break;\n            }\n        }\n    }\n    beginEmitViewEvents() {\n        this._collectorCnt++;\n        if (this._collectorCnt === 1) {\n            this._collector = new ViewModelEventsCollector();\n        }\n        return this._collector;\n    }\n    endEmitViewEvents() {\n        this._collectorCnt--;\n        if (this._collectorCnt === 0) {\n            const outgoingEvents = this._collector.outgoingEvents;\n            const viewEvents = this._collector.viewEvents;\n            this._collector = null;\n            for (const outgoingEvent of outgoingEvents) {\n                this._addOutgoingEvent(outgoingEvent);\n            }\n            if (viewEvents.length > 0) {\n                this._emitMany(viewEvents);\n            }\n        }\n        this._emitOutgoingEvents();\n    }\n    emitSingleViewEvent(event) {\n        try {\n            const eventsCollector = this.beginEmitViewEvents();\n            eventsCollector.emitViewEvent(event);\n        }\n        finally {\n            this.endEmitViewEvents();\n        }\n    }\n    _emitMany(events) {\n        if (this._viewEventQueue) {\n            this._viewEventQueue = this._viewEventQueue.concat(events);\n        }\n        else {\n            this._viewEventQueue = events;\n        }\n        if (!this._isConsumingViewEventQueue) {\n            this._consumeViewEventQueue();\n        }\n    }\n    _consumeViewEventQueue() {\n        try {\n            this._isConsumingViewEventQueue = true;\n            this._doConsumeQueue();\n        }\n        finally {\n            this._isConsumingViewEventQueue = false;\n        }\n    }\n    _doConsumeQueue() {\n        while (this._viewEventQueue) {\n            // Empty event queue, as events might come in while sending these off\n            const events = this._viewEventQueue;\n            this._viewEventQueue = null;\n            // Use a clone of the event handlers list, as they might remove themselves\n            const eventHandlers = this._eventHandlers.slice(0);\n            for (const eventHandler of eventHandlers) {\n                eventHandler.handleEvents(events);\n            }\n        }\n    }\n}\nexport class ViewModelEventsCollector {\n    constructor() {\n        this.viewEvents = [];\n        this.outgoingEvents = [];\n    }\n    emitViewEvent(event) {\n        this.viewEvents.push(event);\n    }\n    emitOutgoingEvent(e) {\n        this.outgoingEvents.push(e);\n    }\n}\nexport class ContentSizeChangedEvent {\n    constructor(oldContentWidth, oldContentHeight, contentWidth, contentHeight) {\n        this.kind = 0 /* OutgoingViewModelEventKind.ContentSizeChanged */;\n        this._oldContentWidth = oldContentWidth;\n        this._oldContentHeight = oldContentHeight;\n        this.contentWidth = contentWidth;\n        this.contentHeight = contentHeight;\n        this.contentWidthChanged = (this._oldContentWidth !== this.contentWidth);\n        this.contentHeightChanged = (this._oldContentHeight !== this.contentHeight);\n    }\n    isNoOp() {\n        return (!this.contentWidthChanged && !this.contentHeightChanged);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new ContentSizeChangedEvent(this._oldContentWidth, this._oldContentHeight, other.contentWidth, other.contentHeight);\n    }\n}\nexport class FocusChangedEvent {\n    constructor(oldHasFocus, hasFocus) {\n        this.kind = 1 /* OutgoingViewModelEventKind.FocusChanged */;\n        this.oldHasFocus = oldHasFocus;\n        this.hasFocus = hasFocus;\n    }\n    isNoOp() {\n        return (this.oldHasFocus === this.hasFocus);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new FocusChangedEvent(this.oldHasFocus, other.hasFocus);\n    }\n}\nexport class ScrollChangedEvent {\n    constructor(oldScrollWidth, oldScrollLeft, oldScrollHeight, oldScrollTop, scrollWidth, scrollLeft, scrollHeight, scrollTop) {\n        this.kind = 2 /* OutgoingViewModelEventKind.ScrollChanged */;\n        this._oldScrollWidth = oldScrollWidth;\n        this._oldScrollLeft = oldScrollLeft;\n        this._oldScrollHeight = oldScrollHeight;\n        this._oldScrollTop = oldScrollTop;\n        this.scrollWidth = scrollWidth;\n        this.scrollLeft = scrollLeft;\n        this.scrollHeight = scrollHeight;\n        this.scrollTop = scrollTop;\n        this.scrollWidthChanged = (this._oldScrollWidth !== this.scrollWidth);\n        this.scrollLeftChanged = (this._oldScrollLeft !== this.scrollLeft);\n        this.scrollHeightChanged = (this._oldScrollHeight !== this.scrollHeight);\n        this.scrollTopChanged = (this._oldScrollTop !== this.scrollTop);\n    }\n    isNoOp() {\n        return (!this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new ScrollChangedEvent(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, other.scrollWidth, other.scrollLeft, other.scrollHeight, other.scrollTop);\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.kind = 3 /* OutgoingViewModelEventKind.ViewZonesChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class HiddenAreasChangedEvent {\n    constructor() {\n        this.kind = 4 /* OutgoingViewModelEventKind.HiddenAreasChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class CursorStateChangedEvent {\n    constructor(oldSelections, selections, oldModelVersionId, modelVersionId, source, reason, reachedMaxCursorCount) {\n        this.kind = 6 /* OutgoingViewModelEventKind.CursorStateChanged */;\n        this.oldSelections = oldSelections;\n        this.selections = selections;\n        this.oldModelVersionId = oldModelVersionId;\n        this.modelVersionId = modelVersionId;\n        this.source = source;\n        this.reason = reason;\n        this.reachedMaxCursorCount = reachedMaxCursorCount;\n    }\n    static _selectionsAreEqual(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!a[i].equalsSelection(b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isNoOp() {\n        return (CursorStateChangedEvent._selectionsAreEqual(this.oldSelections, this.selections)\n            && this.oldModelVersionId === this.modelVersionId);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new CursorStateChangedEvent(this.oldSelections, other.selections, this.oldModelVersionId, other.modelVersionId, other.source, other.reason, this.reachedMaxCursorCount || other.reachedMaxCursorCount);\n    }\n}\nexport class ReadOnlyEditAttemptEvent {\n    constructor() {\n        this.kind = 5 /* OutgoingViewModelEventKind.ReadOnlyEditAttempt */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class ModelDecorationsChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 7 /* OutgoingViewModelEventKind.ModelDecorationsChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelLanguageChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 8 /* OutgoingViewModelEventKind.ModelLanguageChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelLanguageConfigurationChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 9 /* OutgoingViewModelEventKind.ModelLanguageConfigurationChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelContentChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 10 /* OutgoingViewModelEventKind.ModelContentChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelOptionsChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 11 /* OutgoingViewModelEventKind.ModelOptionsChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelTokensChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 12 /* OutgoingViewModelEventKind.ModelTokensChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\n"],"names":["BracketInfo","constructor","range","nestingLevel","nestingLevelOfEqualBracketType","isInvalid","this","BracketPairInfo","openingBracketRange","closingBracketRange","bracketPairNode","openingBracketInfo","openingBracket","bracketInfo","BracketPairWithMinIndentationInfo","minVisibleColumnIndentation","super","ModelRawFlush","changeType","LineInjectedText","applyInjectedText","lineText","injectedTexts","length","result","lastOriginalOffset","injectedText","substring","column","options","content","fromDecorations","decorations","decoration","before","push","ownerId","startLineNumber","startColumn","after","endLineNumber","endColumn","sort","a","b","lineNumber","order","ModelRawLineChanged","detail","ModelRawLinesDeleted","fromLineNumber","toLineNumber","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","changes","versionId","isUndoing","isRedoing","resultingSelection","containsEvent","type","i","len","merge","concat","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","rawContentChangedEvent","contentChangedEvent","other","_mergeChangeEvents","eol","isFlush","isEolChange","HorizontalGuidesState","IndentGuide","visibleColumn","className","horizontalLine","forWrappedLinesAfterColumn","forWrappedLinesBeforeOrAtColumn","Error","IndentGuideHorizontalLine","top","TokenizationRegistry","_tokenizationSupports","Map","_factories","_onDidChange","Emitter","onDidChange","event","_colorMap","handleChange","languageIds","fire","changedLanguages","changedColorMap","register","languageId","support","set","toDisposable","get","delete","registerFactory","factory","_a","dispose","myData","TokenizationSupportFactoryData","v","getOrCreate","tokenizationSupport","isResolved","resolve","setColorMap","colorMap","Array","from","keys","getColorMap","getDefaultBackground","Disposable","_isResolved","_registry","_languageId","_factory","_isDisposed","_resolvePromise","_create","value","_register","ContiguousMultilineTokens","_startLineNumber","_tokens","tokens","getLineTokens","appendLineTokens","lineTokens","ContiguousMultilineTokensBuilder","add","last","finalize","EMPTY_LINE_TOKENS","Uint32Array","buffer","ContiguousTokensEditing","deleteBeginning","toChIndex","deleteEnding","fromChIndex","toUint32Array","lineTextLength","tokensCount","fromTokenIndex","LineTokens","findIndexInTokensArray","fromTokenStartOffset","delta","dest","lastEnd","tokenIndex","tokenEndOffset","tmp","subarray","append","_otherTokens","myTokens","otherTokens","otherTokensCount","insert","chIndex","textLength","arr","ContiguousTokensStore","languageIdCodec","_lineTokens","_len","_languageIdCodec","flush","hasTokens","getTokens","topLevelLanguageId","lineIndex","rawLineTokens","getDefaultMetadata","encodeLanguageId","_massageTokens","hasDifferentLanguageId","TokenMetadata","getLanguageId","byteOffset","byteLength","_ensureLine","_deleteLines","start","deleteCount","splice","_insertLines","insertIndex","insertCount","arrays","setTokens","checkEquality","oldTokens","_equals","_b","acceptEdit","eolCount","firstLineLength","_acceptDeleteRange","_acceptInsertText","Position","firstLineIndex","lastLineIndex","lastLineTokens","position","setMultilineTokens","textModel","ranges","element","minChangedLineNumber","maxChangedLineNumber","hasChange","getLineLength","createEmpty","lineContent","decoder","defaultMetadata","defaultTokenMetadata","text","_lineTokensBrand","undefined","_tokensCount","_text","equals","slicedEquals","sliceFromTokenIndex","sliceTokenCount","to","getLineContent","getCount","getStartOffset","getMetadata","metadata","decodeLanguageId","getStandardTokenType","getTokenType","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","getInlineStyleFromMetadata","getPresentation","getPresentationFromMetadata","getEndOffset","findTokenIndexAtOffset","offset","inflate","sliceAndInflate","startOffset","endOffset","deltaOffset","SliceLineTokens","convertToEndOffset","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","withInserted","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","tokenMetadata","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","min","SparseMultilineTokens","create","SparseMultilineTokensStorage","_endLineNumber","getMaxDeltaLine","toString","_updateEndLineNumber","isEmpty","getRange","deltaRange","Range","removeTokens","startLineIndex","endLineIndex","split","bDeltaLine","applyEdit","lastLineLength","countEOL","charCodeAt","firstCharCode","deletedLinesCount","tokenMaxDeltaLine","clear","deletedBefore","acceptDeleteRange","acceptInsertText","_tokenCount","pieces","_getDeltaLine","_getStartCharacter","_getEndCharacter","join","tokenCount","_getTokenCount","startChar","maxDeltaLine","endChar","deltaLine","midDeltaLine","max","SparseLineTokens","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","destOffset","aTokens","bTokens","destTokens","destFirstDeltaLine","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","character","isInsertingPreciselyOneWordCharacter","tokenLength","getStartCharacter","getEndCharacter","SparseTokensStore","_pieces","_isComplete","isComplete","setPartial","_range","_firstRange","_lastRange","plusRange","insertPosition","piece","index","addSparseTokens","_findFirstPieceWithLine","aLen","bLen","aIndex","resultLen","lastEndOffset","emitToken","bIndex","bStartCharacter","bEndCharacter","bMetadata","bMask","aMask","aMergeIndex","ViewEventHandler","_shouldRender","shouldRender","forceShouldRender","setShouldRender","onDidRender","onCompositionStart","e","onCompositionEnd","onConfigurationChanged","onCursorStateChanged","onDecorationsChanged","onFlushed","onFocusChanged","onLanguageConfigurationChanged","onLineMappingChanged","onLinesChanged","onLinesDeleted","onLinesInserted","onRevealRangeRequest","onScrollChanged","onThemeChanged","onTokensChanged","onTokensColorsChanged","onZonesChanged","handleEvents","events","console","info","ViewCompositionStartEvent","ViewCompositionEndEvent","ViewConfigurationChangedEvent","hasChanged","id","ViewCursorStateChangedEvent","selections","modelSelections","reason","ViewDecorationsChangedEvent","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","affectsLineNumber","ViewFlushedEvent","ViewFocusChangedEvent","isFocused","ViewLanguageConfigurationEvent","ViewLineMappingChangedEvent","ViewLinesChangedEvent","count","ViewLinesDeletedEvent","ViewLinesInsertedEvent","ViewRevealRangeRequestEvent","minimalReveal","verticalType","revealHorizontal","scrollType","ViewScrollChangedEvent","scrollWidth","scrollLeft","scrollHeight","scrollTop","scrollWidthChanged","scrollLeftChanged","scrollHeightChanged","scrollTopChanged","ViewThemeChangedEvent","theme","ViewTokensChangedEvent","ViewTokensColorsChangedEvent","ViewZonesChangedEvent","LineDecoration","_lineDecorationBrand","equalsArr","extractWrapped","lineLength","r","rLength","dec","filter","lineDecorations","minLineColumn","maxLineColumn","d","inlineClassName","_typeCompare","ORDER","compare","typeCmp","DecorationSegment","Stack","stopOffsets","classNames","_metadata","consumeLowerThan","maxStopOffset","nextStartOffset","stopOffset","LineDecorationsNormalizer","normalize","stack","charCodeBefore","strings","currentStartOffset","currentEndOffset","LinePart","endIndex","containsRTL","_linePartBrand","isWhitespace","isPseudoAfter","LineRange","startIndex","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","continuesWithWrappedLine","isBasicASCII","fauxIndentLength","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","abs","renderSpaceWidth","renderSpaceCharCode","sameSelection","otherSelections","DomPosition","partIndex","charIndex","CharacterMapping","getPartIndex","partData","getCharIndex","partCount","_data","_horizontalOffset","setColumnInfo","horizontalOffset","getHorizontalOffset","charOffsetToPartData","charOffset","getDomPosition","getColumn","domPosition","partLength","partDataToCharOffset","searchEntry","midEntry","minEntry","maxEntry","minPartIndex","minCharIndex","maxCharIndex","RenderLineOutput","characterMapping","containsForeignElements","_renderLineOutputBrand","renderViewLine","input","sb","appendString","beforeCount","afterCount","lineDecoration","fontIsMonospace","isOverflowing","overflowingCharCount","parts","lastCharacterMappingDefined","charOffsetInPart","charHorizontalOffset","partDisplacement","tokensLen","part","partEndIndex","partType","partContainsRTL","partRendersWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","appendASCIICharCode","partWidth","_charIndex","_visibleColumn","charWidth","String","producedCharacters","appendCharCode","space","charCode","isControlCharacter","to4CharHex","nls","n","toFixed","renderOverflowingCharCount","_renderLine","lineContainsRTL","tokenContainsRTL","transformAndRemoveOverflowing","lastLinePart","token","tokenEndIndex","extractControlCharacters","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokenType","tokensLength","lastNonWhitespaceIndex","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","generateWhitespace","lastCharCode","prevCharCode","_applyRenderWhitespace","_lineDecorations","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastTokenEndIndex","_applyInlineDecorations","onlyAtSpaces","lastSpaceOffset","currTokenStart","j","diff","piecesCount","ceil","pieceEndIndex","splitLargeTokens","ResolvedRenderLineInput","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","StringBuilder","out","build","toUpperCase","padStart","ViewportData","partialData","whitespaceViewportData","model","relativeVerticalOffset","bigNumbersDelta","lineHeight","_model","visibleRange","getLineMinColumn","getLineMaxColumn","getViewLineRenderingData","getViewportViewLineRenderingData","getDecorationsInViewport","Viewport","left","width","height","_viewportBrand","MinimapLinesRenderingData","data","ViewLineData","minColumn","maxColumn","inlineDecorations","_viewLineDataBrand","ViewLineRenderingData","mightContainRTL","mightContainNonBasicASCII","InlineDecoration","SingleLineInlineDecoration","inlineClassNameAffectsLetterSpacing","toInlineDecoration","ViewModelDecoration","_viewModelDecorationBrand","OverviewRulerDecorationsGroup","color","zIndex","compareByRenderingProps","MinimapTokensColorTracker","getInstance","_INSTANCE","markAsSingleton","_updateColorMap","_colors","RGBA8","Empty","_backgroundIsLight","colorId","rgba","g","round","backgroundLuminosity","getRelativeLuminance","getColor","backgroundIsLight","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","classifier","WrappingCharacterClassifier","createLineBreaksComputer","fontInfo","wrappingColumn","wrappingIndent","wordBreak","requests","previousBreakingData","addRequest","previousLineBreakData","columnsForFullWidthChar","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","injectionOptions","createLineBreaks","createLineBreaksFromPreviousLineBreaks","arrPool1","arrPool2","CharacterClassifier","BREAK_BEFORE","BREAK_AFTER","_asciiMap","_map","_defaultValue","firstLineBreakColumn","isKeepAll","prevBreakingOffsets","breakOffsets","prevBreakingOffsetsVisibleColumn","breakOffsetsVisibleColumn","wrappedTextIndentLength","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","lastBreakingOffset","lastBreakingOffsetVisibleColumn","breakingColumn","prevLen","prevIndex","bestDistance","distance","prevBreakOffset","prevBreakOffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","_lineText","injectionOffsets","map","t","ModelLineProjectionData","tabCharacterWidth","numberOfAdditionalTabs","ColorZone","_colorZoneBrand","OverviewRulerZone","heightInLines","_overviewRulerZoneBrand","_colorZone","setColorZone","colorZone","getColorZones","OverviewZoneManager","getVerticalOffsetForLine","_getVerticalOffsetForLine","_zones","_colorZonesInvalid","_lineHeight","_domWidth","_domHeight","_outerHeight","_pixelRatio","_lastAssignedId","_color2Id","Object","_id2Color","getId2Color","setZones","newZones","setLineHeight","setPixelRatio","pixelRatio","getDOMWidth","getCanvasWidth","setDOMWidth","getDOMHeight","getCanvasHeight","setDOMHeight","getOuterHeight","setOuterHeight","outerHeight","resolveColorZones","colorZonesInvalid","totalHeight","heightRatio","halfMinimumHeight","allColorZones","zone","offset1","offset2","y1","y2","ycenter","halfHeight","ViewContext","configuration","EditorTheme","viewModel","viewLayout","addEventHandler","eventHandler","addViewEventHandler","removeEventHandler","removeViewEventHandler","ViewModelDecorations","editorId","linesCollection","coordinatesConverter","_linesCollection","_coordinatesConverter","_decorationsCache","_cachedModelDecorationsResolver","_cachedModelDecorationsResolverViewRange","_clearCachedModelDecorationsResolver","reset","onModelDecorationsChanged","_getOrCreateViewModelDecoration","modelDecoration","modelRange","viewRange","isWholeLine","convertModelPositionToViewPosition","end","convertModelRangeToViewRange","getMinimapDecorationsInRange","_getDecorationsInRange","getDecorationsViewportData","cacheIsValid","equalsRange","getInlineDecorationsOnLine","onlyMinimapDecorations","arguments","onlyMarginDecorations","getViewLineMinColumn","getViewLineMaxColumn","modelDecorations","getDecorationsInRange","filterValidationDecorations","decorationsInViewport","decorationsInViewportLen","decorationOptions","isModelDecorationVisible","viewModelDecoration","inlineDecoration","intersectedStartLineNumber","intersectedEndLineNumber","beforeContentClassName","afterContentClassName","hideInCommentTokens","isModelDecorationInComment","hideInStringTokens","isModelDecorationInString","testTokensInRange","callback","tokenization","isFirstLine","isEndLine","tokenIdx","PendingChanges","_hasPending","_inserts","_changes","_removes","x","change","remove","mustCommit","commit","linesLayout","inserts","removes","_commitPendingChanges","EditorWhitespace","afterLineNumber","ordinal","minWidth","prefixSum","LinesLayout","lineCount","paddingTop","paddingBottom","_instanceId","INSTANCE_COUNT","_pendingChanges","_lastWhitespaceId","_arr","_prefixSumValidIndex","_minWidth","_lineCount","_paddingTop","_paddingBottom","findInsertionIndex","_checkPendingChanges","setPadding","changeWhitespace","hadAChange","insertWhitespace","heightInPx","changeOneWhitespace","newAfterLineNumber","newHeight","removeWhitespace","_insertWhitespace","_changeOneWhitespace","_findWhitespaceIndex","_removeWhitespace","toRemove","Set","toChange","applyRemoveAndChange","whitespaces","whitespace","has","removeIndex","getWhitespacesTotalHeight","getWhitespacesAccumulatedHeight","getLinesTotalHeight","getWhitespaceAccumulatedHeightBeforeLineNumber","lastWhitespaceBeforeLineNumber","_findLastWhitespaceBeforeLineNumber","_findFirstWhitespaceAfterLineNumber","firstWhitespaceAfterLineNumber","getFirstWhitespaceIndexAfterLineNumber","getVerticalOffsetForLineNumber","previousLinesHeight","includeViewZones","getVerticalOffsetAfterLineNumber","getWhitespaceMinWidth","isAfterLines","verticalOffset","isInTopPadding","isInBottomPadding","getLineNumberAtOrAfterVerticalOffset","linesCount","minLineNumber","maxLineNumber","midLineNumber","midLineNumberVerticalOffset","getLinesViewportData","verticalOffset1","verticalOffset2","startLineNumberVerticalOffset","whitespaceIndex","whitespaceCount","getWhitespacesCount","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","getAfterLineNumberForWhitespaceIndex","getHeightForWhitespaceIndex","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","linesOffsets","verticalCenter","centeredLineNumber","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","getVerticalOffsetForWhitespaceIndex","previousWhitespacesHeight","getWhitespaceIndexAtOrAfterVerticallOffset","minWhitespaceIndex","maxWhitespaceIndex","midWhitespaceIndex","midWhitespaceVerticalOffset","getWhitespaceAtVerticalOffset","candidateIndex","candidateTop","candidateHeight","getIdForWhitespaceIndex","getWhitespaceViewportData","getWhitespaces","slice","EditorScrollDimensions","contentWidth","contentHeight","EditorScrollable","smoothScrollDuration","scheduleAtNextAnimationFrame","_onDidContentSizeChange","onDidContentSizeChange","_dimensions","_scrollable","Scrollable","forceIntegerValues","onDidScroll","onScroll","getScrollable","setSmoothScrollDuration","validateScrollPosition","scrollPosition","getScrollDimensions","setScrollDimensions","dimensions","oldDimensions","contentWidthChanged","contentHeightChanged","ContentSizeChangedEvent","getFutureScrollPosition","getCurrentScrollPosition","setScrollPositionNow","update","setScrollPositionSmooth","hasPendingScrollAnimation","ViewLayout","_configuration","layoutInfo","padding","_linesLayout","bottom","_maxLineWidth","_overlayWidgetsMinWidth","_configureSmoothScrollDuration","_updateHeight","onHeightMaybeChanged","scrollDimensions","_getContentHeight","_getHorizontalScrollbarHeight","scrollbar","horizontal","horizontalScrollbarSize","ignoreHorizontalScrollbarInContentHeight","getCurrentViewport","currentScrollPosition","getFutureViewport","_computeContentWidth","maxLineWidth","wrappingInfo","isViewportWrapping","minimap","enabled","side","verticalScrollbarWidth","extraHorizontalSpace","whitespaceMinWidth","setMaxLineWidth","_updateContentWidth","setOverlayWidgetsMinWidth","maxMinWidth","saveState","firstLineNumberInViewport","scrollTopWithoutViewZones","getLineNumberAtVerticalOffset","visibleBox","getLinesViewportDataAtScrollTop","getContentWidth","getScrollWidth","getContentHeight","getScrollHeight","getCurrentScrollLeft","getCurrentScrollTop","setScrollPosition","deltaScrollNow","deltaScrollLeft","deltaScrollTop","createModelLineProjection","lineBreakData","isVisible","IdentityModelLineProjection","INSTANCE","HiddenModelLineProjection","ModelLineProjection","_projectionData","_isVisible","setVisible","getProjectionData","getViewLineCount","getOutputLineCount","getViewLineContent","modelLineNumber","outputLineIndex","_assertVisible","startOffsetInInputWithInjections","endOffsetInInputWithInjections","idx","getValueInRange","spaces","getViewLineLength","_modelLineNumber","getMinOutputOffset","getMaxOutputOffset","getViewLineData","getViewLinesData","outputLineIdx","globalStartIndex","needed","lineWithInjections","inlineDecorationsPerOutputLine","totalInjectedTextLengthBefore","currentInjectedOffset","lineStartOffsetInInputWithInjections","lineEndOffsetInInputWithInjections","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","globalIndex","_getViewLineData","deltaStartIndex","getModelColumnOfViewPosition","outputColumn","translateToInputOffset","getViewPositionOfModelPosition","deltaLineNumber","inputColumn","affinity","translateToOutputPosition","toPosition","getViewLineNumberOfModelPosition","normalizePosition","outputPosition","baseViewLineNumber","normalizeOutputPosition","getInjectedTextAt","getInjectedText","_outputLineIndex","_fromOuputLineIndex","_toOutputLineIndex","_inputColumn","_outputColumn","_globalStartIndex","_needed","_result","_deltaLineNumber","_spaces","_makeSpaces","ViewModelLinesFromProjectedModel","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","wrappingStrategy","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","hiddenAreasDecorationIds","deltaDecorations","createCoordinatesConverter","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","modelLineProjections","linesContent","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineBreaksComputer","injectedTextQueue","lineInjectedText","takeWhile","linesBreaks","values","hiddenAreas","areaId","getDecorationRange","compareRangesUsingStarts","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","isInHiddenArea","line","getVersionId","projectedModelLineLineCounts","ConstantTimePrefixSumComputer","getHiddenAreas","decId","setHiddenAreas","_ranges","newRanges","sortedRanges","currentRangeStart","currentRangeEnd","normalizeLineRanges","validateRange","oldRanges","hasDifference","newDecorations","ModelDecorationOptions","EMPTY","hasVisibleLine","lineChanged","newOutputLineCount","setValue","modelPositionIsVisible","_modelColumn","getModelLineViewLineCount","setTabSize","newTabSize","setWrappingSettings","equalFontInfo","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","equalWordBreak","onlyWrappingColumnChanged","onModelFlushed","onModelLinesDeleted","outputFromLineNumber","getPrefixSum","outputToLineNumber","removeValues","viewEvents","onModelLinesInserted","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","outputLineCount","insertValues","onModelLineChanged","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","acceptVersionId","getTotalSum","_toValidViewLineNumber","viewLineNumber","viewLineCount","getActiveIndentGuide","modelPosition","convertViewPositionToModelPosition","modelMinPosition","modelMaxPosition","guides","viewStartPosition","viewEndPosition","indent","getViewLineInfo","getIndexOf","remainder","ViewLineInfo","getMinColumnOfViewLine","viewLineInfo","modelLineWrappedLineIdx","getMaxColumnOfViewLine","getModelStartPositionOfViewLine","minViewColumn","getModelEndPositionOfViewLine","maxViewColumn","getViewLineInfosGroupedByModelRanges","viewStartLineNumber","viewEndLineNumber","startViewLine","endViewLine","lastVisibleModelPos","viewLines","curModelLine","lastVisibleModelPos2","fromPositions","ViewLineInfoGroupedByModelRange","getViewLinesBracketGuides","activeViewPosition","modelActivePosition","resultPerViewLine","group","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","p","viewPosition","getViewLinesIndentGuides","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","viewLineEndIndex","option","getLinesIndentGuides","viewIndents","currIndex","blockAtIndex","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","validateViewPosition","viewColumn","expectedModelPosition","computedModelColumn","validatePosition","validateViewRange","expectedModelRange","validViewStart","getStartPosition","validViewEnd","getEndPosition","convertViewRangeToModelRange","allowZeroLineNumber","belowHiddenRanges","validPosition","inputLineNumber","lineIndexChanged","modelColumn","filterOutValidation","res","finalResult","finalResultLen","prevDecId","getLineIndentColumn","lines","_lines","allowZero","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","_versionId","_minLineNumber","_maxLineNumber","activePosition","fill","_validPosition","pos","_validRange","_viewPosition","_viewRange","MAX_LANE","GlyphMarginLane","Right","GlyphMarginLanesModel","maxLine","persist","_requiredLanes","lanes","Uint8Array","bytes","requiredLanes","lane","bit","countAtLine","getLanesAtLine","Center","ViewModel","languageConfigurationService","_themeService","_attachedView","hiddenAreasModel","HiddenAreasModel","previousHiddenAreas","_eventDispatcher","ViewModelEventDispatcher","onEvent","cursorConfig","CursorConfiguration","getOptions","_updateConfigurationViewLineCount","RunOnceScheduler","_updateConfigurationViewLineCountNow","_hasFocus","_viewportStart","ViewportStart","glyphLanes","isTooLargeForTokenization","_cursor","CursorsController","_handleVisibleLinesChanged","invalidate","emitSingleViewEvent","emitOutgoingEvent","ScrollChangedEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","_decorations","_registerModelEvents","onDidChangeFast","eventsCollector","beginEmitViewEvents","_onConfigurationChanged","endEmitViewEvents","onDidColorThemeChange","_invalidateDecorationsColorCache","setViewLineCount","getModelVisibleRanges","linesViewportData","viewVisibleRange","_toModelVisibleRanges","visibleLinesStabilized","modelVisibleRanges","setVisibleLines","setHasFocus","hasFocus","FocusChangedEvent","_captureStableViewport","isValid","previousViewportStartViewPosition","previousViewportStartModelPosition","StableViewport","startLineDelta","stableViewport","emitViewEvent","schedule","recoverViewportStart","shouldRecreate","updateConfiguration","onDidChangeContentOrInjectedText","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","textModelEvents","lineIdx","lineBreakQueue","ArrayQueue","linesDeletedEvent","insertedLineBreaks","takeCount","linesInsertedEvent","changedLineBreakData","dequeue","linesChangedEvent","viewportStartWasValid","setModelLineCount","getAttachedEditorCount","_getTrackedRange","modelTrackedRange","viewPositionTop","ModelContentChangedEvent","onModelContentChanged","onDidChangeTokens","viewRanges","lenJ","ModelTokensChangedEvent","onDidChangeLanguageConfiguration","ModelLanguageConfigurationChangedEvent","onDidChangeLanguage","ModelLanguageChangedEvent","onDidChangeOptions","ModelOptionsChangedEvent","onDidChangeDecorations","ModelDecorationsChangedEvent","mergedRanges","getMergedRanges","firstModelLineInViewPort","viewportStartModelPosition","some","HiddenAreasChangedEvent","getVisibleRangesPlusViewportAboveBelow","linesAround","startViewLineNumber","endViewLineNumber","getVisibleRanges","visibleViewRange","getCompletelyVisibleViewRange","hiddenStartLineNumber","hiddenEndLineNumber","getCompletelyVisibleViewRangeAtScrollTop","compatViewState","firstViewLineNumber","firstPosition","firstPositionDeltaTop","reduceRestoreState","state","_reduceRestoreStateCompatibility","getTabSize","setViewport","getBracketGuidesInRangeByLine","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","_getViewLineRenderingData","lineData","getMinimapLinesRenderingData","getAllOverviewRulerDecorations","getOverviewRulerDecorations","OverviewRulerDecorations","opts","overviewRuler","accept","asArray","opts1","invalidateCachedColor","opts2","getValueLengthInRange","modifyPosition","resultModelPosition","deduceModelPositionRelativeToViewPosition","viewAnchorPosition","lineFeedCnt","modelAnchor","getEOL","resultOffset","getOffsetAt","getPositionAt","getPlainTextToCopy","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","hasEmptyRange","hasNonEmptyRange","modelLineNumbers","prevModelLineNumber","getRichTextToCopy","PLAINTEXT_LANGUAGE_ID","_getColorMap","fontFamily","test","EDITOR_FONT_DEFAULTS","replace","mode","fontWeight","fontSize","_getHTMLToCopy","tokenizeLineToHTML","platform","Color","Format","CSS","formatHex","getPrimaryCursorState","getLastAddedCursorIndex","getCursorStates","setCursorStates","states","_withViewEventsCollector","setStates","getCursorColumnSelectData","getCursorAutoClosedCharacters","getAutoClosedCharacters","setCursorColumnSelectData","columnSelectData","getPrevEditOperationType","setPrevEditOperationType","getSelection","getSelections","getPosition","modelState","setSelections","saveCursorState","restoreCursorState","restoreState","_executeCursorEdit","context","readOnly","ReadOnlyEditAttemptEvent","executeEdits","edits","cursorStateComputer","startComposition","endComposition","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","paste","pasteOnNewLine","multicursorText","cut","executeCommand","command","executeCommands","commands","revealAllCursors","revealAll","revealPrimaryCursor","revealPrimary","revealTopMostCursor","getTopMostViewPosition","revealBottomMostCursor","getBottomMostViewPosition","revealRange","batchEvents","viewportStartLineTrackedRange","_setTrackedRange","_viewLineNumber","_isValid","_modelTrackedRange","_startLineDelta","viewportStartLineTop","_asMap","prevGroup","prevData","prevLane","prevEndLineNumber","shouldRecompute","existing","rangeArraysEqual","reduce","arr1","arr2","item1","item2","mergeLineRangeArray","_onEvent","_eventHandlers","_viewEventQueue","_isConsumingViewEventQueue","_collector","_collectorCnt","_outgoingEvents","_addOutgoingEvent","_emitOutgoingEvents","mergeResult","kind","attemptToMerge","shift","isNoOp","warn","ViewModelEventsCollector","outgoingEvents","outgoingEvent","_emitMany","_consumeViewEventQueue","_doConsumeQueue","eventHandlers","oldContentWidth","oldContentHeight","_oldContentWidth","_oldContentHeight","oldHasFocus","_oldScrollWidth","_oldScrollLeft","_oldScrollHeight","_oldScrollTop","CursorStateChangedEvent","oldSelections","oldModelVersionId","modelVersionId","reachedMaxCursorCount","_selectionsAreEqual","equalsSelection"],"sourceRoot":""}