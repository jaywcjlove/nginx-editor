{"version":3,"file":"static/js/monaco-editor-vendor.afb535f1.11f3dab4.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/smartLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/diffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/utils.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js","../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineRange } from '../core/lineRange.js';\nexport class LinesDiff {\n    constructor(changes, \n    /**\n     * Sorted by original line ranges.\n     * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n     */\n    moves, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.moves = moves;\n        this.hitTimeout = hitTimeout;\n    }\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.originalRange.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modifiedRange.startLineNumber), undefined);\n            if (!r.modifiedRange.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.originalRange.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modifiedRange.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), undefined);\n        if (!r.modifiedRange.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n        this.innerChanges = innerChanges;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    get changedLineCount() {\n        return Math.max(this.originalRange.length, this.modifiedRange.length);\n    }\n    flip() {\n        var _a;\n        return new LineRangeMapping(this.modifiedRange, this.originalRange, (_a = this.innerChanges) === null || _a === void 0 ? void 0 : _a.map(c => c.flip()));\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    flip() {\n        return new RangeMapping(this.modifiedRange, this.originalRange);\n    }\n}\n// TODO@hediet: Make LineRangeMapping extend from this!\nexport class SimpleLineRangeMapping {\n    constructor(original, modified) {\n        this.original = original;\n        this.modified = modified;\n    }\n    toString() {\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\n    }\n    flip() {\n        return new SimpleLineRangeMapping(this.modified, this.original);\n    }\n}\nexport class MovedText {\n    constructor(lineRangeMapping, changes) {\n        this.lineRangeMapping = lineRangeMapping;\n        this.changes = changes;\n    }\n    flip() {\n        return new MovedText(this.lineRangeMapping.flip(), this.changes.map(c => c.flip()));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { RangeMapping, LineRangeMapping, LinesDiff } from './linesDiffComputer.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class SmartLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new LineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber\n                    || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n                m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n        });\n        return new LinesDiff(changes, [], result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SmartLinesDiffComputer } from './smartLinesDiffComputer.js';\nimport { StandardLinesDiffComputer } from './standardLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    getLegacy: () => new SmartLinesDiffComputer(),\n    getAdvanced: () => new StandardLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nexport class DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class SequenceDiff {\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    reverse() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n    }\n}\nexport class InfiniteTimeout {\n    isValid() {\n        return true;\n    }\n}\nInfiniteTimeout.instance = new InfiniteTimeout();\nexport class DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from './utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff } from './diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffs(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\nexport function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nexport function removeRandomMatches(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (Math.pow((Math.pow(max, 1.5)), 1.5)) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nexport function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start + d) !== sequence1.getElement(cur.seq1Range.endExclusive + d) ||\n                    sequence2.getElement(cur.seq2Range.start + d) !== sequence2.getElement(cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nexport function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).reverse();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.getElement(diff.seq2Range.start - deltaBefore) ===\n            sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.getElement(diff.seq2Range.start + deltaAfter) ===\n            sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        function getXAfterSnake(x, y) {\n            while (x < seq1.length && y < seq2.length && seq1.getElement(x) === seq2.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seq1, seq2);\n            }\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n            const lowerBound = -Math.min(d, seq2.length + (d % 2));\n            const upperBound = Math.min(d, seq1.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seq1)\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seq1)\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);\n                const y = x - k;\n                if (x > seq1.length || y > seq2.length) {\n                    // This diagonal is irrelevant for the result.\n                    // TODO: Don't pay the cost for this in the next iteration.\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seq1.length && V.get(k) - k === seq2.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seq1.length;\n        let lastAligningPosS2 = seq2.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { optimizeSequenceDiffs, removeRandomMatches, smoothenSequenceDiffs } from './algorithms/joinSequenceDiffs.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { LineRangeMapping, LinesDiff, MovedText, RangeMapping, SimpleLineRangeMapping } from './linesDiffComputer.js';\nexport class StandardLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return {\n                changes: [\n                    new LineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n                        new RangeMapping(new Range(1, 1, originalLines.length, originalLines[0].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))\n                    ])\n                ],\n                hitTimeout: false,\n                moves: [],\n            };\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const srcDocLines = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const tgtDocLines = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(srcDocLines, originalLines);\n        const sequence2 = new LineSequence(tgtDocLines, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1500) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        const moves = [];\n        if (options.computeMoves) {\n            const deletions = changes\n                .filter(c => c.modifiedRange.isEmpty && c.originalRange.length >= 3)\n                .map(d => new LineRangeFragment(d.originalRange, originalLines));\n            const insertions = new Set(changes\n                .filter(c => c.originalRange.isEmpty && c.modifiedRange.length >= 3)\n                .map(d => new LineRangeFragment(d.modifiedRange, modifiedLines)));\n            for (const deletion of deletions) {\n                let highestSimilarity = -1;\n                let best;\n                for (const insertion of insertions) {\n                    const similarity = deletion.computeSimilarity(insertion);\n                    if (similarity > highestSimilarity) {\n                        highestSimilarity = similarity;\n                        best = insertion;\n                    }\n                }\n                if (highestSimilarity > 0.90 && best) {\n                    const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(deletion.range.startLineNumber - 1, deletion.range.endLineNumberExclusive - 1), new OffsetRange(best.range.startLineNumber - 1, best.range.endLineNumberExclusive - 1)), timeout, considerWhitespaceChanges);\n                    const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n                    insertions.delete(best);\n                    moves.push(new MovedText(new SimpleLineRangeMapping(deletion.range, best.range), mappings));\n                }\n            }\n        }\n        // Make sure all ranges are valid\n        assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modifiedRange, modifiedLines) || !validateRange(c.originalRange, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return new LinesDiff(changes, moves, hitTimeout);\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\n        const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        diffs = coverFullWords(slice1, slice2, diffs);\n        diffs = smoothenSequenceDiffs(slice1, slice2, diffs);\n        diffs = removeRandomMatches(slice1, slice2, diffs);\n        const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nfunction coverFullWords(sequence1, sequence2, sequenceDiffs) {\n    const additional = [];\n    let lastModifiedWord = undefined;\n    function maybePushWordToAdditional() {\n        if (!lastModifiedWord) {\n            return;\n        }\n        const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n        const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n        if (originalLength1 !== originalLength2) {\n            // TODO figure out why this happens\n        }\n        if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {\n            additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n        }\n        lastModifiedWord = undefined;\n    }\n    for (const s of sequenceDiffs) {\n        function processWord(s1Range, s2Range) {\n            var _a, _b, _c, _d;\n            if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n                if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {\n                    const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n                    const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n                    lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;\n                    lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;\n                    lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n                    lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n                }\n                else {\n                    maybePushWordToAdditional();\n                    lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range: s1Range, s2Range: s2Range };\n                }\n            }\n            const changedS1 = s1Range.intersect(s.seq1Range);\n            const changedS2 = s2Range.intersect(s.seq2Range);\n            lastModifiedWord.count++;\n            lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;\n            lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;\n        }\n        const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n        const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n        const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n        const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n        if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {\n            processWord(w1Before, w2Before);\n        }\n        else {\n            if (w1Before && w2Before) {\n                processWord(w1Before, w2Before);\n            }\n            if (w1After && w2After) {\n                processWord(w1After, w2After);\n            }\n        }\n    }\n    maybePushWordToAdditional();\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of group(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.originalRange.overlapOrTouch(a2.originalRange)\n        || a1.modifiedRange.overlapOrTouch(a2.modifiedRange))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new LineRangeMapping(first.originalRange.join(last.originalRange), first.modifiedRange.join(last.modifiedRange), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        if (!dontAssertStartLine) {\n            if (changes.length > 0 && changes[0].originalRange.startLineNumber !== changes[0].modifiedRange.startLineNumber) {\n                return false;\n            }\n        }\n        return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n            m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        // We can only do this if the range is not empty yet\n        lineEndDelta = -1;\n    }\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        // We can only do this if the range is not empty yet\n        lineStartDelta = 1;\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new LineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\nfunction* group(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\nexport class LinesSliceCharSequence {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLineMinusOne = [];\n        // To account for trimming\n        this.offsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.offsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLineMinusOne[i - this.lineRange.start] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.offsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new Position(this.lineRange.start + 1, 1);\n        }\n        let i = 0;\n        let j = this.firstCharOffsetByLineMinusOne.length;\n        while (i < j) {\n            const k = Math.floor((i + j) / 2);\n            if (this.firstCharOffsetByLineMinusOne[k] > offset) {\n                j = k;\n            }\n            else {\n                i = k + 1;\n            }\n        }\n        const offsetOfFirstCharInLine = i === 0 ? 0 : this.firstCharOffsetByLineMinusOne[i - 1];\n        return new Position(this.lineRange.start + i + 1, offset - offsetOfFirstCharInLine + 1 + this.offsetByLine[i]);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Space */]: 3,\n    [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [7 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 7 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 6 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 5 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\nfunction isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\nconst chrKeys = new Map();\nfunction getKey(chr) {\n    let key = chrKeys.get(chr);\n    if (key === undefined) {\n        key = chrKeys.size;\n        chrKeys.set(chr, key);\n    }\n    return key;\n}\nclass LineRangeFragment {\n    constructor(range, lines) {\n        this.range = range;\n        this.lines = lines;\n        this.histogram = [];\n        let counter = 0;\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n            const line = lines[i];\n            for (let j = 0; j < line.length; j++) {\n                counter++;\n                const chr = line[j];\n                const key = getKey(chr);\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\n            }\n            counter++;\n            const key = getKey('\\n');\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\n        }\n        this.totalCount = counter;\n    }\n    computeSimilarity(other) {\n        var _a, _b;\n        let sumDifferences = 0;\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\n        for (let i = 0; i < maxLength; i++) {\n            sumDifferences += Math.abs(((_a = this.histogram[i]) !== null && _a !== void 0 ? _a : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));\n        }\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run(args) {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run(args);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read-only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.isEmbeddedDiffEditor = new RawContextKey('isEmbeddedDiffEditor', false, nls.localize('isEmbeddedDiffEditor', \"Whether the context is an embedded diff editor\"));\n    EditorContextKeys.accessibleDiffViewerVisible = new RawContextKey('accessibleDiffViewerVisible', false, nls.localize('accessibleDiffViewerVisible', \"Whether the accessible diff viewer is visible\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    EditorContextKeys.hoverFocused = new RawContextKey('editorHoverFocused', false, nls.localize('editorHoverFocused', \"Whether the editor hover is focused\"));\n    EditorContextKeys.stickyScrollFocused = new RawContextKey('stickyScrollFocused', false, nls.localize('stickyScrollFocused', \"Whether the sticky scroll is focused\"));\n    EditorContextKeys.stickyScrollVisible = new RawContextKey('stickyScrollVisible', false, nls.localize('stickyScrollVisible', \"Whether the sticky scroll is visible\"));\n    EditorContextKeys.standaloneColorPickerVisible = new RawContextKey('standaloneColorPickerVisible', false, nls.localize('standaloneColorPickerVisible', \"Whether the standalone color picker is visible\"));\n    EditorContextKeys.standaloneColorPickerFocused = new RawContextKey('standaloneColorPickerFocused', false, nls.localize('standaloneColorPickerFocused', \"Whether the standalone color picker is focused\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst editorFeatures = [];\n/**\n * Registers an editor feature. Editor features will be instantiated only once, as soon as\n * the first code editor is instantiated.\n */\nexport function registerEditorFeature(ctor) {\n    editorFeatures.push(ctor);\n}\nexport function getEditorFeatures() {\n    return editorFeatures.slice(0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    constructor(theme) {\n        this._theme = theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n"],"names":["LinesDiff","_createClass","changes","moves","hitTimeout","_classCallCheck","this","LineRangeMapping","originalRange","modifiedRange","innerChanges","key","value","concat","toString","get","Math","max","length","_a","map","c","flip","mapping","originalLineCount","modifiedLineCount","_step","result","lastOriginalEndLineNumber","lastModifiedEndLineNumber","_iterator","_createForOfIteratorHelper","s","n","done","m","r","LineRange","startLineNumber","undefined","isEmpty","push","endLineNumberExclusive","err","e","f","RangeMapping","SimpleLineRangeMapping","original","modified","MovedText","lineRangeMapping","SmartLinesDiffComputer","originalLines","modifiedLines","options","DiffComputer","maxComputationTime","maxComputationTimeMs","shouldIgnoreTrimWhitespace","ignoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","computeDiff","lastChange","originalEndLineNumber","originalStartLineNumber","modifiedEndLineNumber","modifiedStartLineNumber","change","charChanges","Range","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","join","pop","assertFn","checkAdjacentItems","m1","m2","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","LineSequence","lines","startColumns","endColumns","i","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","elements","len","substring","index","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","startColumn","endColumn","col","charCodeAt","CharSequence","_charCodes","_lineNumbers","_columns","_this","idx","String","fromCharCode","arr","Error","getEndLineNumber","_assertIndex","getStartLineNumber","getEndColumn","getStartColumn","CharChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","LineChange","originalLineSequence","modifiedLineSequence","continueCharDiff","createCharSequence","getElements","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","min","postProcessCharChanges","createFromDiffChange","opts","continueLineDiff","createContinueProcessingPredicate","diffResult","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","strings","maximumRuntime","startTime","Date","now","linesDiffComputers","getLegacy","getAdvanced","StandardLinesDiffComputer","DiffAlgorithmResult","diffs","seq1","seq2","SequenceDiff","OffsetRange","seq1Range","seq2Range","other","offset","delta","InfiniteTimeout","instance","DateTimeout","timeout","valid","BugIndicatingError","Array2D","width","height","array","Array","x","y","DynamicProgrammingDiffing","sequence1","sequence2","arguments","equalityScore","trivial","lcsLengths","directions","lengths","s1","s2","isValid","trivialTimedOut","horizontalLen","verticalLen","extendedSeqScore","getElement","newValue","prevLen","set","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","reverse","optimizeSequenceDiffs","sequenceDiffs","prevResult","cur","start","endExclusive","d","result2","nextResult","joinSequenceDiffs","getBoundaryScore","prevDiff","diff","nextDiff","seq1ValidRange","seq2ValidRange","shiftDiffToBetterPosition","shiftSequenceDiffs","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","score","MyersDiffAlgorithm","getXAfterSnake","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","k","loop","lowerBound","upperBound","maxXofDLineTop","maxXofDLineLeft","newMaxX","lastPath","path","endX","endY","prev","positiveArr","Int32Array","negativeArr","group","dynamicProgrammingDiffing","myersDiffingAlgorithm","considerWhitespaceChanges","perfectHashes","Map","getOrCreateHash","text","hash","size","srcDocLines","l","trim","tgtDocLines","lineAlignmentResult","compute","offset1","offset2","log","lineAlignments","_step2","alignments","scanForWhitespaceChanges","equalLinesCount","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","mappings","a","_iterator2","_loop","_step7","_iterator7","lineRangeMappingFromRangeMappings","computeMoves","_step3","deletions","filter","LineRangeFragment","insertions","Set","_iterator3","_step4","deletion","highestSimilarity","best","_iterator4","insertion","similarity","computeSimilarity","range","delete","validatePosition","pos","lineNumber","line","column","validateRange","_step5","_iterator5","_step6","_iterator6","ic","getStartPosition","getEndPosition","slice1","LinesSliceCharSequence","slice2","additional","lastModifiedWord","maybePushWordToAdditional","originalLength1","s1Range","deleted","s2Range","added","count","_step8","_iterator8","_loop2","processWord","_b","_c","_d","containsRange","s1Added","tryCreate","s2Added","changedS1","intersect","changedS2","w1Before","findWordContaining","w2Before","w1After","w2After","equals","sequenceDiffs1","sequenceDiffs2","sd1","sd2","next","shift","mergeSequenceDiffs","coverFullWords","last","smoothenSequenceDiffs","shouldRepeat","counter","lastResult","before","after","unchangedRange","countLinesIn","unchangedText","getText","split","beforeLineCount1","beforeSeq1Length","beforeLineCount2","beforeSeq2Length","afterLineCount1","afterSeq1Length","afterLineCount2","afterSeq2Length","cap","v","pow","shouldJoinDiffs","removeRandomMatches","translateRange","_step9","dontAssertStartLine","_iterator9","rangeMapping","lineStartDelta","lineEndDelta","endLineNumber","originalLineRange","modifiedLineRange","getLineRangeMapping","a1","a2","overlapOrTouch","g","first","items","shouldBeGrouped","currentGroup","_iterator10","_step10","item","_regeneratorRuntime","wrap","_context","t0","finish","stop","_marked","trimmedHash","getIndentation","str","lineRange","firstCharOffsetByLineMinusOne","offsetByLine","trimFirstLineFully","trimmedStartLine","trimStart","trimEnd","slice","prevCategory","getCategory","nextCategory","getCategoryBoundaryScore","Position","j","floor","offsetOfFirstCharInLine","fromPositions","translateOffset","isWordChar","end","charCode","_score","_defineProperty","category","isSpace","chrKeys","getKey","chr","histogram","totalCount","sumDifferences","maxLength","abs","InternalEditorAction","id","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","contextMatchesRules","args","isSupported","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","nls","focus","textInputFocus","readOnly","inDiffEditor","isEmbeddedDiffEditor","accessibleDiffViewerVisible","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","hoverFocused","stickyScrollFocused","stickyScrollVisible","standaloneColorPickerVisible","standaloneColorPickerFocused","inCompositeEditor","notInCompositeEditor","languageId","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","editorFeatures","registerEditorFeature","ctor","getEditorFeatures","EditorTheme","theme","_theme","type","color","getColor"],"sourceRoot":""}