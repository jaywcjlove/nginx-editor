{"version":3,"file":"static/js/monaco-editor-vendor.cb843302.5b9f1555.js","mappings":"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","sources":["../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/hiddenRangeModel.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingDecorations.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingRanges.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/indentRangeProvider.js","../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/syntaxRangeProvider.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findFirstIdxMonotonousOrArrLen } from '../../../../base/common/arraysFind.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Range } from '../../../common/core/range.js';\nimport { countEOL } from '../../../common/core/eolCounter.js';\nexport class HiddenRangeModel {\n    get onDidChange() { return this._updateEventEmitter.event; }\n    get hiddenRanges() { return this._hiddenRanges; }\n    constructor(model) {\n        this._updateEventEmitter = new Emitter();\n        this._hasLineChanges = false;\n        this._foldingModel = model;\n        this._foldingModelListener = model.onDidChange(_ => this.updateHiddenRanges());\n        this._hiddenRanges = [];\n        if (model.regions.length) {\n            this.updateHiddenRanges();\n        }\n    }\n    notifyChangeModelContent(e) {\n        if (this._hiddenRanges.length && !this._hasLineChanges) {\n            this._hasLineChanges = e.changes.some(change => {\n                return change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;\n            });\n        }\n    }\n    updateHiddenRanges() {\n        let updateHiddenAreas = false;\n        const newHiddenAreas = [];\n        let i = 0; // index into hidden\n        let k = 0;\n        let lastCollapsedStart = Number.MAX_VALUE;\n        let lastCollapsedEnd = -1;\n        const ranges = this._foldingModel.regions;\n        for (; i < ranges.length; i++) {\n            if (!ranges.isCollapsed(i)) {\n                continue;\n            }\n            const startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden\n            const endLineNumber = ranges.getEndLineNumber(i);\n            if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {\n                // ignore ranges contained in collapsed regions\n                continue;\n            }\n            if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {\n                // reuse the old ranges\n                newHiddenAreas.push(this._hiddenRanges[k]);\n                k++;\n            }\n            else {\n                updateHiddenAreas = true;\n                newHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));\n            }\n            lastCollapsedStart = startLineNumber;\n            lastCollapsedEnd = endLineNumber;\n        }\n        if (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) {\n            this.applyHiddenRanges(newHiddenAreas);\n        }\n    }\n    applyHiddenRanges(newHiddenAreas) {\n        this._hiddenRanges = newHiddenAreas;\n        this._hasLineChanges = false;\n        this._updateEventEmitter.fire(newHiddenAreas);\n    }\n    hasRanges() {\n        return this._hiddenRanges.length > 0;\n    }\n    isHidden(line) {\n        return findRange(this._hiddenRanges, line) !== null;\n    }\n    adjustSelections(selections) {\n        let hasChanges = false;\n        const editorModel = this._foldingModel.textModel;\n        let lastRange = null;\n        const adjustLine = (line) => {\n            if (!lastRange || !isInside(line, lastRange)) {\n                lastRange = findRange(this._hiddenRanges, line);\n            }\n            if (lastRange) {\n                return lastRange.startLineNumber - 1;\n            }\n            return null;\n        };\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let selection = selections[i];\n            const adjustedStartLine = adjustLine(selection.startLineNumber);\n            if (adjustedStartLine) {\n                selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));\n                hasChanges = true;\n            }\n            const adjustedEndLine = adjustLine(selection.endLineNumber);\n            if (adjustedEndLine) {\n                selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));\n                hasChanges = true;\n            }\n            selections[i] = selection;\n        }\n        return hasChanges;\n    }\n    dispose() {\n        if (this.hiddenRanges.length > 0) {\n            this._hiddenRanges = [];\n            this._updateEventEmitter.fire(this._hiddenRanges);\n        }\n        if (this._foldingModelListener) {\n            this._foldingModelListener.dispose();\n            this._foldingModelListener = null;\n        }\n    }\n}\nfunction isInside(line, range) {\n    return line >= range.startLineNumber && line <= range.endLineNumber;\n}\nfunction findRange(ranges, line) {\n    const i = findFirstIdxMonotonousOrArrLen(ranges, r => line < r.startLineNumber) - 1;\n    if (i >= 0 && ranges[i].endLineNumber >= line) {\n        return ranges[i];\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar FoldingController_1;\nimport { createCancelablePromise, Delayer, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { illegalArgument, onUnexpectedError } from '../../../../base/common/errors.js';\nimport { KeyChord } from '../../../../base/common/keyCodes.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { escapeRegExpCharacters } from '../../../../base/common/strings.js';\nimport * as types from '../../../../base/common/types.js';\nimport './folding.css';\nimport { StableEditorScrollState } from '../../../browser/stableEditorScroll.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution, registerInstantiatedEditorAction } from '../../../browser/editorExtensions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { FoldingRangeKind } from '../../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { FoldingModel, getNextFoldLine, getParentFoldLine as getParentFoldLine, getPreviousFoldLine, setCollapseStateAtLevel, setCollapseStateForMatchingLines, setCollapseStateForRest, setCollapseStateForType, setCollapseStateLevelsDown, setCollapseStateLevelsUp, setCollapseStateUp, toggleCollapseState } from './foldingModel.js';\nimport { HiddenRangeModel } from './hiddenRangeModel.js';\nimport { IndentRangeProvider } from './indentRangeProvider.js';\nimport * as nls from '../../../../nls.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { FoldingDecorationProvider } from './foldingDecorations.js';\nimport { FoldingRegions } from './foldingRanges.js';\nimport { SyntaxRangeProvider } from './syntaxRangeProvider.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nconst CONTEXT_FOLDING_ENABLED = new RawContextKey('foldingEnabled', false);\nlet FoldingController = FoldingController_1 = class FoldingController extends Disposable {\n    static get(editor) {\n        return editor.getContribution(FoldingController_1.ID);\n    }\n    static getFoldingRangeProviders(languageFeaturesService, model) {\n        var _a, _b;\n        const foldingRangeProviders = languageFeaturesService.foldingRangeProvider.ordered(model);\n        return (_b = ((_a = FoldingController_1._foldingRangeSelector) === null || _a === void 0 ? void 0 : _a.call(FoldingController_1, foldingRangeProviders, model))) !== null && _b !== void 0 ? _b : foldingRangeProviders;\n    }\n    constructor(editor, contextKeyService, languageConfigurationService, notificationService, languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this.contextKeyService = contextKeyService;\n        this.languageConfigurationService = languageConfigurationService;\n        this.languageFeaturesService = languageFeaturesService;\n        this.localToDispose = this._register(new DisposableStore());\n        this.editor = editor;\n        this._foldingLimitReporter = new RangesLimitReporter(editor);\n        const options = this.editor.getOptions();\n        this._isEnabled = options.get(43 /* EditorOption.folding */);\n        this._useFoldingProviders = options.get(44 /* EditorOption.foldingStrategy */) !== 'indentation';\n        this._unfoldOnClickAfterEndOfLine = options.get(48 /* EditorOption.unfoldOnClickAfterEndOfLine */);\n        this._restoringViewState = false;\n        this._currentModelHasFoldedImports = false;\n        this._foldingImportsByDefault = options.get(46 /* EditorOption.foldingImportsByDefault */);\n        this.updateDebounceInfo = languageFeatureDebounceService.for(languageFeaturesService.foldingRangeProvider, 'Folding', { min: 200 });\n        this.foldingModel = null;\n        this.hiddenRangeModel = null;\n        this.rangeProvider = null;\n        this.foldingRegionPromise = null;\n        this.foldingModelPromise = null;\n        this.updateScheduler = null;\n        this.cursorChangedScheduler = null;\n        this.mouseDownInfo = null;\n        this.foldingDecorationProvider = new FoldingDecorationProvider(editor);\n        this.foldingDecorationProvider.showFoldingControls = options.get(110 /* EditorOption.showFoldingControls */);\n        this.foldingDecorationProvider.showFoldingHighlights = options.get(45 /* EditorOption.foldingHighlight */);\n        this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);\n        this.foldingEnabled.set(this._isEnabled);\n        this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));\n        this._register(this.editor.onDidChangeConfiguration((e) => {\n            if (e.hasChanged(43 /* EditorOption.folding */)) {\n                this._isEnabled = this.editor.getOptions().get(43 /* EditorOption.folding */);\n                this.foldingEnabled.set(this._isEnabled);\n                this.onModelChanged();\n            }\n            if (e.hasChanged(47 /* EditorOption.foldingMaximumRegions */)) {\n                this.onModelChanged();\n            }\n            if (e.hasChanged(110 /* EditorOption.showFoldingControls */) || e.hasChanged(45 /* EditorOption.foldingHighlight */)) {\n                const options = this.editor.getOptions();\n                this.foldingDecorationProvider.showFoldingControls = options.get(110 /* EditorOption.showFoldingControls */);\n                this.foldingDecorationProvider.showFoldingHighlights = options.get(45 /* EditorOption.foldingHighlight */);\n                this.triggerFoldingModelChanged();\n            }\n            if (e.hasChanged(44 /* EditorOption.foldingStrategy */)) {\n                this._useFoldingProviders = this.editor.getOptions().get(44 /* EditorOption.foldingStrategy */) !== 'indentation';\n                this.onFoldingStrategyChanged();\n            }\n            if (e.hasChanged(48 /* EditorOption.unfoldOnClickAfterEndOfLine */)) {\n                this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(48 /* EditorOption.unfoldOnClickAfterEndOfLine */);\n            }\n            if (e.hasChanged(46 /* EditorOption.foldingImportsByDefault */)) {\n                this._foldingImportsByDefault = this.editor.getOptions().get(46 /* EditorOption.foldingImportsByDefault */);\n            }\n        }));\n        this.onModelChanged();\n    }\n    /**\n     * Store view state.\n     */\n    saveViewState() {\n        const model = this.editor.getModel();\n        if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {\n            return {};\n        }\n        if (this.foldingModel) { // disposed ?\n            const collapsedRegions = this.foldingModel.getMemento();\n            const provider = this.rangeProvider ? this.rangeProvider.id : undefined;\n            return { collapsedRegions, lineCount: model.getLineCount(), provider, foldedImports: this._currentModelHasFoldedImports };\n        }\n        return undefined;\n    }\n    /**\n     * Restore view state.\n     */\n    restoreViewState(state) {\n        const model = this.editor.getModel();\n        if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {\n            return;\n        }\n        if (!state) {\n            return;\n        }\n        this._currentModelHasFoldedImports = !!state.foldedImports;\n        if (state.collapsedRegions && state.collapsedRegions.length > 0 && this.foldingModel) {\n            this._restoringViewState = true;\n            try {\n                this.foldingModel.applyMemento(state.collapsedRegions);\n            }\n            finally {\n                this._restoringViewState = false;\n            }\n        }\n    }\n    onModelChanged() {\n        this.localToDispose.clear();\n        const model = this.editor.getModel();\n        if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {\n            // huge files get no view model, so they cannot support hidden areas\n            return;\n        }\n        this._currentModelHasFoldedImports = false;\n        this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);\n        this.localToDispose.add(this.foldingModel);\n        this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);\n        this.localToDispose.add(this.hiddenRangeModel);\n        this.localToDispose.add(this.hiddenRangeModel.onDidChange(hr => this.onHiddenRangesChanges(hr)));\n        this.updateScheduler = new Delayer(this.updateDebounceInfo.get(model));\n        this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);\n        this.localToDispose.add(this.cursorChangedScheduler);\n        this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged()));\n        this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged())); // covers model language changes as well\n        this.localToDispose.add(this.editor.onDidChangeModelContent(e => this.onDidChangeModelContent(e)));\n        this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));\n        this.localToDispose.add(this.editor.onMouseDown(e => this.onEditorMouseDown(e)));\n        this.localToDispose.add(this.editor.onMouseUp(e => this.onEditorMouseUp(e)));\n        this.localToDispose.add({\n            dispose: () => {\n                var _a, _b;\n                if (this.foldingRegionPromise) {\n                    this.foldingRegionPromise.cancel();\n                    this.foldingRegionPromise = null;\n                }\n                (_a = this.updateScheduler) === null || _a === void 0 ? void 0 : _a.cancel();\n                this.updateScheduler = null;\n                this.foldingModel = null;\n                this.foldingModelPromise = null;\n                this.hiddenRangeModel = null;\n                this.cursorChangedScheduler = null;\n                (_b = this.rangeProvider) === null || _b === void 0 ? void 0 : _b.dispose();\n                this.rangeProvider = null;\n            }\n        });\n        this.triggerFoldingModelChanged();\n    }\n    onFoldingStrategyChanged() {\n        var _a;\n        (_a = this.rangeProvider) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.rangeProvider = null;\n        this.triggerFoldingModelChanged();\n    }\n    getRangeProvider(editorModel) {\n        if (this.rangeProvider) {\n            return this.rangeProvider;\n        }\n        const indentRangeProvider = new IndentRangeProvider(editorModel, this.languageConfigurationService, this._foldingLimitReporter);\n        this.rangeProvider = indentRangeProvider; // fallback\n        if (this._useFoldingProviders && this.foldingModel) {\n            const selectedProviders = FoldingController_1.getFoldingRangeProviders(this.languageFeaturesService, editorModel);\n            if (selectedProviders.length > 0) {\n                this.rangeProvider = new SyntaxRangeProvider(editorModel, selectedProviders, () => this.triggerFoldingModelChanged(), this._foldingLimitReporter, indentRangeProvider);\n            }\n        }\n        return this.rangeProvider;\n    }\n    getFoldingModel() {\n        return this.foldingModelPromise;\n    }\n    onDidChangeModelContent(e) {\n        var _a;\n        (_a = this.hiddenRangeModel) === null || _a === void 0 ? void 0 : _a.notifyChangeModelContent(e);\n        this.triggerFoldingModelChanged();\n    }\n    triggerFoldingModelChanged() {\n        if (this.updateScheduler) {\n            if (this.foldingRegionPromise) {\n                this.foldingRegionPromise.cancel();\n                this.foldingRegionPromise = null;\n            }\n            this.foldingModelPromise = this.updateScheduler.trigger(() => {\n                const foldingModel = this.foldingModel;\n                if (!foldingModel) { // null if editor has been disposed, or folding turned off\n                    return null;\n                }\n                const sw = new StopWatch();\n                const provider = this.getRangeProvider(foldingModel.textModel);\n                const foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise(token => provider.compute(token));\n                return foldingRegionPromise.then(foldingRanges => {\n                    if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) { // new request or cancelled in the meantime?\n                        let scrollState;\n                        if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {\n                            const hasChanges = foldingRanges.setCollapsedAllOfType(FoldingRangeKind.Imports.value, true);\n                            if (hasChanges) {\n                                scrollState = StableEditorScrollState.capture(this.editor);\n                                this._currentModelHasFoldedImports = hasChanges;\n                            }\n                        }\n                        // some cursors might have moved into hidden regions, make sure they are in expanded regions\n                        const selections = this.editor.getSelections();\n                        const selectionLineNumbers = selections ? selections.map(s => s.startLineNumber) : [];\n                        foldingModel.update(foldingRanges, selectionLineNumbers);\n                        scrollState === null || scrollState === void 0 ? void 0 : scrollState.restore(this.editor);\n                        // update debounce info\n                        const newValue = this.updateDebounceInfo.update(foldingModel.textModel, sw.elapsed());\n                        if (this.updateScheduler) {\n                            this.updateScheduler.defaultDelay = newValue;\n                        }\n                    }\n                    return foldingModel;\n                });\n            }).then(undefined, (err) => {\n                onUnexpectedError(err);\n                return null;\n            });\n        }\n    }\n    onHiddenRangesChanges(hiddenRanges) {\n        if (this.hiddenRangeModel && hiddenRanges.length && !this._restoringViewState) {\n            const selections = this.editor.getSelections();\n            if (selections) {\n                if (this.hiddenRangeModel.adjustSelections(selections)) {\n                    this.editor.setSelections(selections);\n                }\n            }\n        }\n        this.editor.setHiddenAreas(hiddenRanges, this);\n    }\n    onCursorPositionChanged() {\n        if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {\n            this.cursorChangedScheduler.schedule();\n        }\n    }\n    revealCursor() {\n        const foldingModel = this.getFoldingModel();\n        if (!foldingModel) {\n            return;\n        }\n        foldingModel.then(foldingModel => {\n            if (foldingModel) {\n                const selections = this.editor.getSelections();\n                if (selections && selections.length > 0) {\n                    const toToggle = [];\n                    for (const selection of selections) {\n                        const lineNumber = selection.selectionStartLineNumber;\n                        if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {\n                            toToggle.push(...foldingModel.getAllRegionsAtLine(lineNumber, r => r.isCollapsed && lineNumber > r.startLineNumber));\n                        }\n                    }\n                    if (toToggle.length) {\n                        foldingModel.toggleCollapseState(toToggle);\n                        this.reveal(selections[0].getPosition());\n                    }\n                }\n            }\n        }).then(undefined, onUnexpectedError);\n    }\n    onEditorMouseDown(e) {\n        this.mouseDownInfo = null;\n        if (!this.hiddenRangeModel || !e.target || !e.target.range) {\n            return;\n        }\n        if (!e.event.leftButton && !e.event.middleButton) {\n            return;\n        }\n        const range = e.target.range;\n        let iconClicked = false;\n        switch (e.target.type) {\n            case 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */: {\n                const data = e.target.detail;\n                const offsetLeftInGutter = e.target.element.offsetLeft;\n                const gutterOffsetX = data.offsetX - offsetLeftInGutter;\n                // const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;\n                // TODO@joao TODO@alex TODO@martin this is such that we don't collide with dirty diff\n                if (gutterOffsetX < 4) { // the whitespace between the border and the real folding icon border is 4px\n                    return;\n                }\n                iconClicked = true;\n                break;\n            }\n            case 7 /* MouseTargetType.CONTENT_EMPTY */: {\n                if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {\n                    const data = e.target.detail;\n                    if (!data.isAfterLines) {\n                        break;\n                    }\n                }\n                return;\n            }\n            case 6 /* MouseTargetType.CONTENT_TEXT */: {\n                if (this.hiddenRangeModel.hasRanges()) {\n                    const model = this.editor.getModel();\n                    if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {\n                        break;\n                    }\n                }\n                return;\n            }\n            default:\n                return;\n        }\n        this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked };\n    }\n    onEditorMouseUp(e) {\n        const foldingModel = this.foldingModel;\n        if (!foldingModel || !this.mouseDownInfo || !e.target) {\n            return;\n        }\n        const lineNumber = this.mouseDownInfo.lineNumber;\n        const iconClicked = this.mouseDownInfo.iconClicked;\n        const range = e.target.range;\n        if (!range || range.startLineNumber !== lineNumber) {\n            return;\n        }\n        if (iconClicked) {\n            if (e.target.type !== 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */) {\n                return;\n            }\n        }\n        else {\n            const model = this.editor.getModel();\n            if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {\n                return;\n            }\n        }\n        const region = foldingModel.getRegionAtLine(lineNumber);\n        if (region && region.startLineNumber === lineNumber) {\n            const isCollapsed = region.isCollapsed;\n            if (iconClicked || isCollapsed) {\n                const surrounding = e.event.altKey;\n                let toToggle = [];\n                if (surrounding) {\n                    const filter = (otherRegion) => !otherRegion.containedBy(region) && !region.containedBy(otherRegion);\n                    const toMaybeToggle = foldingModel.getRegionsInside(null, filter);\n                    for (const r of toMaybeToggle) {\n                        if (r.isCollapsed) {\n                            toToggle.push(r);\n                        }\n                    }\n                    // if any surrounding regions are folded, unfold those. Otherwise, fold all surrounding\n                    if (toToggle.length === 0) {\n                        toToggle = toMaybeToggle;\n                    }\n                }\n                else {\n                    const recursive = e.event.middleButton || e.event.shiftKey;\n                    if (recursive) {\n                        for (const r of foldingModel.getRegionsInside(region)) {\n                            if (r.isCollapsed === isCollapsed) {\n                                toToggle.push(r);\n                            }\n                        }\n                    }\n                    // when recursive, first only collapse all children. If all are already folded or there are no children, also fold parent.\n                    if (isCollapsed || !recursive || toToggle.length === 0) {\n                        toToggle.push(region);\n                    }\n                }\n                foldingModel.toggleCollapseState(toToggle);\n                this.reveal({ lineNumber, column: 1 });\n            }\n        }\n    }\n    reveal(position) {\n        this.editor.revealPositionInCenterIfOutsideViewport(position, 0 /* ScrollType.Smooth */);\n    }\n};\nFoldingController.ID = 'editor.contrib.folding';\nFoldingController = FoldingController_1 = __decorate([\n    __param(1, IContextKeyService),\n    __param(2, ILanguageConfigurationService),\n    __param(3, INotificationService),\n    __param(4, ILanguageFeatureDebounceService),\n    __param(5, ILanguageFeaturesService)\n], FoldingController);\nexport { FoldingController };\nexport class RangesLimitReporter {\n    constructor(editor) {\n        this.editor = editor;\n        this._onDidChange = new Emitter();\n        this._computed = 0;\n        this._limited = false;\n    }\n    get limit() {\n        return this.editor.getOptions().get(47 /* EditorOption.foldingMaximumRegions */);\n    }\n    update(computed, limited) {\n        if (computed !== this._computed || limited !== this._limited) {\n            this._computed = computed;\n            this._limited = limited;\n            this._onDidChange.fire();\n        }\n    }\n}\nclass FoldingAction extends EditorAction {\n    runEditorCommand(accessor, editor, args) {\n        const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n        const foldingController = FoldingController.get(editor);\n        if (!foldingController) {\n            return;\n        }\n        const foldingModelPromise = foldingController.getFoldingModel();\n        if (foldingModelPromise) {\n            this.reportTelemetry(accessor, editor);\n            return foldingModelPromise.then(foldingModel => {\n                if (foldingModel) {\n                    this.invoke(foldingController, foldingModel, editor, args, languageConfigurationService);\n                    const selection = editor.getSelection();\n                    if (selection) {\n                        foldingController.reveal(selection.getStartPosition());\n                    }\n                }\n            });\n        }\n    }\n    getSelectedLines(editor) {\n        const selections = editor.getSelections();\n        return selections ? selections.map(s => s.startLineNumber) : [];\n    }\n    getLineNumbers(args, editor) {\n        if (args && args.selectionLines) {\n            return args.selectionLines.map(l => l + 1); // to 0-bases line numbers\n        }\n        return this.getSelectedLines(editor);\n    }\n    run(_accessor, _editor) {\n    }\n}\nfunction foldingArgumentsConstraint(args) {\n    if (!types.isUndefined(args)) {\n        if (!types.isObject(args)) {\n            return false;\n        }\n        const foldingArgs = args;\n        if (!types.isUndefined(foldingArgs.levels) && !types.isNumber(foldingArgs.levels)) {\n            return false;\n        }\n        if (!types.isUndefined(foldingArgs.direction) && !types.isString(foldingArgs.direction)) {\n            return false;\n        }\n        if (!types.isUndefined(foldingArgs.selectionLines) && (!Array.isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(types.isNumber))) {\n            return false;\n        }\n    }\n    return true;\n}\nclass UnfoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfold',\n            label: nls.localize('unfoldAction.label', \"Unfold\"),\n            alias: 'Unfold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 94 /* KeyCode.BracketRight */,\n                mac: {\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 94 /* KeyCode.BracketRight */\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            metadata: {\n                description: 'Unfold the content in the editor',\n                args: [\n                    {\n                        name: 'Unfold editor argument',\n                        description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t* 'levels': Number of levels to unfold. If not set, defaults to 1.\n\t\t\t\t\t\t* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.\n\t\t\t\t\t\t* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t`,\n                        constraint: foldingArgumentsConstraint,\n                        schema: {\n                            'type': 'object',\n                            'properties': {\n                                'levels': {\n                                    'type': 'number',\n                                    'default': 1\n                                },\n                                'direction': {\n                                    'type': 'string',\n                                    'enum': ['up', 'down'],\n                                    'default': 'down'\n                                },\n                                'selectionLines': {\n                                    'type': 'array',\n                                    'items': {\n                                        'type': 'number'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args) {\n        const levels = args && args.levels || 1;\n        const lineNumbers = this.getLineNumbers(args, editor);\n        if (args && args.direction === 'up') {\n            setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);\n        }\n        else {\n            setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);\n        }\n    }\n}\nclass UnFoldRecursivelyAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldRecursively',\n            label: nls.localize('unFoldRecursivelyAction.label', \"Unfold Recursively\"),\n            alias: 'Unfold Recursively',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 94 /* KeyCode.BracketRight */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, _args) {\n        setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor));\n    }\n}\nclass FoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.fold',\n            label: nls.localize('foldAction.label', \"Fold\"),\n            alias: 'Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* KeyMod.CtrlCmd */ | 1024 /* KeyMod.Shift */ | 92 /* KeyCode.BracketLeft */,\n                mac: {\n                    primary: 2048 /* KeyMod.CtrlCmd */ | 512 /* KeyMod.Alt */ | 92 /* KeyCode.BracketLeft */\n                },\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            },\n            metadata: {\n                description: 'Fold the content in the editor',\n                args: [\n                    {\n                        name: 'Fold editor argument',\n                        description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'levels': Number of levels to fold.\n\t\t\t\t\t\t\t* 'direction': If 'up', folds given number of levels up otherwise folds down.\n\t\t\t\t\t\t\t* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t\tIf no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.\n\t\t\t\t\t\t`,\n                        constraint: foldingArgumentsConstraint,\n                        schema: {\n                            'type': 'object',\n                            'properties': {\n                                'levels': {\n                                    'type': 'number',\n                                },\n                                'direction': {\n                                    'type': 'string',\n                                    'enum': ['up', 'down'],\n                                },\n                                'selectionLines': {\n                                    'type': 'array',\n                                    'items': {\n                                        'type': 'number'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args) {\n        const lineNumbers = this.getLineNumbers(args, editor);\n        const levels = args && args.levels;\n        const direction = args && args.direction;\n        if (typeof levels !== 'number' && typeof direction !== 'string') {\n            // fold the region at the location or if already collapsed, the first uncollapsed parent instead.\n            setCollapseStateUp(foldingModel, true, lineNumbers);\n        }\n        else {\n            if (direction === 'up') {\n                setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);\n            }\n            else {\n                setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);\n            }\n        }\n    }\n}\nclass ToggleFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.toggleFold',\n            label: nls.localize('toggleFoldAction.label', \"Toggle Fold\"),\n            alias: 'Toggle Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 42 /* KeyCode.KeyL */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        toggleCollapseState(foldingModel, 1, selectedLines);\n    }\n}\nclass FoldRecursivelyAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldRecursively',\n            label: nls.localize('foldRecursivelyAction.label', \"Fold Recursively\"),\n            alias: 'Fold Recursively',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 92 /* KeyCode.BracketLeft */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);\n    }\n}\nclass FoldAllBlockCommentsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllBlockComments',\n            label: nls.localize('foldAllBlockComments.label', \"Fold All Block Comments\"),\n            alias: 'Fold All Block Comments',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 90 /* KeyCode.Slash */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const comments = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).comments;\n            if (comments && comments.blockCommentStartToken) {\n                const regExp = new RegExp('^\\\\s*' + escapeRegExpCharacters(comments.blockCommentStartToken));\n                setCollapseStateForMatchingLines(foldingModel, regExp, true);\n            }\n        }\n    }\n}\nclass FoldAllRegionsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllMarkerRegions',\n            label: nls.localize('foldAllMarkerRegions.label', \"Fold All Regions\"),\n            alias: 'Fold All Regions',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 29 /* KeyCode.Digit8 */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;\n            if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n                const regExp = new RegExp(foldingRules.markers.start);\n                setCollapseStateForMatchingLines(foldingModel, regExp, true);\n            }\n        }\n    }\n}\nclass UnfoldAllRegionsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAllMarkerRegions',\n            label: nls.localize('unfoldAllMarkerRegions.label', \"Unfold All Regions\"),\n            alias: 'Unfold All Regions',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 30 /* KeyCode.Digit9 */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;\n            if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n                const regExp = new RegExp(foldingRules.markers.start);\n                setCollapseStateForMatchingLines(foldingModel, regExp, false);\n            }\n        }\n    }\n}\nclass FoldAllExceptAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllExcept',\n            label: nls.localize('foldAllExcept.label', \"Fold All Except Selected\"),\n            alias: 'Fold All Except Selected',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 88 /* KeyCode.Minus */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        setCollapseStateForRest(foldingModel, true, selectedLines);\n    }\n}\nclass UnfoldAllExceptAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAllExcept',\n            label: nls.localize('unfoldAllExcept.label', \"Unfold All Except Selected\"),\n            alias: 'Unfold All Except Selected',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 86 /* KeyCode.Equal */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        setCollapseStateForRest(foldingModel, false, selectedLines);\n    }\n}\nclass FoldAllAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAll',\n            label: nls.localize('foldAllAction.label', \"Fold All\"),\n            alias: 'Fold All',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 21 /* KeyCode.Digit0 */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, _editor) {\n        setCollapseStateLevelsDown(foldingModel, true);\n    }\n}\nclass UnfoldAllAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAll',\n            label: nls.localize('unfoldAllAction.label', \"Unfold All\"),\n            alias: 'Unfold All',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 40 /* KeyCode.KeyJ */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, _editor) {\n        setCollapseStateLevelsDown(foldingModel, false);\n    }\n}\nclass FoldLevelAction extends FoldingAction {\n    getFoldingLevel() {\n        return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor));\n    }\n}\nFoldLevelAction.ID_PREFIX = 'editor.foldLevel';\nFoldLevelAction.ID = (level) => FoldLevelAction.ID_PREFIX + level;\n/** Action to go to the parent fold of current line */\nclass GotoParentFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoParentFold',\n            label: nls.localize('gotoParentFold.label', \"Go to Parent Fold\"),\n            alias: 'Go to Parent Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            const startLineNumber = getParentFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\n/** Action to go to the previous fold of current line */\nclass GotoPreviousFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoPreviousFold',\n            label: nls.localize('gotoPreviousFold.label', \"Go to Previous Folding Range\"),\n            alias: 'Go to Previous Folding Range',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            const startLineNumber = getPreviousFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\n/** Action to go to the next fold of current line */\nclass GotoNextFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoNextFold',\n            label: nls.localize('gotoNextFold.label', \"Go to Next Folding Range\"),\n            alias: 'Go to Next Folding Range',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        const selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            const startLineNumber = getNextFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\nclass FoldRangeFromSelectionAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.createFoldingRangeFromSelection',\n            label: nls.localize('createManualFoldRange.label', \"Create Folding Range from Selection\"),\n            alias: 'Create Folding Range from Selection',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 87 /* KeyCode.Comma */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        var _a;\n        const collapseRanges = [];\n        const selections = editor.getSelections();\n        if (selections) {\n            for (const selection of selections) {\n                let endLineNumber = selection.endLineNumber;\n                if (selection.endColumn === 1) {\n                    --endLineNumber;\n                }\n                if (endLineNumber > selection.startLineNumber) {\n                    collapseRanges.push({\n                        startLineNumber: selection.startLineNumber,\n                        endLineNumber: endLineNumber,\n                        type: undefined,\n                        isCollapsed: true,\n                        source: 1 /* FoldSource.userDefined */\n                    });\n                    editor.setSelection({\n                        startLineNumber: selection.startLineNumber,\n                        startColumn: 1,\n                        endLineNumber: selection.startLineNumber,\n                        endColumn: 1\n                    });\n                }\n            }\n            if (collapseRanges.length > 0) {\n                collapseRanges.sort((a, b) => {\n                    return a.startLineNumber - b.startLineNumber;\n                });\n                const newRanges = FoldingRegions.sanitizeAndMerge(foldingModel.regions, collapseRanges, (_a = editor.getModel()) === null || _a === void 0 ? void 0 : _a.getLineCount());\n                foldingModel.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n            }\n        }\n    }\n}\nclass RemoveFoldRangeFromSelectionAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.removeManualFoldingRanges',\n            label: nls.localize('removeManualFoldingRanges.label', \"Remove Manual Folding Ranges\"),\n            alias: 'Remove Manual Folding Ranges',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | 89 /* KeyCode.Period */),\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    invoke(foldingController, foldingModel, editor) {\n        const selections = editor.getSelections();\n        if (selections) {\n            const ranges = [];\n            for (const selection of selections) {\n                const { startLineNumber, endLineNumber } = selection;\n                ranges.push(endLineNumber >= startLineNumber ? { startLineNumber, endLineNumber } : { endLineNumber, startLineNumber });\n            }\n            foldingModel.removeManualRanges(ranges);\n            foldingController.triggerFoldingModelChanged();\n        }\n    }\n}\nregisterEditorContribution(FoldingController.ID, FoldingController, 0 /* EditorContributionInstantiation.Eager */); // eager because it uses `saveViewState`/`restoreViewState`\nregisterEditorAction(UnfoldAction);\nregisterEditorAction(UnFoldRecursivelyAction);\nregisterEditorAction(FoldAction);\nregisterEditorAction(FoldRecursivelyAction);\nregisterEditorAction(FoldAllAction);\nregisterEditorAction(UnfoldAllAction);\nregisterEditorAction(FoldAllBlockCommentsAction);\nregisterEditorAction(FoldAllRegionsAction);\nregisterEditorAction(UnfoldAllRegionsAction);\nregisterEditorAction(FoldAllExceptAction);\nregisterEditorAction(UnfoldAllExceptAction);\nregisterEditorAction(ToggleFoldAction);\nregisterEditorAction(GotoParentFoldAction);\nregisterEditorAction(GotoPreviousFoldAction);\nregisterEditorAction(GotoNextFoldAction);\nregisterEditorAction(FoldRangeFromSelectionAction);\nregisterEditorAction(RemoveFoldRangeFromSelectionAction);\nfor (let i = 1; i <= 7; i++) {\n    registerInstantiatedEditorAction(new FoldLevelAction({\n        id: FoldLevelAction.ID(i),\n        label: nls.localize('foldLevelAction.label', \"Fold Level {0}\", i),\n        alias: `Fold Level ${i}`,\n        precondition: CONTEXT_FOLDING_ENABLED,\n        kbOpts: {\n            kbExpr: EditorContextKeys.editorTextFocus,\n            primary: KeyChord(2048 /* KeyMod.CtrlCmd */ | 41 /* KeyCode.KeyK */, 2048 /* KeyMod.CtrlCmd */ | (21 /* KeyCode.Digit0 */ + i)),\n            weight: 100 /* KeybindingWeight.EditorContrib */\n        }\n    }));\n}\nCommandsRegistry.registerCommand('_executeFoldingRangeProvider', async function (accessor, ...args) {\n    const [resource] = args;\n    if (!(resource instanceof URI)) {\n        throw illegalArgument();\n    }\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const model = accessor.get(IModelService).getModel(resource);\n    if (!model) {\n        throw illegalArgument();\n    }\n    const configurationService = accessor.get(IConfigurationService);\n    if (!configurationService.getValue('editor.folding', { resource })) {\n        return [];\n    }\n    const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n    const strategy = configurationService.getValue('editor.foldingStrategy', { resource });\n    const foldingLimitReporter = {\n        get limit() {\n            return configurationService.getValue('editor.foldingMaximumRegions', { resource });\n        },\n        update: (computed, limited) => { }\n    };\n    const indentRangeProvider = new IndentRangeProvider(model, languageConfigurationService, foldingLimitReporter);\n    let rangeProvider = indentRangeProvider;\n    if (strategy !== 'indentation') {\n        const providers = FoldingController.getFoldingRangeProviders(languageFeaturesService, model);\n        if (providers.length) {\n            rangeProvider = new SyntaxRangeProvider(model, providers, () => { }, foldingLimitReporter, indentRangeProvider);\n        }\n    }\n    const ranges = await rangeProvider.compute(CancellationToken.None);\n    const result = [];\n    try {\n        if (ranges) {\n            for (let i = 0; i < ranges.length; i++) {\n                const type = ranges.getType(i);\n                result.push({ start: ranges.getStartLineNumber(i), end: ranges.getEndLineNumber(i), kind: type ? FoldingRangeKind.fromValue(type) : undefined });\n            }\n        }\n        return result;\n    }\n    finally {\n        rangeProvider.dispose();\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { localize } from '../../../../nls.js';\nimport { editorSelectionBackground, iconForeground, registerColor, transparent } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerIcon } from '../../../../platform/theme/common/iconRegistry.js';\nimport { themeColorFromId } from '../../../../platform/theme/common/themeService.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nconst foldBackground = registerColor('editor.foldBackground', { light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hcDark: null, hcLight: null }, localize('foldBackgroundBackground', \"Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations.\"), true);\nregisterColor('editorGutter.foldingControlForeground', { dark: iconForeground, light: iconForeground, hcDark: iconForeground, hcLight: iconForeground }, localize('editorGutter.foldingControlForeground', 'Color of the folding control in the editor gutter.'));\nexport const foldingExpandedIcon = registerIcon('folding-expanded', Codicon.chevronDown, localize('foldingExpandedIcon', 'Icon for expanded ranges in the editor glyph margin.'));\nexport const foldingCollapsedIcon = registerIcon('folding-collapsed', Codicon.chevronRight, localize('foldingCollapsedIcon', 'Icon for collapsed ranges in the editor glyph margin.'));\nexport const foldingManualCollapsedIcon = registerIcon('folding-manual-collapsed', foldingCollapsedIcon, localize('foldingManualCollapedIcon', 'Icon for manually collapsed ranges in the editor glyph margin.'));\nexport const foldingManualExpandedIcon = registerIcon('folding-manual-expanded', foldingExpandedIcon, localize('foldingManualExpandedIcon', 'Icon for manually expanded ranges in the editor glyph margin.'));\nconst foldedBackgroundMinimap = { color: themeColorFromId(foldBackground), position: 1 /* MinimapPosition.Inline */ };\nconst collapsed = localize('linesCollapsed', \"Click to expand the range.\");\nconst expanded = localize('linesExpanded', \"Click to collapse the range.\");\nexport class FoldingDecorationProvider {\n    constructor(editor) {\n        this.editor = editor;\n        this.showFoldingControls = 'mouseover';\n        this.showFoldingHighlights = true;\n    }\n    getDecorationOption(isCollapsed, isHidden, isManual) {\n        if (isHidden) { // is inside another collapsed region\n            return FoldingDecorationProvider.HIDDEN_RANGE_DECORATION;\n        }\n        if (this.showFoldingControls === 'never') {\n            if (isCollapsed) {\n                return this.showFoldingHighlights ? FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION : FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_RANGE_DECORATION;\n            }\n            return FoldingDecorationProvider.NO_CONTROLS_EXPANDED_RANGE_DECORATION;\n        }\n        if (isCollapsed) {\n            return isManual ?\n                (this.showFoldingHighlights ? FoldingDecorationProvider.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.MANUALLY_COLLAPSED_VISUAL_DECORATION)\n                : (this.showFoldingHighlights ? FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION);\n        }\n        else if (this.showFoldingControls === 'mouseover') {\n            return isManual ? FoldingDecorationProvider.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION : FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION;\n        }\n        else {\n            return isManual ? FoldingDecorationProvider.MANUALLY_EXPANDED_VISUAL_DECORATION : FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION;\n        }\n    }\n    changeDecorations(callback) {\n        return this.editor.changeDecorations(callback);\n    }\n    removeDecorations(decorationIds) {\n        this.editor.removeDecorations(decorationIds);\n    }\n}\nFoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-collapsed-visual-decoration',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    afterContentClassName: 'inline-folded',\n    isWholeLine: true,\n    linesDecorationsTooltip: collapsed,\n    firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon),\n});\nFoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-collapsed-highlighted-visual-decoration',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    afterContentClassName: 'inline-folded',\n    className: 'folded-background',\n    minimap: foldedBackgroundMinimap,\n    isWholeLine: true,\n    linesDecorationsTooltip: collapsed,\n    firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)\n});\nFoldingDecorationProvider.MANUALLY_COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-manually-collapsed-visual-decoration',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    afterContentClassName: 'inline-folded',\n    isWholeLine: true,\n    linesDecorationsTooltip: collapsed,\n    firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualCollapsedIcon)\n});\nFoldingDecorationProvider.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-manually-collapsed-highlighted-visual-decoration',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    afterContentClassName: 'inline-folded',\n    className: 'folded-background',\n    minimap: foldedBackgroundMinimap,\n    isWholeLine: true,\n    linesDecorationsTooltip: collapsed,\n    firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualCollapsedIcon)\n});\nFoldingDecorationProvider.NO_CONTROLS_COLLAPSED_RANGE_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-no-controls-range-decoration',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    afterContentClassName: 'inline-folded',\n    isWholeLine: true,\n    linesDecorationsTooltip: collapsed,\n});\nFoldingDecorationProvider.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-no-controls-range-decoration',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    afterContentClassName: 'inline-folded',\n    className: 'folded-background',\n    minimap: foldedBackgroundMinimap,\n    isWholeLine: true,\n    linesDecorationsTooltip: collapsed,\n});\nFoldingDecorationProvider.EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-expanded-visual-decoration',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n    isWholeLine: true,\n    firstLineDecorationClassName: 'alwaysShowFoldIcons ' + ThemeIcon.asClassName(foldingExpandedIcon),\n    linesDecorationsTooltip: expanded,\n});\nFoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-expanded-auto-hide-visual-decoration',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n    isWholeLine: true,\n    firstLineDecorationClassName: ThemeIcon.asClassName(foldingExpandedIcon),\n    linesDecorationsTooltip: expanded,\n});\nFoldingDecorationProvider.MANUALLY_EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-manually-expanded-visual-decoration',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    isWholeLine: true,\n    firstLineDecorationClassName: 'alwaysShowFoldIcons ' + ThemeIcon.asClassName(foldingManualExpandedIcon),\n    linesDecorationsTooltip: expanded,\n});\nFoldingDecorationProvider.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-manually-expanded-auto-hide-visual-decoration',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    isWholeLine: true,\n    firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualExpandedIcon),\n    linesDecorationsTooltip: expanded,\n});\nFoldingDecorationProvider.NO_CONTROLS_EXPANDED_RANGE_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-no-controls-range-decoration',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    isWholeLine: true\n});\nFoldingDecorationProvider.HIDDEN_RANGE_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-hidden-range-decoration',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\nimport { hash } from '../../../../base/common/hash.js';\nexport class FoldingModel {\n    get regions() { return this._regions; }\n    get textModel() { return this._textModel; }\n    constructor(textModel, decorationProvider) {\n        this._updateEventEmitter = new Emitter();\n        this.onDidChange = this._updateEventEmitter.event;\n        this._textModel = textModel;\n        this._decorationProvider = decorationProvider;\n        this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n        this._editorDecorationIds = [];\n    }\n    toggleCollapseState(toggledRegions) {\n        if (!toggledRegions.length) {\n            return;\n        }\n        toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\n        const processed = {};\n        this._decorationProvider.changeDecorations(accessor => {\n            let k = 0; // index from [0 ... this.regions.length]\n            let dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n            let lastHiddenLine = -1; // the end of the last hidden lines\n            const updateDecorationsUntil = (index) => {\n                while (k < index) {\n                    const endLineNumber = this._regions.getEndLineNumber(k);\n                    const isCollapsed = this._regions.isCollapsed(k);\n                    if (endLineNumber <= dirtyRegionEndLine) {\n                        const isManual = this.regions.getSource(k) !== 0 /* FoldSource.provider */;\n                        accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));\n                    }\n                    if (isCollapsed && endLineNumber > lastHiddenLine) {\n                        lastHiddenLine = endLineNumber;\n                    }\n                    k++;\n                }\n            };\n            for (const region of toggledRegions) {\n                const index = region.regionIndex;\n                const editorDecorationId = this._editorDecorationIds[index];\n                if (editorDecorationId && !processed[editorDecorationId]) {\n                    processed[editorDecorationId] = true;\n                    updateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n                    const newCollapseState = !this._regions.isCollapsed(index);\n                    this._regions.setCollapsed(index, newCollapseState);\n                    dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\n                }\n            }\n            updateDecorationsUntil(this._regions.length);\n        });\n        this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });\n    }\n    removeManualRanges(ranges) {\n        const newFoldingRanges = new Array();\n        const intersects = (foldRange) => {\n            for (const range of ranges) {\n                if (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        for (let i = 0; i < this._regions.length; i++) {\n            const foldRange = this._regions.toFoldRange(i);\n            if (foldRange.source === 0 /* FoldSource.provider */ || !intersects(foldRange)) {\n                newFoldingRanges.push(foldRange);\n            }\n        }\n        this.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));\n    }\n    update(newRegions, blockedLineNumers = []) {\n        const foldedOrManualRanges = this._currentFoldedOrManualRanges(blockedLineNumers);\n        const newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount());\n        this.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n    }\n    updatePost(newRegions) {\n        const newEditorDecorations = [];\n        let lastHiddenLine = -1;\n        for (let index = 0, limit = newRegions.length; index < limit; index++) {\n            const startLineNumber = newRegions.getStartLineNumber(index);\n            const endLineNumber = newRegions.getEndLineNumber(index);\n            const isCollapsed = newRegions.isCollapsed(index);\n            const isManual = newRegions.getSource(index) !== 0 /* FoldSource.provider */;\n            const decorationRange = {\n                startLineNumber: startLineNumber,\n                startColumn: this._textModel.getLineMaxColumn(startLineNumber),\n                endLineNumber: endLineNumber,\n                endColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1\n            };\n            newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual) });\n            if (isCollapsed && endLineNumber > lastHiddenLine) {\n                lastHiddenLine = endLineNumber;\n            }\n        }\n        this._decorationProvider.changeDecorations(accessor => this._editorDecorationIds = accessor.deltaDecorations(this._editorDecorationIds, newEditorDecorations));\n        this._regions = newRegions;\n        this._updateEventEmitter.fire({ model: this });\n    }\n    _currentFoldedOrManualRanges(blockedLineNumers = []) {\n        const isBlocked = (startLineNumber, endLineNumber) => {\n            for (const blockedLineNumber of blockedLineNumers) {\n                if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\n                    return true;\n                }\n            }\n            return false;\n        };\n        const foldedRanges = [];\n        for (let i = 0, limit = this._regions.length; i < limit; i++) {\n            let isCollapsed = this.regions.isCollapsed(i);\n            const source = this.regions.getSource(i);\n            if (isCollapsed || source !== 0 /* FoldSource.provider */) {\n                const foldRange = this._regions.toFoldRange(i);\n                const decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n                if (decRange) {\n                    if (isCollapsed && isBlocked(decRange.startLineNumber, decRange.endLineNumber)) {\n                        isCollapsed = false; // uncollapse is the range is blocked\n                    }\n                    foldedRanges.push({\n                        startLineNumber: decRange.startLineNumber,\n                        endLineNumber: decRange.endLineNumber,\n                        type: foldRange.type,\n                        isCollapsed,\n                        source\n                    });\n                }\n            }\n        }\n        return foldedRanges;\n    }\n    /**\n     * Collapse state memento, for persistence only\n     */\n    getMemento() {\n        const foldedOrManualRanges = this._currentFoldedOrManualRanges();\n        const result = [];\n        const maxLineNumber = this._textModel.getLineCount();\n        for (let i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {\n            const range = foldedOrManualRanges[i];\n            if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n                continue;\n            }\n            const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n            result.push({\n                startLineNumber: range.startLineNumber,\n                endLineNumber: range.endLineNumber,\n                isCollapsed: range.isCollapsed,\n                source: range.source,\n                checksum: checksum\n            });\n        }\n        return (result.length > 0) ? result : undefined;\n    }\n    /**\n     * Apply persisted state, for persistence only\n     */\n    applyMemento(state) {\n        var _a, _b;\n        if (!Array.isArray(state)) {\n            return;\n        }\n        const rangesToRestore = [];\n        const maxLineNumber = this._textModel.getLineCount();\n        for (const range of state) {\n            if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n                continue;\n            }\n            const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n            if (!range.checksum || checksum === range.checksum) {\n                rangesToRestore.push({\n                    startLineNumber: range.startLineNumber,\n                    endLineNumber: range.endLineNumber,\n                    type: undefined,\n                    isCollapsed: (_a = range.isCollapsed) !== null && _a !== void 0 ? _a : true,\n                    source: (_b = range.source) !== null && _b !== void 0 ? _b : 0 /* FoldSource.provider */\n                });\n            }\n        }\n        const newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);\n        this.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n    }\n    _getLinesChecksum(lineNumber1, lineNumber2) {\n        const h = hash(this._textModel.getLineContent(lineNumber1)\n            + this._textModel.getLineContent(lineNumber2));\n        return h % 1000000; // 6 digits is plenty\n    }\n    dispose() {\n        this._decorationProvider.removeDecorations(this._editorDecorationIds);\n    }\n    getAllRegionsAtLine(lineNumber, filter) {\n        const result = [];\n        if (this._regions) {\n            let index = this._regions.findRange(lineNumber);\n            let level = 1;\n            while (index >= 0) {\n                const current = this._regions.toRegion(index);\n                if (!filter || filter(current, level)) {\n                    result.push(current);\n                }\n                level++;\n                index = current.parentIndex;\n            }\n        }\n        return result;\n    }\n    getRegionAtLine(lineNumber) {\n        if (this._regions) {\n            const index = this._regions.findRange(lineNumber);\n            if (index >= 0) {\n                return this._regions.toRegion(index);\n            }\n        }\n        return null;\n    }\n    getRegionsInside(region, filter) {\n        const result = [];\n        const index = region ? region.regionIndex + 1 : 0;\n        const endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n        if (filter && filter.length === 2) {\n            const levelStack = [];\n            for (let i = index, len = this._regions.length; i < len; i++) {\n                const current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n                        levelStack.pop();\n                    }\n                    levelStack.push(current);\n                    if (filter(current, levelStack.length)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            for (let i = index, len = this._regions.length; i < len; i++) {\n                const current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    if (!filter || filter(current)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n    const toToggle = [];\n    for (const lineNumber of lineNumbers) {\n        const region = foldingModel.getRegionAtLine(lineNumber);\n        if (region) {\n            const doCollapse = !region.isCollapsed;\n            toToggle.push(region);\n            if (levels > 1) {\n                const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                toToggle.push(...regionsInside);\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {\n    const toToggle = [];\n    if (lineNumbers && lineNumbers.length > 0) {\n        for (const lineNumber of lineNumbers) {\n            const region = foldingModel.getRegionAtLine(lineNumber);\n            if (region) {\n                if (region.isCollapsed !== doCollapse) {\n                    toToggle.push(region);\n                }\n                if (levels > 1) {\n                    const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                    toToggle.push(...regionsInside);\n                }\n            }\n        }\n    }\n    else {\n        const regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n        toToggle.push(...regionsInside);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n    const toToggle = [];\n    for (const lineNumber of lineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n        toToggle.push(...regions);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n    const toToggle = [];\n    for (const lineNumber of lineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);\n        if (regions.length > 0) {\n            toToggle.push(regions[0]);\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n*/\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n    const filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n    const toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\nexport function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {\n    const filteredRegions = [];\n    for (const lineNumber of blockedLineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n        if (regions.length > 0) {\n            filteredRegions.push(regions[0]);\n        }\n    }\n    const filter = (region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;\n    const toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n    const editorModel = foldingModel.textModel;\n    const regions = foldingModel.regions;\n    const toToggle = [];\n    for (let i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i)) {\n            const startLineNumber = regions.getStartLineNumber(i);\n            if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n                toToggle.push(regions.toRegion(i));\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n    const regions = foldingModel.regions;\n    const toToggle = [];\n    for (let i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n            toToggle.push(regions.toRegion(i));\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\nexport function getParentFoldLine(lineNumber, foldingModel) {\n    let startLineNumber = null;\n    const foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    if (foldingRegion !== null) {\n        startLineNumber = foldingRegion.startLineNumber;\n        // If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n        if (lineNumber === startLineNumber) {\n            const parentFoldingIdx = foldingRegion.parentIndex;\n            if (parentFoldingIdx !== -1) {\n                startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);\n            }\n            else {\n                startLineNumber = null;\n            }\n        }\n    }\n    return startLineNumber;\n}\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\nexport function getPreviousFoldLine(lineNumber, foldingModel) {\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    // If on the folding range start line, go to previous sibling.\n    if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n        // If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n        if (lineNumber !== foldingRegion.startLineNumber) {\n            return foldingRegion.startLineNumber;\n        }\n        else {\n            // Find min line number to stay within parent.\n            const expectedParentIndex = foldingRegion.parentIndex;\n            let minLineNumber = 0;\n            if (expectedParentIndex !== -1) {\n                minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);\n            }\n            // Find fold at same level.\n            while (foldingRegion !== null) {\n                if (foldingRegion.regionIndex > 0) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n                    // Keep at same level.\n                    if (foldingRegion.startLineNumber <= minLineNumber) {\n                        return null;\n                    }\n                    else if (foldingRegion.parentIndex === expectedParentIndex) {\n                        return foldingRegion.startLineNumber;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    }\n    else {\n        // Go to last fold that's before the current line.\n        if (foldingModel.regions.length > 0) {\n            foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);\n            while (foldingRegion !== null) {\n                // Found fold before current line.\n                if (foldingRegion.startLineNumber < lineNumber) {\n                    return foldingRegion.startLineNumber;\n                }\n                if (foldingRegion.regionIndex > 0) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n                }\n                else {\n                    foldingRegion = null;\n                }\n            }\n        }\n    }\n    return null;\n}\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\nexport function getNextFoldLine(lineNumber, foldingModel) {\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    // If on the folding range start line, go to next sibling.\n    if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n        // Find max line number to stay within parent.\n        const expectedParentIndex = foldingRegion.parentIndex;\n        let maxLineNumber = 0;\n        if (expectedParentIndex !== -1) {\n            maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);\n        }\n        else if (foldingModel.regions.length === 0) {\n            return null;\n        }\n        else {\n            maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);\n        }\n        // Find fold at same level.\n        while (foldingRegion !== null) {\n            if (foldingRegion.regionIndex < foldingModel.regions.length) {\n                foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n                // Keep at same level.\n                if (foldingRegion.startLineNumber >= maxLineNumber) {\n                    return null;\n                }\n                else if (foldingRegion.parentIndex === expectedParentIndex) {\n                    return foldingRegion.startLineNumber;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    else {\n        // Go to first fold that's after the current line.\n        if (foldingModel.regions.length > 0) {\n            foldingRegion = foldingModel.regions.toRegion(0);\n            while (foldingRegion !== null) {\n                // Found fold after current line.\n                if (foldingRegion.startLineNumber > lineNumber) {\n                    return foldingRegion.startLineNumber;\n                }\n                if (foldingRegion.regionIndex < foldingModel.regions.length) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n                }\n                else {\n                    foldingRegion = null;\n                }\n            }\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const foldSourceAbbr = {\n    [0 /* FoldSource.provider */]: ' ',\n    [1 /* FoldSource.userDefined */]: 'u',\n    [2 /* FoldSource.recovered */]: 'r',\n};\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\nconst MASK_INDENT = 0xFF000000;\nclass BitField {\n    constructor(size) {\n        const numWords = Math.ceil(size / 32);\n        this._states = new Uint32Array(numWords);\n    }\n    get(index) {\n        const arrayIndex = (index / 32) | 0;\n        const bit = index % 32;\n        return (this._states[arrayIndex] & (1 << bit)) !== 0;\n    }\n    set(index, newState) {\n        const arrayIndex = (index / 32) | 0;\n        const bit = index % 32;\n        const value = this._states[arrayIndex];\n        if (newState) {\n            this._states[arrayIndex] = value | (1 << bit);\n        }\n        else {\n            this._states[arrayIndex] = value & ~(1 << bit);\n        }\n    }\n}\nexport class FoldingRegions {\n    constructor(startIndexes, endIndexes, types) {\n        if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n            throw new Error('invalid startIndexes or endIndexes size');\n        }\n        this._startIndexes = startIndexes;\n        this._endIndexes = endIndexes;\n        this._collapseStates = new BitField(startIndexes.length);\n        this._userDefinedStates = new BitField(startIndexes.length);\n        this._recoveredStates = new BitField(startIndexes.length);\n        this._types = types;\n        this._parentsComputed = false;\n    }\n    ensureParentIndices() {\n        if (!this._parentsComputed) {\n            this._parentsComputed = true;\n            const parentIndexes = [];\n            const isInsideLast = (startLineNumber, endLineNumber) => {\n                const index = parentIndexes[parentIndexes.length - 1];\n                return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n            };\n            for (let i = 0, len = this._startIndexes.length; i < len; i++) {\n                const startLineNumber = this._startIndexes[i];\n                const endLineNumber = this._endIndexes[i];\n                if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n                    throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n                }\n                while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n                    parentIndexes.pop();\n                }\n                const parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n                parentIndexes.push(i);\n                this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n                this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n            }\n        }\n    }\n    get length() {\n        return this._startIndexes.length;\n    }\n    getStartLineNumber(index) {\n        return this._startIndexes[index] & MAX_LINE_NUMBER;\n    }\n    getEndLineNumber(index) {\n        return this._endIndexes[index] & MAX_LINE_NUMBER;\n    }\n    getType(index) {\n        return this._types ? this._types[index] : undefined;\n    }\n    hasTypes() {\n        return !!this._types;\n    }\n    isCollapsed(index) {\n        return this._collapseStates.get(index);\n    }\n    setCollapsed(index, newState) {\n        this._collapseStates.set(index, newState);\n    }\n    isUserDefined(index) {\n        return this._userDefinedStates.get(index);\n    }\n    setUserDefined(index, newState) {\n        return this._userDefinedStates.set(index, newState);\n    }\n    isRecovered(index) {\n        return this._recoveredStates.get(index);\n    }\n    setRecovered(index, newState) {\n        return this._recoveredStates.set(index, newState);\n    }\n    getSource(index) {\n        if (this.isUserDefined(index)) {\n            return 1 /* FoldSource.userDefined */;\n        }\n        else if (this.isRecovered(index)) {\n            return 2 /* FoldSource.recovered */;\n        }\n        return 0 /* FoldSource.provider */;\n    }\n    setSource(index, source) {\n        if (source === 1 /* FoldSource.userDefined */) {\n            this.setUserDefined(index, true);\n            this.setRecovered(index, false);\n        }\n        else if (source === 2 /* FoldSource.recovered */) {\n            this.setUserDefined(index, false);\n            this.setRecovered(index, true);\n        }\n        else {\n            this.setUserDefined(index, false);\n            this.setRecovered(index, false);\n        }\n    }\n    setCollapsedAllOfType(type, newState) {\n        let hasChanged = false;\n        if (this._types) {\n            for (let i = 0; i < this._types.length; i++) {\n                if (this._types[i] === type) {\n                    this.setCollapsed(i, newState);\n                    hasChanged = true;\n                }\n            }\n        }\n        return hasChanged;\n    }\n    toRegion(index) {\n        return new FoldingRegion(this, index);\n    }\n    getParentIndex(index) {\n        this.ensureParentIndices();\n        const parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n        if (parent === MAX_FOLDING_REGIONS) {\n            return -1;\n        }\n        return parent;\n    }\n    contains(index, line) {\n        return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n    }\n    findIndex(line) {\n        let low = 0, high = this._startIndexes.length;\n        if (high === 0) {\n            return -1; // no children\n        }\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (line < this.getStartLineNumber(mid)) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low - 1;\n    }\n    findRange(line) {\n        let index = this.findIndex(line);\n        if (index >= 0) {\n            const endLineNumber = this.getEndLineNumber(index);\n            if (endLineNumber >= line) {\n                return index;\n            }\n            index = this.getParentIndex(index);\n            while (index !== -1) {\n                if (this.contains(index, line)) {\n                    return index;\n                }\n                index = this.getParentIndex(index);\n            }\n        }\n        return -1;\n    }\n    toString() {\n        const res = [];\n        for (let i = 0; i < this.length; i++) {\n            res[i] = `[${foldSourceAbbr[this.getSource(i)]}${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n        }\n        return res.join(', ');\n    }\n    toFoldRange(index) {\n        return {\n            startLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,\n            endLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,\n            type: this._types ? this._types[index] : undefined,\n            isCollapsed: this.isCollapsed(index),\n            source: this.getSource(index)\n        };\n    }\n    static fromFoldRanges(ranges) {\n        const rangesLength = ranges.length;\n        const startIndexes = new Uint32Array(rangesLength);\n        const endIndexes = new Uint32Array(rangesLength);\n        let types = [];\n        let gotTypes = false;\n        for (let i = 0; i < rangesLength; i++) {\n            const range = ranges[i];\n            startIndexes[i] = range.startLineNumber;\n            endIndexes[i] = range.endLineNumber;\n            types.push(range.type);\n            if (range.type) {\n                gotTypes = true;\n            }\n        }\n        if (!gotTypes) {\n            types = undefined;\n        }\n        const regions = new FoldingRegions(startIndexes, endIndexes, types);\n        for (let i = 0; i < rangesLength; i++) {\n            if (ranges[i].isCollapsed) {\n                regions.setCollapsed(i, true);\n            }\n            regions.setSource(i, ranges[i].source);\n        }\n        return regions;\n    }\n    /**\n     * Two inputs, each a FoldingRegions or a FoldRange[], are merged.\n     * Each input must be pre-sorted on startLineNumber.\n     * The first list is assumed to always include all regions currently defined by range providers.\n     * The second list only contains the previously collapsed and all manual ranges.\n     * If the line position matches, the range of the new range is taken, and the range is no longer manual\n     * When an entry in one list overlaps an entry in the other, the second list's entry \"wins\" and\n     * overlapping entries in the first list are discarded.\n     * Invalid entries are discarded. An entry is invalid if:\n     * \t\tthe start and end line numbers aren't a valid range of line numbers,\n     * \t\tit is out of sequence or has the same start line as a preceding entry,\n     * \t\tit overlaps a preceding entry and is not fully contained by that entry.\n     */\n    static sanitizeAndMerge(rangesA, rangesB, maxLineNumber) {\n        maxLineNumber = maxLineNumber !== null && maxLineNumber !== void 0 ? maxLineNumber : Number.MAX_VALUE;\n        const getIndexedFunction = (r, limit) => {\n            return Array.isArray(r)\n                ? ((i) => { return (i < limit) ? r[i] : undefined; })\n                : ((i) => { return (i < limit) ? r.toFoldRange(i) : undefined; });\n        };\n        const getA = getIndexedFunction(rangesA, rangesA.length);\n        const getB = getIndexedFunction(rangesB, rangesB.length);\n        let indexA = 0;\n        let indexB = 0;\n        let nextA = getA(0);\n        let nextB = getB(0);\n        const stackedRanges = [];\n        let topStackedRange;\n        let prevLineNumber = 0;\n        const resultRanges = [];\n        while (nextA || nextB) {\n            let useRange = undefined;\n            if (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {\n                if (nextA && nextA.startLineNumber === nextB.startLineNumber) {\n                    if (nextB.source === 1 /* FoldSource.userDefined */) {\n                        // a user defined range (possibly unfolded)\n                        useRange = nextB;\n                    }\n                    else {\n                        // a previously folded range or a (possibly unfolded) recovered range\n                        useRange = nextA;\n                        useRange.isCollapsed = nextB.isCollapsed && nextA.endLineNumber === nextB.endLineNumber;\n                        useRange.source = 0 /* FoldSource.provider */;\n                    }\n                    nextA = getA(++indexA); // not necessary, just for speed\n                }\n                else {\n                    useRange = nextB;\n                    if (nextB.isCollapsed && nextB.source === 0 /* FoldSource.provider */) {\n                        // a previously collapsed range\n                        useRange.source = 2 /* FoldSource.recovered */;\n                    }\n                }\n                nextB = getB(++indexB);\n            }\n            else {\n                // nextA is next. The user folded B set takes precedence and we sometimes need to look\n                // ahead in it to check for an upcoming conflict.\n                let scanIndex = indexB;\n                let prescanB = nextB;\n                while (true) {\n                    if (!prescanB || prescanB.startLineNumber > nextA.endLineNumber) {\n                        useRange = nextA;\n                        break; // no conflict, use this nextA\n                    }\n                    if (prescanB.source === 1 /* FoldSource.userDefined */ && prescanB.endLineNumber > nextA.endLineNumber) {\n                        // we found a user folded range, it wins\n                        break; // without setting nextResult, so this nextA gets skipped\n                    }\n                    prescanB = getB(++scanIndex);\n                }\n                nextA = getA(++indexA);\n            }\n            if (useRange) {\n                while (topStackedRange\n                    && topStackedRange.endLineNumber < useRange.startLineNumber) {\n                    topStackedRange = stackedRanges.pop();\n                }\n                if (useRange.endLineNumber > useRange.startLineNumber\n                    && useRange.startLineNumber > prevLineNumber\n                    && useRange.endLineNumber <= maxLineNumber\n                    && (!topStackedRange\n                        || topStackedRange.endLineNumber >= useRange.endLineNumber)) {\n                    resultRanges.push(useRange);\n                    prevLineNumber = useRange.startLineNumber;\n                    if (topStackedRange) {\n                        stackedRanges.push(topStackedRange);\n                    }\n                    topStackedRange = useRange;\n                }\n            }\n        }\n        return resultRanges;\n    }\n}\nexport class FoldingRegion {\n    constructor(ranges, index) {\n        this.ranges = ranges;\n        this.index = index;\n    }\n    get startLineNumber() {\n        return this.ranges.getStartLineNumber(this.index);\n    }\n    get endLineNumber() {\n        return this.ranges.getEndLineNumber(this.index);\n    }\n    get regionIndex() {\n        return this.index;\n    }\n    get parentIndex() {\n        return this.ranges.getParentIndex(this.index);\n    }\n    get isCollapsed() {\n        return this.ranges.isCollapsed(this.index);\n    }\n    containedBy(range) {\n        return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n    }\n    containsLine(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { computeIndentLevel } from '../../../common/model/utils.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5000;\nconst ID_INDENT_PROVIDER = 'indent';\nexport class IndentRangeProvider {\n    constructor(editorModel, languageConfigurationService, foldingRangesLimit) {\n        this.editorModel = editorModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.foldingRangesLimit = foldingRangesLimit;\n        this.id = ID_INDENT_PROVIDER;\n    }\n    dispose() { }\n    compute(cancelationToken) {\n        const foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;\n        const offSide = foldingRules && !!foldingRules.offSide;\n        const markers = foldingRules && foldingRules.markers;\n        return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.foldingRangesLimit));\n    }\n}\n// public only for testing\nexport class RangesCollector {\n    constructor(foldingRangesLimit) {\n        this._startIndexes = [];\n        this._endIndexes = [];\n        this._indentOccurrences = [];\n        this._length = 0;\n        this._foldingRangesLimit = foldingRangesLimit;\n    }\n    insertFirst(startLineNumber, endLineNumber, indent) {\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n            return;\n        }\n        const index = this._length;\n        this._startIndexes[index] = startLineNumber;\n        this._endIndexes[index] = endLineNumber;\n        this._length++;\n        if (indent < 1000) {\n            this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n        }\n    }\n    toIndentRanges(model) {\n        const limit = this._foldingRangesLimit.limit;\n        if (this._length <= limit) {\n            this._foldingRangesLimit.update(this._length, false);\n            // reverse and create arrays of the exact length\n            const startIndexes = new Uint32Array(this._length);\n            const endIndexes = new Uint32Array(this._length);\n            for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\n                startIndexes[k] = this._startIndexes[i];\n                endIndexes[k] = this._endIndexes[i];\n            }\n            return new FoldingRegions(startIndexes, endIndexes);\n        }\n        else {\n            this._foldingRangesLimit.update(this._length, limit);\n            let entries = 0;\n            let maxIndent = this._indentOccurrences.length;\n            for (let i = 0; i < this._indentOccurrences.length; i++) {\n                const n = this._indentOccurrences[i];\n                if (n) {\n                    if (n + entries > limit) {\n                        maxIndent = i;\n                        break;\n                    }\n                    entries += n;\n                }\n            }\n            const tabSize = model.getOptions().tabSize;\n            // reverse and create arrays of the exact length\n            const startIndexes = new Uint32Array(limit);\n            const endIndexes = new Uint32Array(limit);\n            for (let i = this._length - 1, k = 0; i >= 0; i--) {\n                const startIndex = this._startIndexes[i];\n                const lineContent = model.getLineContent(startIndex);\n                const indent = computeIndentLevel(lineContent, tabSize);\n                if (indent < maxIndent || (indent === maxIndent && entries++ < limit)) {\n                    startIndexes[k] = startIndex;\n                    endIndexes[k] = this._endIndexes[i];\n                    k++;\n                }\n            }\n            return new FoldingRegions(startIndexes, endIndexes);\n        }\n    }\n}\nconst foldingRangesLimitDefault = {\n    limit: MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT,\n    update: () => { }\n};\nexport function computeRanges(model, offSide, markers, foldingRangesLimit = foldingRangesLimitDefault) {\n    const tabSize = model.getOptions().tabSize;\n    const result = new RangesCollector(foldingRangesLimit);\n    let pattern = undefined;\n    if (markers) {\n        pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);\n    }\n    const previousRegions = [];\n    const line = model.getLineCount() + 1;\n    previousRegions.push({ indent: -1, endAbove: line, line }); // sentinel, to make sure there's at least one entry\n    for (let line = model.getLineCount(); line > 0; line--) {\n        const lineContent = model.getLineContent(line);\n        const indent = computeIndentLevel(lineContent, tabSize);\n        let previous = previousRegions[previousRegions.length - 1];\n        if (indent === -1) {\n            if (offSide) {\n                // for offSide languages, empty lines are associated to the previous block\n                // note: the next block is already written to the results, so this only\n                // impacts the end position of the block before\n                previous.endAbove = line;\n            }\n            continue; // only whitespace\n        }\n        let m;\n        if (pattern && (m = lineContent.match(pattern))) {\n            // folding pattern match\n            if (m[1]) { // start pattern match\n                // discard all regions until the folding pattern\n                let i = previousRegions.length - 1;\n                while (i > 0 && previousRegions[i].indent !== -2) {\n                    i--;\n                }\n                if (i > 0) {\n                    previousRegions.length = i + 1;\n                    previous = previousRegions[i];\n                    // new folding range from pattern, includes the end line\n                    result.insertFirst(line, previous.line, indent);\n                    previous.line = line;\n                    previous.indent = indent;\n                    previous.endAbove = line;\n                    continue;\n                }\n                else {\n                    // no end marker found, treat line as a regular line\n                }\n            }\n            else { // end pattern match\n                previousRegions.push({ indent: -2, endAbove: line, line });\n                continue;\n            }\n        }\n        if (previous.indent > indent) {\n            // discard all regions with larger indent\n            do {\n                previousRegions.pop();\n                previous = previousRegions[previousRegions.length - 1];\n            } while (previous.indent > indent);\n            // new folding range\n            const endLineNumber = previous.endAbove - 1;\n            if (endLineNumber - line >= 1) { // needs at east size 1\n                result.insertFirst(line, endLineNumber, indent);\n            }\n        }\n        if (previous.indent === indent) {\n            previous.endAbove = line;\n        }\n        else { // previous.indent < indent\n            // new region with a bigger indent\n            previousRegions.push({ indent, endAbove: line, line });\n        }\n    }\n    return result.toIndentRanges(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst foldingContext = {};\nconst ID_SYNTAX_PROVIDER = 'syntax';\nexport class SyntaxRangeProvider {\n    constructor(editorModel, providers, handleFoldingRangesChange, foldingRangesLimit, fallbackRangeProvider // used when all providers return null\n    ) {\n        this.editorModel = editorModel;\n        this.providers = providers;\n        this.handleFoldingRangesChange = handleFoldingRangesChange;\n        this.foldingRangesLimit = foldingRangesLimit;\n        this.fallbackRangeProvider = fallbackRangeProvider;\n        this.id = ID_SYNTAX_PROVIDER;\n        this.disposables = new DisposableStore();\n        if (fallbackRangeProvider) {\n            this.disposables.add(fallbackRangeProvider);\n        }\n        for (const provider of providers) {\n            if (typeof provider.onDidChange === 'function') {\n                this.disposables.add(provider.onDidChange(handleFoldingRangesChange));\n            }\n        }\n    }\n    compute(cancellationToken) {\n        return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {\n            var _a, _b;\n            if (ranges) {\n                const res = sanitizeRanges(ranges, this.foldingRangesLimit);\n                return res;\n            }\n            return (_b = (_a = this.fallbackRangeProvider) === null || _a === void 0 ? void 0 : _a.compute(cancellationToken)) !== null && _b !== void 0 ? _b : null;\n        });\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\n    let rangeData = null;\n    const promises = providers.map((provider, i) => {\n        return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {\n            if (cancellationToken.isCancellationRequested) {\n                return;\n            }\n            if (Array.isArray(ranges)) {\n                if (!Array.isArray(rangeData)) {\n                    rangeData = [];\n                }\n                const nLines = model.getLineCount();\n                for (const r of ranges) {\n                    if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n                        rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });\n                    }\n                }\n            }\n        }, onUnexpectedExternalError);\n    });\n    return Promise.all(promises).then(_ => {\n        return rangeData;\n    });\n}\nclass RangesCollector {\n    constructor(foldingRangesLimit) {\n        this._startIndexes = [];\n        this._endIndexes = [];\n        this._nestingLevels = [];\n        this._nestingLevelCounts = [];\n        this._types = [];\n        this._length = 0;\n        this._foldingRangesLimit = foldingRangesLimit;\n    }\n    add(startLineNumber, endLineNumber, type, nestingLevel) {\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n            return;\n        }\n        const index = this._length;\n        this._startIndexes[index] = startLineNumber;\n        this._endIndexes[index] = endLineNumber;\n        this._nestingLevels[index] = nestingLevel;\n        this._types[index] = type;\n        this._length++;\n        if (nestingLevel < 30) {\n            this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n        }\n    }\n    toIndentRanges() {\n        const limit = this._foldingRangesLimit.limit;\n        if (this._length <= limit) {\n            this._foldingRangesLimit.update(this._length, false);\n            const startIndexes = new Uint32Array(this._length);\n            const endIndexes = new Uint32Array(this._length);\n            for (let i = 0; i < this._length; i++) {\n                startIndexes[i] = this._startIndexes[i];\n                endIndexes[i] = this._endIndexes[i];\n            }\n            return new FoldingRegions(startIndexes, endIndexes, this._types);\n        }\n        else {\n            this._foldingRangesLimit.update(this._length, limit);\n            let entries = 0;\n            let maxLevel = this._nestingLevelCounts.length;\n            for (let i = 0; i < this._nestingLevelCounts.length; i++) {\n                const n = this._nestingLevelCounts[i];\n                if (n) {\n                    if (n + entries > limit) {\n                        maxLevel = i;\n                        break;\n                    }\n                    entries += n;\n                }\n            }\n            const startIndexes = new Uint32Array(limit);\n            const endIndexes = new Uint32Array(limit);\n            const types = [];\n            for (let i = 0, k = 0; i < this._length; i++) {\n                const level = this._nestingLevels[i];\n                if (level < maxLevel || (level === maxLevel && entries++ < limit)) {\n                    startIndexes[k] = this._startIndexes[i];\n                    endIndexes[k] = this._endIndexes[i];\n                    types[k] = this._types[i];\n                    k++;\n                }\n            }\n            return new FoldingRegions(startIndexes, endIndexes, types);\n        }\n    }\n}\nexport function sanitizeRanges(rangeData, foldingRangesLimit) {\n    const sorted = rangeData.sort((d1, d2) => {\n        let diff = d1.start - d2.start;\n        if (diff === 0) {\n            diff = d1.rank - d2.rank;\n        }\n        return diff;\n    });\n    const collector = new RangesCollector(foldingRangesLimit);\n    let top = undefined;\n    const previous = [];\n    for (const entry of sorted) {\n        if (!top) {\n            top = entry;\n            collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        }\n        else {\n            if (entry.start > top.start) {\n                if (entry.end <= top.end) {\n                    previous.push(top);\n                    top = entry;\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                }\n                else {\n                    if (entry.start > top.end) {\n                        do {\n                            top = previous.pop();\n                        } while (top && entry.start > top.end);\n                        if (top) {\n                            previous.push(top);\n                        }\n                        top = entry;\n                    }\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                }\n            }\n        }\n    }\n    return collector.toIndentRanges();\n}\n"],"names":["HiddenRangeModel","onDidChange","this","_updateEventEmitter","event","hiddenRanges","_hiddenRanges","constructor","model","Emitter","_hasLineChanges","_foldingModel","_foldingModelListener","_","updateHiddenRanges","regions","length","notifyChangeModelContent","e","changes","some","change","range","endLineNumber","startLineNumber","countEOL","text","updateHiddenAreas","newHiddenAreas","i","k","lastCollapsedStart","Number","MAX_VALUE","lastCollapsedEnd","ranges","isCollapsed","getStartLineNumber","getEndLineNumber","push","Range","applyHiddenRanges","fire","hasRanges","isHidden","line","findRange","adjustSelections","selections","hasChanges","editorModel","textModel","lastRange","adjustLine","isInside","len","selection","adjustedStartLine","setStartPosition","getLineMaxColumn","adjustedEndLine","setEndPosition","dispose","findFirstIdxMonotonousOrArrLen","r","FoldingController_1","__decorate","decorators","target","key","desc","d","c","arguments","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","CONTEXT_FOLDING_ENABLED","RawContextKey","FoldingController","Disposable","get","editor","getContribution","ID","getFoldingRangeProviders","languageFeaturesService","_a","_b","foldingRangeProviders","foldingRangeProvider","ordered","_foldingRangeSelector","call","contextKeyService","languageConfigurationService","notificationService","languageFeatureDebounceService","super","localToDispose","_register","DisposableStore","_foldingLimitReporter","RangesLimitReporter","options","getOptions","_isEnabled","_useFoldingProviders","_unfoldOnClickAfterEndOfLine","_restoringViewState","_currentModelHasFoldedImports","_foldingImportsByDefault","updateDebounceInfo","for","min","foldingModel","hiddenRangeModel","rangeProvider","foldingRegionPromise","foldingModelPromise","updateScheduler","cursorChangedScheduler","mouseDownInfo","foldingDecorationProvider","FoldingDecorationProvider","showFoldingControls","showFoldingHighlights","foldingEnabled","bindTo","set","onDidChangeModel","onModelChanged","onDidChangeConfiguration","hasChanged","triggerFoldingModelChanged","onFoldingStrategyChanged","saveViewState","getModel","isTooLargeForTokenization","collapsedRegions","getMemento","provider","id","undefined","lineCount","getLineCount","foldedImports","restoreViewState","state","applyMemento","clear","FoldingModel","add","hr","onHiddenRangesChanges","Delayer","RunOnceScheduler","revealCursor","onDidChangeModelLanguageConfiguration","onDidChangeModelContent","onDidChangeCursorPosition","onCursorPositionChanged","onMouseDown","onEditorMouseDown","onMouseUp","onEditorMouseUp","cancel","getRangeProvider","indentRangeProvider","IndentRangeProvider","selectedProviders","SyntaxRangeProvider","getFoldingModel","trigger","sw","StopWatch","createCancelablePromise","token","compute","then","foldingRanges","scrollState","setCollapsedAllOfType","FoldingRangeKind","Imports","value","StableEditorScrollState","capture","getSelections","selectionLineNumbers","map","s","update","restore","newValue","elapsed","defaultDelay","err","onUnexpectedError","setSelections","setHiddenAreas","schedule","toToggle","lineNumber","selectionStartLineNumber","getAllRegionsAtLine","toggleCollapseState","reveal","getPosition","leftButton","middleButton","iconClicked","type","data","detail","offsetLeftInGutter","element","offsetLeft","offsetX","isAfterLines","startColumn","region","getRegionAtLine","altKey","filter","otherRegion","containedBy","toMaybeToggle","getRegionsInside","recursive","shiftKey","column","position","revealPositionInCenterIfOutsideViewport","IContextKeyService","ILanguageConfigurationService","INotificationService","ILanguageFeatureDebounceService","ILanguageFeaturesService","_onDidChange","_computed","_limited","limit","computed","limited","FoldingAction","EditorAction","runEditorCommand","accessor","args","foldingController","reportTelemetry","invoke","getSelection","getStartPosition","getSelectedLines","getLineNumbers","selectionLines","l","run","_accessor","_editor","foldingArgumentsConstraint","types","foldingArgs","levels","direction","Array","isArray","every","FoldLevelAction","getFoldingLevel","parseInt","substr","ID_PREFIX","_foldingController","setCollapseStateAtLevel","level","registerEditorContribution","registerEditorAction","label","nls","alias","precondition","kbOpts","kbExpr","EditorContextKeys","editorTextFocus","primary","mac","weight","metadata","description","name","constraint","schema","lineNumbers","setCollapseStateLevelsUp","setCollapseStateLevelsDown","KeyChord","_args","setCollapseStateUp","selectedLines","hasTypes","setCollapseStateForType","Comment","comments","getLanguageConfiguration","getLanguageId","blockCommentStartToken","regExp","RegExp","escapeRegExpCharacters","setCollapseStateForMatchingLines","Region","foldingRules","markers","start","setCollapseStateForRest","getParentFoldLine","setSelection","endColumn","getPreviousFoldLine","getNextFoldLine","collapseRanges","source","sort","a","b","newRanges","FoldingRegions","sanitizeAndMerge","updatePost","fromFoldRanges","removeManualRanges","registerInstantiatedEditorAction","concat","CommandsRegistry","registerCommand","async","_len","_key","resource","URI","illegalArgument","IModelService","configurationService","IConfigurationService","getValue","strategy","foldingLimitReporter","providers","CancellationToken","None","result","getType","end","kind","fromValue","foldBackground","registerColor","light","transparent","editorSelectionBackground","dark","hcDark","hcLight","localize","iconForeground","foldingExpandedIcon","registerIcon","Codicon","chevronDown","foldingCollapsedIcon","chevronRight","foldingManualCollapsedIcon","foldingManualExpandedIcon","foldedBackgroundMinimap","color","themeColorFromId","collapsed","expanded","getDecorationOption","isManual","HIDDEN_RANGE_DECORATION","NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION","NO_CONTROLS_COLLAPSED_RANGE_DECORATION","NO_CONTROLS_EXPANDED_RANGE_DECORATION","MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION","MANUALLY_COLLAPSED_VISUAL_DECORATION","COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION","COLLAPSED_VISUAL_DECORATION","MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION","EXPANDED_AUTO_HIDE_VISUAL_DECORATION","MANUALLY_EXPANDED_VISUAL_DECORATION","EXPANDED_VISUAL_DECORATION","changeDecorations","callback","removeDecorations","decorationIds","ModelDecorationOptions","register","stickiness","afterContentClassName","isWholeLine","linesDecorationsTooltip","firstLineDecorationClassName","ThemeIcon","asClassName","className","minimap","_regions","_textModel","decorationProvider","_decorationProvider","Uint32Array","_editorDecorationIds","toggledRegions","r1","r2","regionIndex","processed","dirtyRegionEndLine","lastHiddenLine","updateDecorationsUntil","index","getSource","changeDecorationOptions","editorDecorationId","newCollapseState","setCollapsed","Math","max","collapseStateChanged","newFoldingRanges","intersects","foldRange","toFoldRange","newRegions","blockedLineNumers","foldedOrManualRanges","_currentFoldedOrManualRanges","newEditorDecorations","decorationRange","deltaDecorations","isBlocked","blockedLineNumber","foldedRanges","decRange","getDecorationRange","maxLineNumber","checksum","_getLinesChecksum","rangesToRestore","lineNumber1","lineNumber2","hash","getLineContent","current","toRegion","parentIndex","levelStack","pop","doCollapse","regionsInside","foldLevel","blockedLineNumbers","containsLine","filteredRegions","filteredRegion","test","foldingRegion","parentFoldingIdx","expectedParentIndex","minLineNumber","foldSourceAbbr","MAX_LINE_NUMBER","MASK_INDENT","BitField","size","numWords","ceil","_states","arrayIndex","bit","newState","startIndexes","endIndexes","Error","_startIndexes","_endIndexes","_collapseStates","_userDefinedStates","_recoveredStates","_types","_parentsComputed","ensureParentIndices","parentIndexes","isInsideLast","isUserDefined","setUserDefined","isRecovered","setRecovered","setSource","FoldingRegion","getParentIndex","parent","contains","findIndex","low","high","mid","floor","toString","res","join","rangesLength","gotTypes","rangesA","rangesB","getIndexedFunction","getA","getB","indexA","indexB","nextA","nextB","stackedRanges","topStackedRange","prevLineNumber","resultRanges","useRange","scanIndex","prescanB","foldingRangesLimit","cancelationToken","offSide","Promise","resolve","foldingRangesLimitDefault","tabSize","RangesCollector","pattern","previousRegions","indent","endAbove","lineContent","computeIndentLevel","m","previous","match","insertFirst","toIndentRanges","computeRanges","_indentOccurrences","_length","_foldingRangesLimit","entries","maxIndent","n","startIndex","foldingContext","handleFoldingRangesChange","fallbackRangeProvider","disposables","cancellationToken","rangeData","promises","provideFoldingRanges","isCancellationRequested","nLines","rank","onUnexpectedExternalError","all","collectSyntaxRanges","sorted","d1","d2","diff","collector","top","entry","sanitizeRanges","_nestingLevels","_nestingLevelCounts","nestingLevel","maxLevel"],"sourceRoot":""}