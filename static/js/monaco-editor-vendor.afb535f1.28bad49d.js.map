{"version":3,"file":"static/js/monaco-editor-vendor.afb535f1.28bad49d.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js","../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js","../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/offsetRange.js';\nexport class DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class SequenceDiff {\n    static invert(sequenceDiffs, doc1Length) {\n        const result = [];\n        forEachAdjacent(sequenceDiffs, (a, b) => {\n            result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));\n        });\n        return result;\n    }\n    static fromOffsetPairs(start, endExclusive) {\n        return new SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));\n    }\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    swap() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n    }\n    deltaStart(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n    }\n    deltaEnd(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n    }\n    intersect(other) {\n        const i1 = this.seq1Range.intersect(other.seq1Range);\n        const i2 = this.seq2Range.intersect(other.seq2Range);\n        if (!i1 || !i2) {\n            return undefined;\n        }\n        return new SequenceDiff(i1, i2);\n    }\n    getStarts() {\n        return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n    }\n    getEndExclusives() {\n        return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n    }\n}\nexport class OffsetPair {\n    constructor(offset1, offset2) {\n        this.offset1 = offset1;\n        this.offset2 = offset2;\n    }\n    toString() {\n        return `${this.offset1} <-> ${this.offset2}`;\n    }\n}\nOffsetPair.zero = new OffsetPair(0, 0);\nOffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\nexport class InfiniteTimeout {\n    isValid() {\n        return true;\n    }\n}\nInfiniteTimeout.instance = new InfiniteTimeout();\nexport class DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\nexport function isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\nexport class LineRangeFragment {\n    static getKey(chr) {\n        let key = this.chrKeys.get(chr);\n        if (key === undefined) {\n            key = this.chrKeys.size;\n            this.chrKeys.set(chr, key);\n        }\n        return key;\n    }\n    constructor(range, lines, source) {\n        this.range = range;\n        this.lines = lines;\n        this.source = source;\n        this.histogram = [];\n        let counter = 0;\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n            const line = lines[i];\n            for (let j = 0; j < line.length; j++) {\n                counter++;\n                const chr = line[j];\n                const key = LineRangeFragment.getKey(chr);\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\n            }\n            counter++;\n            const key = LineRangeFragment.getKey('\\n');\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\n        }\n        this.totalCount = counter;\n    }\n    computeSimilarity(other) {\n        var _a, _b;\n        let sumDifferences = 0;\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\n        for (let i = 0; i < maxLength; i++) {\n            sumDifferences += Math.abs(((_a = this.histogram[i]) !== null && _a !== void 0 ? _a : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));\n        }\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\n    }\n}\nLineRangeFragment.chrKeys = new Map();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        const seqX = seq1; // Text on the x axis\n        const seqY = seq2; // Text on the y axis\n        function getXAfterSnake(x, y) {\n            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        // k=1 -> (1,0),(2,1)\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n            }\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n            const lowerBound = -Math.min(d, seqY.length + (d % 2));\n            const upperBound = Math.min(d, seqX.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                let step = 0;\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n                step++;\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n                const y = x - k;\n                step++;\n                if (x > seqX.length || y > seqY.length) {\n                    // This diagonal is irrelevant for the result.\n                    // TODO: Don't pay the cost for this in the next iteration.\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seqX.length;\n        let lastAligningPosS2 = seqY.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nexport class LinesSliceCharSequence {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLine = [];\n        // To account for trimming\n        this.additionalOffsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        this.firstCharOffsetByLine[0] = 0;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.additionalOffsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.additionalOffsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new Position(this.lineRange.start + 1, 1);\n        }\n        const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);\n        return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.elements[offset1] === this.elements[offset2];\n    }\n    extendToFullLines(range) {\n        var _a, _b;\n        const start = (_a = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start)) !== null && _a !== void 0 ? _a : 0;\n        const end = (_b = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Space */]: 3,\n    [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [7 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 7 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 6 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 5 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    // Ignore too short moves\n    moves = moves.filter(current => {\n        const originalText = current.original.toOffsetRange().slice(originalLines).map(l => l.trim()).join('\\n');\n        return originalText.length >= 10;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => new LineRangeFragment(d.original, originalLines, d));\n    const insertions = new Set(changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n    const excludedChanges = new Set();\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(new LineRangeMapping(deletion.range, best.range));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = new SetMap();\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = new LineRange(i, i + 3);\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    // does this match extend some last match?\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n                        lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = new LineRangeSet();\n    const originalSet = new LineRangeSet();\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = new MonotonousArray(changes);\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n            modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n            modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = new MonotonousArray(changes);\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.endLineNumberExclusive < m.original.endLineNumberExclusive)\n            || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.endLineNumberExclusive < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n    getText(range) {\n        return this.lines.slice(range.start, range.endExclusive).join('\\n');\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.lines[offset1] === this.lines[offset2];\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals, groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Range } from '../../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs, removeShortMatches } from './heuristicSequenceOptimizations.js';\nimport { LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, RangeMapping } from '../rangeMapping.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineSequence } from './lineSequence.js';\nexport class DefaultLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n            return new LinesDiff([], [], false);\n        }\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return new LinesDiff([\n                new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n                    new RangeMapping(new Range(1, 1, originalLines.length, originalLines[0].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))\n                ])\n            ], [], false);\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(originalLinesHashes, originalLines);\n        const sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1700) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        let moves = [];\n        if (options.computeMoves) {\n            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n        }\n        // Make sure all ranges are valid\n        assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return new LinesDiff(changes, moves, hitTimeout);\n    }\n    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n        const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n        const movesWithDiffs = moves.map(m => {\n            const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n            return new MovedText(m, mappings);\n        });\n        return movesWithDiffs;\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\n        const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n        diffs = removeShortMatches(slice1, slice2, diffs);\n        diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n        const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of groupAdjacentBy(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original)\n        || a1.modified.overlapOrTouch(a2.modified))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        if (!dontAssertStartLine) {\n            if (changes.length > 0 && changes[0].original.startLineNumber !== changes[0].modified.startLineNumber) {\n                return false;\n            }\n        }\n        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        // We can only do this if the range is not empty yet\n        lineEndDelta = -1;\n    }\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        // We can only do this if the range is not empty yet\n        lineStartDelta = 1;\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\nexport function removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nexport function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n    const additional = [];\n    let lastModifiedWord = undefined;\n    function maybePushWordToAdditional() {\n        if (!lastModifiedWord) {\n            return;\n        }\n        const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n        const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n        if (originalLength1 !== originalLength2) {\n            // TODO figure out why this happens\n        }\n        if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {\n            additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n        }\n        lastModifiedWord = undefined;\n    }\n    for (const s of sequenceDiffs) {\n        function processWord(s1Range, s2Range) {\n            var _a, _b, _c, _d;\n            if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n                if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {\n                    const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n                    const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n                    lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;\n                    lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;\n                    lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n                    lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n                }\n                else {\n                    maybePushWordToAdditional();\n                    lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range: s1Range, s2Range: s2Range };\n                }\n            }\n            const changedS1 = s1Range.intersect(s.seq1Range);\n            const changedS2 = s2Range.intersect(s.seq2Range);\n            lastModifiedWord.count++;\n            lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;\n            lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;\n        }\n        const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n        const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n        const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n        const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n        if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {\n            processWord(w1Before, w2Before);\n        }\n        else {\n            if (w1Before && w2Before) {\n                processWord(w1Before, w2Before);\n            }\n            if (w1After && w2After) {\n                processWord(w1After, w2After);\n            }\n        }\n    }\n    maybePushWordToAdditional();\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedText = sequence1.getText(unchangedRange);\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n                if (unchangedTextWithoutWs.length <= 4\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (Math.pow((Math.pow(max, 1.5)), 1.5)) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    const newDiffs = [];\n    // Remove short suffixes/prefixes\n    forEachWithNeighbors(diffs, (prev, cur, next) => {\n        let newDiff = cur;\n        function shouldMarkAsChanged(text) {\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n        }\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n        const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n        if (shouldMarkAsChanged(prefix)) {\n            newDiff = newDiff.deltaStart(-prefix.length);\n        }\n        const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n        if (shouldMarkAsChanged(suffix)) {\n            newDiff = newDiff.deltaEnd(suffix.length);\n        }\n        const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n        const result = newDiff.intersect(availableSpace);\n        newDiffs.push(result);\n    });\n    return newDiffs;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LinesDiff {\n    constructor(changes, \n    /**\n     * Sorted by original line ranges.\n     * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n     */\n    moves, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.moves = moves;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class MovedText {\n    constructor(lineRangeMapping, changes) {\n        this.lineRangeMapping = lineRangeMapping;\n        this.changes = changes;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class LegacyLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n        });\n        return new LinesDiff(changes, [], result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    getLegacy: () => new LegacyLinesDiffComputer(),\n    getDefault: () => new DefaultLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineRange } from '../core/lineRange.js';\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new DetailedLineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber), undefined);\n            if (!r.modified.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n        }\n        const r = new DetailedLineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), undefined);\n        if (!r.modified.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange) {\n        this.original = originalRange;\n        this.modified = modifiedRange;\n    }\n    toString() {\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\n    }\n    flip() {\n        return new LineRangeMapping(this.modified, this.original);\n    }\n    join(other) {\n        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n    }\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n    constructor(originalRange, modifiedRange, innerChanges) {\n        super(originalRange, modifiedRange);\n        this.innerChanges = innerChanges;\n    }\n    flip() {\n        var _a;\n        return new DetailedLineRangeMapping(this.modified, this.original, (_a = this.innerChanges) === null || _a === void 0 ? void 0 : _a.map(c => c.flip()));\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    flip() {\n        return new RangeMapping(this.modifiedRange, this.originalRange);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run(args) {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run(args);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read-only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.isEmbeddedDiffEditor = new RawContextKey('isEmbeddedDiffEditor', false, nls.localize('isEmbeddedDiffEditor', \"Whether the context is an embedded diff editor\"));\n    EditorContextKeys.comparingMovedCode = new RawContextKey('comparingMovedCode', false, nls.localize('comparingMovedCode', \"Whether a moved code block is selected for comparison\"));\n    EditorContextKeys.accessibleDiffViewerVisible = new RawContextKey('accessibleDiffViewerVisible', false, nls.localize('accessibleDiffViewerVisible', \"Whether the accessible diff viewer is visible\"));\n    EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached = new RawContextKey('diffEditorRenderSideBySideInlineBreakpointReached', false, nls.localize('diffEditorRenderSideBySideInlineBreakpointReached', \"Whether the diff editor render side by side inline breakpoint is reached\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    EditorContextKeys.hoverFocused = new RawContextKey('editorHoverFocused', false, nls.localize('editorHoverFocused', \"Whether the editor hover is focused\"));\n    EditorContextKeys.stickyScrollFocused = new RawContextKey('stickyScrollFocused', false, nls.localize('stickyScrollFocused', \"Whether the sticky scroll is focused\"));\n    EditorContextKeys.stickyScrollVisible = new RawContextKey('stickyScrollVisible', false, nls.localize('stickyScrollVisible', \"Whether the sticky scroll is visible\"));\n    EditorContextKeys.standaloneColorPickerVisible = new RawContextKey('standaloneColorPickerVisible', false, nls.localize('standaloneColorPickerVisible', \"Whether the standalone color picker is visible\"));\n    EditorContextKeys.standaloneColorPickerFocused = new RawContextKey('standaloneColorPickerFocused', false, nls.localize('standaloneColorPickerFocused', \"Whether the standalone color picker is focused\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst editorFeatures = [];\n/**\n * Registers an editor feature. Editor features will be instantiated only once, as soon as\n * the first code editor is instantiated.\n */\nexport function registerEditorFeature(ctor) {\n    editorFeatures.push(ctor);\n}\nexport function getEditorFeatures() {\n    return editorFeatures.slice(0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    constructor(theme) {\n        this._theme = theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n"],"names":["DiffAlgorithmResult","trivial","seq1","seq2","SequenceDiff","OffsetRange","ofLength","length","trivialTimedOut","constructor","diffs","hitTimeout","this","invert","sequenceDiffs","doc1Length","result","forEachAdjacent","a","b","push","fromOffsetPairs","getEndExclusives","OffsetPair","zero","getStarts","seq2Range","endExclusive","seq1Range","start","offset1","offset2","swap","toString","concat","join","other","delta","offset","deltaStart","deltaEnd","intersect","i1","i2","max","Number","MAX_SAFE_INTEGER","InfiniteTimeout","isValid","instance","DateTimeout","timeout","startTime","Date","now","valid","BugIndicatingError","Array2D","width","height","array","Array","get","x","y","set","value","isSpace","charCode","LineRangeFragment","getKey","chr","key","chrKeys","undefined","size","range","lines","source","histogram","counter","i","startLineNumber","endLineNumberExclusive","line","j","totalCount","computeSimilarity","_a","_b","sumDifferences","maxLength","Math","abs","Map","DynamicProgrammingDiffing","compute","sequence1","sequence2","arguments","equalityScore","lcsLengths","directions","lengths","s1","s2","horizontalLen","verticalLen","extendedSeqScore","getElement","newValue","prevLen","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","reverse","MyersDiffAlgorithm","seqX","seqY","getXAfterSnake","d","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","k","loop","lowerBound","min","upperBound","step","maxXofDLineTop","maxXofDLineLeft","newMaxX","lastPath","path","endX","endY","prev","positiveArr","Int32Array","negativeArr","idx","arr","LinesSliceCharSequence","lineRange","considerWhitespaceChanges","elements","firstCharOffsetByLine","additionalOffsetByLine","trimFirstLineFully","trimmedStartLine","trimStart","trimEnd","charCodeAt","text","getText","slice","map","e","String","fromCharCode","getBoundaryScore","prevCategory","getCategory","nextCategory","score","getCategoryBoundaryScore","translateOffset","isEmpty","Position","findLastIdxMonotonous","translateRange","Range","fromPositions","findWordContaining","isWordChar","end","countLinesIn","lineNumber","isStronglyEqual","extendToFullLines","findLastMonotonous","findFirstMonotonous","category","computeMovedLines","changes","originalLines","modifiedLines","hashedOriginalLines","hashedModifiedLines","moves","excludedChanges","deletions","filter","c","modified","original","insertions","Set","deletion","best","highestSimilarity","insertion","similarity","delete","LineRangeMapping","add","computeMovesFromSimpleDeletionsToSimpleInsertions","unchangedMoves","original3LineHashes","SetMap","change","LineRange","possibleMappings","sort","compareBy","numberComparator","lastMappings","currentModifiedRange","nextMappings","forEach","_ref","lastMapping","originalLineRange","modifiedLineRange","mapping","reverseOrder","m","modifiedSet","LineRangeSet","originalSet","diffOrigToMod","modifiedSections","subtractFrom","originalTranslatedSections","getWithDelta","modifiedIntersectedSections","getIntersection","s","ranges","addRange","monotonousChanges","MonotonousArray","move","firstTouchingChangeOrig","firstTouchingChangeMod","linesAbove","lastTouchingChangeOrig","lastTouchingChangeMod","linesBelow","extendToTop","extendToBottom","origLine","modLine","contains","areLinesSimilar","computeUnchangedMoves","has","pushMany","last","current","originalDist","modifiedDist","joinCloseConsecutiveMoves","toOffsetRange","l","trim","changesMonotonous","removeMovesInSameDiff","line1","line2","commonNonSpaceCharCount","inverted","seq","longerLineLength","str","count","countNonWsChars","LineSequence","trimmedHash","getIndentation","DefaultLinesDiffComputer","dynamicProgrammingDiffing","myersDiffingAlgorithm","computeDiff","options","equals","LinesDiff","DetailedLineRangeMapping","RangeMapping","maxComputationTimeMs","ignoreTrimWhitespace","perfectHashes","getOrCreateHash","hash","originalLinesHashes","modifiedLinesHashes","lineAlignmentResult","log","lineAlignments","optimizeSequenceDiffs","removeVeryShortMatchingLinesBetweenDiffs","alignments","scanForWhitespaceChanges","equalLinesCount","seq1Offset","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","mappings","diff","assertFn","lineRangeMappingFromRangeMappings","computeMoves","validatePosition","pos","column","validateRange","innerChanges","ic","modifiedRange","getStartPosition","getEndPosition","originalRange","MovedText","slice1","slice2","diffResult","extendDiffsToEntireWordIfAppropriate","removeShortMatches","removeVeryShortMatchingTextBetweenLongDiffs","dontAssertStartLine","g","groupAdjacentBy","rangeMapping","lineStartDelta","lineEndDelta","endColumn","endLineNumber","startColumn","getLineRangeMapping","a1","a2","overlapOrTouch","first","checkAdjacentItems","m1","m2","prevResult","cur","result2","nextResult","joinSequenceDiffsByShifting","prevDiff","nextDiff","seq1ValidRange","seq2ValidRange","shiftDiffToBetterPosition","shiftSequenceDiffs","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","additional","lastModifiedWord","maybePushWordToAdditional","originalLength1","s1Range","deleted","s2Range","added","processWord","_c","_d","containsRange","s1Added","tryCreate","s2Added","changedS1","changedS2","w1Before","w2Before","w1After","w2After","sequenceDiffs1","sequenceDiffs2","sd1","sd2","next","shift","mergeSequenceDiffs","_sequence2","shouldRepeat","lastResult","shouldJoinDiffs","before","after","unchangedRange","replace","unchangedText","split","beforeLineCount1","beforeSeq1Length","beforeLineCount2","beforeSeq2Length","afterLineCount1","afterSeq1Length","afterLineCount2","afterSeq2Length","cap","v","pow","newDiffs","forEachWithNeighbors","newDiff","shouldMarkAsChanged","fullRange1","prefix","suffix","availableSpace","lineRangeMapping","LegacyLinesDiffComputer","DiffComputer","maxComputationTime","shouldIgnoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","lastChange","originalEndLineNumber","originalStartLineNumber","modifiedEndLineNumber","modifiedStartLineNumber","charChanges","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","pop","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","getElements","len","substring","getStrictElement","index","getStartLineNumber","getEndLineNumber","createCharSequence","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","col","CharSequence","_charCodes","_lineNumbers","_columns","_assertIndex","Error","getStartColumn","getEndColumn","CharChange","createFromDiffChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","LineChange","createFromDiffResult","originalLineSequence","modifiedLineSequence","continueCharDiff","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","postProcessCharChanges","opts","continueLineDiff","createContinueProcessingPredicate","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","strings","maximumRuntime","linesDiffComputers","getLegacy","getDefault","inverse","originalLineCount","modifiedLineCount","lastOriginalEndLineNumber","lastModifiedEndLineNumber","flip","super","InternalEditorAction","id","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","isSupported","contextMatchesRules","args","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","nls","focus","textInputFocus","readOnly","inDiffEditor","isEmbeddedDiffEditor","comparingMovedCode","accessibleDiffViewerVisible","diffEditorRenderSideBySideInlineBreakpointReached","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","hoverFocused","stickyScrollFocused","stickyScrollVisible","standaloneColorPickerVisible","standaloneColorPickerFocused","inCompositeEditor","notInCompositeEditor","languageId","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","editorFeatures","registerEditorFeature","ctor","getEditorFeatures","EditorTheme","type","_theme","theme","update","getColor","color"],"sourceRoot":""}