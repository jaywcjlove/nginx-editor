{"version":3,"file":"static/js/monaco-editor-vendor.1a061fac.f34801e1.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js","../node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelText.js","../node_modules/monaco-editor/esm/vs/editor/common/model/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\nexport class MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    get version() {\n        return this._versionId;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        const insertLines = splitLines(insertText);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        const newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\nexport class PrefixSumComputer {\n    constructor(values) {\n        this.values = values;\n        this.prefixSum = new Uint32Array(values.length);\n        this.prefixSumValidIndex = new Int32Array(1);\n        this.prefixSumValidIndex[0] = -1;\n    }\n    insertValues(insertIndex, insertValues) {\n        insertIndex = toUint32(insertIndex);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        const insertValuesLen = insertValues.length;\n        if (insertValuesLen === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n        this.values.set(insertValues, insertIndex);\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = insertIndex - 1;\n        }\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    setValue(index, value) {\n        index = toUint32(index);\n        value = toUint32(value);\n        if (this.values[index] === value) {\n            return false;\n        }\n        this.values[index] = value;\n        if (index - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = index - 1;\n        }\n        return true;\n    }\n    removeValues(startIndex, count) {\n        startIndex = toUint32(startIndex);\n        count = toUint32(count);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        if (startIndex >= oldValues.length) {\n            return false;\n        }\n        const maxCount = oldValues.length - startIndex;\n        if (count >= maxCount) {\n            count = maxCount;\n        }\n        if (count === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length - count);\n        this.values.set(oldValues.subarray(0, startIndex), 0);\n        this.values.set(oldValues.subarray(startIndex + count), startIndex);\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = startIndex - 1;\n        }\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    getTotalSum() {\n        if (this.values.length === 0) {\n            return 0;\n        }\n        return this._getPrefixSum(this.values.length - 1);\n    }\n    /**\n     * Returns the sum of the first `index + 1` many items.\n     * @returns `SUM(0 <= j <= index, values[j])`.\n     */\n    getPrefixSum(index) {\n        if (index < 0) {\n            return 0;\n        }\n        index = toUint32(index);\n        return this._getPrefixSum(index);\n    }\n    _getPrefixSum(index) {\n        if (index <= this.prefixSumValidIndex[0]) {\n            return this.prefixSum[index];\n        }\n        let startIndex = this.prefixSumValidIndex[0] + 1;\n        if (startIndex === 0) {\n            this.prefixSum[0] = this.values[0];\n            startIndex++;\n        }\n        if (index >= this.values.length) {\n            index = this.values.length - 1;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n        }\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n        return this.prefixSum[index];\n    }\n    getIndexOf(sum) {\n        sum = Math.floor(sum);\n        // Compute all sums (to get a fully valid prefixSum)\n        this.getTotalSum();\n        let low = 0;\n        let high = this.values.length - 1;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStop = this.prefixSum[mid];\n            midStart = midStop - this.values[mid];\n            if (sum < midStart) {\n                high = mid - 1;\n            }\n            else if (sum >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new PrefixSumIndexOfResult(mid, sum - midStart);\n    }\n}\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nexport class ConstantTimePrefixSumComputer {\n    constructor(values) {\n        this._values = values;\n        this._isValid = false;\n        this._validEndIndex = -1;\n        this._prefixSum = [];\n        this._indexBySum = [];\n    }\n    /**\n     * @returns SUM(0 <= j < values.length, values[j])\n     */\n    getTotalSum() {\n        this._ensureValid();\n        return this._indexBySum.length;\n    }\n    /**\n     * Returns the sum of the first `count` many items.\n     * @returns `SUM(0 <= j < count, values[j])`.\n     */\n    getPrefixSum(count) {\n        this._ensureValid();\n        if (count === 0) {\n            return 0;\n        }\n        return this._prefixSum[count - 1];\n    }\n    /**\n     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n     */\n    getIndexOf(sum) {\n        this._ensureValid();\n        const idx = this._indexBySum[sum];\n        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n    }\n    removeValues(start, deleteCount) {\n        this._values.splice(start, deleteCount);\n        this._invalidate(start);\n    }\n    insertValues(insertIndex, insertArr) {\n        this._values = arrayInsert(this._values, insertIndex, insertArr);\n        this._invalidate(insertIndex);\n    }\n    _invalidate(index) {\n        this._isValid = false;\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n    _ensureValid() {\n        if (this._isValid) {\n            return;\n        }\n        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n            const value = this._values[i];\n            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n            this._prefixSum[i] = sumAbove + value;\n            for (let j = 0; j < value; j++) {\n                this._indexBySum[sumAbove + j] = i;\n            }\n        }\n        // trim things\n        this._prefixSum.length = this._values.length;\n        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n        // mark as valid\n        this._isValid = true;\n        this._validEndIndex = this._values.length - 1;\n    }\n    setValue(index, value) {\n        if (this._values[index] === value) {\n            // no change\n            return;\n        }\n        this._values[index] = value;\n        this._invalidate(index);\n    }\n}\nexport class PrefixSumIndexOfResult {\n    constructor(index, remainder) {\n        this.index = index;\n        this.remainder = remainder;\n        this._prefixSumIndexOfResultBrand = undefined;\n        this.index = index;\n        this.remainder = remainder;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        var _a;\n        const firstInvalidLine = (_a = this._tokenizerWithStateStore) === null || _a === void 0 ? void 0 : _a.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableMap, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nexport class TokenizationTextModelPart extends TextModelPart {\n    constructor(_languageService, _languageConfigurationService, _textModel, _bracketPairsTextModelPart, _languageId, _attachedViews) {\n        super();\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this.grammarTokens = this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        this._register(this.grammarTokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._register(this.grammarTokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this.grammarTokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this.grammarTokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this.grammarTokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this.grammarTokens.hasTokens;\n    }\n    resetTokenization() {\n        this.grammarTokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this.grammarTokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this.grammarTokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this.grammarTokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this.grammarTokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this.grammarTokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this.grammarTokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this.grammarTokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this.grammarTokens.resetTokenization();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n}\nclass GrammarTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId, attachedViews) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        var _a;\n        this._tokens.flush();\n        (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    var _a;\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        (_a = this._tokenizer) === null || _a === void 0 ? void 0 : _a.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if ((tokenizationSupport === null || tokenizationSupport === void 0 ? void 0 : tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        var _a;\n                        (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        var _a;\n                        (_a = this._debugBackgroundStates) === null || _a === void 0 ? void 0 : _a.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        var _a;\n        (_a = this._defaultBackgroundTokenizer) === null || _a === void 0 ? void 0 : _a.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        var _a, _b, _c;\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            (_b = this._debugBackgroundStates) === null || _b === void 0 ? void 0 : _b.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            (_c = this._defaultBackgroundTokenizer) === null || _c === void 0 ? void 0 : _c.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        var _a, _b;\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                (_a = this._backgroundTokenizer.value) === null || _a === void 0 ? void 0 : _a.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 ? void 0 : _b.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        var _a, _b;\n        const builder = new ContiguousMultilineTokensBuilder();\n        (_a = this._tokenizer) === null || _a === void 0 ? void 0 : _a.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 ? void 0 : _b.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n    getLineTokens(lineNumber) {\n        var _a;\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && ((_a = this._debugBackgroundTokenizer.value) === null || _a === void 0 ? void 0 : _a.reportMismatchingTokens)) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\nclass AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = TextModel_1 = class TextModel extends Disposable {\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB,  // used in tests\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; // 256M characters, usually ~> 512MB memory usage\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService)\n], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        var _a;\n        this.position = (_a = options === null || options === void 0 ? void 0 : options.position) !== null && _a !== void 0 ? _a : model.GlyphMarginLane.Center;\n        this.persistLane = options === null || options === void 0 ? void 0 : options.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        var _a, _b;\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = (_a = options.sectionHeaderStyle) !== null && _a !== void 0 ? _a : null;\n        this.sectionHeaderText = (_b = options.sectionHeaderText) !== null && _b !== void 0 ? _b : null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f;\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = (_a = options.blockDoesNotCollapse) !== null && _a !== void 0 ? _a : null;\n        this.blockIsAfterEnd = (_b = options.blockIsAfterEnd) !== null && _b !== void 0 ? _b : null;\n        this.blockPadding = (_c = options.blockPadding) !== null && _c !== void 0 ? _c : null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = (_d = options.shouldFillLineOnLineBreak) !== null && _d !== void 0 ? _d : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = (_e = options.hideInCommentTokens) !== null && _e !== void 0 ? _e : false;\n        this.hideInStringTokens = (_f = options.hideInStringTokens) !== null && _f !== void 0 ? _f : false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        var _a;\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        var _a, _b;\n        this._affectsMinimap || (this._affectsMinimap = !!((_a = options.minimap) === null || _a === void 0 ? void 0 : _a.position));\n        this._affectsOverviewRuler || (this._affectsOverviewRuler = !!((_b = options.overviewRuler) === null || _b === void 0 ? void 0 : _b.color));\n        this._affectsGlyphMargin || (this._affectsGlyphMargin = !!options.glyphMarginClassName);\n        this._affectsLineNumber || (this._affectsLineNumber = !!options.lineNumberClassName);\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { AbstractText } from '../core/textEdit.js';\nimport { TextLength } from '../core/textLength.js';\nexport class TextModelText extends AbstractText {\n    constructor(_textModel) {\n        super();\n        this._textModel = _textModel;\n    }\n    getValueOfRange(range) {\n        return this._textModel.getValueInRange(range);\n    }\n    get length() {\n        const lastLineNumber = this._textModel.getLineCount();\n        const lastLineLen = this._textModel.getLineLength(lastLineNumber);\n        return new TextLength(lastLineNumber - 1, lastLineLen);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n"],"names":["MirrorTextModel","constructor","uri","lines","eol","versionId","this","_uri","_lines","_eol","_versionId","_lineStarts","_cachedTextValue","dispose","length","version","getText","join","onEvents","e","changes","change","_acceptDeleteRange","range","_acceptInsertText","Position","startLineNumber","startColumn","text","_ensureLineStarts","eolLength","linesLength","lineStartValues","Uint32Array","i","PrefixSumComputer","_setLineText","lineIndex","newValue","setValue","endLineNumber","substring","endColumn","splice","removeValues","position","insertText","insertLines","splitLines","lineNumber","column","newLengths","insertValues","values","prefixSum","prefixSumValidIndex","Int32Array","insertIndex","toUint32","oldValues","oldPrefixSum","insertValuesLen","set","subarray","index","value","startIndex","count","maxCount","getTotalSum","_getPrefixSum","getPrefixSum","Math","max","getIndexOf","sum","floor","low","high","mid","midStop","midStart","PrefixSumIndexOfResult","ConstantTimePrefixSumComputer","_values","_isValid","_validEndIndex","_prefixSum","_indexBySum","_ensureValid","idx","viewLinesAbove","start","deleteCount","_invalidate","insertArr","arrayInsert","min","len","sumAbove","j","remainder","_prefixSumIndexOfResultBrand","undefined","TreeNode","piece","color","size_left","lf_left","parent","left","right","next","SENTINEL","leftest","node","prev","righttest","detach","calculateSize","calculateLF","lineFeedCnt","resetSentinel","leftRotate","tree","x","y","root","rightRotate","rbDelete","z","yWasRed","recomputeTreeMetadata","newSizeLeft","newLFLeft","delta","lf_delta","updateTreeMetadata","w","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","arr","r","Uint16Array","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","str","readonly","arguments","rLength","chr","charCodeAt","Piece","bufferIndex","end","StringBuffer","buffer","PieceTreeSnapshot","BOM","_pieces","_tree","_BOM","_index","iterate","push","read","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","get","offset","nodePos","nodeStartOffset","get2","nodeStartLineNumber","nodePosition","shift","validate","hasInvalidVal","tmp","newArr","entry","PieceTreeBase","chunks","eolNormalized","create","_buffers","_lastChangeBufferPos","line","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","normalizeEOL","averageBufferSize","tempChunk","tempChunkLen","getNodeContent","replace","getEOL","setEOL","newEOL","createSnapshot","getOffsetAt","leftLen","getAccumulatedValue","getPositionAt","lfCnt","originalOffset","out","getValueInRange","startPosition","nodeAt2","endPosition","getValueInRange2","startOffset","offsetInBuffer","ret","substr","getLinesContent","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineCount","getLineContent","getLineRawContent","_getCharCode","matchingNode","targetOffset","getLineCharCode","getLineLength","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","resultLen","result","startOffsetInBuffer","m","searchText","_wordSeparators","reset","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","createFindMatch","Range","findMatchesLineByLine","searchRange","Searcher","wordSeparators","regex","currentNode","lineBreakCnt","nextLineStartOffset","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","textLength","lastMatchIndex","indexOf","isValidMatch","FindMatch","insert","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","nodeCharCodeAt","newStart","startWithLF","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","delete","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","nPiece","newNode","adjustCarriageReturnFromNext","endOffset","previousCharOffset","cursor","nodes","lastChar","splitText","concat","slice","endIndex","endPos","newPiece","cache","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","size_delta","newLength","originalStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","prevAccumualtedValue","offsetOfNode","newOffset","val","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","p","prevNode","PieceTreeTextBuffer","Disposable","containsRTL","containsUnusualLineTerminators","super","_onDidChangeContent","_register","Emitter","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","preserveBOM","getRangeAt","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","eolOffsetCompensation","desiredEOL","actualEOL","getCharacterCountInRange","fromLineNumber","toLineNumber","lineContent","fromOffset","toOffset","strings","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","Error","applyEdits","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","op","_isTracked","validatedRange","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","countEOL","bufferEOL","sortIndex","identifier","rangeOffset","rangeLength","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","TextChange","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","prevContent","fire","ApplyEditsResult","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","_sortOpsDescending","contentChangeRange","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","compareRangesUsingEnds","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","_getEOL","defaultEOL","totalEOLCount","totalCRCount","newLineStart","textBuffer","disposable","PieceTreeTextBufferBuilder","_hasPreviousChar","_previousChar","_tmpLineStarts","acceptChunk","chunk","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","createLineStarts","finish","_finish","lastChunk","newLineStarts","TokenizerWithStateStore","tokenizationSupport","initialState","getInitialState","store","TrackingTokenizationStateStore","getStartState","getFirstInvalidLine","TokenizerWithStateStoreAndTextModel","_textModel","_languageIdCodec","updateTokensUntilLine","builder","languageId","getLanguageId","lineToTokenize","safeTokenize","startState","add","tokens","setEndState","endState","getTokenTypeIfInsertingCharacter","character","lineStartState","lineTokens","LineTokens","getCount","tokenIndex","findTokenIndexAtOffset","getStandardTokenType","tokenizeLineWithEdit","newText","curLineContent","newLineContent","getLanguageIdAtPosition","hasAccurateTokensForLine","getFirstInvalidEndStateLineNumberOrMax","isCheapToTokenize","firstInvalidLineNumber","tokenizeHeuristically","heuristicTokens","state","guessStartState","nonWhitespaceColumn","likelyRelevantLines","newNonWhitespaceIndex","reverse","_tokenizationStateStore","TokenizationStateStore","_invalidEndStatesLineNumbers","RangePriorityQueueImpl","addRange","OffsetRange","getEndState","BugIndicatingError","acceptChange","newLineCount","addRangeAndResize","endLineNumberExclusive","acceptChanges","c","LineRange","invalidateEndStateRange","getFirstInvalidEndStateLineNumber","Number","MAX_SAFE_INTEGER","allStatesValid","_lineEndStates","FixedArray","oldState","equals","_ranges","findIndex","contains","endExclusive","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","toString","map","languageIdCodec","hasEOL","tokenizeEncoded","clone","onUnexpectedError","nullTokenizeEncoded","encodeLanguageId","convertToEndOffset","DefaultBackgroundTokenizer","_tokenizerWithStateStore","_backgroundTokenStore","_isDisposed","_isScheduled","handleChanges","_beginBackgroundTokenization","isAttachedToEditor","_hasLinesToTokenize","runWhenGlobalIdle","deadline","_backgroundTokenizeWithDeadline","endTime","Date","now","timeRemaining","execute","_backgroundTokenizeForAtLeast1ms","setTimeout0","ContiguousMultilineTokensBuilder","sw","StopWatch","elapsed","_tokenizeOneInvalidLine","setTokens","finalize","checkFinished","_a","firstInvalidLine","backgroundTokenizationFinished","requestTokens","TokenizationTextModelPart","TextModelPart","_languageService","_languageConfigurationService","_bracketPairsTextModelPart","_languageId","_attachedViews","_semanticTokens","SparseTokensStore","_onDidChangeLanguage","onDidChangeLanguage","event","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","grammarTokens","GrammarTokens","onDidChange","affects","_emitModelTokensChangedEvent","onDidChangeBackgroundTokenizationState","handleDidChangeBackgroundTokenizationState","handleDidChangeContent","isFlush","flush","isEolChange","acceptEdit","handleDidChangeAttached","getLineTokens","validateLineNumber","syntacticTokens","addSparseTokens","_isDisposing","handleDidChangeTokens","hasTokens","resetTokenization","backgroundTokenizationState","forceTokenization","tokenizeIfCheap","setSemanticTokens","isComplete","semanticTokensApplied","ranges","hasCompleteSemanticTokens","hasSomeSemanticTokens","setPartialSemanticTokens","changedRange","validateRange","setPartial","getWordAtPosition","_position","assertNotDisposed","validatePosition","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getWordAtText","getLanguageConfiguration","getWordDefinition","lbStartOffset","lbEndOffset","leftBiasedWord","getStartOffset","tokenCount","getEndOffset","getWordUntilPosition","wordAtPosition","word","setLanguageId","source","oldLanguage","newLanguage","handleDidChangeLanguage","_backgroundTokenizationState","attachedViews","_tokenizer","_defaultBackgroundTokenizer","_backgroundTokenizer","MutableDisposable","_tokens","ContiguousTokensStore","_debugBackgroundTokenizer","_onDidChangeBackgroundTokenizationState","_attachedViewStates","DisposableMap","TokenizationRegistry","changedLanguages","onDidChangeVisibleRanges","_ref","view","existing","AttachedViewHandler","refreshRanges","lineRanges","handleStateChange","deleteAndDispose","fireTokenChangeEvent","_debugBackgroundTokens","_debugBackgroundStates","initializeTokenization","isTooLargeForTokenization","clear","firstInvalidEndStateLineNumber","createBackgroundTokenizer","backgroundTokenizerShouldOnlyVerifyTokens","setMultilineTokens","refreshAllVisibleLineTokens","_b","_c","joinMany","_ref2","_","s","refreshRange","changedTokens","lineText","getTokens","backgroundResult","reportMismatchingTokens","validatedPosition","_lineRanges","_refreshTokens","runner","RunOnceScheduler","update","_computedLineRanges","visibleLineRanges","stabilized","cancel","schedule","TextModel_1","__decorate","decorators","target","key","desc","d","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","createTextBuffer","factory","createTextBufferFactory","model","snapshot","createTextBufferFactoryFromSnapshot","MODEL_ID","TextModelSnapshot","_source","_eos","resultCnt","resultLength","invalidFunc","TextModel","resolveOptions","options","detectIndentation","guessedIndentation","guessIndentation","tabSize","insertSpaces","indentSize","trimAutoWhitespace","bracketPairColorizationOptions","_tokenizationTextModelPart","onDidChangeContent","listener","_eventEmitter","slowEvent","contentChangedEvent","onDidChangeContentOrInjectedText","combinedDisposable","fastEvent","_onDidChangeInjectedText","__isDisposing","tokenization","bracketPairs","_bracketPairs","guides","_guidesTextModelPart","languageIdOrSelection","creationOptions","associatedResource","_undoRedoService","_onWillDispose","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","DidChangeContentEmitter","_languageSelectionListener","_deltaDecorationCallCnt","AttachedViews","id","isForSimpleWidget","_associatedResource","URI","parse","_attachedEditorCount","_buffer","_bufferDisposable","_options","_setLanguage","BracketPairsTextModelPart","GuidesTextModelPart","_decorationProvider","ColorizedBracketPairsDecorationProvider","bufferLineCount","bufferTextLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForHeapOperation","LARGE_FILE_HEAP_OPERATION_THRESHOLD","_isTooLargeForSyncing","_MODEL_SYNC_LIMIT","_alternativeVersionId","_initialUndoRedoSnapshot","_instanceId","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","EditStack","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","endDeferredEmit","requestRichLanguageFeatures","emptyDisposedTextBuffer","None","_assertNotDisposed","_emitContentChangedEvent","rawChange","InternalModelContentChangeEvent","illegalArgument","_setValueFromTextBuffer","_createContentChanged2","isUndoing","isRedoing","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","getLineMaxColumn","_increaseVersionId","ModelRawContentChangedEvent","ModelRawFlush","getValue","_onBeforeEOLChange","_onAfterEOLChange","ModelRawEOLChanged","ensureAllNodesHaveRanges","allDecorations","collectNodesPostOrder","cachedAbsoluteStart","cachedAbsoluteEnd","cachedVersionId","recomputeMaxEnd","onBeforeAttached","attachView","onBeforeDetached","detachView","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForHeapOperation","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineLength","getOptions","getFormattingOptions","updateOptions","_newOpts","originalIndentSize","bracketColorizationOptions","newOpts","createChangeEvent","handleDidChangeOptions","defaultInsertSpaces","defaultTabSize","normalizeIndentation","removeUnusualLineTerminators","selections","matches","findMatches","pushEditOperations","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","_validatePosition","rawOffset","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","getValueLength","rawRange","getEndOfLineSequence","getLineMinColumn","_validateRangeRelaxedNoAllocations","linesCount","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","Selection","_isValidPosition","validationType","charCodeBefore","_lineNumber","_column","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","modifyPosition","candidate","rawSearchScope","isRegex","matchCase","searchRanges","Array","isArray","every","searchScope","isIRange","d1","d2","uniqueSearchRanges","matchMapper","reduce","curr","areIntersecting","plusRange","SearchParams","parseSearchRequest","TextModelSearch","findNextMatch","rawSearchStart","searchStart","findPreviousMatch","pushStackElement","popStackElement","pushEOL","_validateEditOperation","rawOperation","_validateEditOperations","beforeCursorState","editOperations","cursorStateComputer","group","_pushEditOperations","incomingEdits","editsAreNearCursors","sel","foundEditNearSel","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","charAt","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","oldText","_applyUndoRedoEdits","_applyRedo","oldPosition","oldEnd","oldLineCount","acceptReplace","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","LineInjectedText","fromDecorations","injectedTextInEditedRangeQueue","ArrayQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","ModelRawLineChanged","spliceStartLineNumber","ModelRawLinesDeleted","spliceLineNumber","injectedTexts","newLines","takeWhile","ModelRawLinesInserted","reverseEdits","undo","canUndo","redo","canRedo","size","lineChangeEvents","from","_getInjectedTextInLine","ModelInjectedTextChangedEvent","changeDecorations","ownerId","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","setOptions","removeAllDecorationsWithOwnerId","collectNodesFromOwner","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","onlyMarginDecorations","decorations","_getDecorationsInRange","pushMany","getDecorationsInRange","onlyMinimapDecorations","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","filter","t","getAllDecorations","getAllMarginDecorations","filterRange","filterOwnerId","getAllInInterval","after","oldRange","recordLineAffectedByInjectedText","before","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","nodeIsInOverviewRuler","nodeRange","movedInOverviewRuler","changedWhetherInjectedText","isOptionsInjectedText","isNodeInjectedText","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","IntervalNode","newDecoration","setLanguage","normalizePosition","affinity","getLineIndentColumn","indent","indentOfLine","isNodeInOverviewRuler","DEFAULT_CREATION_OPTIONS","EDITOR_MODEL_DEFAULTS","IUndoRedoService","ILanguageService","ILanguageConfigurationService","_decorationsTree0","IntervalTree","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","intervalSearch","r1","r2","showIfCollapsed","search","overviewRulerOnly","_search","_resolveNode","resolveNode","cleanClassName","className","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","Center","getColor","theme","type","_resolveColor","invalidateCachedColor","ModelDecorationGlyphMarginOptions","persistLane","ModelDecorationMinimapOptions","sectionHeaderStyle","sectionHeaderText","Color","fromHex","ModelDecorationInjectedTextOptions","content","inlineClassName","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","register","createDynamic","_d","_e","_f","description","blockClassName","blockDoesNotCollapse","blockIsAfterEnd","blockPadding","stickiness","zIndex","shouldFillLineOnLineBreak","hoverMessage","glyphMarginHoverMessage","lineNumberHoverMessage","isWholeLine","collapseOnReplaceEdit","minimap","glyphMargin","glyphMarginClassName","linesDecorationsClassName","lineNumberClassName","linesDecorationsTooltip","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFireDeferred","_affectsMinimap","_affectsOverviewRuler","_affectsGlyphMargin","_affectsLineNumber","doFire","Set","tryFire","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","affectsLineNumber","_fastEmitter","_slowEmitter","_deferredEvent","rawContentChangedEvent","merge","_onDidChangeVisibleRanges","_views","AttachedViewImpl","setVisibleLines","visibleLines","multiline","chCode","nextChCode","isMultilineRegexSource","wholeWord","global","unicode","err","canUseSimpleSearch","toLowerCase","toUpperCase","SearchData","getMapForWordSeparators","rawMatches","LineFeedCounter","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","findLineFeedCountBeforeOffset","searchParams","_doFindMatchesMultiline","_doFindMatchesLineByLine","_getMultilineMatchRange","lfCounter","matchIndex","match0","lineFeedCountBeforeMatch","lineFeedCountInMatch","counter","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","_findFirstMatchInLine","fromColumn","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","bestResult","matchStartIndex","matchLength","charBefore","firstCharInMatch","leftIsWordBounday","charAfter","lastCharInMatch","rightIsWordBounday","searchRegex","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec","TextModelText","AbstractText","getValueOfRange","lastLineNumber","lastLineLen","TextLength","computeIndentLevel"],"sourceRoot":""}