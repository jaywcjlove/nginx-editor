{"version":3,"file":"static/js/monaco-editor-vendor.19a39495.3c847aca.js","mappings":"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","sources":["../../node_modules/monaco-editor/esm/vs/base/common/equals.js","../../node_modules/monaco-editor/esm/vs/base/common/errorMessage.js","../../node_modules/monaco-editor/esm/vs/base/common/errors.js","../../node_modules/monaco-editor/esm/vs/base/common/event.js","../../node_modules/monaco-editor/esm/vs/base/common/extpath.js","../../node_modules/monaco-editor/esm/vs/base/common/filters.js","../../node_modules/monaco-editor/esm/vs/base/common/functional.js","../../node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js","../../node_modules/monaco-editor/esm/vs/base/common/glob.js","../../node_modules/monaco-editor/esm/vs/base/common/hash.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\nexport const strictEquals = (a, b) => a === b;\n/**\n * Checks if the items of two arrays are equal.\n * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.\n */\nexport function itemsEquals(itemEquals = strictEquals) {\n    return (a, b) => arrays.equals(a, b, itemEquals);\n}\n/**\n * Uses `item.equals(other)` to determine equality.\n */\nexport function itemEquals() {\n    return (a, b) => a.equals(b);\n}\nexport function equalsIfDefined(v1, v2, equals) {\n    if (!v1 || !v2) {\n        return v1 === v2;\n    }\n    return equals(v1, v2);\n}\nconst objIds = new WeakMap();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\nimport * as types from './types.js';\nimport * as nls from '../../nls.js';\nfunction exceptionToErrorMessage(exception, verbose) {\n    if (verbose && (exception.stack || exception.stacktrace)) {\n        return nls.localize('stackTrace.format', \"{0}: {1}\", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));\n    }\n    return detectSystemErrorMessage(exception);\n}\nfunction stackToString(stack) {\n    if (Array.isArray(stack)) {\n        return stack.join('\\n');\n    }\n    return stack;\n}\nfunction detectSystemErrorMessage(exception) {\n    // Custom node.js error from us\n    if (exception.code === 'ERR_UNC_HOST_NOT_ALLOWED') {\n        return `${exception.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;\n    }\n    // See https://nodejs.org/api/errors.html#errors_class_system_error\n    if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {\n        return nls.localize('nodeExceptionMessage', \"A system error occurred ({0})\", exception.message);\n    }\n    return exception.message || nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n/**\n * Tries to generate a human readable error message out of the error. If the verbose parameter\n * is set to true, the error message will include stacktrace details if provided.\n *\n * @returns A string containing the error message.\n */\nexport function toErrorMessage(error = null, verbose = false) {\n    if (!error) {\n        return nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n    }\n    if (Array.isArray(error)) {\n        const errors = arrays.coalesce(error);\n        const msg = toErrorMessage(errors[0], verbose);\n        if (errors.length > 1) {\n            return nls.localize('error.moreErrors', \"{0} ({1} errors in total)\", msg, errors.length);\n        }\n        return msg;\n    }\n    if (types.isString(error)) {\n        return error;\n    }\n    if (error.detail) {\n        const detail = error.detail;\n        if (detail.error) {\n            return exceptionToErrorMessage(detail.error, verbose);\n        }\n        if (detail.exception) {\n            return exceptionToErrorMessage(detail.exception, verbose);\n        }\n    }\n    if (error.stack) {\n        return exceptionToErrorMessage(error, verbose);\n    }\n    if (error.message) {\n        return error.message;\n    }\n    return nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n    constructor() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(() => {\n                if (e.stack) {\n                    if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n                        throw new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n                    }\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    emit(e) {\n        this.listeners.forEach((listener) => {\n            listener(e);\n        });\n    }\n    onUnexpectedError(e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    }\n    // For external errors, we don't want the listeners to be called\n    onUnexpectedExternalError(e) {\n        this.unexpectedErrorHandler(e);\n    }\n}\nexport const errorHandler = new ErrorHandler();\nexport function onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nexport function onUnexpectedExternalError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        errorHandler.onUnexpectedExternalError(e);\n    }\n    return undefined;\n}\nexport function transformErrorForSerialization(error) {\n    if (error instanceof Error) {\n        const { name, message } = error;\n        const stack = error.stacktrace || error.stack;\n        return {\n            $isError: true,\n            name,\n            message,\n            stack,\n            noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\n        };\n    }\n    // return as is\n    return error;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error) {\n    if (error instanceof CancellationError) {\n        return true;\n    }\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n    constructor() {\n        super(canceledName);\n        this.name = this.message;\n    }\n}\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled() {\n    const error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\nexport function illegalArgument(name) {\n    if (name) {\n        return new Error(`Illegal argument: ${name}`);\n    }\n    else {\n        return new Error('Illegal argument');\n    }\n}\nexport function illegalState(name) {\n    if (name) {\n        return new Error(`Illegal state: ${name}`);\n    }\n    else {\n        return new Error('Illegal state');\n    }\n}\nexport class NotSupportedError extends Error {\n    constructor(message) {\n        super('NotSupported');\n        if (message) {\n            this.message = message;\n        }\n    }\n}\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'CodeExpectedError';\n    }\n    static fromError(err) {\n        if (err instanceof ErrorNoTelemetry) {\n            return err;\n        }\n        const result = new ErrorNoTelemetry();\n        result.message = err.message;\n        result.stack = err.stack;\n        return result;\n    }\n    static isErrorNoTelemetry(err) {\n        return err.name === 'CodeExpectedError';\n    }\n}\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n    constructor(message) {\n        super(message || 'An unexpected bug occurred.');\n        Object.setPrototypeOf(this, BugIndicatingError.prototype);\n        // Because we know for sure only buggy code throws this,\n        // we definitely want to break here and fix the bug.\n        // eslint-disable-next-line no-debugger\n        // debugger;\n    }\n}\n","import { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onDidAddListener: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onDidAddListener = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n     * result of merging events and to try prevent race conditions that could arise when using related deferred and\n     * non-deferred events.\n     *\n     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n     * (eg. latency of keypress to text rendered).\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function defer(event, disposable) {\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n    }\n    Event.defer = defer;\n    /**\n     * Given an event, returns another event which only fires once.\n     *\n     * @param event The event source for the new event.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Maps an event of one type into an event of another type using a mapping function, similar to how\n     * `Array.prototype.map` works.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param map The mapping function.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * Wraps an event in another event that performs some function on the event object before firing.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param each The function to perform on the event object.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => {\n            const disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n            return addAndReturnDisposable(disposable, disposables);\n        };\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onWillAddFirstListener() {\n                listener = event(emitter.fire, emitter);\n            },\n            onDidRemoveLastListener() {\n                listener === null || listener === void 0 ? void 0 : listener.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    /**\n     * Adds the IDisposable to the store if it's set, and returns it. Useful to\n     * Event function implementation.\n     */\n    function addAndReturnDisposable(d, store) {\n        if (store instanceof Array) {\n            store.push(d);\n        }\n        else if (store) {\n            store.add(d);\n        }\n        return d;\n    }\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        let doFire;\n        const options = {\n            leakWarningThreshold,\n            onWillAddFirstListener() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    doFire = () => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    };\n                    if (typeof delay === 'number') {\n                        clearTimeout(handle);\n                        handle = setTimeout(doFire, delay);\n                    }\n                    else {\n                        if (handle === undefined) {\n                            handle = 0;\n                            queueMicrotask(doFire);\n                        }\n                    }\n                });\n            },\n            onWillRemoveListener() {\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\n                    doFire === null || doFire === void 0 ? void 0 : doFire();\n                }\n            },\n            onDidRemoveLastListener() {\n                doFire = undefined;\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function accumulate(event, delay = 0, disposable) {\n        return Event.debounce(event, (last, e) => {\n            if (!last) {\n                return [e];\n            }\n            last.push(e);\n            return last;\n        }, delay, undefined, true, undefined, disposable);\n    }\n    Event.accumulate = accumulate;\n    /**\n     * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n     * event objects from different sources do not fire the same event object.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param equals The equality condition.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     *\n     * @example\n     * ```\n     * // Fire only one time when a single window is opened or focused\n     * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n     * ```\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @example\n     * ```\n     * const event = new EventEmitter<number | undefined>().event;\n     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n     * ```\n     *\n     * @param event The event source for the new event.\n     * @param isT A function that determines what event is of the first type.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * Buffers an event until it has a listener attached.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n     * `setTimeout` when the first event listener is added.\n     * @param _buffer Internal: A source event array used for tests.\n     *\n     * @example\n     * ```\n     * // Start accumulating events, when the first listener is attached, flush\n     * // the event after a timeout such that multiple listeners attached before\n     * // the timeout would receive the event\n     * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n     * ```\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        if (disposable) {\n            disposable.add(listener);\n        }\n        const flush = () => {\n            buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onWillAddFirstListener() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                    if (disposable) {\n                        disposable.add(listener);\n                    }\n                }\n            },\n            onDidAddFirstListener() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onDidRemoveLastListener() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        if (disposable) {\n            disposable.add(emitter);\n        }\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    /**\n     * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n     *\n     * @example\n     * ```\n     * // Normal\n     * const onEnterPressNormal = Event.filter(\n     *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n     *   e.keyCode === KeyCode.Enter\n     * ).event;\n     *\n     * // Using chain\n     * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n     *   .map(e => new StandardKeyboardEvent(e))\n     *   .filter(e => e.keyCode === KeyCode.Enter)\n     * );\n     * ```\n     */\n    function chain(event, sythensize) {\n        const fn = (listener, thisArgs, disposables) => {\n            const cs = sythensize(new ChainableSynthesis());\n            return event(function (value) {\n                const result = cs.evaluate(value);\n                if (result !== HaltChainable) {\n                    listener.call(thisArgs, result);\n                }\n            }, undefined, disposables);\n        };\n        return fn;\n    }\n    Event.chain = chain;\n    const HaltChainable = Symbol('HaltChainable');\n    class ChainableSynthesis {\n        constructor() {\n            this.steps = [];\n        }\n        map(fn) {\n            this.steps.push(fn);\n            return this;\n        }\n        forEach(fn) {\n            this.steps.push(v => {\n                fn(v);\n                return v;\n            });\n            return this;\n        }\n        filter(fn) {\n            this.steps.push(v => fn(v) ? v : HaltChainable);\n            return this;\n        }\n        reduce(merge, initial) {\n            let last = initial;\n            this.steps.push(v => {\n                last = merge(last, v);\n                return last;\n            });\n            return this;\n        }\n        latch(equals = (a, b) => a === b) {\n            let firstCall = true;\n            let cache;\n            this.steps.push(value => {\n                const shouldEmit = firstCall || !equals(value, cache);\n                firstCall = false;\n                cache = value;\n                return shouldEmit ? value : HaltChainable;\n            });\n            return this;\n        }\n        evaluate(value) {\n            for (const step of this.steps) {\n                value = step(value);\n                if (value === HaltChainable) {\n                    break;\n                }\n            }\n            return value;\n        }\n    }\n    /**\n     * Creates an {@link Event} from a node event emitter.\n     */\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    /**\n     * Creates an {@link Event} from a DOM event emitter.\n     */\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    /**\n     * Creates a promise out of an event, using the {@link Event.once} helper.\n     */\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    /**\n     * Creates an event out of a promise that fires once when the promise is\n     * resolved with the result of the promise or `undefined`.\n     */\n    function fromPromise(promise) {\n        const result = new Emitter();\n        promise.then(res => {\n            result.fire(res);\n        }, () => {\n            result.fire(undefined);\n        }).finally(() => {\n            result.dispose();\n        });\n        return result.event;\n    }\n    Event.fromPromise = fromPromise;\n    function runAndSubscribe(event, handler, initial) {\n        handler(initial);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    class EmitterObserver {\n        constructor(_observable, store) {\n            this._observable = _observable;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onWillAddFirstListener: () => {\n                    _observable.addObserver(this);\n                },\n                onDidRemoveLastListener: () => {\n                    _observable.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter++;\n        }\n        handlePossibleChange(_observable) {\n            // assert(_observable === this.obs);\n        }\n        handleChange(_observable, _change) {\n            // assert(_observable === this.obs);\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter--;\n            if (this._counter === 0) {\n                this._observable.reportChanges();\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this._observable.get());\n                }\n            }\n        }\n    }\n    /**\n     * Creates an event emitter that is fired when the observable changes.\n     * Each listeners subscribes to the emitter.\n     */\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n    /**\n     * Each listener is attached to the observable directly.\n     */\n    function fromObservableLight(observable) {\n        return (listener, thisArgs, disposables) => {\n            let count = 0;\n            let didChange = false;\n            const observer = {\n                beginUpdate() {\n                    count++;\n                },\n                endUpdate() {\n                    count--;\n                    if (count === 0) {\n                        observable.reportChanges();\n                        if (didChange) {\n                            didChange = false;\n                            listener.call(thisArgs);\n                        }\n                    }\n                },\n                handlePossibleChange() {\n                    // noop\n                },\n                handleChange() {\n                    didChange = true;\n                }\n            };\n            observable.addObserver(observer);\n            observable.reportChanges();\n            const disposable = {\n                dispose() {\n                    observable.removeObserver(observer);\n                }\n            };\n            if (disposables instanceof DisposableStore) {\n                disposables.add(disposable);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(disposable);\n            }\n            return disposable;\n        };\n    }\n    Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nexport class EventProfiling {\n    constructor(name) {\n        this.listenerCount = 0;\n        this.invocationCount = 0;\n        this.elapsedOverall = 0;\n        this.durations = [];\n        this.name = `${name}_${EventProfiling._idPool++}`;\n        EventProfiling.all.add(this);\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch();\n        this.listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this.durations.push(elapsed);\n            this.elapsedOverall += elapsed;\n            this.invocationCount += 1;\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling.all = new Set();\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.threshold = threshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        var _a;\n        (_a = this._stacks) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    check(stack, listenerCount) {\n        const threshold = this.threshold;\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n}\nclass Stacktrace {\n    static create() {\n        var _a;\n        return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\nclass UniqueContainer {\n    constructor(value) {\n        this.value = value;\n    }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n    if (listeners instanceof UniqueContainer) {\n        fn(listeners);\n    }\n    else {\n        for (let i = 0; i < listeners.length; i++) {\n            const l = listeners[i];\n            if (l) {\n                fn(l);\n            }\n        }\n    }\n};\nconst _listenerFinalizers = _enableListenerGCedWarning\n    ? new FinalizationRegistry(heldValue => {\n        if (typeof heldValue === 'string') {\n            console.warn('[LEAKING LISTENER] GC\\'ed a listener that was NOT yet disposed. This is where is was created:');\n            console.warn(heldValue);\n        }\n    })\n    : undefined;\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        var _a, _b, _c, _d, _e;\n        this._size = 0;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a = this._options) === null || _a === void 0 ? void 0 : _a.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : undefined;\n        this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;\n    }\n    dispose() {\n        var _a, _b, _c, _d;\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) === this) {\n                this._deliveryQueue.reset();\n            }\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = this._listeners;\n                    queueMicrotask(() => {\n                        forEachListener(listeners, l => { var _a; return (_a = l.stack) === null || _a === void 0 ? void 0 : _a.print(); });\n                    });\n                }\n                this._listeners = undefined;\n                this._size = 0;\n            }\n            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);\n            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        var _a;\n        (_a = this._event) !== null && _a !== void 0 ? _a : (this._event = (callback, thisArgs, disposables) => {\n            var _a, _b, _c, _d, _e;\n            if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {\n                console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);\n                return Disposable.None;\n            }\n            if (this._disposed) {\n                // todo: should we warn if a listener is added to a disposed emitter? This happens often\n                return Disposable.None;\n            }\n            if (thisArgs) {\n                callback = callback.bind(thisArgs);\n            }\n            const contained = new UniqueContainer(callback);\n            let removeMonitor;\n            let stack;\n            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n                // check and record this emitter for potential leakage\n                contained.stack = Stacktrace.create();\n                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n            }\n            if (_enableDisposeWithListenerWarning) {\n                contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n            }\n            if (!this._listeners) {\n                (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillAddFirstListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n                this._listeners = contained;\n                (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n            }\n            else if (this._listeners instanceof UniqueContainer) {\n                (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : (this._deliveryQueue = new EventDeliveryQueuePrivate());\n                this._listeners = [this._listeners, contained];\n            }\n            else {\n                this._listeners.push(contained);\n            }\n            this._size++;\n            const result = toDisposable(() => {\n                _listenerFinalizers === null || _listenerFinalizers === void 0 ? void 0 : _listenerFinalizers.unregister(result);\n                removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n                this._removeListener(contained);\n            });\n            if (disposables instanceof DisposableStore) {\n                disposables.add(result);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(result);\n            }\n            if (_listenerFinalizers) {\n                const stack = new Error().stack.split('\\n').slice(2).join('\\n').trim();\n                _listenerFinalizers.register(result, stack, result);\n            }\n            return result;\n        });\n        return this._event;\n    }\n    _removeListener(listener) {\n        var _a, _b, _c, _d;\n        (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n        if (!this._listeners) {\n            return; // expected if a listener gets disposed\n        }\n        if (this._size === 1) {\n            this._listeners = undefined;\n            (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n            this._size = 0;\n            return;\n        }\n        // size > 1 which requires that listeners be a list:\n        const listeners = this._listeners;\n        const index = listeners.indexOf(listener);\n        if (index === -1) {\n            console.log('disposed?', this._disposed);\n            console.log('size?', this._size);\n            console.log('arr?', JSON.stringify(this._listeners));\n            throw new Error('Attempted to dispose unknown listener');\n        }\n        this._size--;\n        listeners[index] = undefined;\n        const adjustDeliveryQueue = this._deliveryQueue.current === this;\n        if (this._size * compactionThreshold <= listeners.length) {\n            let n = 0;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listeners[i]) {\n                    listeners[n++] = listeners[i];\n                }\n                else if (adjustDeliveryQueue) {\n                    this._deliveryQueue.end--;\n                    if (n < this._deliveryQueue.i) {\n                        this._deliveryQueue.i--;\n                    }\n                }\n            }\n            listeners.length = n;\n        }\n    }\n    _deliver(listener, value) {\n        var _a;\n        if (!listener) {\n            return;\n        }\n        const errorHandler = ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onListenerError) || onUnexpectedError;\n        if (!errorHandler) {\n            listener.value(value);\n            return;\n        }\n        try {\n            listener.value(value);\n        }\n        catch (e) {\n            errorHandler(e);\n        }\n    }\n    /** Delivers items in the queue. Assumes the queue is ready to go. */\n    _deliverQueue(dq) {\n        const listeners = dq.current._listeners;\n        while (dq.i < dq.end) {\n            // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n            this._deliver(listeners[dq.i++], dq.value);\n        }\n        dq.reset();\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b, _c, _d;\n        if ((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) {\n            this._deliverQueue(this._deliveryQueue);\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n        }\n        (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);\n        if (!this._listeners) {\n            // no-op\n        }\n        else if (this._listeners instanceof UniqueContainer) {\n            this._deliver(this._listeners, event);\n        }\n        else {\n            const dq = this._deliveryQueue;\n            dq.enqueue(this, event, this._listeners.length);\n            this._deliverQueue(dq);\n        }\n        (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();\n    }\n    hasListeners() {\n        return this._size > 0;\n    }\n}\nexport const createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nclass EventDeliveryQueuePrivate {\n    constructor() {\n        /**\n         * Index in current's listener list.\n         */\n        this.i = -1;\n        /**\n         * The last index in the listener's list to deliver.\n         */\n        this.end = 0;\n    }\n    enqueue(emitter, value, end) {\n        this.i = 0;\n        this.end = end;\n        this.current = emitter;\n        this.value = value;\n    }\n    reset() {\n        this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n        this.current = undefined;\n        this.value = undefined;\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                if (this._eventQueue.size > 0) {\n                    const events = Array.from(this._eventQueue);\n                    this._eventQueue.clear();\n                    super.fire(this._mergeFn(events));\n                }\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._size) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._queuedEvents = [];\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    fire(event) {\n        if (!this.hasListeners()) {\n            return;\n        }\n        this._queuedEvents.push(event);\n        if (this._queuedEvents.length === 1) {\n            queueMicrotask(() => {\n                if (this._mergeFn) {\n                    super.fire(this._mergeFn(this._queuedEvents));\n                }\n                else {\n                    this._queuedEvents.forEach(e => super.fire(e));\n                }\n                this._queuedEvents = [];\n            });\n        }\n    }\n}\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\n        });\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return toDisposable(createSingleCallFunction(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        var _a;\n        (_a = e.listener) === null || _a === void 0 ? void 0 : _a.dispose();\n        e.listener = null;\n    }\n    dispose() {\n        var _a;\n        this.emitter.dispose();\n        for (const e of this.events) {\n            (_a = e.listener) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n        this.events = [];\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onDidAddFirstListener: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onDidRemoveLastListener: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { startsWithIgnoreCase } from './strings.js';\nexport function isPathSeparator(code) {\n    return code === 47 /* CharCode.Slash */ || code === 92 /* CharCode.Backslash */;\n}\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath) {\n    return osPath.replace(/[\\\\/]/g, posix.sep);\n}\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath) {\n    if (osPath.indexOf('/') === -1) {\n        osPath = toSlashes(osPath);\n    }\n    if (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n        osPath = '/' + osPath;\n    }\n    return osPath;\n}\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path, sep = posix.sep) {\n    if (!path) {\n        return '';\n    }\n    const len = path.length;\n    const firstLetter = path.charCodeAt(0);\n    if (isPathSeparator(firstLetter)) {\n        if (isPathSeparator(path.charCodeAt(1))) {\n            // UNC candidate \\\\localhost\\shares\\ddd\n            //               ^^^^^^^^^^^^^^^^^^^\n            if (!isPathSeparator(path.charCodeAt(2))) {\n                let pos = 3;\n                const start = pos;\n                for (; pos < len; pos++) {\n                    if (isPathSeparator(path.charCodeAt(pos))) {\n                        break;\n                    }\n                }\n                if (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n                    pos += 1;\n                    for (; pos < len; pos++) {\n                        if (isPathSeparator(path.charCodeAt(pos))) {\n                            return path.slice(0, pos + 1) // consume this separator\n                                .replace(/[\\\\/]/g, sep);\n                        }\n                    }\n                }\n            }\n        }\n        // /user/far\n        // ^\n        return sep;\n    }\n    else if (isWindowsDriveLetter(firstLetter)) {\n        // check for windows drive letter c:\\ or c:\n        if (path.charCodeAt(1) === 58 /* CharCode.Colon */) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n                // C:\\fff\n                // ^^^\n                return path.slice(0, 2) + sep;\n            }\n            else {\n                // C:\n                // ^^\n                return path.slice(0, 2);\n            }\n        }\n    }\n    // check for URI\n    // scheme://authority/path\n    // ^^^^^^^^^^^^^^^^^^^\n    let pos = path.indexOf('://');\n    if (pos !== -1) {\n        pos += 3; // 3 -> \"://\".length\n        for (; pos < len; pos++) {\n            if (isPathSeparator(path.charCodeAt(pos))) {\n                return path.slice(0, pos + 1); // consume this separator\n            }\n        }\n    }\n    return '';\n}\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {\n    if (base === parentCandidate) {\n        return true;\n    }\n    if (!base || !parentCandidate) {\n        return false;\n    }\n    if (parentCandidate.length > base.length) {\n        return false;\n    }\n    if (ignoreCase) {\n        const beginsWith = startsWithIgnoreCase(base, parentCandidate);\n        if (!beginsWith) {\n            return false;\n        }\n        if (parentCandidate.length === base.length) {\n            return true; // same path, different casing\n        }\n        let sepOffset = parentCandidate.length;\n        if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n            sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n        }\n        return base.charAt(sepOffset) === separator;\n    }\n    if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n        parentCandidate += separator;\n    }\n    return base.indexOf(parentCandidate) === 0;\n}\nexport function isWindowsDriveLetter(char0) {\n    return char0 >= 65 /* CharCode.A */ && char0 <= 90 /* CharCode.Z */ || char0 >= 97 /* CharCode.a */ && char0 <= 122 /* CharCode.z */;\n}\nexport function hasDriveLetter(path, isWindowsOS = isWindows) {\n    if (isWindowsOS) {\n        return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* CharCode.Colon */;\n    }\n    return false;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport { getKoreanAltChars } from './naturalLanguage/korean.js';\nimport * as strings from './strings.js';\n// Combined filters\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter) {\n    return function (word, wordToMatchAgainst) {\n        for (let i = 0, len = filter.length; i < len; i++) {\n            const match = filter[i](word, wordToMatchAgainst);\n            if (match) {\n                return match;\n            }\n        }\n        return null;\n    };\n}\n// Prefix\nexport const matchesStrictPrefix = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n        return null;\n    }\n    let matches;\n    if (ignoreCase) {\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n    }\n    else {\n        matches = wordToMatchAgainst.indexOf(word) === 0;\n    }\n    if (!matches) {\n        return null;\n    }\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n// Contiguous Substring\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n    if (index === -1) {\n        return null;\n    }\n    return [{ start: index, end: index + word.length }];\n}\n// Substring\nexport function matchesSubString(word, wordToMatchAgainst) {\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === wordToMatchAgainst.length) {\n        return null;\n    }\n    else {\n        if (word[i] === wordToMatchAgainst[j]) {\n            let result = null;\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n                return join({ start: j, end: j + 1 }, result);\n            }\n            return null;\n        }\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n    }\n}\n// CamelCase\nfunction isLower(code) {\n    return 97 /* CharCode.a */ <= code && code <= 122 /* CharCode.z */;\n}\nexport function isUpper(code) {\n    return 65 /* CharCode.A */ <= code && code <= 90 /* CharCode.Z */;\n}\nfunction isNumber(code) {\n    return 48 /* CharCode.Digit0 */ <= code && code <= 57 /* CharCode.Digit9 */;\n}\nfunction isWhitespace(code) {\n    return (code === 32 /* CharCode.Space */\n        || code === 9 /* CharCode.Tab */\n        || code === 10 /* CharCode.LineFeed */\n        || code === 13 /* CharCode.CarriageReturn */);\n}\nconst wordSeparators = new Set();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n'()[]{}<>`\\'\"-/;:,.?!'\n    .split('')\n    .forEach(s => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n    return isWhitespace(code) || wordSeparators.has(code);\n}\nfunction charactersMatch(codeA, codeB) {\n    return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\nconst alternateCharsCache = new Map();\n/**\n * Gets alternative codes to the character code passed in. This comes in the\n * form of an array of character codes, all of which must match _in order_ to\n * successfully match.\n *\n * @param code The character code to check.\n */\nfunction getAlternateCodes(code) {\n    if (alternateCharsCache.has(code)) {\n        return alternateCharsCache.get(code);\n    }\n    // NOTE: This function is written in such a way that it can be extended in\n    // the future, but right now the return type takes into account it's only\n    // supported by a single \"alt codes provider\".\n    // `ArrayLike<ArrayLike<number>>` is a more appropriate type if changed.\n    let result;\n    const codes = getKoreanAltChars(code);\n    if (codes) {\n        result = codes;\n    }\n    alternateCharsCache.set(code, result);\n    return result;\n}\nfunction isAlphanumeric(code) {\n    return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n    if (tail.length === 0) {\n        tail = [head];\n    }\n    else if (head.end === tail[0].start) {\n        tail[0].start = head.start;\n    }\n    else {\n        tail.unshift(head);\n    }\n    return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n    for (let i = start; i < camelCaseWord.length; i++) {\n        const c = camelCaseWord.charCodeAt(i);\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === camelCaseWord.length) {\n        return null;\n    }\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextUpperIndex = j + 1;\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n            nextUpperIndex++;\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isAlphanumeric(code)) {\n            alpha++;\n        }\n        if (isNumber(code)) {\n            numeric++;\n        }\n    }\n    const upperPercent = upper / word.length;\n    const lowerPercent = lower / word.length;\n    const alphaPercent = alpha / word.length;\n    const numericPercent = numeric / word.length;\n    return { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\nfunction isUpperCaseWord(analysis) {\n    const { upperPercent, lowerPercent } = analysis;\n    return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n    let upper = 0, lower = 0, code = 0, whitespace = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isWhitespace(code)) {\n            whitespace++;\n        }\n    }\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\n        return word.length <= 30;\n    }\n    else {\n        return upper <= 5;\n    }\n}\nexport function matchesCamelCase(word, camelCaseWord) {\n    if (!camelCaseWord) {\n        return null;\n    }\n    camelCaseWord = camelCaseWord.trim();\n    if (camelCaseWord.length === 0) {\n        return null;\n    }\n    if (!isCamelCasePattern(word)) {\n        return null;\n    }\n    // TODO: Consider removing this check\n    if (camelCaseWord.length > 60) {\n        camelCaseWord = camelCaseWord.substring(0, 60);\n    }\n    const analysis = analyzeCamelCaseWord(camelCaseWord);\n    if (!isCamelCaseWord(analysis)) {\n        if (!isUpperCaseWord(analysis)) {\n            return null;\n        }\n        camelCaseWord = camelCaseWord.toLowerCase();\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n        i = nextAnchor(camelCaseWord, i + 1);\n    }\n    return result;\n}\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\nexport function matchesWords(word, target, contiguous = false) {\n    if (!target || target.length === 0) {\n        return null;\n    }\n    let result = null;\n    let targetIndex = 0;\n    word = word.toLowerCase();\n    target = target.toLowerCase();\n    while (targetIndex < target.length) {\n        result = _matchesWords(word, target, 0, targetIndex, contiguous);\n        if (result !== null) {\n            break;\n        }\n        targetIndex = nextWord(target, targetIndex + 1);\n    }\n    return result;\n}\nfunction _matchesWords(word, target, wordIndex, targetIndex, contiguous) {\n    let targetIndexOffset = 0;\n    if (wordIndex === word.length) {\n        return [];\n    }\n    else if (targetIndex === target.length) {\n        return null;\n    }\n    else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {\n        // Verify alternate characters before exiting\n        const altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n        if (!altChars) {\n            return null;\n        }\n        for (let k = 0; k < altChars.length; k++) {\n            if (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {\n                return null;\n            }\n        }\n        targetIndexOffset += altChars.length - 1;\n    }\n    let result = null;\n    let nextWordIndex = targetIndex + targetIndexOffset + 1;\n    result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n    if (!contiguous) {\n        while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n            result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n            nextWordIndex++;\n        }\n    }\n    if (!result) {\n        return null;\n    }\n    // If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).\n    // We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.\n    if (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {\n        // Verify alternate characters before exiting\n        const altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n        if (!altChars) {\n            return result;\n        }\n        for (let k = 0; k < altChars.length; k++) {\n            if (altChars[k] !== target.charCodeAt(targetIndex + k)) {\n                return result;\n            }\n        }\n    }\n    return join({ start: targetIndex, end: targetIndex + targetIndexOffset + 1 }, result);\n}\nfunction nextWord(word, start) {\n    for (let i = start; i < word.length; i++) {\n        if (isWordSeparator(word.charCodeAt(i)) ||\n            (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return word.length;\n}\n// Fuzzy\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n        return null; // return early for invalid input\n    }\n    // Form RegExp for wildcard matches\n    let regexp = fuzzyRegExpCache.get(word);\n    if (!regexp) {\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n        fuzzyRegExpCache.set(word, regexp);\n    }\n    // RegExp Filter\n    const match = regexp.exec(wordToMatchAgainst);\n    if (match) {\n        return [{ start: match.index, end: match.index + match[0].length }];\n    }\n    // Default Filter\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern, word) {\n    const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n    return score ? createMatches(score) : null;\n}\nexport function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n    const max = Math.min(13, pattern.length);\n    for (; patternPos < max; patternPos++) {\n        const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });\n        if (result) {\n            return result;\n        }\n    }\n    return [0, wordPos];\n}\n//#region --- fuzzyScore ---\nexport function createMatches(score) {\n    if (typeof score === 'undefined') {\n        return [];\n    }\n    const res = [];\n    const wordPos = score[1];\n    for (let i = score.length - 1; i > 1; i--) {\n        const pos = score[i] + wordPos;\n        const last = res[res.length - 1];\n        if (last && last.end === pos) {\n            last.end = pos + 1;\n        }\n        else {\n            res.push({ start: pos, end: pos + 1 });\n        }\n    }\n    return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n    const table = [];\n    const row = [];\n    for (let i = 0; i <= _maxLen; i++) {\n        row[i] = 0;\n    }\n    for (let i = 0; i <= _maxLen; i++) {\n        table.push(row.slice(0));\n    }\n    return table;\n}\nfunction initArr(maxLen) {\n    const row = [];\n    for (let i = 0; i <= maxLen; i++) {\n        row[i] = 0;\n    }\n    return row;\n}\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = initTable();\nconst _debug = false;\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n    function pad(s, n, pad = ' ') {\n        while (s.length < n) {\n            s = pad + s;\n        }\n        return s;\n    }\n    let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n    for (let i = 0; i <= patternLen; i++) {\n        if (i === 0) {\n            ret += ' |';\n        }\n        else {\n            ret += `${pattern[i - 1]}|`;\n        }\n        ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n    }\n    return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n    pattern = pattern.substr(patternStart);\n    word = word.substr(wordStart);\n    console.log(printTable(_table, pattern, pattern.length, word, word.length));\n    console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n    console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\nfunction isSeparatorAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.codePointAt(index);\n    switch (code) {\n        case 95 /* CharCode.Underline */:\n        case 45 /* CharCode.Dash */:\n        case 46 /* CharCode.Period */:\n        case 32 /* CharCode.Space */:\n        case 47 /* CharCode.Slash */:\n        case 92 /* CharCode.Backslash */:\n        case 39 /* CharCode.SingleQuote */:\n        case 34 /* CharCode.DoubleQuote */:\n        case 58 /* CharCode.Colon */:\n        case 36 /* CharCode.DollarSign */:\n        case 60 /* CharCode.LessThan */:\n        case 62 /* CharCode.GreaterThan */:\n        case 40 /* CharCode.OpenParen */:\n        case 41 /* CharCode.CloseParen */:\n        case 91 /* CharCode.OpenSquareBracket */:\n        case 93 /* CharCode.CloseSquareBracket */:\n        case 123 /* CharCode.OpenCurlyBrace */:\n        case 125 /* CharCode.CloseCurlyBrace */:\n            return true;\n        case undefined:\n            return false;\n        default:\n            if (strings.isEmojiImprecise(code)) {\n                return true;\n            }\n            return false;\n    }\n}\nfunction isWhitespaceAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.charCodeAt(index);\n    switch (code) {\n        case 32 /* CharCode.Space */:\n        case 9 /* CharCode.Tab */:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n    return word[pos] !== wordLow[pos];\n}\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n    while (patternPos < patternLen && wordPos < wordLen) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            if (fillMinWordPosArr) {\n                // Remember the min word position for each pattern position\n                _minWordMatchPos[patternPos] = wordPos;\n            }\n            patternPos += 1;\n        }\n        wordPos += 1;\n    }\n    return patternPos === patternLen; // pattern must be exhausted\n}\nexport var FuzzyScore;\n(function (FuzzyScore) {\n    /**\n     * No matches and value `-100`\n     */\n    FuzzyScore.Default = ([-100, 0]);\n    function isDefault(score) {\n        return !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n    }\n    FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\nexport class FuzzyScoreOptions {\n    constructor(firstMatchCanBeWeak, boostFullMatch) {\n        this.firstMatchCanBeWeak = firstMatchCanBeWeak;\n        this.boostFullMatch = boostFullMatch;\n    }\n}\nFuzzyScoreOptions.default = { boostFullMatch: true, firstMatchCanBeWeak: false };\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options = FuzzyScoreOptions.default) {\n    const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n    const wordLen = word.length > _maxLen ? _maxLen : word.length;\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n        return undefined;\n    }\n    // Run a simple check if the characters of pattern occur\n    // (in order) at all in word. If that isn't the case we\n    // stop because no match will be possible\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n        return undefined;\n    }\n    // Find the max matching word position for each pattern position\n    // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n    _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n    let row = 1;\n    let column = 1;\n    let patternPos = patternStart;\n    let wordPos = wordStart;\n    const hasStrongFirstMatch = [false];\n    // There will be a match, fill in tables\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n        // Reduce search space to possible matching word positions and to possible access from next row\n        const minWordMatchPos = _minWordMatchPos[patternPos];\n        const maxWordMatchPos = _maxWordMatchPos[patternPos];\n        const nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n        for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n            let score = Number.MIN_SAFE_INTEGER;\n            let canComeDiag = false;\n            if (wordPos <= maxWordMatchPos) {\n                score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n            }\n            let diagScore = 0;\n            if (score !== Number.MAX_SAFE_INTEGER) {\n                canComeDiag = true;\n                diagScore = score + _table[row - 1][column - 1];\n            }\n            const canComeLeft = wordPos > minWordMatchPos;\n            const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n            const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n            const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n            if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n                // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n                _table[row][column] = leftLeftScore;\n                _arrows[row][column] = 3 /* Arrow.LeftLeft */;\n                _diag[row][column] = 0;\n            }\n            else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n                // always prefer choosing left since that means a match is earlier in the word\n                _table[row][column] = leftScore;\n                _arrows[row][column] = 2 /* Arrow.Left */;\n                _diag[row][column] = 0;\n            }\n            else if (canComeDiag) {\n                _table[row][column] = diagScore;\n                _arrows[row][column] = 1 /* Arrow.Diag */;\n                _diag[row][column] = _diag[row - 1][column - 1] + 1;\n            }\n            else {\n                throw new Error(`not possible`);\n            }\n        }\n    }\n    if (_debug) {\n        printTables(pattern, patternStart, word, wordStart);\n    }\n    if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n        return undefined;\n    }\n    row--;\n    column--;\n    const result = [_table[row][column], wordStart];\n    let backwardsDiagLength = 0;\n    let maxMatchColumn = 0;\n    while (row >= 1) {\n        // Find the column where we go diagonally up\n        let diagColumn = column;\n        do {\n            const arrow = _arrows[row][diagColumn];\n            if (arrow === 3 /* Arrow.LeftLeft */) {\n                diagColumn = diagColumn - 2;\n            }\n            else if (arrow === 2 /* Arrow.Left */) {\n                diagColumn = diagColumn - 1;\n            }\n            else {\n                // found the diagonal\n                break;\n            }\n        } while (diagColumn >= 1);\n        // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n        if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n            && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n            && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n            && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n        ) {\n            diagColumn = column;\n        }\n        if (diagColumn === column) {\n            // this is a contiguous match\n            backwardsDiagLength++;\n        }\n        else {\n            backwardsDiagLength = 1;\n        }\n        if (!maxMatchColumn) {\n            // remember the last matched column\n            maxMatchColumn = diagColumn;\n        }\n        row--;\n        column = diagColumn - 1;\n        result.push(column);\n    }\n    if (wordLen === patternLen && options.boostFullMatch) {\n        // the word matches the pattern with all characters!\n        // giving the score a total match boost (to come up ahead other words)\n        result[0] += 2;\n    }\n    // Add 1 penalty for each skipped character in the word\n    const skippedCharsCount = maxMatchColumn - patternLen;\n    result[0] -= skippedCharsCount;\n    return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n    let patternPos = patternLen - 1;\n    let wordPos = wordLen - 1;\n    while (patternPos >= patternStart && wordPos >= wordStart) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            _maxWordMatchPos[patternPos] = wordPos;\n            patternPos--;\n        }\n        wordPos--;\n    }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\n        return Number.MIN_SAFE_INTEGER;\n    }\n    let score = 1;\n    let isGapLocation = false;\n    if (wordPos === (patternPos - patternStart)) {\n        // common prefix: `foobar <-> foobaz`\n        //                            ^^^^^\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    }\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n        // hitting upper-case: `foo <-> forOthers`\n        //                              ^^ ^\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n        isGapLocation = true;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n        // hitting a separator: `. <-> foo.bar`\n        //                                ^\n        score = 5;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n        // post separator: `foo <-> bar_foo`\n        //                              ^^^\n        score = 5;\n        isGapLocation = true;\n    }\n    if (score > 1 && patternPos === patternStart) {\n        outFirstMatchStrong[0] = true;\n    }\n    if (!isGapLocation) {\n        isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n    }\n    //\n    if (patternPos === patternStart) { // first character in pattern\n        if (wordPos > wordStart) {\n            // the first pattern character would match a word character that is not at the word start\n            // so introduce a penalty to account for the gap preceding this match\n            score -= isGapLocation ? 3 : 5;\n        }\n    }\n    else {\n        if (newMatchStart) {\n            // this would be the beginning of a new match (i.e. there would be a gap before this location)\n            score += isGapLocation ? 2 : 0;\n        }\n        else {\n            // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n            score += isGapLocation ? 0 : 1;\n        }\n    }\n    if (wordPos + 1 === wordLen) {\n        // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n        // so pretend there is a gap after the last character in the word to normalize things\n        score -= isGapLocation ? 3 : 5;\n    }\n    return score;\n}\n//#endregion\n//#region --- graceful ---\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {\n    let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n    if (top && !aggressive) {\n        // when using the original pattern yield a result we`\n        // return it unless we are aggressive and try to find\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n        return top;\n    }\n    if (pattern.length >= 3) {\n        // When the pattern is long enough then try a few (max 7)\n        // permutations of the pattern to find a better match. The\n        // permutations only swap neighbouring characters, e.g\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n        const tries = Math.min(7, pattern.length - 1);\n        for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n            const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n            if (newPattern) {\n                const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n                if (candidate) {\n                    candidate[0] -= 3; // permutation penalty\n                    if (!top || candidate[0] > top[0]) {\n                        top = candidate;\n                    }\n                }\n            }\n        }\n    }\n    return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n    if (patternPos + 1 >= pattern.length) {\n        return undefined;\n    }\n    const swap1 = pattern[patternPos];\n    const swap2 = pattern[patternPos + 1];\n    if (swap1 === swap2) {\n        return undefined;\n    }\n    return pattern.slice(0, patternPos)\n        + swap2\n        + swap1\n        + pattern.slice(patternPos + 2);\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Given a function, returns a function that is only calling that function once.\n */\nexport function createSingleCallFunction(fn, fnDidRunCallback) {\n    const _this = this;\n    let didCall = false;\n    let result;\n    return function () {\n        if (didCall) {\n            return result;\n        }\n        didCall = true;\n        if (fnDidRunCallback) {\n            try {\n                result = fn.apply(_this, arguments);\n            }\n            finally {\n                fnDidRunCallback();\n            }\n        }\n        else {\n            result = fn.apply(_this, arguments);\n        }\n        return result;\n    };\n}\n","import { createMatches as createFuzzyMatches, fuzzyScore } from './filters.js';\nimport { sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { stripWildcards } from './strings.js';\nconst NO_SCORE2 = [undefined, []];\nexport function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {\n    // Score: multiple inputs\n    const preparedQuery = query;\n    if (preparedQuery.values && preparedQuery.values.length > 1) {\n        return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n    }\n    // Score: single input\n    return doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\nfunction doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {\n    let totalScore = 0;\n    const totalMatches = [];\n    for (const queryPiece of query) {\n        const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n        if (typeof score !== 'number') {\n            // if a single query value does not match, return with\n            // no score entirely, we require all queries to match\n            return NO_SCORE2;\n        }\n        totalScore += score;\n        totalMatches.push(...matches);\n    }\n    // if we have a score, ensure that the positions are\n    // sorted in ascending order and distinct\n    return [totalScore, normalizeMatches(totalMatches)];\n}\nfunction doScoreFuzzy2Single(target, query, patternStart, wordStart) {\n    const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, { firstMatchCanBeWeak: true, boostFullMatch: true });\n    if (!score) {\n        return NO_SCORE2;\n    }\n    return [score[0], createFuzzyMatches(score)];\n}\nconst NO_ITEM_SCORE = Object.freeze({ score: 0 });\nfunction normalizeMatches(matches) {\n    // sort matches by start to be able to normalize\n    const sortedMatches = matches.sort((matchA, matchB) => {\n        return matchA.start - matchB.start;\n    });\n    // merge matches that overlap\n    const normalizedMatches = [];\n    let currentMatch = undefined;\n    for (const match of sortedMatches) {\n        // if we have no current match or the matches\n        // do not overlap, we take it as is and remember\n        // it for future merging\n        if (!currentMatch || !matchOverlaps(currentMatch, match)) {\n            currentMatch = match;\n            normalizedMatches.push(match);\n        }\n        // otherwise we merge the matches\n        else {\n            currentMatch.start = Math.min(currentMatch.start, match.start);\n            currentMatch.end = Math.max(currentMatch.end, match.end);\n        }\n    }\n    return normalizedMatches;\n}\nfunction matchOverlaps(matchA, matchB) {\n    if (matchA.end < matchB.start) {\n        return false; // A ends before B starts\n    }\n    if (matchB.end < matchA.start) {\n        return false; // B ends before A starts\n    }\n    return true;\n}\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query) {\n    return query.startsWith('\"') && query.endsWith('\"');\n}\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original) {\n    if (typeof original !== 'string') {\n        original = '';\n    }\n    const originalLowercase = original.toLowerCase();\n    const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\n    const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n    const expectExactMatch = queryExpectsExactMatch(original);\n    let values = undefined;\n    const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n    if (originalSplit.length > 1) {\n        for (const originalPiece of originalSplit) {\n            const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n            const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);\n            if (normalizedPiece) {\n                if (!values) {\n                    values = [];\n                }\n                values.push({\n                    original: originalPiece,\n                    originalLowercase: originalPiece.toLowerCase(),\n                    pathNormalized: pathNormalizedPiece,\n                    normalized: normalizedPiece,\n                    normalizedLowercase: normalizedLowercasePiece,\n                    expectContiguousMatch: expectExactMatchPiece\n                });\n            }\n        }\n    }\n    return { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };\n}\nfunction normalizeQuery(original) {\n    let pathNormalized;\n    if (isWindows) {\n        pathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n    }\n    else {\n        pathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n    }\n    // we remove quotes here because quotes are used for exact match search\n    const normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, '');\n    return {\n        pathNormalized,\n        normalized,\n        normalizedLowercase: normalized.toLowerCase()\n    };\n}\nexport function pieceToQuery(arg1) {\n    if (Array.isArray(arg1)) {\n        return prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n    }\n    return prepareQuery(arg1.original);\n}\n//#endregion\n","import { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n            //           in which case also matches (Path Sep followed by Path Val)\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Treat globstar specially\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            // Anything else, not globstar\n            else {\n                // States\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    // Support brace expansion\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    // Support brackets\n                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                        let res;\n                        // range operator\n                        if (char === '-') {\n                            res = char;\n                        }\n                        // negation operator (only valid on first index in bracket)\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        // glob split matching is not allowed within character ranges\n                        // see http://man7.org/linux/man-pages/man7/glob.7.html\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        // anything else gets escaped\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            // Converts {foo,bar} => [foo|bar]\n                            const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                // Tail: Add the slash we had split on if there is more to\n                // come and the remaining pattern is not a globstar\n                // For example if pattern: some/**/*.js we want the \"/\" after\n                // some to be included in the RegEx to prevent a folder called\n                // \"something\" to match as well.\n                if (index < segments.length - 1 && // more segments to come after this\n                    (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...\n                        index + 2 < segments.length // ...next segment is ** but there is more segments after that\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            // update globstar state\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle relative patterns\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            // skip glob matching if `base` is not a parent of `path`\n            return null;\n        }\n        // Given we have checked `base` being a parent of `path`,\n        // we can now remove the `base` portion of the `path`\n        // and only match on the remaining path components\n        // For that we try to extract the portion of the `path`\n        // that comes after the `base` portion. We have to account\n        // for the fact that `base` might end in a path separator\n        // (https://github.com/microsoft/vscode/issues/162498)\n        return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n    };\n    // Make sure to preserve associated metadata\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result; // immediately return as soon as the first expression matches\n                }\n                // If the result is a promise, we have to keep it for\n                // later processing and await the result properly.\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            // With result promises, we have to loop over each and\n            // await the result before we can return any result.\n            if (resultPromises) {\n                return (async () => {\n                    for (const resultPromise of resultPromises) {\n                        const result = await resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                })();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result; // immediately return as soon as the first expression matches\n            }\n            // If the result is a promise, we have to keep it for\n            // later processing and await the result properly.\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        // With result promises, we have to loop over each and\n        // await the result before we can return any result.\n        if (resultPromises) {\n            return (async () => {\n                for (const resultPromise of resultPromises) {\n                    const result = await resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            })();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', () => name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\n/**\n * Return a hash value for an object.\n */\nexport function hash(obj) {\n    return doHash(obj, 0);\n}\nexport function doHash(obj, hashVal) {\n    switch (typeof obj) {\n        case 'object':\n            if (obj === null) {\n                return numberHash(349, hashVal);\n            }\n            else if (Array.isArray(obj)) {\n                return arrayHash(obj, hashVal);\n            }\n            return objectHash(obj, hashVal);\n        case 'string':\n            return stringHash(obj, hashVal);\n        case 'boolean':\n            return booleanHash(obj, hashVal);\n        case 'number':\n            return numberHash(obj, hashVal);\n        case 'undefined':\n            return numberHash(937, hashVal);\n        default:\n            return numberHash(617, hashVal);\n    }\n}\nexport function numberHash(val, initialHashVal) {\n    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32\n}\nfunction booleanHash(b, initialHashVal) {\n    return numberHash(b ? 433 : 863, initialHashVal);\n}\nexport function stringHash(s, hashVal) {\n    hashVal = numberHash(149417, hashVal);\n    for (let i = 0, length = s.length; i < length; i++) {\n        hashVal = numberHash(s.charCodeAt(i), hashVal);\n    }\n    return hashVal;\n}\nfunction arrayHash(arr, initialHashVal) {\n    initialHashVal = numberHash(104579, initialHashVal);\n    return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\n}\nfunction objectHash(obj, initialHashVal) {\n    initialHashVal = numberHash(181387, initialHashVal);\n    return Object.keys(obj).sort().reduce((hashVal, key) => {\n        hashVal = stringHash(key, hashVal);\n        return doHash(obj[key], hashVal);\n    }, initialHashVal);\n}\nfunction leftRotate(value, bits, totalBits = 32) {\n    // delta + bits = totalBits\n    const delta = totalBits - bits;\n    // All ones, expect `delta` zeros aligned to the right\n    const mask = ~((1 << delta) - 1);\n    // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\n    return ((value << bits) | ((mask & value) >>> delta)) >>> 0;\n}\nfunction fill(dest, index = 0, count = dest.byteLength, value = 0) {\n    for (let i = 0; i < count; i++) {\n        dest[index + i] = value;\n    }\n}\nfunction leftPad(value, length, char = '0') {\n    while (value.length < length) {\n        value = char + value;\n    }\n    return value;\n}\nexport function toHexString(bufferOrValue, bitsize = 32) {\n    if (bufferOrValue instanceof ArrayBuffer) {\n        return Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');\n    }\n    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);\n}\n/**\n * A SHA1 implementation that works with strings and does not allocate.\n */\nexport class StringSHA1 {\n    constructor() {\n        this._h0 = 0x67452301;\n        this._h1 = 0xEFCDAB89;\n        this._h2 = 0x98BADCFE;\n        this._h3 = 0x10325476;\n        this._h4 = 0xC3D2E1F0;\n        this._buff = new Uint8Array(64 /* SHA1Constant.BLOCK_SIZE */ + 3 /* to fit any utf-8 */);\n        this._buffDV = new DataView(this._buff.buffer);\n        this._buffLen = 0;\n        this._totalLen = 0;\n        this._leftoverHighSurrogate = 0;\n        this._finished = false;\n    }\n    update(str) {\n        const strLen = str.length;\n        if (strLen === 0) {\n            return;\n        }\n        const buff = this._buff;\n        let buffLen = this._buffLen;\n        let leftoverHighSurrogate = this._leftoverHighSurrogate;\n        let charCode;\n        let offset;\n        if (leftoverHighSurrogate !== 0) {\n            charCode = leftoverHighSurrogate;\n            offset = -1;\n            leftoverHighSurrogate = 0;\n        }\n        else {\n            charCode = str.charCodeAt(0);\n            offset = 0;\n        }\n        while (true) {\n            let codePoint = charCode;\n            if (strings.isHighSurrogate(charCode)) {\n                if (offset + 1 < strLen) {\n                    const nextCharCode = str.charCodeAt(offset + 1);\n                    if (strings.isLowSurrogate(nextCharCode)) {\n                        offset++;\n                        codePoint = strings.computeCodePoint(charCode, nextCharCode);\n                    }\n                    else {\n                        // illegal => unicode replacement character\n                        codePoint = 65533 /* SHA1Constant.UNICODE_REPLACEMENT */;\n                    }\n                }\n                else {\n                    // last character is a surrogate pair\n                    leftoverHighSurrogate = charCode;\n                    break;\n                }\n            }\n            else if (strings.isLowSurrogate(charCode)) {\n                // illegal => unicode replacement character\n                codePoint = 65533 /* SHA1Constant.UNICODE_REPLACEMENT */;\n            }\n            buffLen = this._push(buff, buffLen, codePoint);\n            offset++;\n            if (offset < strLen) {\n                charCode = str.charCodeAt(offset);\n            }\n            else {\n                break;\n            }\n        }\n        this._buffLen = buffLen;\n        this._leftoverHighSurrogate = leftoverHighSurrogate;\n    }\n    _push(buff, buffLen, codePoint) {\n        if (codePoint < 0x0080) {\n            buff[buffLen++] = codePoint;\n        }\n        else if (codePoint < 0x0800) {\n            buff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        else if (codePoint < 0x10000) {\n            buff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        else {\n            buff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        if (buffLen >= 64 /* SHA1Constant.BLOCK_SIZE */) {\n            this._step();\n            buffLen -= 64 /* SHA1Constant.BLOCK_SIZE */;\n            this._totalLen += 64 /* SHA1Constant.BLOCK_SIZE */;\n            // take last 3 in case of UTF8 overflow\n            buff[0] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 0];\n            buff[1] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 1];\n            buff[2] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 2];\n        }\n        return buffLen;\n    }\n    digest() {\n        if (!this._finished) {\n            this._finished = true;\n            if (this._leftoverHighSurrogate) {\n                // illegal => unicode replacement character\n                this._leftoverHighSurrogate = 0;\n                this._buffLen = this._push(this._buff, this._buffLen, 65533 /* SHA1Constant.UNICODE_REPLACEMENT */);\n            }\n            this._totalLen += this._buffLen;\n            this._wrapUp();\n        }\n        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n    }\n    _wrapUp() {\n        this._buff[this._buffLen++] = 0x80;\n        fill(this._buff, this._buffLen);\n        if (this._buffLen > 56) {\n            this._step();\n            fill(this._buff);\n        }\n        // this will fit because the mantissa can cover up to 52 bits\n        const ml = 8 * this._totalLen;\n        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n        this._buffDV.setUint32(60, ml % 4294967296, false);\n        this._step();\n    }\n    _step() {\n        const bigBlock32 = StringSHA1._bigBlock32;\n        const data = this._buffDV;\n        for (let j = 0; j < 64 /* 16*4 */; j += 4) {\n            bigBlock32.setUint32(j, data.getUint32(j, false), false);\n        }\n        for (let j = 64; j < 320 /* 80*4 */; j += 4) {\n            bigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);\n        }\n        let a = this._h0;\n        let b = this._h1;\n        let c = this._h2;\n        let d = this._h3;\n        let e = this._h4;\n        let f, k;\n        let temp;\n        for (let j = 0; j < 80; j++) {\n            if (j < 20) {\n                f = (b & c) | ((~b) & d);\n                k = 0x5A827999;\n            }\n            else if (j < 40) {\n                f = b ^ c ^ d;\n                k = 0x6ED9EBA1;\n            }\n            else if (j < 60) {\n                f = (b & c) | (b & d) | (c & d);\n                k = 0x8F1BBCDC;\n            }\n            else {\n                f = b ^ c ^ d;\n                k = 0xCA62C1D6;\n            }\n            temp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;\n            e = d;\n            d = c;\n            c = leftRotate(b, 30);\n            b = a;\n            a = temp;\n        }\n        this._h0 = (this._h0 + a) & 0xffffffff;\n        this._h1 = (this._h1 + b) & 0xffffffff;\n        this._h2 = (this._h2 + c) & 0xffffffff;\n        this._h3 = (this._h3 + d) & 0xffffffff;\n        this._h4 = (this._h4 + e) & 0xffffffff;\n    }\n}\nStringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320\n"],"names":["strictEquals","a","b","itemsEquals","itemEquals","arguments","length","undefined","arrays","equals","equalsIfDefined","v1","v2","WeakMap","exceptionToErrorMessage","exception","verbose","stack","stacktrace","nls","detectSystemErrorMessage","stackToString","Array","isArray","join","code","concat","message","errno","syscall","toErrorMessage","error","errors","msg","types","detail","errorHandler","constructor","this","listeners","unexpectedErrorHandler","e","setTimeout","ErrorNoTelemetry","isErrorNoTelemetry","Error","emit","forEach","listener","onUnexpectedError","onUnexpectedExternalError","isCancellationError","transformErrorForSerialization","name","$isError","noTelemetry","canceledName","CancellationError","super","canceled","illegalArgument","illegalState","NotSupportedError","fromError","err","result","BugIndicatingError","Object","setPrototypeOf","prototype","Event","_addLeakageTraceLogic","options","once","event","thisArgs","didFire","dispose","call","map","disposable","snapshot","i","filter","onWillAddFirstListener","emitter","fire","onDidRemoveLastListener","Emitter","add","debounce","merge","subscription","output","handle","doFire","delay","leading","flushOnListenerRemove","numDebouncedCalls","leakWarningThreshold","cur","_output","clearTimeout","queueMicrotask","onWillRemoveListener","None","Disposable","defer","each","signal","any","_len","events","_key","disposables","d","store","push","addAndReturnDisposable","combinedDisposable","reduce","initial","accumulate","last","latch","cache","firstCall","value","shouldEmit","split","isT","buffer","flushAfterTimeout","slice","flush","onDidAddFirstListener","chain","sythensize","fn","cs","ChainableSynthesis","evaluate","HaltChainable","Symbol","steps","v","step","fromNodeEventEmitter","eventName","id","onFirstListenerAdd","on","onLastListenerRemove","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","toPromise","Promise","resolve","fromPromise","promise","then","res","finally","runAndSubscribe","handler","EmitterObserver","_observable","_counter","_hasChanged","addObserver","removeObserver","beginUpdate","handlePossibleChange","handleChange","_change","endUpdate","reportChanges","get","fromObservable","obs","fromObservableLight","observable","count","didChange","observer","DisposableStore","EventProfiling","listenerCount","invocationCount","elapsedOverall","durations","_idPool","all","start","_stopWatch","StopWatch","stop","elapsed","Set","LeakageMonitor","threshold","Math","random","toString","_warnCountdown","_a","_stacks","clear","check","Map","set","topStack","topCount","console","warn","Stacktrace","create","print","UniqueContainer","_listenerFinalizers","_b","_c","_d","_e","_size","_options","_leakageMon","_perfMon","_profName","_deliveryQueue","deliveryQueue","_disposed","current","reset","_listeners","_event","callback","bind","contained","removeMonitor","ceil","EventDeliveryQueuePrivate","toDisposable","unregister","_removeListener","trim","register","index","indexOf","log","JSON","stringify","adjustDeliveryQueue","n","end","_deliver","onListenerError","_deliverQueue","dq","enqueue","hasListeners","createEventDeliveryQueue","PauseableEmitter","_isPaused","_eventQueue","LinkedList","_mergeFn","pause","resume","size","from","shift","DebounceEmitter","_delay","_handle","MicrotaskEmitter","_queuedEvents","EventMultiplexer","hook","createSingleCallFunction","unhook","idx","splice","r","EventBufferer","buffers","wrapEvent","bufferEvents","pop","Relay","listening","inputEvent","inputEventListener","input","isPathSeparator","toSlashes","osPath","replace","posix","sep","toPosixPath","test","getRoot","path","len","firstLetter","charCodeAt","pos","isWindowsDriveLetter","isEqualOrParent","base","parentCandidate","ignoreCase","separator","startsWithIgnoreCase","sepOffset","charAt","char0","hasDriveLetter","isWindows","or","word","wordToMatchAgainst","match","_matchesPrefix","matchesPrefix","matches","strings","matchesContiguousSubString","toLowerCase","matchesSubString","_matchesSubString","j","isLower","isUpper","isNumber","isWhitespace","wordSeparators","isWordSeparator","has","charactersMatch","codeA","codeB","s","alternateCharsCache","getAlternateCodes","codes","getKoreanAltChars","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","_matchesCamelCase","nextUpperIndex","matchesCamelCase","upper","lower","whitespace","isCamelCasePattern","substring","analysis","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","analyzeCamelCaseWord","isCamelCaseWord","isUpperCaseWord","matchesWords","target","contiguous","targetIndex","_matchesWords","nextWord","wordIndex","targetIndexOffset","altChars","k","nextWordIndex","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","LRUCache","matchesFuzzy","enableSeparateSubstringMatching","regexp","RegExp","exec","matchesFuzzy2","pattern","score","fuzzyScore","firstMatchCanBeWeak","boostFullMatch","createMatches","anyScore","lowPattern","patternPos","lowWord","wordPos","max","min","_maxLen","initTable","table","row","initArr","maxLen","_minWordMatchPos","_maxWordMatchPos","_diag","_table","_arrows","_debug","printTable","patternLen","wordLen","pad","ret","isSeparatorAtPos","codePointAt","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","FuzzyScore","Default","isDefault","FuzzyScoreOptions","patternLow","patternStart","wordStart","default","fillMinWordPosArr","isPatternInWord","_fillInMaxWordMatchPos","column","hasStrongFirstMatch","minWordMatchPos","maxWordMatchPos","nextMaxWordMatchPos","Number","MIN_SAFE_INTEGER","canComeDiag","_doScore","diagScore","MAX_SAFE_INTEGER","canComeLeft","leftScore","canComeLeftLeft","leftLeftScore","substr","printTables","backwardsDiagLength","maxMatchColumn","diagColumn","arrow","skippedCharsCount","newMatchStart","outFirstMatchStrong","isGapLocation","fuzzyScoreGracefulAggressive","aggressive","top","tries","movingPatternPos","newPattern","nextTypoPermutation","candidate","fuzzyScoreWithPermutations","swap1","swap2","fnDidRunCallback","_this","didCall","apply","NO_SCORE2","scoreFuzzy2","query","preparedQuery","values","totalScore","totalMatches","queryPiece","doScoreFuzzy2Single","normalizeMatches","doScoreFuzzy2Multiple","original","originalLowercase","createFuzzyMatches","freeze","sortedMatches","sort","matchA","matchB","normalizedMatches","currentMatch","matchOverlaps","queryExpectsExactMatch","startsWith","endsWith","MULTIPLE_QUERY_VALUES_SEPARATOR","prepareQuery","pathNormalized","normalized","normalizedLowercase","normalizeQuery","containsPathSeparator","expectExactMatch","originalSplit","originalPiece","expectExactMatchPiece","pathNormalizedPiece","normalizedPiece","normalizedLowercasePiece","expectContiguousMatch","stripWildcards","pieceToQuery","arg1","piece","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","splitGlobAware","splitChar","segments","inBraces","inBrackets","curVal","char","parseRegExp","regEx","every","segment","previousSegmentWasGlobStar","braceVal","bracketVal","choices","braceRegExp","choice","escapeRegExpCharacters","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","patternKey","trimForExclusions","parsedPattern","basename","trivia1","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","parsedPatterns","aggregateBasenameMatches","patternsLength","withBasenames","find","allPaths","trivia3","trivia4and5","regExp","lastIndex","toRegExp","wrapRelativePattern","arg2","wrappedPattern","isLinux","ltrim","targetPath","matchPathEnds","usingPosixSep","nativePath","nativePathEnd","targetPathEnd","hasSibling","parse","obj","rp","isRelativePattern","resultPattern","expression","getOwnPropertyNames","when","matched","isThenable","requiresSiblings","parseExpressionPattern","some","resultExpression","resultPromises","resultPromise","extname","parsedExpression","basenamePatterns","aggregate","ch","aggregatedPatterns","hash","doHash","hashVal","numberHash","arr","initialHashVal","item","keys","key","stringHash","objectHash","booleanHash","val","leftRotate","bits","delta","fill","dest","byteLength","toHexString","bufferOrValue","bitsize","ArrayBuffer","Uint8Array","padStart","leftPad","StringSHA1","_h0","_h1","_h2","_h3","_h4","_buff","_buffDV","DataView","_buffLen","_totalLen","_leftoverHighSurrogate","_finished","update","str","strLen","buff","charCode","offset","buffLen","leftoverHighSurrogate","codePoint","nextCharCode","_push","_step","digest","_wrapUp","ml","setUint32","floor","bigBlock32","_bigBlock32","data","getUint32","f","temp"],"sourceRoot":""}