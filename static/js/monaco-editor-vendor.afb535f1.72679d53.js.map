{"version":3,"file":"static/js/monaco-editor-vendor.afb535f1.72679d53.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../node_modules/monaco-editor/esm/vs/editor/common/languageSelector.js","../node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/languages.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/nullMode.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/textToHtmlTokenizer.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/unicodeTextModelHighlighter.js","../node_modules/monaco-editor/esm/vs/editor/common/model.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js","../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","../node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport * as strings from '../../../base/common/strings.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        return this._columns[i];\n    }\n    getEndLineNumber(i) {\n        return this._lineNumbers[i];\n    }\n    getEndColumn(i) {\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        let originalStartLineNumber;\n        let originalStartColumn;\n        let originalEndLineNumber;\n        let originalEndColumn;\n        let modifiedStartLineNumber;\n        let modifiedStartColumn;\n        let modifiedEndLineNumber;\n        let modifiedEndColumn;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = 0;\n            originalStartColumn = 0;\n            originalEndLineNumber = 0;\n            originalEndColumn = 0;\n        }\n        else {\n            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = 0;\n            modifiedStartColumn = 0;\n            modifiedEndLineNumber = 0;\n            modifiedEndColumn = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n            if (shouldPostProcessCharChanges) {\n                rawChanges = postProcessCharChanges(rawChanges);\n            }\n            charChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run() {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run();\n    }\n}\n","/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { match as matchGlobPattern } from '../../base/common/glob.js';\nimport { normalize } from '../../base/common/path.js';\nexport function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme, hasAccessToAllModels } = selector; // TODO: microsoft/TypeScript#42768\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                // Since this pattern has a `base` property, we need\n                // to normalize this path first before passing it on\n                // because we will compare it against `Uri.fsPath`\n                // which uses platform specific separators.\n                // Refs: https://github.com/microsoft/vscode/issues/99938\n                normalizedPattern = Object.assign(Object.assign({}, pattern), { base: normalize(pattern.base) });\n            }\n            if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor() {\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n    }\n    get onDidChange() {\n        return this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model);\n        const result = [];\n        // from registry\n        for (let entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model) {\n        const result = [];\n        this._orderedForEach(model, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, callback) {\n        if (!model) {\n            return;\n        }\n        this._updateScores(model);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model) {\n        const candidate = {\n            uri: model.uri.toString(),\n            language: model.getLanguageId()\n        };\n        if (this._lastCandidate\n            && this._lastCandidate.language === candidate.language\n            && this._lastCandidate.uri === candidate.uri) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (let entry of this._entries) {\n            entry._score = score(entry.selector, model.uri, model.getLanguageId(), shouldSynchronizeModel(model));\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                // support for one exclusive selector that overwrites\n                // any other selector\n                for (let entry of this._entries) {\n                    entry._score = 0;\n                }\n                entry._score = 1000;\n                break;\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        else if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { URI } from '../../base/common/uri.js';\nimport { Range } from './core/range.js';\nimport { LanguageFeatureRegistry } from './languageFeatureRegistry.js';\nimport { TokenizationRegistry as TokenizationRegistryImpl } from './tokenizationRegistry.js';\nimport { Codicon } from '../../base/common/codicons.js';\n/**\n * @internal\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 768 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 15360 /* FONT_STYLE_MASK */) >>> 10 /* FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 8372224 /* FOREGROUND_MASK */) >>> 14 /* FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4286578688 /* BACKGROUND_MASK */) >>> 23 /* BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        const fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* Underline */) {\n            className += ' mtku';\n        }\n        if (fontStyle & 8 /* Strikethrough */) {\n            className += ' mtks';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* Bold */) {\n            result += 'font-weight: bold;';\n        }\n        let textDecoration = '';\n        if (fontStyle & 4 /* Underline */) {\n            textDecoration += ' underline';\n        }\n        if (fontStyle & 8 /* Strikethrough */) {\n            textDecoration += ' line-through';\n        }\n        if (textDecoration) {\n            result += `text-decoration:${textDecoration};`;\n        }\n        return result;\n    }\n    static getPresentationFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* Italic */),\n            bold: Boolean(fontStyle & 2 /* Bold */),\n            underline: Boolean(fontStyle & 4 /* Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* Strikethrough */),\n        };\n    }\n}\nexport class Token {\n    constructor(offset, type, language) {\n        this._tokenBrand = undefined;\n        this.offset = offset;\n        this.type = type;\n        this.language = language;\n    }\n    toString() {\n        return '(' + this.offset + ', ' + this.type + ')';\n    }\n}\n/**\n * @internal\n */\nexport class TokenizationResult {\n    constructor(tokens, endState) {\n        this._tokenizationResultBrand = undefined;\n        this.tokens = tokens;\n        this.endState = endState;\n    }\n}\n/**\n * @internal\n */\nexport class EncodedTokenizationResult {\n    constructor(tokens, endState) {\n        this._encodedTokenizationResultBrand = undefined;\n        this.tokens = tokens;\n        this.endState = endState;\n    }\n}\n/**\n * @internal\n */\nexport var CompletionItemKinds;\n(function (CompletionItemKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* Method */, Codicon.symbolMethod);\n    byKind.set(1 /* Function */, Codicon.symbolFunction);\n    byKind.set(2 /* Constructor */, Codicon.symbolConstructor);\n    byKind.set(3 /* Field */, Codicon.symbolField);\n    byKind.set(4 /* Variable */, Codicon.symbolVariable);\n    byKind.set(5 /* Class */, Codicon.symbolClass);\n    byKind.set(6 /* Struct */, Codicon.symbolStruct);\n    byKind.set(7 /* Interface */, Codicon.symbolInterface);\n    byKind.set(8 /* Module */, Codicon.symbolModule);\n    byKind.set(9 /* Property */, Codicon.symbolProperty);\n    byKind.set(10 /* Event */, Codicon.symbolEvent);\n    byKind.set(11 /* Operator */, Codicon.symbolOperator);\n    byKind.set(12 /* Unit */, Codicon.symbolUnit);\n    byKind.set(13 /* Value */, Codicon.symbolValue);\n    byKind.set(15 /* Enum */, Codicon.symbolEnum);\n    byKind.set(14 /* Constant */, Codicon.symbolConstant);\n    byKind.set(15 /* Enum */, Codicon.symbolEnum);\n    byKind.set(16 /* EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(17 /* Keyword */, Codicon.symbolKeyword);\n    byKind.set(27 /* Snippet */, Codicon.symbolSnippet);\n    byKind.set(18 /* Text */, Codicon.symbolText);\n    byKind.set(19 /* Color */, Codicon.symbolColor);\n    byKind.set(20 /* File */, Codicon.symbolFile);\n    byKind.set(21 /* Reference */, Codicon.symbolReference);\n    byKind.set(22 /* Customcolor */, Codicon.symbolCustomColor);\n    byKind.set(23 /* Folder */, Codicon.symbolFolder);\n    byKind.set(24 /* TypeParameter */, Codicon.symbolTypeParameter);\n    byKind.set(25 /* User */, Codicon.account);\n    byKind.set(26 /* Issue */, Codicon.issues);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let codicon = byKind.get(kind);\n        if (!codicon) {\n            console.info('No codicon found for CompletionItemKind ' + kind);\n            codicon = Codicon.symbolProperty;\n        }\n        return codicon;\n    }\n    CompletionItemKinds.toIcon = toIcon;\n    const data = new Map();\n    data.set('method', 0 /* Method */);\n    data.set('function', 1 /* Function */);\n    data.set('constructor', 2 /* Constructor */);\n    data.set('field', 3 /* Field */);\n    data.set('variable', 4 /* Variable */);\n    data.set('class', 5 /* Class */);\n    data.set('struct', 6 /* Struct */);\n    data.set('interface', 7 /* Interface */);\n    data.set('module', 8 /* Module */);\n    data.set('property', 9 /* Property */);\n    data.set('event', 10 /* Event */);\n    data.set('operator', 11 /* Operator */);\n    data.set('unit', 12 /* Unit */);\n    data.set('value', 13 /* Value */);\n    data.set('constant', 14 /* Constant */);\n    data.set('enum', 15 /* Enum */);\n    data.set('enum-member', 16 /* EnumMember */);\n    data.set('enumMember', 16 /* EnumMember */);\n    data.set('keyword', 17 /* Keyword */);\n    data.set('snippet', 27 /* Snippet */);\n    data.set('text', 18 /* Text */);\n    data.set('color', 19 /* Color */);\n    data.set('file', 20 /* File */);\n    data.set('reference', 21 /* Reference */);\n    data.set('customcolor', 22 /* Customcolor */);\n    data.set('folder', 23 /* Folder */);\n    data.set('type-parameter', 24 /* TypeParameter */);\n    data.set('typeParameter', 24 /* TypeParameter */);\n    data.set('account', 25 /* User */);\n    data.set('issue', 26 /* Issue */);\n    /**\n     * @internal\n     */\n    function fromString(value, strict) {\n        let res = data.get(value);\n        if (typeof res === 'undefined' && !strict) {\n            res = 9 /* Property */;\n        }\n        return res;\n    }\n    CompletionItemKinds.fromString = fromString;\n})(CompletionItemKinds || (CompletionItemKinds = {}));\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport var SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * @internal\n */\nexport function isLocationLink(thing) {\n    return thing\n        && URI.isUri(thing.uri)\n        && Range.isIRange(thing.range)\n        && (Range.isIRange(thing.originSelectionRange) || Range.isIRange(thing.targetSelectionRange));\n}\n/**\n * @internal\n */\nexport var SymbolKinds;\n(function (SymbolKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* File */, Codicon.symbolFile);\n    byKind.set(1 /* Module */, Codicon.symbolModule);\n    byKind.set(2 /* Namespace */, Codicon.symbolNamespace);\n    byKind.set(3 /* Package */, Codicon.symbolPackage);\n    byKind.set(4 /* Class */, Codicon.symbolClass);\n    byKind.set(5 /* Method */, Codicon.symbolMethod);\n    byKind.set(6 /* Property */, Codicon.symbolProperty);\n    byKind.set(7 /* Field */, Codicon.symbolField);\n    byKind.set(8 /* Constructor */, Codicon.symbolConstructor);\n    byKind.set(9 /* Enum */, Codicon.symbolEnum);\n    byKind.set(10 /* Interface */, Codicon.symbolInterface);\n    byKind.set(11 /* Function */, Codicon.symbolFunction);\n    byKind.set(12 /* Variable */, Codicon.symbolVariable);\n    byKind.set(13 /* Constant */, Codicon.symbolConstant);\n    byKind.set(14 /* String */, Codicon.symbolString);\n    byKind.set(15 /* Number */, Codicon.symbolNumber);\n    byKind.set(16 /* Boolean */, Codicon.symbolBoolean);\n    byKind.set(17 /* Array */, Codicon.symbolArray);\n    byKind.set(18 /* Object */, Codicon.symbolObject);\n    byKind.set(19 /* Key */, Codicon.symbolKey);\n    byKind.set(20 /* Null */, Codicon.symbolNull);\n    byKind.set(21 /* EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(22 /* Struct */, Codicon.symbolStruct);\n    byKind.set(23 /* Event */, Codicon.symbolEvent);\n    byKind.set(24 /* Operator */, Codicon.symbolOperator);\n    byKind.set(25 /* TypeParameter */, Codicon.symbolTypeParameter);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let icon = byKind.get(kind);\n        if (!icon) {\n            console.info('No codicon found for SymbolKind ' + kind);\n            icon = Codicon.symbolProperty;\n        }\n        return icon;\n    }\n    SymbolKinds.toIcon = toIcon;\n})(SymbolKinds || (SymbolKinds = {}));\nexport class FoldingRangeKind {\n    /**\n     * Creates a new {@link FoldingRangeKind}.\n     *\n     * @param value of the kind.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Kind for folding range representing a comment. The value of the kind is 'comment'.\n */\nFoldingRangeKind.Comment = new FoldingRangeKind('comment');\n/**\n * Kind for folding range representing a import. The value of the kind is 'imports'.\n */\nFoldingRangeKind.Imports = new FoldingRangeKind('imports');\n/**\n * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\n * The value of the kind is 'region'.\n */\nFoldingRangeKind.Region = new FoldingRangeKind('region');\n/**\n * @internal\n */\nexport var Command;\n(function (Command) {\n    /**\n     * @internal\n     */\n    function is(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return false;\n        }\n        return typeof obj.id === 'string' &&\n            typeof obj.title === 'string';\n    }\n    Command.is = is;\n})(Command || (Command = {}));\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Other\"] = 0] = \"Other\";\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\n// --- feature registries ------\n/**\n * @internal\n */\nexport const ReferenceProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const RenameProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const CompletionProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const InlineCompletionsProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const SignatureHelpProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const HoverProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const EvaluatableExpressionProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const InlineValuesProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentSymbolProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentHighlightProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const LinkedEditingRangeProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DefinitionProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DeclarationProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const ImplementationProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const TypeDefinitionProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const CodeLensProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const InlayHintsProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const CodeActionProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentFormattingEditProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentRangeFormattingEditProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const OnTypeFormattingEditProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const LinkProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const ColorProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const SelectionRangeRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const FoldingRangeProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentSemanticTokensProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const DocumentRangeSemanticTokensProviderRegistry = new LanguageFeatureRegistry();\n/**\n * @internal\n */\nexport const TokenizationRegistry = new TokenizationRegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* Other */:\n                return true;\n            case 1 /* Comment */:\n                return this._inComment;\n            case 2 /* String */:\n                return this._inString;\n            case 3 /* RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* Digit0 */, 57 /* Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* a */, 122 /* z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* A */, 90 /* Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.colorizedBracketPairs) {\n            this._colorizedBracketPairs = filterValidBrackets(config.colorizedBracketPairs.map(b => [b[0], b[1]]));\n        }\n        else if (config.brackets) {\n            this._colorizedBracketPairs = filterValidBrackets(config.brackets\n                .map((b) => [b[0], b[1]])\n                // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n                // This leads to problems when colorizing this bracket, so we exclude it by default.\n                // Languages can still override this by configuring `colorizedBracketPairs`\n                // https://github.com/microsoft/vscode/issues/132476\n                .filter((p) => !(p[0] === '<' && p[1] === '>')));\n        }\n        else {\n            this._colorizedBracketPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBefore = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet() {\n        return this._autoCloseBefore;\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n    getColorizedBrackets() {\n        return this._colorizedBracketPairs;\n    }\n}\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = ';:.,=}])> \\n\\t';\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from '../services/language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(LanguageConfigurationRegistry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, configurationService, languageService) {\n    let languageConfig = LanguageConfigurationRegistry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            throw new Error('Unexpected languageId');\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistryImpl {\n    constructor() {\n        this._entries = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n    }\n    getComments(languageId) {\n        const value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.comments || null;\n    }\n    // begin Indent Rules\n    getIndentRulesSupport(languageId) {\n        const value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.indentRulesSupport || null;\n    }\n    /**\n     * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n     * Result:\n     * -1: run into the boundary of embedded languages\n     * 0: every line above are invalid\n     * else: nearest preceding line of the same language\n     */\n    getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n        const languageId = model.getLanguageIdAtPosition(lineNumber, 0);\n        if (lineNumber > 1) {\n            let lastLineNumber;\n            let resultLineNumber = -1;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n                    return resultLineNumber;\n                }\n                const text = model.getLineContent(lastLineNumber);\n                if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                    resultLineNumber = lastLineNumber;\n                    continue;\n                }\n                return lastLineNumber;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Get inherited indentation from above lines.\n     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n     * 3. If this line doesn't match any indent rules\n     *   a. check whether the line above it matches indentNextLinePattern\n     *   b. If not, the indent level of this line is the result\n     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n     *\n     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n     */\n    getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber <= 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n        if (precedingUnIgnoredLine < 0) {\n            return null;\n        }\n        else if (precedingUnIgnoredLine < 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n        if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: IndentAction.Indent,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // precedingUnIgnoredLine can not be ignored.\n            // it doesn't increase indent of following lines\n            // it doesn't increase just next line\n            // so current line is not affect by precedingUnIgnoredLine\n            // and then we should get a correct inheritted indentation from above lines\n            if (precedingUnIgnoredLine === 1) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            const previousLine = precedingUnIgnoredLine - 1;\n            const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n            if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) &&\n                (previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */)) {\n                let stopLine = 0;\n                for (let i = previousLine - 1; i > 0; i--) {\n                    if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                        continue;\n                    }\n                    stopLine = i;\n                    break;\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                    action: null,\n                    line: stopLine + 1\n                };\n            }\n            if (honorIntentialIndent) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            else {\n                // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n                for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                    const lineContent = model.getLineContent(i);\n                    if (indentRulesSupport.shouldIncrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: IndentAction.Indent,\n                            line: i\n                        };\n                    }\n                    else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                        let stopLine = 0;\n                        for (let j = i - 1; j > 0; j--) {\n                            if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                                continue;\n                            }\n                            stopLine = j;\n                            break;\n                        }\n                        return {\n                            indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                            action: null,\n                            line: stopLine + 1\n                        };\n                    }\n                    else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: null,\n                            line: i\n                        };\n                    }\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                    action: null,\n                    line: 1\n                };\n            }\n        }\n    }\n    getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const richEditSupport = this.getLanguageConfiguration(languageId);\n        if (!richEditSupport) {\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\n        const lineContent = virtualModel.getLineContent(lineNumber);\n        if (indent) {\n            const inheritLine = indent.line;\n            if (inheritLine !== undefined) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n            if (indentRulesSupport.shouldDecrease(lineContent)) {\n                if (indent.action === IndentAction.Indent) {\n                    return indent.indentation;\n                }\n                else {\n                    return indentConverter.unshiftIndent(indent.indentation);\n                }\n            }\n            else {\n                if (indent.action === IndentAction.Indent) {\n                    return indentConverter.shiftIndent(indent.indentation);\n                }\n                else {\n                    return indent.indentation;\n                }\n            }\n        }\n        return null;\n    }\n    getIndentForEnter(autoIndent, model, range, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        model.forceTokenization(range.startLineNumber);\n        const lineTokens = model.getLineTokens(range.startLineNumber);\n        const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n        const scopedLineText = scopedLineTokens.getLineContent();\n        let embeddedLanguage = false;\n        let beforeEnterText;\n        if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n            // we are in the embeded language content\n            embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n            beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n        }\n        let afterEnterText;\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const beforeEnterResult = beforeEnterText;\n        const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n        const virtualModel = {\n            getLineTokens: (lineNumber) => {\n                return model.getLineTokens(lineNumber);\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n            getLineContent: (lineNumber) => {\n                if (lineNumber === range.startLineNumber) {\n                    return beforeEnterResult;\n                }\n                else {\n                    return model.getLineContent(lineNumber);\n                }\n            }\n        };\n        const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n        const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\n        if (!afterEnterAction) {\n            const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n            return {\n                beforeEnter: beforeEnter,\n                afterEnter: beforeEnter\n            };\n        }\n        let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n        if (afterEnterAction.action === IndentAction.Indent) {\n            afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n        }\n        if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n            afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n        }\n        return {\n            beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n            afterEnter: afterEnterIndent\n        };\n    }\n    /**\n     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n     */\n    getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        if (scopedLineTokens.firstCharOffset) {\n            // this line has mixed languages and indentation rules will not work\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const scopedLineText = scopedLineTokens.getLineContent();\n        const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        // selection support\n        let afterTypeText;\n        if (range.isEmpty()) {\n            afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n        // Users might change the indentation by purpose and we should honor that instead of readjusting.\n        if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n            // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n            // 1. Get inherited indent action\n            const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\n            if (!r) {\n                return null;\n            }\n            let indentation = r.indentation;\n            if (r.action !== IndentAction.Indent) {\n                indentation = indentConverter.unshiftIndent(indentation);\n            }\n            return indentation;\n        }\n        return null;\n    }\n    getIndentMetadata(model, lineNumber) {\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n            return null;\n        }\n        return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n    }\n    // end Indent Rules\n    // begin onEnter\n    getEnterAction(autoIndent, model, range) {\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        const richEditSupport = this.getLanguageConfiguration(scopedLineTokens.languageId);\n        if (!richEditSupport) {\n            return null;\n        }\n        const scopedLineText = scopedLineTokens.getLineContent();\n        const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        // selection support\n        let afterEnterText;\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        let previousLineText = '';\n        if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n            // This is not the first line and the entire line belongs to this mode\n            const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\n            if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n                // The line above ends with text belonging to the same mode\n                previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n            }\n        }\n        const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n        if (!enterResult) {\n            return null;\n        }\n        const indentAction = enterResult.indentAction;\n        let appendText = enterResult.appendText;\n        const removeText = enterResult.removeText || 0;\n        // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n        if (!appendText) {\n            if ((indentAction === IndentAction.Indent) ||\n                (indentAction === IndentAction.IndentOutdent)) {\n                appendText = '\\t';\n            }\n            else {\n                appendText = '';\n            }\n        }\n        else if (indentAction === IndentAction.Indent) {\n            appendText = '\\t' + appendText;\n        }\n        let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        if (removeText) {\n            indentation = indentation.substring(0, indentation.length - removeText);\n        }\n        return {\n            indentAction: indentAction,\n            appendText: appendText,\n            removeText: removeText,\n            indentation: indentation\n        };\n    }\n    getIndentationAtPosition(model, lineNumber, column) {\n        const lineText = model.getLineContent(lineNumber);\n        let indentation = strings.getLeadingWhitespace(lineText);\n        if (indentation.length > column - 1) {\n            indentation = indentation.substring(0, column - 1);\n        }\n        return indentation;\n    }\n    getScopedLineTokens(model, lineNumber, columnNumber) {\n        model.forceTokenization(lineNumber);\n        const lineTokens = model.getLineTokens(lineNumber);\n        const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n        return createScopedLineTokens(lineTokens, column);\n    }\n}\n/**\n * @deprecated Use ILanguageConfigurationService instead.\n*/\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet() {\n        return this.characterPair.getAutoCloseBeforeSet();\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nexport class Uint8Matrix {\n    constructor(rows, cols, defaultValue) {\n        const data = new Uint8Array(rows * cols);\n        for (let i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    get(row, col) {\n        return this._data[row * this.cols + col];\n    }\n    set(row, col, value) {\n        this._data[row * this.cols + col] = value;\n    }\n}\nexport class StateMachine {\n    constructor(edges) {\n        let maxCharCode = 0;\n        let maxState = 0 /* Invalid */;\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* Invalid */);\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    nextState(currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    }\n}\n// State machine for http:// or https:// or file://\nlet _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* Start */, 104 /* h */, 2 /* H */],\n            [1 /* Start */, 72 /* H */, 2 /* H */],\n            [1 /* Start */, 102 /* f */, 6 /* F */],\n            [1 /* Start */, 70 /* F */, 6 /* F */],\n            [2 /* H */, 116 /* t */, 3 /* HT */],\n            [2 /* H */, 84 /* T */, 3 /* HT */],\n            [3 /* HT */, 116 /* t */, 4 /* HTT */],\n            [3 /* HT */, 84 /* T */, 4 /* HTT */],\n            [4 /* HTT */, 112 /* p */, 5 /* HTTP */],\n            [4 /* HTT */, 80 /* P */, 5 /* HTTP */],\n            [5 /* HTTP */, 115 /* s */, 9 /* BeforeColon */],\n            [5 /* HTTP */, 83 /* S */, 9 /* BeforeColon */],\n            [5 /* HTTP */, 58 /* Colon */, 10 /* AfterColon */],\n            [6 /* F */, 105 /* i */, 7 /* FI */],\n            [6 /* F */, 73 /* I */, 7 /* FI */],\n            [7 /* FI */, 108 /* l */, 8 /* FIL */],\n            [7 /* FI */, 76 /* L */, 8 /* FIL */],\n            [8 /* FIL */, 101 /* e */, 9 /* BeforeColon */],\n            [8 /* FIL */, 69 /* E */, 9 /* BeforeColon */],\n            [9 /* BeforeColon */, 58 /* Colon */, 10 /* AfterColon */],\n            [10 /* AfterColon */, 47 /* Slash */, 11 /* AlmostThere */],\n            [11 /* AlmostThere */, 47 /* Slash */, 12 /* End */],\n        ]);\n    }\n    return _stateMachine;\n}\nlet _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new CharacterClassifier(0 /* None */);\n        // allow-any-unicode-next-line\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…';\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* ForceTermination */);\n        }\n        const CANNOT_END_WITH_CHARACTERS = '.,;';\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nexport class LinkComputer {\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        let lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\n            const chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* OpenParen */ && lastCharCodeInLink === 41 /* CloseParen */)\n                || (charCodeBeforeLink === 91 /* OpenSquareBracket */ && lastCharCodeInLink === 93 /* CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    }\n    static computeLinks(model, stateMachine = getStateMachine()) {\n        const classifier = getClassifier();\n        const result = [];\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            const line = model.getLineContent(i);\n            const len = line.length;\n            let j = 0;\n            let linkBeginIndex = 0;\n            let linkBeginChCode = 0;\n            let state = 1 /* Start */;\n            let hasOpenParens = false;\n            let hasOpenSquareBracket = false;\n            let inSquareBrackets = false;\n            let hasOpenCurlyBracket = false;\n            while (j < len) {\n                let resetStateMachine = false;\n                const chCode = line.charCodeAt(j);\n                if (state === 13 /* Accept */) {\n                    let chClass;\n                    switch (chCode) {\n                        case 40 /* OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* None */;\n                            break;\n                        case 41 /* CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        case 91 /* OpenSquareBracket */:\n                            inSquareBrackets = true;\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* None */;\n                            break;\n                        case 93 /* CloseSquareBracket */:\n                            inSquareBrackets = false;\n                            chClass = (hasOpenSquareBracket ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        case 123 /* OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* None */;\n                            break;\n                        case 125 /* CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        /* The following three rules make it that ' or \" or ` are allowed inside links if the link began with a different one */\n                        case 39 /* SingleQuote */:\n                            chClass = (linkBeginChCode === 34 /* DoubleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;\n                            break;\n                        case 34 /* DoubleQuote */:\n                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;\n                            break;\n                        case 96 /* BackTick */:\n                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 34 /* DoubleQuote */) ? 0 /* None */ : 1 /* ForceTermination */;\n                            break;\n                        case 42 /* Asterisk */:\n                            // `*` terminates a link if the link began with `*`\n                            chClass = (linkBeginChCode === 42 /* Asterisk */) ? 1 /* ForceTermination */ : 0 /* None */;\n                            break;\n                        case 124 /* Pipe */:\n                            // `|` terminates a link if the link began with `|`\n                            chClass = (linkBeginChCode === 124 /* Pipe */) ? 1 /* ForceTermination */ : 0 /* None */;\n                            break;\n                        case 32 /* Space */:\n                            // ` ` allow space in between [ and ]\n                            chClass = (inSquareBrackets ? 0 /* None */ : 1 /* ForceTermination */);\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* End */) {\n                    let chClass;\n                    if (chCode === 91 /* OpenSquareBracket */) {\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                        hasOpenSquareBracket = true;\n                        chClass = 0 /* None */;\n                    }\n                    else {\n                        chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    }\n}\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { LanguageConfigurationRegistry } from './languageConfigurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Extensions as ConfigurationExtensions } from '../../../platform/configuration/common/configurationRegistry.js';\n// Define extension point ids\nexport const Extensions = {\n    ModesRegistry: 'editor.modesRegistry'\n};\nexport class EditorModesRegistry {\n    constructor() {\n        this._onDidChangeLanguages = new Emitter();\n        this.onDidChangeLanguages = this._onDidChangeLanguages.event;\n        this._languages = [];\n    }\n    registerLanguage(def) {\n        this._languages.push(def);\n        this._onDidChangeLanguages.fire(undefined);\n        return {\n            dispose: () => {\n                for (let i = 0, len = this._languages.length; i < len; i++) {\n                    if (this._languages[i] === def) {\n                        this._languages.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    getLanguages() {\n        return this._languages;\n    }\n}\nexport const ModesRegistry = new EditorModesRegistry();\nRegistry.add(Extensions.ModesRegistry, ModesRegistry);\nexport const PLAINTEXT_LANGUAGE_ID = 'plaintext';\nexport const PLAINTEXT_EXTENSION = '.txt';\nModesRegistry.registerLanguage({\n    id: PLAINTEXT_LANGUAGE_ID,\n    extensions: [PLAINTEXT_EXTENSION],\n    aliases: [nls.localize('plainText.alias', \"Plain Text\"), 'text'],\n    mimetypes: [Mimes.text]\n});\nLanguageConfigurationRegistry.register(PLAINTEXT_LANGUAGE_ID, {\n    brackets: [\n        ['(', ')'],\n        ['[', ']'],\n        ['{', '}'],\n    ],\n    surroundingPairs: [\n        { open: '{', close: '}' },\n        { open: '[', close: ']' },\n        { open: '(', close: ')' },\n        { open: '<', close: '>' },\n        { open: '\\\"', close: '\\\"' },\n        { open: '\\'', close: '\\'' },\n        { open: '`', close: '`' },\n    ],\n    colorizedBracketPairs: [],\n    folding: {\n        offSide: true\n    }\n}, 0);\nRegistry.as(ConfigurationExtensions.Configuration)\n    .registerDefaultConfigurations([{\n        overrides: {\n            '[plaintext]': {\n                'editor.unicodeHighlight.ambiguousCharacters': false,\n                'editor.unicodeHighlight.invisibleCharacters': false\n            }\n        }\n    }]);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* LANGUAGEID_OFFSET */)\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\n        | (0 /* None */ << 10 /* FONT_STYLE_OFFSET */)\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            const result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            const result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        const numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        let n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        if (stringBuilder.hasTextDecoder) {\n            // create a Uint16Array and then use a TextDecoder to create a string\n            const arr = new Uint16Array(str.length);\n            let offset = 0;\n            for (let i = str.length - 1; i >= 0; i--) {\n                arr[offset++] = str.charCodeAt(i);\n            }\n            return stringBuilder.getPlatformTextDecoder().decode(arr);\n        }\n        else {\n            const result = [];\n            let resultLen = 0;\n            for (let i = str.length - 1; i >= 0; i--) {\n                result[resultLen++] = str.charAt(i);\n            }\n            return result.join('');\n        }\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (let color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* Comment */;\n        case 'string':\n            return 2 /* String */;\n        case 'regex':\n            return 3 /* RegEx */;\n        case 'regexp':\n            return 3 /* RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 10 /* FONT_STYLE_OFFSET */)\n            | (this._foreground << 14 /* FOREGROUND_OFFSET */)\n            | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 10 /* FONT_STYLE_OFFSET */)\n            | (this._foreground << 14 /* FOREGROUND_OFFSET */)\n            | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullMode.js';\nconst fallback = {\n    getInitialState: () => NullState,\n    tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* Null */, state)\n};\nexport function tokenizeToString(languageService, text, languageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!languageId) {\n            return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n        }\n        const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);\n        return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n    });\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    let prevIsSpace = true;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* Tab */: {\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        if (useNbsp && prevIsSpace) {\n                            partContent += '&#160;';\n                            prevIsSpace = false;\n                        }\n                        else {\n                            partContent += ' ';\n                            prevIsSpace = true;\n                        }\n                        insertSpacesCount--;\n                    }\n                    break;\n                }\n                case 60 /* LessThan */:\n                    partContent += '&lt;';\n                    prevIsSpace = false;\n                    break;\n                case 62 /* GreaterThan */:\n                    partContent += '&gt;';\n                    prevIsSpace = false;\n                    break;\n                case 38 /* Ampersand */:\n                    partContent += '&amp;';\n                    prevIsSpace = false;\n                    break;\n                case 0 /* Null */:\n                    partContent += '&#00;';\n                    prevIsSpace = false;\n                    break;\n                case 65279 /* UTF8_BOM */:\n                case 8232 /* LINE_SEPARATOR */:\n                case 8233 /* PARAGRAPH_SEPARATOR */:\n                case 133 /* NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    prevIsSpace = false;\n                    break;\n                case 13 /* CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    prevIsSpace = false;\n                    break;\n                case 32 /* Space */:\n                    if (useNbsp && prevIsSpace) {\n                        partContent += '&#160;';\n                        prevIsSpace = false;\n                    }\n                    else {\n                        partContent += ' ';\n                        prevIsSpace = true;\n                    }\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n                    prevIsSpace = false;\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    const lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n        const viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/types.js';\nexport class UnicodeTextModelHighlighter {\n    static computeUnicodeHighlights(model, options, range) {\n        const startLine = range ? range.startLineNumber : 1;\n        const endLine = range ? range.endLineNumber : model.getLineCount();\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const candidates = codePointHighlighter.getCandidateCodePoints();\n        let regex;\n        if (candidates === 'allNonBasicAscii') {\n            regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n        }\n        else {\n            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n        }\n        const searcher = new Searcher(null, regex);\n        const ranges = [];\n        let hasMore = false;\n        let m;\n        let ambiguousCharacterCount = 0;\n        let invisibleCharacterCount = 0;\n        let nonBasicAsciiCharacterCount = 0;\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n            const lineContent = model.getLineContent(lineNumber);\n            const lineLength = lineContent.length;\n            // Reset regex to search from the beginning\n            searcher.reset(0);\n            do {\n                m = searcher.next(lineContent);\n                if (m) {\n                    let startIndex = m.index;\n                    let endIndex = m.index + m[0].length;\n                    // Extend range to entire code point\n                    if (startIndex > 0) {\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            startIndex--;\n                        }\n                    }\n                    if (endIndex + 1 < lineLength) {\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            endIndex++;\n                        }\n                    }\n                    const str = lineContent.substring(startIndex, endIndex);\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str);\n                    if (highlightReason !== 0 /* None */) {\n                        if (highlightReason === 3 /* Ambiguous */) {\n                            ambiguousCharacterCount++;\n                        }\n                        else if (highlightReason === 2 /* Invisible */) {\n                            invisibleCharacterCount++;\n                        }\n                        else if (highlightReason === 1 /* NonBasicASCII */) {\n                            nonBasicAsciiCharacterCount++;\n                        }\n                        else {\n                            assertNever(highlightReason);\n                        }\n                        const MAX_RESULT_LENGTH = 1000;\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\n                            hasMore = true;\n                            break forLoop;\n                        }\n                        ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n                    }\n                }\n            } while (m);\n        }\n        return {\n            ranges,\n            hasMore,\n            ambiguousCharacterCount,\n            invisibleCharacterCount,\n            nonBasicAsciiCharacterCount\n        };\n    }\n    static computeUnicodeHighlightReason(char, options) {\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char);\n        switch (reason) {\n            case 0 /* None */:\n                return null;\n            case 2 /* Invisible */:\n                return { kind: 1 /* Invisible */ };\n            case 3 /* Ambiguous */: {\n                const codePoint = char.codePointAt(0);\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n                const notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter((l) => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n                return { kind: 0 /* Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n            }\n            case 1 /* NonBasicASCII */:\n                return { kind: 2 /* NonBasicAscii */ };\n        }\n    }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n    const src = `[${strings.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;\n    return src;\n}\nclass CodePointHighlighter {\n    constructor(options) {\n        this.options = options;\n        this.allowedCodePoints = new Set(options.allowedCodePoints);\n        this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n    }\n    getCandidateCodePoints() {\n        if (this.options.nonBasicASCII) {\n            return 'allNonBasicAscii';\n        }\n        const set = new Set();\n        if (this.options.invisibleCharacters) {\n            for (const cp of strings.InvisibleCharacters.codePoints) {\n                set.add(cp);\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n                set.add(cp);\n            }\n        }\n        for (const cp of this.allowedCodePoints) {\n            set.delete(cp);\n        }\n        return set;\n    }\n    shouldHighlightNonBasicASCII(character) {\n        const codePoint = character.codePointAt(0);\n        if (this.allowedCodePoints.has(codePoint)) {\n            return 0 /* None */;\n        }\n        if (this.options.nonBasicASCII) {\n            return 1 /* NonBasicASCII */;\n        }\n        if (this.options.invisibleCharacters) {\n            const isAllowedInvisibleCharacter = character === ' ' || character === '\\n' || character === '\\t';\n            // TODO check for emojis\n            if (!isAllowedInvisibleCharacter && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                return 2 /* Invisible */;\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n                return 3 /* Ambiguous */;\n            }\n        }\n        return 0 /* None */;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../base/common/objects.js';\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport var OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\n/**\n * Position in the minimap to render the decoration.\n */\nexport var MinimapPosition;\n(function (MinimapPosition) {\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {}));\nexport var InjectedTextCursorStops;\n(function (InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nexport class TextModelResolvedOptions {\n    /**\n     * @internal\n     */\n    constructor(src) {\n        this._textModelResolvedOptionsBrand = undefined;\n        this.tabSize = Math.max(1, src.tabSize | 0);\n        this.indentSize = src.tabSize | 0;\n        this.insertSpaces = Boolean(src.insertSpaces);\n        this.defaultEOL = src.defaultEOL | 0;\n        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.tabSize === other.tabSize\n            && this.indentSize === other.indentSize\n            && this.insertSpaces === other.insertSpaces\n            && this.defaultEOL === other.defaultEOL\n            && this.trimAutoWhitespace === other.trimAutoWhitespace\n            && equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));\n    }\n    /**\n     * @internal\n     */\n    createChangeEvent(newOpts) {\n        return {\n            tabSize: this.tabSize !== newOpts.tabSize,\n            indentSize: this.indentSize !== newOpts.indentSize,\n            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n        };\n    }\n}\nexport class FindMatch {\n    /**\n     * @internal\n     */\n    constructor(range, matches) {\n        this._findMatchBrand = undefined;\n        this.range = range;\n        this.matches = matches;\n    }\n}\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation {\n    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {\n        this.identifier = identifier;\n        this.range = range;\n        this.text = text;\n        this.forceMoveMarkers = forceMoveMarkers;\n        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;\n        this._isTracked = _isTracked;\n    }\n}\n/**\n * @internal\n */\nexport class SearchData {\n    constructor(regex, wordSeparators, simpleSearch) {\n        this.regex = regex;\n        this.wordSeparators = wordSeparators;\n        this.simpleSearch = simpleSearch;\n    }\n}\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {\n        this.reverseEdits = reverseEdits;\n        this.changes = changes;\n        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;\n    }\n}\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model) {\n    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThanEqual, lengthOfString, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nexport class BracketPairsTree extends Disposable {\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this._register(textModel.onBackgroundTokenizationStateChanged(() => {\n            if (textModel.backgroundTokenizationState === 2 /* Completed */) {\n                const wasUndefined = this.initialAstWithoutTokens === undefined;\n                // Clear the initial tree as we can use the tree with token information now.\n                this.initialAstWithoutTokens = undefined;\n                if (!wasUndefined) {\n                    this.didChangeEmitter.fire();\n                }\n            }\n        }));\n        this._register(textModel.onDidChangeTokens(({ ranges }) => {\n            const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n            this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n            if (!this.initialAstWithoutTokens) {\n                this.didChangeEmitter.fire();\n            }\n        }));\n        if (textModel.backgroundTokenizationState === 0 /* Uninitialized */) {\n            // There are no token information yet\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.backgroundTokenizationState === 2 /* Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else if (textModel.backgroundTokenizationState === 1 /* InProgress */) {\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    handleContentChanged(change) {\n        const edits = change.changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n        if (this.initialAstWithoutTokens) {\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(edits, this.initialAstWithoutTokens, false);\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range) {\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        const result = new Array();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        collectBrackets(node, lengthZero, node.length, startOffset, endOffset, result);\n        return result;\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        const result = new Array();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        const context = new CollectBracketPairsContext(result, includeMinIndentation, this.textModel);\n        collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context);\n        return result;\n    }\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level = 0) {\n    if (node.kind === 1 /* Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level - 1, false));\n    }\n    else if (node.kind === 3 /* UnexpectedClosingBracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level - 1, true));\n    }\n    else if (node.kind === 4 /* List */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n    }\n    else if (node.kind === 2 /* Pair */) {\n        // Don't use node.children here to improve performance\n        level++;\n        {\n            const child = node.openingBracket;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        if (node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        if (node.closingBracket) {\n            const child = node.closingBracket;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(result, includeMinIndentation, textModel) {\n        this.result = result;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffset, nodeOffsetEnd, startOffset, endOffset, context, level = 0) {\n    var _a;\n    if (node.kind === 2 /* Pair */) {\n        const openingBracketEnd = lengthAdd(nodeOffset, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffset, context.textModel);\n        }\n        context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffset, nodeOffsetEnd), lengthsToRange(nodeOffset, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)\n            : undefined, level, minIndentation));\n        level++;\n    }\n    let curOffset = nodeOffset;\n    for (const child of node.children) {\n        const childOffset = curOffset;\n        curOffset = lengthAdd(curOffset, child.length);\n        if (lengthLessThanEqual(childOffset, endOffset) && lengthLessThanEqual(startOffset, curOffset)) {\n            collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(textModel.onDidChangeOptions(e => {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }));\n        this._register(textModel.onDidChangeLanguage(e => {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }));\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.bracketPairsTree.clear();\n                this.updateBracketPairsTree();\n            }\n        }));\n    }\n    get isDocumentSupported() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.isDocumentSupported) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    handleContentChanged(change) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || [];\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || [];\n    }\n    getBracketsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range)) || [];\n    }\n    findMatchingBracketUp(_bracket, _position) {\n        const bracket = _bracket.toLowerCase();\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n        if (!bracketsSupport) {\n            return null;\n        }\n        const data = bracketsSupport.textIsBracket[bracket];\n        if (!data) {\n            return null;\n        }\n        return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));\n    }\n    matchBracket(position) {\n        return this._matchBracket(this.textModel.validatePosition(position));\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], null);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(modeBrackets, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(modeBrackets, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        let continueSearchPredicate;\n        if (typeof maxDuration === 'undefined') {\n            continueSearchPredicate = null;\n        }\n        else {\n            const startTime = Date.now();\n            continueSearchPredicate = () => {\n                return (Date.now() - startTime <= maxDuration);\n            };\n        }\n        const position = this.textModel.validatePosition(_position);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(modeBrackets, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const data = modeBrackets.textIsBracket[text];\n        if (!data) {\n            return null;\n        }\n        return {\n            range: r,\n            open: data.open,\n            close: data.close,\n            isOpen: modeBrackets.textIsOpenBracket[text]\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    constructor(length) {\n        this._length = length;\n    }\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = new Array();\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        let lastChild = this;\n        let lastLength;\n        while (lastChild.kind === 4 /* List */ && (lastLength = lastChild.childrenLength) > 0) {\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    constructor(length, languageId, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.languageId = languageId;\n        this.bracketIds = bracketIds;\n    }\n    static create(length, languageId, bracketIds) {\n        const node = new BracketAstNode(length, languageId, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    get kind() {\n        return 3 /* UnexpectedClosingBracket */;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthToObj, toLength } from './length.js';\nexport class TextEditInfo {\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits, documentLength) {\n        this.documentLength = documentLength;\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : this.documentLength;\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(languageId, openingText) {\n            return denseKeyProvider.getKey(`${languageId}:::${openingText}`);\n        }\n        const brackets = configuration.characterPair.getColorizedBrackets();\n        const closingBrackets = new Map();\n        const openingBrackets = new Set();\n        for (const [openingText, closingText] of brackets) {\n            openingBrackets.add(openingText);\n            let info = closingBrackets.get(closingText);\n            const openingTextId = getId(configuration.languageId, openingText);\n            if (!info) {\n                info = { openingBrackets: SmallImmutableSet.getEmpty(), first: openingTextId };\n                closingBrackets.set(closingText, info);\n            }\n            info.openingBrackets = info.openingBrackets.add(openingTextId, identityKeyProvider);\n        }\n        const map = new Map();\n        for (const [closingText, info] of closingBrackets) {\n            const length = toLength(0, closingText.length);\n            map.set(closingText, new Token(length, 2 /* ClosingBracket */, info.first, info.openingBrackets, BracketAstNode.create(length, configuration.languageId, info.openingBrackets)));\n        }\n        for (const openingText of openingBrackets) {\n            const length = toLength(0, openingText.length);\n            const openingTextId = getId(configuration.languageId, openingText);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingText, new Token(length, 1 /* OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, configuration.languageId, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'g') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value);\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    const escaped = escapeRegExpCharacters(str);\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\" (see https://github.com/microsoft/vscode/issues/132162)\n    const needsWordBoundaries = (/^[\\w ]+$/.test(str));\n    return (needsWordBoundaries ? `\\\\b${escaped}\\\\b` : escaped);\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        const existing = this.languageIdToBracketTokens.get(languageId);\n        if (!existing) {\n            return false;\n        }\n        const newRegExpStr = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider).getRegExpStr();\n        return existing.getRegExpStr() !== newRegExpStr;\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\n/**\n * Represents a non-negative length in terms of line and column count.\n * Prefer using {@link Length} for performance reasons.\n*/\nexport class LengthObj {\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\nLengthObj.zero = new LengthObj(0, 0);\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n *\n * Set boolean to `true` when debugging, so that debugging is easier.\n */\nconst factor = /* is debug: */ false ? 100000 : Math.pow(2, 26);\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new LengthObj(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    return ((l2 < factor)\n        ? (l1 + l2) // l2 is the amount of columns (zero line count). Keep the column count from l1.\n        : (l1 - (l1 % factor) + l2)); // l1 - (l1 % factor) equals toLength(l1.lineCount, 0)\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = new Array();\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = new Array();\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits, tokenizer.length);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty());\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds) {\n        const items = new Array();\n        while (true) {\n            const token = this.tokenizer.peek();\n            if (!token ||\n                (token.kind === 2 /* ClosingBracket */ &&\n                    token.bracketIds.intersects(openedBracketIds))) {\n                break;\n            }\n            const child = this.parseChild(openedBracketIds);\n            if (child.kind === 4 /* List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    parseChild(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (!lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    if (!lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* Text */:\n                return token.astNode;\n            case 1 /* OpeningBracket */: {\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = new Array();\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static getEmpty() {\n        return this.empty;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = new Array();\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../languages.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* Other */;\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (isOther && endOffset !== this.lineCharOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(brackets.getRegExpStr() + '|\\n', 'g') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = new Array();\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = new Array();\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.onDidChangeOptions(e => {\n            this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        }));\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = new Array();\n        const bracketsInRange = this.textModel.bracketPairs.getBracketsInRange(range);\n        for (const bracket of bracketsInRange) {\n            result.push({\n                id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n                options: { description: 'BracketPairColorization', inlineClassName: this.colorProvider.getInlineClassName(bracket) },\n                ownerId: 0,\n                range: bracket.range\n            });\n        }\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageAgnosticBracketTokens } from './bracketPairsTree/brackets.js';\nimport { lengthAdd, lengthGetColumnCountIfZeroLineCount, lengthZero } from './bracketPairsTree/length.js';\nimport { parseDocument } from './bracketPairsTree/parser.js';\nimport { DenseKeyProvider } from './bracketPairsTree/smallImmutableSet.js';\nimport { TextBufferTokenizer } from './bracketPairsTree/tokenizer.js';\nexport function fixBracketsInLine(tokens, languageConfigurationService) {\n    const denseKeyProvider = new DenseKeyProvider();\n    const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));\n    const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);\n    const node = parseDocument(tokenizer, [], undefined, true);\n    let str = '';\n    const line = tokens.getLineContent();\n    function processNode(node, offset) {\n        if (node.kind === 2 /* Pair */) {\n            processNode(node.openingBracket, offset);\n            offset = lengthAdd(offset, node.openingBracket.length);\n            if (node.child) {\n                processNode(node.child, offset);\n                offset = lengthAdd(offset, node.child.length);\n            }\n            if (node.closingBracket) {\n                processNode(node.closingBracket, offset);\n                offset = lengthAdd(offset, node.closingBracket.length);\n            }\n            else {\n                const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node.openingBracket.languageId);\n                const closingTokenText = singleLangBracketTokens.findClosingTokenText(node.openingBracket.bracketIds);\n                str += closingTokenText;\n            }\n        }\n        else if (node.kind === 3 /* UnexpectedClosingBracket */) {\n            // remove the bracket\n        }\n        else if (node.kind === 0 /* Text */ || node.kind === 1 /* Bracket */) {\n            str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node.length)));\n        }\n        else if (node.kind === 4 /* List */) {\n            for (const child of node.children) {\n                processNode(child, offset);\n                offset = lengthAdd(offset, child.length);\n            }\n        }\n    }\n    processNode(node, lengthZero);\n    return str;\n}\nclass StaticTokenizerSource {\n    constructor(lines) {\n        this.lines = lines;\n    }\n    getLineCount() {\n        return this.lines.length;\n    }\n    getLineLength(lineNumber) {\n        return this.lines[lineNumber - 1].getLineContent().length;\n    }\n    getLineTokens(lineNumber) {\n        return this.lines[lineNumber - 1];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    constructor(model, beforeCursorState) {\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    get type() {\n        return 0 /* Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    get label() {\n        return nls.localize('edit', \"Typing\");\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    constructor(label, editStackElements) {\n        this.type = 1 /* Workspace */;\n        this.label = label;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        let result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* LF */;\n    }\n    else {\n        return 1 /* CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue, findLast } from '../../../base/common/arrays.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        var _a, _b, _c, _d, _e;\n        const result = [];\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber)));\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                ? // Does active position intersect with the view port? -> Intersect bracket pairs with activePosition\n                    bracketPairs.filter((bp) => Range.strictContainsPosition(bp.range, activePosition))\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition));\n            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, \n            /* Exclude single line bracket pairs for cases such as\n             * ```\n             * function test() {\n             * \t\tif (true) { | }\n             * }\n             * ```\n             */\n            (i) => i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n        }\n        const queue = new ArrayQueue(bracketPairs);\n        /** Indexed by nesting level */\n        const activeGuides = new Array();\n        const nextGuides = new Array();\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            let guides = new Array();\n            if (nextGuides.length > 0) {\n                guides = guides.concat(nextGuides);\n                nextGuides.length = 0;\n            }\n            result.push(guides);\n            // Update activeGuides\n            for (const pair of queue.takeWhile((b) => b.openingBracketRange.startLineNumber <= lineNumber) || []) {\n                if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                    // ignore single line brackets\n                    continue;\n                }\n                const guideVisibleColumn = Math.min(this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition()), this.getVisibleColumnFromPosition((_c = (_b = pair.closingBracketRange) === null || _b === void 0 ? void 0 : _b.getStartPosition()) !== null && _c !== void 0 ? _c : pair.range.getEndPosition()), pair.minVisibleColumnIndentation + 1);\n                let renderHorizontalEndLineAtTheBottom = false;\n                if (pair.closingBracketRange) {\n                    const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n                    if (firstNonWsIndex < pair.closingBracketRange.startColumn - 1) {\n                        renderHorizontalEndLineAtTheBottom = true;\n                    }\n                }\n                const start = pair.openingBracketRange.getStartPosition();\n                const end = (_e = (_d = pair.closingBracketRange) === null || _d === void 0 ? void 0 : _d.getStartPosition()) !== null && _e !== void 0 ? _e : pair.range.getEndPosition();\n                if (pair.closingBracketRange === undefined) {\n                    // Don't show guides for bracket pairs that are not balanced.\n                    // See #135125.\n                    activeGuides[pair.nestingLevel] = null;\n                }\n                else {\n                    activeGuides[pair.nestingLevel] = {\n                        nestingLevel: pair.nestingLevel,\n                        guideVisibleColumn,\n                        start,\n                        visibleStartColumn: this.getVisibleColumnFromPosition(start),\n                        end,\n                        visibleEndColumn: this.getVisibleColumnFromPosition(end),\n                        bracketPair: pair,\n                        renderHorizontalEndLineAtTheBottom,\n                    };\n                }\n            }\n            for (const line of activeGuides) {\n                if (!line) {\n                    continue;\n                }\n                const isActive = activeBracketPairRange &&\n                    line.bracketPair.range.equalsRange(activeBracketPairRange);\n                const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) +\n                    (options.highlightActive && isActive\n                        ? ' ' + colorProvider.activeClassName\n                        : '');\n                if ((isActive &&\n                    options.horizontalGuides !==\n                        HorizontalGuidesState.Disabled) ||\n                    (options.includeInactive &&\n                        options.horizontalGuides === HorizontalGuidesState.Enabled)) {\n                    if (line.start.lineNumber === lineNumber) {\n                        if (line.guideVisibleColumn < line.visibleStartColumn) {\n                            guides.push(new IndentGuide(line.guideVisibleColumn, className, new IndentGuideHorizontalLine(false, line.start.column)));\n                        }\n                    }\n                    if (line.end.lineNumber === lineNumber + 1) {\n                        // The next line might have horizontal guides.\n                        // However, the next line might also have a new bracket pair with the same indentation,\n                        // so the current bracket pair might get replaced. That's why we push the guide to nextGuides one line ahead.\n                        if (line.guideVisibleColumn < line.visibleEndColumn) {\n                            nextGuides.push(new IndentGuide(line.guideVisibleColumn, className, new IndentGuideHorizontalLine(!line.renderHorizontalEndLineAtTheBottom, line.end.column)));\n                        }\n                    }\n                }\n            }\n            let lastVisibleColumnCount = Number.MAX_SAFE_INTEGER;\n            // Going backwards, so the last guide potentially replaces others\n            for (let i = activeGuides.length - 1; i >= 0; i--) {\n                const line = activeGuides[i];\n                if (!line) {\n                    continue;\n                }\n                const isActive = options.highlightActive &&\n                    activeBracketPairRange &&\n                    line.bracketPair.range.equalsRange(activeBracketPairRange);\n                const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) +\n                    (isActive ? ' ' + colorProvider.activeClassName : '');\n                if (isActive || options.includeInactive) {\n                    if (line.renderHorizontalEndLineAtTheBottom &&\n                        line.end.lineNumber === lineNumber + 1) {\n                        nextGuides.push(new IndentGuide(line.guideVisibleColumn, className, null));\n                    }\n                }\n                if (line.end.lineNumber <= lineNumber ||\n                    line.start.lineNumber >= lineNumber) {\n                    continue;\n                }\n                if (line.guideVisibleColumn >= lastVisibleColumnCount && !isActive) {\n                    // Don't render a guide on top of an existing guide, unless it is active.\n                    continue;\n                }\n                lastVisibleColumnCount = line.guideVisibleColumn;\n                if (isActive || options.includeInactive) {\n                    guides.push(new IndentGuide(line.guideVisibleColumn, className, null));\n                }\n            }\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* ColorMaskInverse */) | (color << 0 /* ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* IsForValidationOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* StickinessMask */) >>> 3 /* StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* StickinessMaskInverse */) | (stickiness << 3 /* StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* CollapseOnReplaceEditMask */) >>> 5 /* CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        _setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* EditorWarningDecoration */\n            || className === \"squiggly-info\" /* EditorInfoDecoration */));\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* Red */) {\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(y, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* Red */) {\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(y, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* Red */) {\n                setNodeColor(w, 0 /* Black */);\n                setNodeColor(x.parent, 1 /* Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\n                setNodeColor(w, 1 /* Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* Black */) {\n                    setNodeColor(w.left, 0 /* Black */);\n                    setNodeColor(w, 1 /* Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(w.right, 0 /* Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* Red */) {\n                setNodeColor(w, 0 /* Black */);\n                setNodeColor(x.parent, 1 /* Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\n                setNodeColor(w, 1 /* Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* Black */) {\n                    setNodeColor(w.right, 0 /* Black */);\n                    setNodeColor(w, 1 /* Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(w.left, 0 /* Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n"],"names":["computeDiff","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","LineSequence","lines","startColumns","endColumns","i","length","getFirstNonBlankColumn","getLastNonBlankColumn","this","_startColumns","_endColumns","elements","len","substring","index","shouldIgnoreTrimWhitespace","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","startColumn","endColumn","col","charCodeAt","CharSequence","_charCodes","_lineNumbers","_columns","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","diffChange","originalCharSequence","modifiedCharSequence","originalLength","getStartLineNumber","originalStart","getStartColumn","getEndLineNumber","getEndColumn","modifiedLength","modifiedStart","LineChange","charChanges","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","undefined","createCharSequence","rawChanges","changes","result","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","Math","min","push","postProcessCharChanges","createFromDiffChange","DiffComputer","originalLines","modifiedLines","opts","shouldMakePrettyDiff","original","modified","continueLineDiff","createContinueProcessingPredicate","maxComputationTime","quitEarly","diffResult","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","strings","maximumRuntime","startTime","Date","now","InternalEditorAction","id","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","contextMatchesRules","isSupported","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","nls","focus","textInputFocus","readOnly","inDiffEditor","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","inCompositeEditor","notInCompositeEditor","languageId","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","score","selector","candidateUri","candidateLanguage","candidateIsSynchronized","Array","isArray","ret","value","language","pattern","scheme","hasAccessToAllModels","max","normalizedPattern","Object","assign","base","normalize","fsPath","matchGlobPattern","isExclusive","every","exclusive","CompletionItemKinds","InlineCompletionTriggerKind","SignatureHelpTriggerKind","DocumentHighlightKind","SymbolKinds","LanguageFeatureRegistry","_clock","_entries","_onDidChange","Emitter","event","provider","entry","_score","_time","_lastCandidate","fire","toDisposable","idx","indexOf","splice","model","all","_updateScores","_orderedForEach","lastBucket","lastBucketScore","callback","candidate","uri","toString","getLanguageId","shouldSynchronizeModel","sort","_compareByScoreAndTime","a","b","TokenMetadata","metadata","className","getForeground","fontStyle","getFontStyle","colorMap","foreground","textDecoration","italic","Boolean","bold","underline","strikethrough","Token","offset","type","_tokenBrand","TokenizationResult","tokens","endState","_tokenizationResultBrand","EncodedTokenizationResult","_encodedTokenizationResultBrand","isLocationLink","thing","URI","Range","range","originSelectionRange","targetSelectionRange","byKind","Map","set","Codicon","toIcon","kind","codicon","get","console","info","data","fromString","strict","res","icon","Command","InlayHintKind","FoldingRangeKind","Comment","Imports","Region","is","obj","title","ReferenceProviderRegistry","RenameProviderRegistry","CompletionProviderRegistry","InlineCompletionsProviderRegistry","SignatureHelpProviderRegistry","HoverProviderRegistry","DocumentSymbolProviderRegistry","DocumentHighlightProviderRegistry","LinkedEditingRangeProviderRegistry","DefinitionProviderRegistry","DeclarationProviderRegistry","ImplementationProviderRegistry","TypeDefinitionProviderRegistry","CodeLensProviderRegistry","InlayHintsProviderRegistry","CodeActionProviderRegistry","DocumentFormattingEditProviderRegistry","DocumentRangeFormattingEditProviderRegistry","OnTypeFormattingEditProviderRegistry","LinkProviderRegistry","ColorProviderRegistry","SelectionRangeRegistry","FoldingRangeProviderRegistry","DocumentSemanticTokensProviderRegistry","DocumentRangeSemanticTokensProviderRegistry","TokenizationRegistry","TokenizationRegistryImpl","IndentAction","StandardAutoClosingPairConditional","source","_neutralCharacter","_neutralCharacterSearched","open","close","_inString","_inComment","_inRegEx","notIn","standardToken","context","column","getTokenCount","tokenIndex","findTokenIndexAtOffset","standardTokenType","getStandardTokenType","isOK","fromCharCode","toCharCode","charCode","character","String","includes","_findNeutralCharacterInRange","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","charAt","target","key","has","CharacterPairSupport","config","_autoClosingPairs","map","el","brackets","colorizedBracketPairs","_colorizedBracketPairs","filterValidBrackets","filter","p","__electricCharacterSupport","docComment","_autoCloseBefore","autoCloseBefore","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED","_surroundingPairs","surroundingPairs","bracketPairs","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","bracket","lastChar","distinct","ignoreBracketsInToken","reversedBracketRegex","reversedRegex","text","getLineContent","BracketsUtils","bracketText","toLowerCase","textIsOpenBracket","textBeforeBracket","getActualLineContentBefore","test","matchOpenBracket","resetGlobalRegex","reg","global","lastIndex","IndentRulesSupport","indentationRules","_indentationRules","increaseIndentPattern","decreaseIndentPattern","indentNextLinePattern","unIndentedLinePattern","shouldIncrease","shouldDecrease","shouldIndentNextLine","shouldIgnore","OnEnterSupport","_brackets","forEach","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","autoIndent","previousLineText","beforeEnterText","afterEnterText","rule","beforeText","afterText","action","indentAction","str","_safeRegExp","def","RegExp","err","onUnexpectedError","__decorate","decorators","desc","d","c","arguments","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","LanguageConfigurationServiceChangeEvent","ILanguageConfigurationService","createDecorator","LanguageConfigurationService","configurationService","languageService","onDidChangeEmitter","_register","onDidChange","configurations","languageConfigKeys","Set","values","customizedLanguageConfigKeys","onDidChangeConfiguration","e","globalConfigChanged","change","keys","some","k","localConfigChanged","overrides","clear","isRegisteredLanguageId","delete","LanguageConfigurationRegistry","languageConfig","getLanguageConfiguration","Error","ResolvedLanguageConfiguration","customizedConfig","getValue","overrideIdentifier","validateBracketPairs","getCustomizedLanguageConfig","combineLanguageConfigurations","underlyingConfig","computeConfig","Disposable","IConfigurationService","ILanguageService","LanguageConfigurationChangeEvent","LanguageConfigurationRegistryImpl","configuration","priority","entries","ComposedLanguageConfiguration","disposable","register","dispose","getResolvedConfiguration","comments","indentRulesSupport","lineNumber","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","honorIntentialIndent","getIndentRulesSupport","indentation","precedingUnIgnoredLine","getPrecedingValidLine","precedingUnIgnoredLineContent","line","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","j","virtualModel","indentConverter","richEditSupport","indent","getInheritIndentForLine","inheritLine","enterResult","onEnter","removeText","shiftIndent","unshiftIndent","appendText","forceTokenization","startLineNumber","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","scopedLineText","embeddedLanguage","firstCharOffset","substr","isEmpty","getScopedLineTokens","endLineNumber","beforeEnterResult","beforeEnterIndent","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","ch","afterTypeText","beforeTypeText","getLineCount","oneLineAboveScopedLineTokens","getIndentationAtPosition","lineText","columnNumber","getLineMaxColumn","_resolved","_order","LanguageConfigurationContribution","_resolve","cmp","configs","wordPattern","folding","order","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","DEFAULT_WORD_REGEXP","foldingRules","ensureValidWordDefinition","RichEditBrackets","getAutoClosingPairs","getAutoCloseBeforeSet","getSurroundingPairs","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","registerSingleton","Uint8Matrix","rows","cols","Uint8Array","_data","row","StateMachine","edges","maxCharCode","maxState","from","chCode","to","states","_states","_maxCharCode","currentState","_stateMachine","getStateMachine","_classifier","getClassifier","CharacterClassifier","FORCE_TERMINATION_CHARACTERS","LinkComputer","classifier","linkBeginIndex","linkEndIndex","lastIncludedCharIndex","charCodeBeforeLink","lastCharCodeInLink","url","stateMachine","lineCount","linkBeginChCode","state","hasOpenParens","hasOpenSquareBracket","inSquareBrackets","hasOpenCurlyBracket","resetStateMachine","chClass","_createLink","nextState","computeLinks","ModesRegistry","_onDidChangeLanguages","onDidChangeLanguages","_languages","Registry","PLAINTEXT_LANGUAGE_ID","registerLanguage","extensions","aliases","mimetypes","Mimes","offSide","ConfigurationExtensions","registerDefaultConfigurations","NullState","other","nullTokenize","nullTokenizeEncoded","Uint32Array","tokenCount","getCount","desiredLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","getStartOffset","getEndOffset","actual","lastCharOffset","_scopedLineTokensBrand","_actual","_firstTokenIndex","_lastTokenIndex","_lastCharOffset","BasicInplaceReplace","_defaultValueSet","range1","text1","range2","text2","up","doNavigateValueSet","numberResult","numberReplace","textReplace","precision","pow","lastIndexOf","n1","Number","n2","parseFloat","isNaN","floor","valueSetsReplace","valueSets","valueSetReplace","valueSet","INSTANCE","RichEditBracket","forwardRegex","_richEditBracketBrand","_openSet","_toSet","_closeSet","arr","element","add","_richEditBracketsBrand","N","group","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","oldG","g","currentOpen","currentClose","groupFuzzyBrackets","currentIndex","pieces","concat","collectSuperstrings","unique","lengthcmp","reverse","createBracketOrRegExp","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","maxBracketLength","dest","seen","prepareBracketForRegExp","insertWordBoundaries","regexStr","join","lastInput","lastOutput","stringBuilder","Uint16Array","decode","resultLen","reversedText","m","match","matchOffset","matchLength","absoluteMatchOffset","startOffset","endOffset","reversedSubstr","_findPrevBracketInText","bracketRegex","findNextBracketInText","ParsedTokenThemeRule","token","background","_parsedThemeRuleBrand","resolveParsedTokenThemeRules","parsedThemeRules","customTokenColors","strcmp","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","shift","ColorMap","color","getId","foregroundColorId","backgroundColorId","defaults","ThemeTrieElementRule","root","ThemeTrieElement","insert","TokenTheme","colorRegExp","_lastColorId","_id2color","_color2id","toUpperCase","Color","slice","_colorMap","_root","_cache","getColorMap","_match","tokenType","STANDARD_TOKEN_TYPE_REGEXP","toStandardTokenType","createFromParsedTokenTheme","segments","split","lenJ","parseTokenTheme","_themeTrieElementRuleBrand","_fontStyle","_foreground","_background","mainRule","_themeTrieElementBrand","_mainRule","_children","head","tail","dotIndex","child","clone","acceptOverwrite","generateTokensCSSForColorMap","rules","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","step","next","rejected","done","then","apply","fallback","getInitialState","tokenizeEncoded","buffer","hasEOL","tokenizeToString","_tokenizeToString","languageIdCodec","tokenizationSupport","tokenizeLineToHTML","viewLineTokens","tabSize","useNbsp","charIndex","tabsCharDelta","prevIsSpace","tokenEndIndex","partContent","insertSpacesCount","getInlineStyle","tokenizationResult","LineTokens","inflate","getClassName","UnicodeTextModelHighlighter","options","regex","codePoints","startLine","endLine","codePointHighlighter","CodePointHighlighter","candidates","getCandidateCodePoints","fromCodePoint","searcher","Searcher","ranges","hasMore","ambiguousCharacterCount","invisibleCharacterCount","nonBasicAsciiCharacterCount","forLoop","lineLength","reset","charCodeBefore","highlightReason","shouldHighlightNonBasicASCII","assertNever","char","codePoint","codePointAt","primaryConfusable","ambiguousCharacters","getPrimaryConfusable","notAmbiguousInLocales","l","allowedLocales","isAmbiguous","confusableWith","allowedCodePoints","nonBasicASCII","invisibleCharacters","cp","getConfusableCodePoints","OverviewRulerLane","MinimapPosition","InjectedTextCursorStops","TextModelResolvedOptions","src","_textModelResolvedOptionsBrand","indentSize","insertSpaces","defaultEOL","trimAutoWhitespace","bracketPairColorizationOptions","equals","newOpts","FindMatch","matches","_findMatchBrand","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","SearchData","wordSeparators","simpleSearch","ApplyEditsResult","reverseEdits","trimAutoWhitespaceLineNumbers","isTooLargeForSyncing","isForSimpleWidget","BracketPairsTree","textModel","didChangeEmitter","denseKeyProvider","DenseKeyProvider","LanguageAgnosticBracketTokens","onBackgroundTokenizationStateChanged","backgroundTokenizationState","wasUndefined","initialAstWithoutTokens","onDidChangeTokens","edits","TextEditInfo","toLength","fromLineNumber","toLineNumber","astWithTokens","parseDocumentFromTextBuffer","getSingleLanguageBracketTokens","tokenizer","FastTokenizer","parseDocument","didLanguageChange","positionToLength","getStartPosition","getEndPosition","lengthOfString","previousAst","immutable","previousAstClone","TextBufferTokenizer","node","collectBrackets","lengthZero","includeMinIndentation","startLength","endLength","CollectBracketPairsContext","collectBracketPairs","nodeOffsetStart","nodeOffsetEnd","level","lengthsToRange","BracketInfo","children","lengthAdd","lengthLessThanEqual","lengthGreaterThanEqual","openingBracket","closingBracket","nodeOffset","_a","openingBracketEnd","minIndentation","computeMinIndentation","BracketPairWithMinIndentationInfo","curOffset","childOffset","BracketPairsTextModelPart","languageConfigurationService","bracketPairsTree","MutableDisposable","bracketsRequested","onDidChangeOptions","updateBracketPairsTree","onDidChangeLanguage","object","getValueLength","isDocumentSupported","store","DisposableStore","handleContentChanged","getBracketPairsInRange","getBracketsInRange","_bracket","_position","position","validatePosition","bracketsSupport","stripBracketSearchCanceled","_findMatchingBracketUp","_matchBracket","modeBrackets","currentLanguageId","searchStartOffset","tokenEndOffset","searchEndOffset","tokenStartOffset","currentModeBrackets","_establishBracketSearchOffsets","bestResult","foundBracket","foundBracketText","_matchFoundBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","isOpen","continueSearchPredicate","matched","_findMatchingBracketDown","count","totalCallCount","searchPrevMatchingBracketInRange","hitText","isClose","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","tokenLanguageId","_toFoundBracket","maxDuration","savedCounts","counts","resetCounts","tmp","searchInRange","getValueInRange","_searchCanceledBrand","BaseAstNode","_length","PairAstNode","missingOpeningBracketIds","openBracketIds","intersects","deepClone","MAX_SAFE_INTEGER","SmallImmutableSet","ListAstNode","listHeight","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","childCount","childrenLength","lastChild","getChild","mutable","toMutable","setChild","firstChild","lastLength","canBeReused","unopenedBrackets","merge","item1","item2","item3","missingBracketIds","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_item1","_item2","_item3","handleChildrenChanged","ArrayListAstNode","item","pop","unshift","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","start","lengthToObj","columnCount","lengthGetLineCount","firstNonWsColumn","getLineFirstNonWhitespaceColumn","visibleColumn","CursorColumns","getOptions","BracketAstNode","bracketIds","InvalidBracketAstNode","closingBrackets","openedBracketIds","newLength","BeforeEditPositionMapper","documentLength","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","edit","TextEditInfoCache","adjustNextEdit","translateCurToOld","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","lengthDiffNonNegative","oldOffsetObj","newOffset","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength","BracketTokens","hasRegExp","_regExpGlobal","escaped","escapeRegExpCharacters","regExpStr","getRegExpStr","openingBracketIds","closingText","size","openingText","getKey","getColorizedBrackets","openingBrackets","openingTextId","first","identityKeyProvider","languageIdToBracketTokens","existing","newRegExpStr","createFromLanguage","singleLanguageBracketTokens","LengthObj","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","zero","lengthIsZero","factor","lengthGetColumnCountIfZeroLineCount","l1","l2","length1","length2","lineCount1","lineCount2","colCount2","lengthLessThan","lengthStart","lengthEnd","colCount","splitLines","concat23TreesOfSameHeight","items","createImmutableLists","heightDiff","node1","node2","abs","list","nodeToAppend","nodeToAppendOfCorrectHeight","curNode","parents","makeLastElementMutable","parent","unappendChild","appendChildOfSameHeight","append","makeFirstElementMutable","nodeToPrependOfCorrectHeight","unprependChild","prependChildOfSameHeight","prepend","NodeReader","lastOffset","nextNodes","offsets","idxs","predicate","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","peek","parseChild","readNode","height","second","concat23Trees","maxCacheableLength","getDistanceToNextChange","cachedNode","readLongestNodeAt","getOffsetBeforeChange","skip","read","astNode","nextToken","bracketId","emptyArr","additionalItems","keyProvider","newItem","create","newItems","merged","cached","cache","empty","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","textBufferLastLineLength","getLineLength","setPosition","lineIdx","lineCharOffset","lineTokenOffset","peekedToken","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","getMetadata","isOther","regexp","regExpGlobal","exec","getToken","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","NotSupportedError","ColorizedBracketPairsDecorationProvider","colorProvider","ColorProvider","colorizationOptions","ownerId","filterOutValidation","enabled","bracketsInRange","nestingLevel","description","inlineClassName","getInlineClassName","getDecorationsInRange","unexpectedClosingBracketClassName","isInvalid","getInlineClassNameOfLevel","registerThemingParticipant","theme","collector","colors","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","addRule","getColor","editorBracketHighlightingUnexpectedBracketForeground","colorValues","isTransparent","fixBracketsInLine","StaticTokenizerSource","processNode","closingTokenText","findClosingTokenText","uriGetComparisonKey","resource","SingleModelEditStackData","beforeVersionId","afterVersionId","beforeEOL","afterEOL","beforeCursorState","afterCursorState","textChanges","compressConsecutiveTextChanges","necessarySize","_writeSelectionsSize","writeSize","_writeSelections","write","alternativeVersionId","getAlternativeVersionId","eol","getModelEOL","selections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","Selection","_readSelections","changeCount","TextChange","SingleModelEditStackElement","deserialize","serialize","_applyUndo","_applyRedo","byteLength","MultiModelEditStackElement","editStackElements","_isOpen","_editStackElementsArr","_editStackElementsMap","editStackElement","_delegate","prepareUndoRedo","setModel","canAppend","undo","redo","heapSize","basename","getEOL","isEditStackElement","EditStack","undoRedoService","_model","_undoRedoService","lastElement","getLastElement","removeElements","newElement","pushElement","_getOrCreateEditStackElement","setEOL","editOperations","cursorStateComputer","inverseEditOperations","applyEdits","_computeCursorState","op","textChange","oldPosition","GuidesTextModelPart","lineIndex","computeIndentLevel","minLineNumber","maxLineNumber","assertNotDisposed","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","_computeIndentLevel","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","activePosition","_b","_c","_d","_e","getBracketPairsInRangeWithMinIndentation","activeBracketPairRange","bracketsContainingActivePosition","bp","findLast","queue","ArrayQueue","activeGuides","nextGuides","BracketPairGuidesClassNames","guides","takeWhile","openingBracketRange","guideVisibleColumn","getVisibleColumnFromPosition","closingBracketRange","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","end","visibleStartColumn","visibleEndColumn","bracketPair","isActive","equalsRange","highlightActive","activeClassName","horizontalGuides","HorizontalGuidesState","includeInactive","IndentGuide","IndentGuideHorizontalLine","lastVisibleColumnCount","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","TextModelPart","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","getLineCharCode","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","left","right","delta","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","versionId","collapseOnReplaceEdit","absoluteStart","absoluteEnd","SENTINEL","IntervalTree","requestNormalizeDelta","filterOwnerId","T","intervalStart","intervalEnd","nodeStart","nodeEnd","setCachedOffsets","include","intervalSearch","search","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","initialNode","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","x","zAbsoluteStart","zAbsoluteEnd","intervalCompare","treeInsert","recomputeMaxEndWalkToRoot","y","leftRotate","rightRotate","leftest","detach","resetSentinel","w","yWasRed","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd"],"sourceRoot":""}