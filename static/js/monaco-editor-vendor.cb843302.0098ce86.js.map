{"version":3,"file":"static/js/monaco-editor-vendor.cb843302.0098ce86.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingRanges.js","../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js","../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/hiddenRangeModel.js","../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/indentRangeProvider.js","../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/syntaxRangeProvider.js","../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/intializingRangeProvider.js","../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingDecorations.js","../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\nconst MASK_INDENT = 0xFF000000;\nexport class FoldingRegions {\n    constructor(startIndexes, endIndexes, types) {\n        if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n            throw new Error('invalid startIndexes or endIndexes size');\n        }\n        this._startIndexes = startIndexes;\n        this._endIndexes = endIndexes;\n        this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));\n        this._types = types;\n        this._parentsComputed = false;\n    }\n    ensureParentIndices() {\n        if (!this._parentsComputed) {\n            this._parentsComputed = true;\n            let parentIndexes = [];\n            let isInsideLast = (startLineNumber, endLineNumber) => {\n                let index = parentIndexes[parentIndexes.length - 1];\n                return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n            };\n            for (let i = 0, len = this._startIndexes.length; i < len; i++) {\n                let startLineNumber = this._startIndexes[i];\n                let endLineNumber = this._endIndexes[i];\n                if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n                    throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n                }\n                while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n                    parentIndexes.pop();\n                }\n                let parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n                parentIndexes.push(i);\n                this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n                this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n            }\n        }\n    }\n    get length() {\n        return this._startIndexes.length;\n    }\n    getStartLineNumber(index) {\n        return this._startIndexes[index] & MAX_LINE_NUMBER;\n    }\n    getEndLineNumber(index) {\n        return this._endIndexes[index] & MAX_LINE_NUMBER;\n    }\n    getType(index) {\n        return this._types ? this._types[index] : undefined;\n    }\n    hasTypes() {\n        return !!this._types;\n    }\n    isCollapsed(index) {\n        let arrayIndex = (index / 32) | 0;\n        let bit = index % 32;\n        return (this._collapseStates[arrayIndex] & (1 << bit)) !== 0;\n    }\n    setCollapsed(index, newState) {\n        let arrayIndex = (index / 32) | 0;\n        let bit = index % 32;\n        let value = this._collapseStates[arrayIndex];\n        if (newState) {\n            this._collapseStates[arrayIndex] = value | (1 << bit);\n        }\n        else {\n            this._collapseStates[arrayIndex] = value & ~(1 << bit);\n        }\n    }\n    setCollapsedAllOfType(type, newState) {\n        let hasChanged = false;\n        if (this._types) {\n            for (let i = 0; i < this._types.length; i++) {\n                if (this._types[i] === type) {\n                    this.setCollapsed(i, newState);\n                    hasChanged = true;\n                }\n            }\n        }\n        return hasChanged;\n    }\n    toRegion(index) {\n        return new FoldingRegion(this, index);\n    }\n    getParentIndex(index) {\n        this.ensureParentIndices();\n        let parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n        if (parent === MAX_FOLDING_REGIONS) {\n            return -1;\n        }\n        return parent;\n    }\n    contains(index, line) {\n        return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n    }\n    findIndex(line) {\n        let low = 0, high = this._startIndexes.length;\n        if (high === 0) {\n            return -1; // no children\n        }\n        while (low < high) {\n            let mid = Math.floor((low + high) / 2);\n            if (line < this.getStartLineNumber(mid)) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low - 1;\n    }\n    findRange(line) {\n        let index = this.findIndex(line);\n        if (index >= 0) {\n            let endLineNumber = this.getEndLineNumber(index);\n            if (endLineNumber >= line) {\n                return index;\n            }\n            index = this.getParentIndex(index);\n            while (index !== -1) {\n                if (this.contains(index, line)) {\n                    return index;\n                }\n                index = this.getParentIndex(index);\n            }\n        }\n        return -1;\n    }\n    toString() {\n        let res = [];\n        for (let i = 0; i < this.length; i++) {\n            res[i] = `[${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n        }\n        return res.join(', ');\n    }\n}\nexport class FoldingRegion {\n    constructor(ranges, index) {\n        this.ranges = ranges;\n        this.index = index;\n    }\n    get startLineNumber() {\n        return this.ranges.getStartLineNumber(this.index);\n    }\n    get endLineNumber() {\n        return this.ranges.getEndLineNumber(this.index);\n    }\n    get regionIndex() {\n        return this.index;\n    }\n    get parentIndex() {\n        return this.ranges.getParentIndex(this.index);\n    }\n    get isCollapsed() {\n        return this.ranges.isCollapsed(this.index);\n    }\n    containedBy(range) {\n        return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n    }\n    containsLine(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\nexport class FoldingModel {\n    constructor(textModel, decorationProvider) {\n        this._updateEventEmitter = new Emitter();\n        this.onDidChange = this._updateEventEmitter.event;\n        this._textModel = textModel;\n        this._decorationProvider = decorationProvider;\n        this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n        this._editorDecorationIds = [];\n        this._isInitialized = false;\n    }\n    get regions() { return this._regions; }\n    get textModel() { return this._textModel; }\n    get isInitialized() { return this._isInitialized; }\n    toggleCollapseState(toggledRegions) {\n        if (!toggledRegions.length) {\n            return;\n        }\n        toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\n        const processed = {};\n        this._decorationProvider.changeDecorations(accessor => {\n            let k = 0; // index from [0 ... this.regions.length]\n            let dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n            let lastHiddenLine = -1; // the end of the last hidden lines\n            const updateDecorationsUntil = (index) => {\n                while (k < index) {\n                    const endLineNumber = this._regions.getEndLineNumber(k);\n                    const isCollapsed = this._regions.isCollapsed(k);\n                    if (endLineNumber <= dirtyRegionEndLine) {\n                        accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine));\n                    }\n                    if (isCollapsed && endLineNumber > lastHiddenLine) {\n                        lastHiddenLine = endLineNumber;\n                    }\n                    k++;\n                }\n            };\n            for (let region of toggledRegions) {\n                let index = region.regionIndex;\n                let editorDecorationId = this._editorDecorationIds[index];\n                if (editorDecorationId && !processed[editorDecorationId]) {\n                    processed[editorDecorationId] = true;\n                    updateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n                    let newCollapseState = !this._regions.isCollapsed(index);\n                    this._regions.setCollapsed(index, newCollapseState);\n                    dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\n                }\n            }\n            updateDecorationsUntil(this._regions.length);\n        });\n        this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });\n    }\n    update(newRegions, blockedLineNumers = []) {\n        let newEditorDecorations = [];\n        let isBlocked = (startLineNumber, endLineNumber) => {\n            for (let blockedLineNumber of blockedLineNumers) {\n                if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\n                    return true;\n                }\n            }\n            return false;\n        };\n        let lastHiddenLine = -1;\n        let initRange = (index, isCollapsed) => {\n            const startLineNumber = newRegions.getStartLineNumber(index);\n            const endLineNumber = newRegions.getEndLineNumber(index);\n            if (!isCollapsed) {\n                isCollapsed = newRegions.isCollapsed(index);\n            }\n            if (isCollapsed && isBlocked(startLineNumber, endLineNumber)) {\n                isCollapsed = false;\n            }\n            newRegions.setCollapsed(index, isCollapsed);\n            const maxColumn = this._textModel.getLineMaxColumn(startLineNumber);\n            const decorationRange = {\n                startLineNumber: startLineNumber,\n                startColumn: Math.max(maxColumn - 1, 1),\n                endLineNumber: startLineNumber,\n                endColumn: maxColumn\n            };\n            newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine) });\n            if (isCollapsed && endLineNumber > lastHiddenLine) {\n                lastHiddenLine = endLineNumber;\n            }\n        };\n        let i = 0;\n        let nextCollapsed = () => {\n            while (i < this._regions.length) {\n                let isCollapsed = this._regions.isCollapsed(i);\n                i++;\n                if (isCollapsed) {\n                    return i - 1;\n                }\n            }\n            return -1;\n        };\n        let k = 0;\n        let collapsedIndex = nextCollapsed();\n        while (collapsedIndex !== -1 && k < newRegions.length) {\n            // get the latest range\n            let decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\n            if (decRange) {\n                let collapsedStartLineNumber = decRange.startLineNumber;\n                if (decRange.startColumn === Math.max(decRange.endColumn - 1, 1) && this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.endColumn) { // test that the decoration is still covering the full line else it got deleted\n                    while (k < newRegions.length) {\n                        let startLineNumber = newRegions.getStartLineNumber(k);\n                        if (collapsedStartLineNumber >= startLineNumber) {\n                            initRange(k, collapsedStartLineNumber === startLineNumber);\n                            k++;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n            collapsedIndex = nextCollapsed();\n        }\n        while (k < newRegions.length) {\n            initRange(k, false);\n            k++;\n        }\n        this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\n        this._regions = newRegions;\n        this._isInitialized = true;\n        this._updateEventEmitter.fire({ model: this });\n    }\n    /**\n     * Collapse state memento, for persistence only\n     */\n    getMemento() {\n        let collapsedRanges = [];\n        for (let i = 0; i < this._regions.length; i++) {\n            if (this._regions.isCollapsed(i)) {\n                let range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n                if (range) {\n                    let startLineNumber = range.startLineNumber;\n                    let endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\n                    collapsedRanges.push({ startLineNumber, endLineNumber });\n                }\n            }\n        }\n        if (collapsedRanges.length > 0) {\n            return collapsedRanges;\n        }\n        return undefined;\n    }\n    /**\n     * Apply persisted state, for persistence only\n     */\n    applyMemento(state) {\n        if (!Array.isArray(state)) {\n            return;\n        }\n        let toToogle = [];\n        for (let range of state) {\n            let region = this.getRegionAtLine(range.startLineNumber);\n            if (region && !region.isCollapsed) {\n                toToogle.push(region);\n            }\n        }\n        this.toggleCollapseState(toToogle);\n    }\n    dispose() {\n        this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\n    }\n    getAllRegionsAtLine(lineNumber, filter) {\n        let result = [];\n        if (this._regions) {\n            let index = this._regions.findRange(lineNumber);\n            let level = 1;\n            while (index >= 0) {\n                let current = this._regions.toRegion(index);\n                if (!filter || filter(current, level)) {\n                    result.push(current);\n                }\n                level++;\n                index = current.parentIndex;\n            }\n        }\n        return result;\n    }\n    getRegionAtLine(lineNumber) {\n        if (this._regions) {\n            let index = this._regions.findRange(lineNumber);\n            if (index >= 0) {\n                return this._regions.toRegion(index);\n            }\n        }\n        return null;\n    }\n    getRegionsInside(region, filter) {\n        let result = [];\n        let index = region ? region.regionIndex + 1 : 0;\n        let endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n        if (filter && filter.length === 2) {\n            const levelStack = [];\n            for (let i = index, len = this._regions.length; i < len; i++) {\n                let current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n                        levelStack.pop();\n                    }\n                    levelStack.push(current);\n                    if (filter(current, levelStack.length)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            for (let i = index, len = this._regions.length; i < len; i++) {\n                let current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    if (!filter || filter(current)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n    let toToggle = [];\n    for (let lineNumber of lineNumbers) {\n        let region = foldingModel.getRegionAtLine(lineNumber);\n        if (region) {\n            const doCollapse = !region.isCollapsed;\n            toToggle.push(region);\n            if (levels > 1) {\n                let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                toToggle.push(...regionsInside);\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {\n    let toToggle = [];\n    if (lineNumbers && lineNumbers.length > 0) {\n        for (let lineNumber of lineNumbers) {\n            let region = foldingModel.getRegionAtLine(lineNumber);\n            if (region) {\n                if (region.isCollapsed !== doCollapse) {\n                    toToggle.push(region);\n                }\n                if (levels > 1) {\n                    let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                    toToggle.push(...regionsInside);\n                }\n            }\n        }\n    }\n    else {\n        let regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n        toToggle.push(...regionsInside);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n    let toToggle = [];\n    for (let lineNumber of lineNumbers) {\n        let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n        toToggle.push(...regions);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n    let toToggle = [];\n    for (let lineNumber of lineNumbers) {\n        let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);\n        if (regions.length > 0) {\n            toToggle.push(regions[0]);\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n*/\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n    let filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n    let toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\nexport function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {\n    let filteredRegions = [];\n    for (let lineNumber of blockedLineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n        if (regions.length > 0) {\n            filteredRegions.push(regions[0]);\n        }\n    }\n    let filter = (region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;\n    let toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n    let editorModel = foldingModel.textModel;\n    let regions = foldingModel.regions;\n    let toToggle = [];\n    for (let i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i)) {\n            let startLineNumber = regions.getStartLineNumber(i);\n            if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n                toToggle.push(regions.toRegion(i));\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n    let regions = foldingModel.regions;\n    let toToggle = [];\n    for (let i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n            toToggle.push(regions.toRegion(i));\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\nexport function getParentFoldLine(lineNumber, foldingModel) {\n    let startLineNumber = null;\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    if (foldingRegion !== null) {\n        startLineNumber = foldingRegion.startLineNumber;\n        // If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n        if (lineNumber === startLineNumber) {\n            let parentFoldingIdx = foldingRegion.parentIndex;\n            if (parentFoldingIdx !== -1) {\n                startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);\n            }\n            else {\n                startLineNumber = null;\n            }\n        }\n    }\n    return startLineNumber;\n}\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\nexport function getPreviousFoldLine(lineNumber, foldingModel) {\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    // If on the folding range start line, go to previous sibling.\n    if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n        // If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n        if (lineNumber !== foldingRegion.startLineNumber) {\n            return foldingRegion.startLineNumber;\n        }\n        else {\n            // Find min line number to stay within parent.\n            let expectedParentIndex = foldingRegion.parentIndex;\n            let minLineNumber = 0;\n            if (expectedParentIndex !== -1) {\n                minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);\n            }\n            // Find fold at same level.\n            while (foldingRegion !== null) {\n                if (foldingRegion.regionIndex > 0) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n                    // Keep at same level.\n                    if (foldingRegion.startLineNumber <= minLineNumber) {\n                        return null;\n                    }\n                    else if (foldingRegion.parentIndex === expectedParentIndex) {\n                        return foldingRegion.startLineNumber;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    }\n    else {\n        // Go to last fold that's before the current line.\n        if (foldingModel.regions.length > 0) {\n            foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);\n            while (foldingRegion !== null) {\n                // Found fold before current line.\n                if (foldingRegion.startLineNumber < lineNumber) {\n                    return foldingRegion.startLineNumber;\n                }\n                if (foldingRegion.regionIndex > 0) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n                }\n                else {\n                    foldingRegion = null;\n                }\n            }\n        }\n    }\n    return null;\n}\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\nexport function getNextFoldLine(lineNumber, foldingModel) {\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    // If on the folding range start line, go to next sibling.\n    if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n        // Find max line number to stay within parent.\n        let expectedParentIndex = foldingRegion.parentIndex;\n        let maxLineNumber = 0;\n        if (expectedParentIndex !== -1) {\n            maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);\n        }\n        else if (foldingModel.regions.length === 0) {\n            return null;\n        }\n        else {\n            maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);\n        }\n        // Find fold at same level.\n        while (foldingRegion !== null) {\n            if (foldingRegion.regionIndex < foldingModel.regions.length) {\n                foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n                // Keep at same level.\n                if (foldingRegion.startLineNumber >= maxLineNumber) {\n                    return null;\n                }\n                else if (foldingRegion.parentIndex === expectedParentIndex) {\n                    return foldingRegion.startLineNumber;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    else {\n        // Go to first fold that's after the current line.\n        if (foldingModel.regions.length > 0) {\n            foldingRegion = foldingModel.regions.toRegion(0);\n            while (foldingRegion !== null) {\n                // Found fold after current line.\n                if (foldingRegion.startLineNumber > lineNumber) {\n                    return foldingRegion.startLineNumber;\n                }\n                if (foldingRegion.regionIndex < foldingModel.regions.length) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n                }\n                else {\n                    foldingRegion = null;\n                }\n            }\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findFirstInSorted } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Range } from '../../../common/core/range.js';\nimport { countEOL } from '../../../common/core/eolCounter.js';\nexport class HiddenRangeModel {\n    constructor(model) {\n        this._updateEventEmitter = new Emitter();\n        this._hasLineChanges = false;\n        this._foldingModel = model;\n        this._foldingModelListener = model.onDidChange(_ => this.updateHiddenRanges());\n        this._hiddenRanges = [];\n        if (model.regions.length) {\n            this.updateHiddenRanges();\n        }\n    }\n    get onDidChange() { return this._updateEventEmitter.event; }\n    get hiddenRanges() { return this._hiddenRanges; }\n    notifyChangeModelContent(e) {\n        if (this._hiddenRanges.length && !this._hasLineChanges) {\n            this._hasLineChanges = e.changes.some(change => {\n                return change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;\n            });\n        }\n    }\n    updateHiddenRanges() {\n        let updateHiddenAreas = false;\n        let newHiddenAreas = [];\n        let i = 0; // index into hidden\n        let k = 0;\n        let lastCollapsedStart = Number.MAX_VALUE;\n        let lastCollapsedEnd = -1;\n        let ranges = this._foldingModel.regions;\n        for (; i < ranges.length; i++) {\n            if (!ranges.isCollapsed(i)) {\n                continue;\n            }\n            let startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden\n            let endLineNumber = ranges.getEndLineNumber(i);\n            if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {\n                // ignore ranges contained in collapsed regions\n                continue;\n            }\n            if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {\n                // reuse the old ranges\n                newHiddenAreas.push(this._hiddenRanges[k]);\n                k++;\n            }\n            else {\n                updateHiddenAreas = true;\n                newHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));\n            }\n            lastCollapsedStart = startLineNumber;\n            lastCollapsedEnd = endLineNumber;\n        }\n        if (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) {\n            this.applyHiddenRanges(newHiddenAreas);\n        }\n    }\n    applyMemento(state) {\n        if (!Array.isArray(state) || state.length === 0) {\n            return false;\n        }\n        let hiddenRanges = [];\n        for (let r of state) {\n            if (!r.startLineNumber || !r.endLineNumber) {\n                return false;\n            }\n            hiddenRanges.push(new Range(r.startLineNumber + 1, 1, r.endLineNumber, 1));\n        }\n        this.applyHiddenRanges(hiddenRanges);\n        return true;\n    }\n    /**\n     * Collapse state memento, for persistence only, only used if folding model is not yet initialized\n     */\n    getMemento() {\n        return this._hiddenRanges.map(r => ({ startLineNumber: r.startLineNumber - 1, endLineNumber: r.endLineNumber }));\n    }\n    applyHiddenRanges(newHiddenAreas) {\n        this._hiddenRanges = newHiddenAreas;\n        this._hasLineChanges = false;\n        this._updateEventEmitter.fire(newHiddenAreas);\n    }\n    hasRanges() {\n        return this._hiddenRanges.length > 0;\n    }\n    isHidden(line) {\n        return findRange(this._hiddenRanges, line) !== null;\n    }\n    adjustSelections(selections) {\n        let hasChanges = false;\n        let editorModel = this._foldingModel.textModel;\n        let lastRange = null;\n        let adjustLine = (line) => {\n            if (!lastRange || !isInside(line, lastRange)) {\n                lastRange = findRange(this._hiddenRanges, line);\n            }\n            if (lastRange) {\n                return lastRange.startLineNumber - 1;\n            }\n            return null;\n        };\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let selection = selections[i];\n            let adjustedStartLine = adjustLine(selection.startLineNumber);\n            if (adjustedStartLine) {\n                selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));\n                hasChanges = true;\n            }\n            let adjustedEndLine = adjustLine(selection.endLineNumber);\n            if (adjustedEndLine) {\n                selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));\n                hasChanges = true;\n            }\n            selections[i] = selection;\n        }\n        return hasChanges;\n    }\n    dispose() {\n        if (this.hiddenRanges.length > 0) {\n            this._hiddenRanges = [];\n            this._updateEventEmitter.fire(this._hiddenRanges);\n        }\n        if (this._foldingModelListener) {\n            this._foldingModelListener.dispose();\n            this._foldingModelListener = null;\n        }\n    }\n}\nfunction isInside(line, range) {\n    return line >= range.startLineNumber && line <= range.endLineNumber;\n}\nfunction findRange(ranges, line) {\n    let i = findFirstInSorted(ranges, r => line < r.startLineNumber) - 1;\n    if (i >= 0 && ranges[i].endLineNumber >= line) {\n        return ranges[i];\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { computeIndentLevel } from '../../../common/model/utils.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5000;\nexport const ID_INDENT_PROVIDER = 'indent';\nexport class IndentRangeProvider {\n    constructor(editorModel, languageConfigurationService, maxFoldingRegions) {\n        this.editorModel = editorModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.maxFoldingRegions = maxFoldingRegions;\n        this.id = ID_INDENT_PROVIDER;\n    }\n    dispose() { }\n    compute(cancelationToken, notifyTooManyRegions) {\n        let foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;\n        let offSide = foldingRules && !!foldingRules.offSide;\n        let markers = foldingRules && foldingRules.markers;\n        return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.maxFoldingRegions, notifyTooManyRegions));\n    }\n}\n// public only for testing\nexport class RangesCollector {\n    constructor(foldingRangesLimit, _notifyTooManyRegions) {\n        this._notifyTooManyRegions = _notifyTooManyRegions;\n        this._startIndexes = [];\n        this._endIndexes = [];\n        this._indentOccurrences = [];\n        this._length = 0;\n        this._foldingRangesLimit = foldingRangesLimit;\n    }\n    insertFirst(startLineNumber, endLineNumber, indent) {\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n            return;\n        }\n        let index = this._length;\n        this._startIndexes[index] = startLineNumber;\n        this._endIndexes[index] = endLineNumber;\n        this._length++;\n        if (indent < 1000) {\n            this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n        }\n    }\n    toIndentRanges(model) {\n        if (this._length <= this._foldingRangesLimit) {\n            // reverse and create arrays of the exact length\n            let startIndexes = new Uint32Array(this._length);\n            let endIndexes = new Uint32Array(this._length);\n            for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\n                startIndexes[k] = this._startIndexes[i];\n                endIndexes[k] = this._endIndexes[i];\n            }\n            return new FoldingRegions(startIndexes, endIndexes);\n        }\n        else {\n            if (this._notifyTooManyRegions) {\n                this._notifyTooManyRegions(this._foldingRangesLimit);\n            }\n            let entries = 0;\n            let maxIndent = this._indentOccurrences.length;\n            for (let i = 0; i < this._indentOccurrences.length; i++) {\n                let n = this._indentOccurrences[i];\n                if (n) {\n                    if (n + entries > this._foldingRangesLimit) {\n                        maxIndent = i;\n                        break;\n                    }\n                    entries += n;\n                }\n            }\n            const tabSize = model.getOptions().tabSize;\n            // reverse and create arrays of the exact length\n            let startIndexes = new Uint32Array(this._foldingRangesLimit);\n            let endIndexes = new Uint32Array(this._foldingRangesLimit);\n            for (let i = this._length - 1, k = 0; i >= 0; i--) {\n                let startIndex = this._startIndexes[i];\n                let lineContent = model.getLineContent(startIndex);\n                let indent = computeIndentLevel(lineContent, tabSize);\n                if (indent < maxIndent || (indent === maxIndent && entries++ < this._foldingRangesLimit)) {\n                    startIndexes[k] = startIndex;\n                    endIndexes[k] = this._endIndexes[i];\n                    k++;\n                }\n            }\n            return new FoldingRegions(startIndexes, endIndexes);\n        }\n    }\n}\nexport function computeRanges(model, offSide, markers, foldingRangesLimit, notifyTooManyRegions) {\n    const tabSize = model.getOptions().tabSize;\n    foldingRangesLimit = foldingRangesLimit !== null && foldingRangesLimit !== void 0 ? foldingRangesLimit : MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT;\n    let result = new RangesCollector(foldingRangesLimit, notifyTooManyRegions);\n    let pattern = undefined;\n    if (markers) {\n        pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);\n    }\n    let previousRegions = [];\n    let line = model.getLineCount() + 1;\n    previousRegions.push({ indent: -1, endAbove: line, line }); // sentinel, to make sure there's at least one entry\n    for (let line = model.getLineCount(); line > 0; line--) {\n        let lineContent = model.getLineContent(line);\n        let indent = computeIndentLevel(lineContent, tabSize);\n        let previous = previousRegions[previousRegions.length - 1];\n        if (indent === -1) {\n            if (offSide) {\n                // for offSide languages, empty lines are associated to the previous block\n                // note: the next block is already written to the results, so this only\n                // impacts the end position of the block before\n                previous.endAbove = line;\n            }\n            continue; // only whitespace\n        }\n        let m;\n        if (pattern && (m = lineContent.match(pattern))) {\n            // folding pattern match\n            if (m[1]) { // start pattern match\n                // discard all regions until the folding pattern\n                let i = previousRegions.length - 1;\n                while (i > 0 && previousRegions[i].indent !== -2) {\n                    i--;\n                }\n                if (i > 0) {\n                    previousRegions.length = i + 1;\n                    previous = previousRegions[i];\n                    // new folding range from pattern, includes the end line\n                    result.insertFirst(line, previous.line, indent);\n                    previous.line = line;\n                    previous.indent = indent;\n                    previous.endAbove = line;\n                    continue;\n                }\n                else {\n                    // no end marker found, treat line as a regular line\n                }\n            }\n            else { // end pattern match\n                previousRegions.push({ indent: -2, endAbove: line, line });\n                continue;\n            }\n        }\n        if (previous.indent > indent) {\n            // discard all regions with larger indent\n            do {\n                previousRegions.pop();\n                previous = previousRegions[previousRegions.length - 1];\n            } while (previous.indent > indent);\n            // new folding range\n            let endLineNumber = previous.endAbove - 1;\n            if (endLineNumber - line >= 1) { // needs at east size 1\n                result.insertFirst(line, endLineNumber, indent);\n            }\n        }\n        if (previous.indent === indent) {\n            previous.endAbove = line;\n        }\n        else { // previous.indent < indent\n            // new region with a bigger indent\n            previousRegions.push({ indent, endAbove: line, line });\n        }\n    }\n    return result.toIndentRanges(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst foldingContext = {};\nexport const ID_SYNTAX_PROVIDER = 'syntax';\nexport class SyntaxRangeProvider {\n    constructor(editorModel, providers, handleFoldingRangesChange, limit) {\n        this.editorModel = editorModel;\n        this.providers = providers;\n        this.limit = limit;\n        this.id = ID_SYNTAX_PROVIDER;\n        for (const provider of providers) {\n            if (typeof provider.onDidChange === 'function') {\n                if (!this.disposables) {\n                    this.disposables = new DisposableStore();\n                }\n                this.disposables.add(provider.onDidChange(handleFoldingRangesChange));\n            }\n        }\n    }\n    compute(cancellationToken, notifyTooManyRegions) {\n        return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {\n            if (ranges) {\n                let res = sanitizeRanges(ranges, this.limit, notifyTooManyRegions);\n                return res;\n            }\n            return null;\n        });\n    }\n    dispose() {\n        var _a;\n        (_a = this.disposables) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n}\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\n    let rangeData = null;\n    let promises = providers.map((provider, i) => {\n        return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {\n            if (cancellationToken.isCancellationRequested) {\n                return;\n            }\n            if (Array.isArray(ranges)) {\n                if (!Array.isArray(rangeData)) {\n                    rangeData = [];\n                }\n                let nLines = model.getLineCount();\n                for (let r of ranges) {\n                    if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n                        rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });\n                    }\n                }\n            }\n        }, onUnexpectedExternalError);\n    });\n    return Promise.all(promises).then(_ => {\n        return rangeData;\n    });\n}\nexport class RangesCollector {\n    constructor(foldingRangesLimit, _notifyTooManyRegions) {\n        this._notifyTooManyRegions = _notifyTooManyRegions;\n        this._startIndexes = [];\n        this._endIndexes = [];\n        this._nestingLevels = [];\n        this._nestingLevelCounts = [];\n        this._types = [];\n        this._length = 0;\n        this._foldingRangesLimit = foldingRangesLimit;\n    }\n    add(startLineNumber, endLineNumber, type, nestingLevel) {\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n            return;\n        }\n        let index = this._length;\n        this._startIndexes[index] = startLineNumber;\n        this._endIndexes[index] = endLineNumber;\n        this._nestingLevels[index] = nestingLevel;\n        this._types[index] = type;\n        this._length++;\n        if (nestingLevel < 30) {\n            this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n        }\n    }\n    toIndentRanges() {\n        if (this._length <= this._foldingRangesLimit) {\n            let startIndexes = new Uint32Array(this._length);\n            let endIndexes = new Uint32Array(this._length);\n            for (let i = 0; i < this._length; i++) {\n                startIndexes[i] = this._startIndexes[i];\n                endIndexes[i] = this._endIndexes[i];\n            }\n            return new FoldingRegions(startIndexes, endIndexes, this._types);\n        }\n        else {\n            if (this._notifyTooManyRegions) {\n                this._notifyTooManyRegions(this._foldingRangesLimit);\n            }\n            let entries = 0;\n            let maxLevel = this._nestingLevelCounts.length;\n            for (let i = 0; i < this._nestingLevelCounts.length; i++) {\n                let n = this._nestingLevelCounts[i];\n                if (n) {\n                    if (n + entries > this._foldingRangesLimit) {\n                        maxLevel = i;\n                        break;\n                    }\n                    entries += n;\n                }\n            }\n            let startIndexes = new Uint32Array(this._foldingRangesLimit);\n            let endIndexes = new Uint32Array(this._foldingRangesLimit);\n            let types = [];\n            for (let i = 0, k = 0; i < this._length; i++) {\n                let level = this._nestingLevels[i];\n                if (level < maxLevel || (level === maxLevel && entries++ < this._foldingRangesLimit)) {\n                    startIndexes[k] = this._startIndexes[i];\n                    endIndexes[k] = this._endIndexes[i];\n                    types[k] = this._types[i];\n                    k++;\n                }\n            }\n            return new FoldingRegions(startIndexes, endIndexes, types);\n        }\n    }\n}\nexport function sanitizeRanges(rangeData, limit, notifyTooManyRegions) {\n    let sorted = rangeData.sort((d1, d2) => {\n        let diff = d1.start - d2.start;\n        if (diff === 0) {\n            diff = d1.rank - d2.rank;\n        }\n        return diff;\n    });\n    let collector = new RangesCollector(limit, notifyTooManyRegions);\n    let top = undefined;\n    let previous = [];\n    for (let entry of sorted) {\n        if (!top) {\n            top = entry;\n            collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        }\n        else {\n            if (entry.start > top.start) {\n                if (entry.end <= top.end) {\n                    previous.push(top);\n                    top = entry;\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                }\n                else {\n                    if (entry.start > top.end) {\n                        do {\n                            top = previous.pop();\n                        } while (top && entry.start > top.end);\n                        if (top) {\n                            previous.push(top);\n                        }\n                        top = entry;\n                    }\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                }\n            }\n        }\n    }\n    return collector.toIndentRanges();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { sanitizeRanges } from './syntaxRangeProvider.js';\nexport const ID_INIT_PROVIDER = 'init';\nexport class InitializingRangeProvider {\n    constructor(editorModel, initialRanges, onTimeout, timeoutTime) {\n        this.editorModel = editorModel;\n        this.id = ID_INIT_PROVIDER;\n        if (initialRanges.length) {\n            let toDecorationRange = (range) => {\n                return {\n                    range: {\n                        startLineNumber: range.startLineNumber,\n                        startColumn: 0,\n                        endLineNumber: range.endLineNumber,\n                        endColumn: editorModel.getLineLength(range.endLineNumber)\n                    },\n                    options: {\n                        description: 'folding-initializing-range-provider',\n                        stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n                    }\n                };\n            };\n            this.decorationIds = editorModel.deltaDecorations([], initialRanges.map(toDecorationRange));\n            this.timeout = setTimeout(onTimeout, timeoutTime);\n        }\n    }\n    dispose() {\n        if (this.decorationIds) {\n            this.editorModel.deltaDecorations(this.decorationIds, []);\n            this.decorationIds = undefined;\n        }\n        if (typeof this.timeout === 'number') {\n            clearTimeout(this.timeout);\n            this.timeout = undefined;\n        }\n    }\n    compute(cancelationToken) {\n        let foldingRangeData = [];\n        if (this.decorationIds) {\n            for (let id of this.decorationIds) {\n                let range = this.editorModel.getDecorationRange(id);\n                if (range) {\n                    foldingRangeData.push({ start: range.startLineNumber, end: range.endLineNumber, rank: 1 });\n                }\n            }\n        }\n        return Promise.resolve(sanitizeRanges(foldingRangeData, Number.MAX_VALUE));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { localize } from '../../../../nls.js';\nimport { registerIcon } from '../../../../platform/theme/common/iconRegistry.js';\nimport { ThemeIcon } from '../../../../platform/theme/common/themeService.js';\nexport const foldingExpandedIcon = registerIcon('folding-expanded', Codicon.chevronDown, localize('foldingExpandedIcon', 'Icon for expanded ranges in the editor glyph margin.'));\nexport const foldingCollapsedIcon = registerIcon('folding-collapsed', Codicon.chevronRight, localize('foldingCollapsedIcon', 'Icon for collapsed ranges in the editor glyph margin.'));\nexport class FoldingDecorationProvider {\n    constructor(editor) {\n        this.editor = editor;\n        this.autoHideFoldingControls = true;\n        this.showFoldingHighlights = true;\n    }\n    getDecorationOption(isCollapsed, isHidden) {\n        if (isHidden) {\n            return FoldingDecorationProvider.HIDDEN_RANGE_DECORATION;\n        }\n        if (isCollapsed) {\n            return this.showFoldingHighlights ? FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION;\n        }\n        else if (this.autoHideFoldingControls) {\n            return FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION;\n        }\n        else {\n            return FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION;\n        }\n    }\n    deltaDecorations(oldDecorations, newDecorations) {\n        return this.editor.deltaDecorations(oldDecorations, newDecorations);\n    }\n    changeDecorations(callback) {\n        return this.editor.changeDecorations(callback);\n    }\n}\nFoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-collapsed-visual-decoration',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    afterContentClassName: 'inline-folded',\n    isWholeLine: true,\n    firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)\n});\nFoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-collapsed-highlighted-visual-decoration',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    afterContentClassName: 'inline-folded',\n    className: 'folded-background',\n    isWholeLine: true,\n    firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)\n});\nFoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-expanded-auto-hide-visual-decoration',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    isWholeLine: true,\n    firstLineDecorationClassName: ThemeIcon.asClassName(foldingExpandedIcon)\n});\nFoldingDecorationProvider.EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-expanded-visual-decoration',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    isWholeLine: true,\n    firstLineDecorationClassName: 'alwaysShowFoldIcons ' + ThemeIcon.asClassName(foldingExpandedIcon)\n});\nFoldingDecorationProvider.HIDDEN_RANGE_DECORATION = ModelDecorationOptions.register({\n    description: 'folding-hidden-range-decoration',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { createCancelablePromise, Delayer, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { KeyChord } from '../../../../base/common/keyCodes.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { escapeRegExpCharacters } from '../../../../base/common/strings.js';\nimport * as types from '../../../../base/common/types.js';\nimport './folding.css';\nimport { StableEditorScrollState } from '../../../browser/stableEditorScroll.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution, registerInstantiatedEditorAction } from '../../../browser/editorExtensions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { FoldingRangeKind, FoldingRangeProviderRegistry } from '../../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { FoldingModel, getNextFoldLine, getParentFoldLine as getParentFoldLine, getPreviousFoldLine, setCollapseStateAtLevel, setCollapseStateForMatchingLines, setCollapseStateForRest, setCollapseStateForType, setCollapseStateLevelsDown, setCollapseStateLevelsUp, setCollapseStateUp, toggleCollapseState } from './foldingModel.js';\nimport { HiddenRangeModel } from './hiddenRangeModel.js';\nimport { IndentRangeProvider } from './indentRangeProvider.js';\nimport { ID_INIT_PROVIDER, InitializingRangeProvider } from './intializingRangeProvider.js';\nimport * as nls from '../../../../nls.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { editorSelectionBackground, iconForeground, registerColor, transparent } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant, ThemeIcon } from '../../../../platform/theme/common/themeService.js';\nimport { foldingCollapsedIcon, FoldingDecorationProvider, foldingExpandedIcon } from './foldingDecorations.js';\nimport { ID_SYNTAX_PROVIDER, SyntaxRangeProvider } from './syntaxRangeProvider.js';\nimport { INotificationService } from '../../../../platform/notification/common/notification.js';\nimport Severity from '../../../../base/common/severity.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nconst CONTEXT_FOLDING_ENABLED = new RawContextKey('foldingEnabled', false);\nlet FoldingController = class FoldingController extends Disposable {\n    constructor(editor, contextKeyService, languageConfigurationService, notificationService, languageFeatureDebounceService) {\n        super();\n        this.contextKeyService = contextKeyService;\n        this.languageConfigurationService = languageConfigurationService;\n        this._tooManyRegionsNotified = false;\n        this.localToDispose = this._register(new DisposableStore());\n        this.editor = editor;\n        const options = this.editor.getOptions();\n        this._isEnabled = options.get(37 /* folding */);\n        this._useFoldingProviders = options.get(38 /* foldingStrategy */) !== 'indentation';\n        this._unfoldOnClickAfterEndOfLine = options.get(42 /* unfoldOnClickAfterEndOfLine */);\n        this._restoringViewState = false;\n        this._currentModelHasFoldedImports = false;\n        this._foldingImportsByDefault = options.get(40 /* foldingImportsByDefault */);\n        this._maxFoldingRegions = options.get(41 /* foldingMaximumRegions */);\n        this.updateDebounceInfo = languageFeatureDebounceService.for(FoldingRangeProviderRegistry, 'Folding', { min: 200 });\n        this.foldingModel = null;\n        this.hiddenRangeModel = null;\n        this.rangeProvider = null;\n        this.foldingRegionPromise = null;\n        this.foldingStateMemento = null;\n        this.foldingModelPromise = null;\n        this.updateScheduler = null;\n        this.cursorChangedScheduler = null;\n        this.mouseDownInfo = null;\n        this.foldingDecorationProvider = new FoldingDecorationProvider(editor);\n        this.foldingDecorationProvider.autoHideFoldingControls = options.get(99 /* showFoldingControls */) === 'mouseover';\n        this.foldingDecorationProvider.showFoldingHighlights = options.get(39 /* foldingHighlight */);\n        this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);\n        this.foldingEnabled.set(this._isEnabled);\n        this._notifyTooManyRegions = (maxFoldingRegions) => {\n            // Message will display once per time vscode runs. Once per file would be tricky.\n            if (!this._tooManyRegionsNotified) {\n                notificationService.notify({\n                    severity: Severity.Warning,\n                    sticky: true,\n                    message: nls.localize('maximum fold ranges', \"The number of foldable regions is limited to a maximum of {0}. Increase configuration option ['Folding Maximum Regions'](command:workbench.action.openSettings?[\\\"editor.foldingMaximumRegions\\\"]) to enable more.\", maxFoldingRegions)\n                });\n                this._tooManyRegionsNotified = true;\n            }\n        };\n        this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));\n        this._register(this.editor.onDidChangeConfiguration((e) => {\n            if (e.hasChanged(37 /* folding */)) {\n                this._isEnabled = this.editor.getOptions().get(37 /* folding */);\n                this.foldingEnabled.set(this._isEnabled);\n                this.onModelChanged();\n            }\n            if (e.hasChanged(41 /* foldingMaximumRegions */)) {\n                this._maxFoldingRegions = this.editor.getOptions().get(41 /* foldingMaximumRegions */);\n                this._tooManyRegionsNotified = false;\n                this.onModelChanged();\n            }\n            if (e.hasChanged(99 /* showFoldingControls */) || e.hasChanged(39 /* foldingHighlight */)) {\n                const options = this.editor.getOptions();\n                this.foldingDecorationProvider.autoHideFoldingControls = options.get(99 /* showFoldingControls */) === 'mouseover';\n                this.foldingDecorationProvider.showFoldingHighlights = options.get(39 /* foldingHighlight */);\n                this.triggerFoldingModelChanged();\n            }\n            if (e.hasChanged(38 /* foldingStrategy */)) {\n                this._useFoldingProviders = this.editor.getOptions().get(38 /* foldingStrategy */) !== 'indentation';\n                this.onFoldingStrategyChanged();\n            }\n            if (e.hasChanged(42 /* unfoldOnClickAfterEndOfLine */)) {\n                this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(42 /* unfoldOnClickAfterEndOfLine */);\n            }\n            if (e.hasChanged(40 /* foldingImportsByDefault */)) {\n                this._foldingImportsByDefault = this.editor.getOptions().get(40 /* foldingImportsByDefault */);\n            }\n        }));\n        this.onModelChanged();\n    }\n    static get(editor) {\n        return editor.getContribution(FoldingController.ID);\n    }\n    /**\n     * Store view state.\n     */\n    saveViewState() {\n        let model = this.editor.getModel();\n        if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {\n            return {};\n        }\n        if (this.foldingModel) { // disposed ?\n            let collapsedRegions = this.foldingModel.isInitialized ? this.foldingModel.getMemento() : this.hiddenRangeModel.getMemento();\n            let provider = this.rangeProvider ? this.rangeProvider.id : undefined;\n            return { collapsedRegions, lineCount: model.getLineCount(), provider, foldedImports: this._currentModelHasFoldedImports };\n        }\n        return undefined;\n    }\n    /**\n     * Restore view state.\n     */\n    restoreViewState(state) {\n        let model = this.editor.getModel();\n        if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {\n            return;\n        }\n        if (!state || state.lineCount !== model.getLineCount()) {\n            return;\n        }\n        this._currentModelHasFoldedImports = !!state.foldedImports;\n        if (!state.collapsedRegions) {\n            return;\n        }\n        if (state.provider === ID_SYNTAX_PROVIDER || state.provider === ID_INIT_PROVIDER) {\n            this.foldingStateMemento = state;\n        }\n        const collapsedRegions = state.collapsedRegions;\n        // set the hidden ranges right away, before waiting for the folding model.\n        if (this.hiddenRangeModel.applyMemento(collapsedRegions)) {\n            const foldingModel = this.getFoldingModel();\n            if (foldingModel) {\n                foldingModel.then(foldingModel => {\n                    if (foldingModel) {\n                        this._restoringViewState = true;\n                        try {\n                            foldingModel.applyMemento(collapsedRegions);\n                        }\n                        finally {\n                            this._restoringViewState = false;\n                        }\n                    }\n                }).then(undefined, onUnexpectedError);\n            }\n        }\n    }\n    onModelChanged() {\n        this.localToDispose.clear();\n        let model = this.editor.getModel();\n        if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {\n            // huge files get no view model, so they cannot support hidden areas\n            return;\n        }\n        this._currentModelHasFoldedImports = false;\n        this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);\n        this.localToDispose.add(this.foldingModel);\n        this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);\n        this.localToDispose.add(this.hiddenRangeModel);\n        this.localToDispose.add(this.hiddenRangeModel.onDidChange(hr => this.onHiddenRangesChanges(hr)));\n        this.updateScheduler = new Delayer(this.updateDebounceInfo.get(model));\n        this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);\n        this.localToDispose.add(this.cursorChangedScheduler);\n        this.localToDispose.add(FoldingRangeProviderRegistry.onDidChange(() => this.onFoldingStrategyChanged()));\n        this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged())); // covers model language changes as well\n        this.localToDispose.add(this.editor.onDidChangeModelContent(e => this.onDidChangeModelContent(e)));\n        this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));\n        this.localToDispose.add(this.editor.onMouseDown(e => this.onEditorMouseDown(e)));\n        this.localToDispose.add(this.editor.onMouseUp(e => this.onEditorMouseUp(e)));\n        this.localToDispose.add({\n            dispose: () => {\n                if (this.foldingRegionPromise) {\n                    this.foldingRegionPromise.cancel();\n                    this.foldingRegionPromise = null;\n                }\n                if (this.updateScheduler) {\n                    this.updateScheduler.cancel();\n                }\n                this.updateScheduler = null;\n                this.foldingModel = null;\n                this.foldingModelPromise = null;\n                this.hiddenRangeModel = null;\n                this.cursorChangedScheduler = null;\n                this.foldingStateMemento = null;\n                if (this.rangeProvider) {\n                    this.rangeProvider.dispose();\n                }\n                this.rangeProvider = null;\n            }\n        });\n        this.triggerFoldingModelChanged();\n    }\n    onFoldingStrategyChanged() {\n        if (this.rangeProvider) {\n            this.rangeProvider.dispose();\n        }\n        this.rangeProvider = null;\n        this.triggerFoldingModelChanged();\n    }\n    getRangeProvider(editorModel) {\n        if (this.rangeProvider) {\n            return this.rangeProvider;\n        }\n        this.rangeProvider = new IndentRangeProvider(editorModel, this.languageConfigurationService, this._maxFoldingRegions); // fallback\n        if (this._useFoldingProviders && this.foldingModel) {\n            let foldingProviders = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel);\n            if (foldingProviders.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {\n                const rangeProvider = this.rangeProvider = new InitializingRangeProvider(editorModel, this.foldingStateMemento.collapsedRegions, () => {\n                    // if after 30 the InitializingRangeProvider is still not replaced, force a refresh\n                    this.foldingStateMemento = null;\n                    this.onFoldingStrategyChanged();\n                }, 30000);\n                return rangeProvider; // keep memento in case there are still no foldingProviders on the next request.\n            }\n            else if (foldingProviders.length > 0) {\n                this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, () => this.triggerFoldingModelChanged(), this._maxFoldingRegions);\n            }\n        }\n        this.foldingStateMemento = null;\n        return this.rangeProvider;\n    }\n    getFoldingModel() {\n        return this.foldingModelPromise;\n    }\n    onDidChangeModelContent(e) {\n        var _a;\n        (_a = this.hiddenRangeModel) === null || _a === void 0 ? void 0 : _a.notifyChangeModelContent(e);\n        this.triggerFoldingModelChanged();\n    }\n    triggerFoldingModelChanged() {\n        if (this.updateScheduler) {\n            if (this.foldingRegionPromise) {\n                this.foldingRegionPromise.cancel();\n                this.foldingRegionPromise = null;\n            }\n            this.foldingModelPromise = this.updateScheduler.trigger(() => {\n                const foldingModel = this.foldingModel;\n                if (!foldingModel) { // null if editor has been disposed, or folding turned off\n                    return null;\n                }\n                const sw = new StopWatch(true);\n                const provider = this.getRangeProvider(foldingModel.textModel);\n                let foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise(token => provider.compute(token, this._notifyTooManyRegions));\n                return foldingRegionPromise.then(foldingRanges => {\n                    if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) { // new request or cancelled in the meantime?\n                        let scrollState;\n                        if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {\n                            const hasChanges = foldingRanges.setCollapsedAllOfType(FoldingRangeKind.Imports.value, true);\n                            if (hasChanges) {\n                                scrollState = StableEditorScrollState.capture(this.editor);\n                                this._currentModelHasFoldedImports = hasChanges;\n                            }\n                        }\n                        // some cursors might have moved into hidden regions, make sure they are in expanded regions\n                        let selections = this.editor.getSelections();\n                        let selectionLineNumbers = selections ? selections.map(s => s.startLineNumber) : [];\n                        foldingModel.update(foldingRanges, selectionLineNumbers);\n                        if (scrollState) {\n                            scrollState.restore(this.editor);\n                        }\n                        // update debounce info\n                        const newValue = this.updateDebounceInfo.update(foldingModel.textModel, sw.elapsed());\n                        if (this.updateScheduler) {\n                            this.updateScheduler.defaultDelay = newValue;\n                        }\n                    }\n                    return foldingModel;\n                });\n            }).then(undefined, (err) => {\n                onUnexpectedError(err);\n                return null;\n            });\n        }\n    }\n    onHiddenRangesChanges(hiddenRanges) {\n        if (this.hiddenRangeModel && hiddenRanges.length && !this._restoringViewState) {\n            let selections = this.editor.getSelections();\n            if (selections) {\n                if (this.hiddenRangeModel.adjustSelections(selections)) {\n                    this.editor.setSelections(selections);\n                }\n            }\n        }\n        this.editor.setHiddenAreas(hiddenRanges);\n    }\n    onCursorPositionChanged() {\n        if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {\n            this.cursorChangedScheduler.schedule();\n        }\n    }\n    revealCursor() {\n        const foldingModel = this.getFoldingModel();\n        if (!foldingModel) {\n            return;\n        }\n        foldingModel.then(foldingModel => {\n            if (foldingModel) {\n                let selections = this.editor.getSelections();\n                if (selections && selections.length > 0) {\n                    let toToggle = [];\n                    for (let selection of selections) {\n                        let lineNumber = selection.selectionStartLineNumber;\n                        if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {\n                            toToggle.push(...foldingModel.getAllRegionsAtLine(lineNumber, r => r.isCollapsed && lineNumber > r.startLineNumber));\n                        }\n                    }\n                    if (toToggle.length) {\n                        foldingModel.toggleCollapseState(toToggle);\n                        this.reveal(selections[0].getPosition());\n                    }\n                }\n            }\n        }).then(undefined, onUnexpectedError);\n    }\n    onEditorMouseDown(e) {\n        this.mouseDownInfo = null;\n        if (!this.hiddenRangeModel || !e.target || !e.target.range) {\n            return;\n        }\n        if (!e.event.leftButton && !e.event.middleButton) {\n            return;\n        }\n        const range = e.target.range;\n        let iconClicked = false;\n        switch (e.target.type) {\n            case 4 /* GUTTER_LINE_DECORATIONS */: {\n                const data = e.target.detail;\n                const offsetLeftInGutter = e.target.element.offsetLeft;\n                const gutterOffsetX = data.offsetX - offsetLeftInGutter;\n                // const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;\n                // TODO@joao TODO@alex TODO@martin this is such that we don't collide with dirty diff\n                if (gutterOffsetX < 5) { // the whitespace between the border and the real folding icon border is 5px\n                    return;\n                }\n                iconClicked = true;\n                break;\n            }\n            case 7 /* CONTENT_EMPTY */: {\n                if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {\n                    const data = e.target.detail;\n                    if (!data.isAfterLines) {\n                        break;\n                    }\n                }\n                return;\n            }\n            case 6 /* CONTENT_TEXT */: {\n                if (this.hiddenRangeModel.hasRanges()) {\n                    let model = this.editor.getModel();\n                    if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {\n                        break;\n                    }\n                }\n                return;\n            }\n            default:\n                return;\n        }\n        this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked };\n    }\n    onEditorMouseUp(e) {\n        const foldingModel = this.getFoldingModel();\n        if (!foldingModel || !this.mouseDownInfo || !e.target) {\n            return;\n        }\n        let lineNumber = this.mouseDownInfo.lineNumber;\n        let iconClicked = this.mouseDownInfo.iconClicked;\n        let range = e.target.range;\n        if (!range || range.startLineNumber !== lineNumber) {\n            return;\n        }\n        if (iconClicked) {\n            if (e.target.type !== 4 /* GUTTER_LINE_DECORATIONS */) {\n                return;\n            }\n        }\n        else {\n            let model = this.editor.getModel();\n            if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {\n                return;\n            }\n        }\n        foldingModel.then(foldingModel => {\n            if (foldingModel) {\n                let region = foldingModel.getRegionAtLine(lineNumber);\n                if (region && region.startLineNumber === lineNumber) {\n                    let isCollapsed = region.isCollapsed;\n                    if (iconClicked || isCollapsed) {\n                        let surrounding = e.event.altKey;\n                        let toToggle = [];\n                        if (surrounding) {\n                            let filter = (otherRegion) => !otherRegion.containedBy(region) && !region.containedBy(otherRegion);\n                            let toMaybeToggle = foldingModel.getRegionsInside(null, filter);\n                            for (const r of toMaybeToggle) {\n                                if (r.isCollapsed) {\n                                    toToggle.push(r);\n                                }\n                            }\n                            // if any surrounding regions are folded, unfold those. Otherwise, fold all surrounding\n                            if (toToggle.length === 0) {\n                                toToggle = toMaybeToggle;\n                            }\n                        }\n                        else {\n                            let recursive = e.event.middleButton || e.event.shiftKey;\n                            if (recursive) {\n                                for (const r of foldingModel.getRegionsInside(region)) {\n                                    if (r.isCollapsed === isCollapsed) {\n                                        toToggle.push(r);\n                                    }\n                                }\n                            }\n                            // when recursive, first only collapse all children. If all are already folded or there are no children, also fold parent.\n                            if (isCollapsed || !recursive || toToggle.length === 0) {\n                                toToggle.push(region);\n                            }\n                        }\n                        foldingModel.toggleCollapseState(toToggle);\n                        this.reveal({ lineNumber, column: 1 });\n                    }\n                }\n            }\n        }).then(undefined, onUnexpectedError);\n    }\n    reveal(position) {\n        this.editor.revealPositionInCenterIfOutsideViewport(position, 0 /* Smooth */);\n    }\n};\nFoldingController.ID = 'editor.contrib.folding';\nFoldingController = __decorate([\n    __param(1, IContextKeyService),\n    __param(2, ILanguageConfigurationService),\n    __param(3, INotificationService),\n    __param(4, ILanguageFeatureDebounceService)\n], FoldingController);\nexport { FoldingController };\nclass FoldingAction extends EditorAction {\n    runEditorCommand(accessor, editor, args) {\n        const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n        const foldingController = FoldingController.get(editor);\n        if (!foldingController) {\n            return;\n        }\n        const foldingModelPromise = foldingController.getFoldingModel();\n        if (foldingModelPromise) {\n            this.reportTelemetry(accessor, editor);\n            return foldingModelPromise.then(foldingModel => {\n                if (foldingModel) {\n                    this.invoke(foldingController, foldingModel, editor, args, languageConfigurationService);\n                    const selection = editor.getSelection();\n                    if (selection) {\n                        foldingController.reveal(selection.getStartPosition());\n                    }\n                }\n            });\n        }\n    }\n    getSelectedLines(editor) {\n        let selections = editor.getSelections();\n        return selections ? selections.map(s => s.startLineNumber) : [];\n    }\n    getLineNumbers(args, editor) {\n        if (args && args.selectionLines) {\n            return args.selectionLines.map(l => l + 1); // to 0-bases line numbers\n        }\n        return this.getSelectedLines(editor);\n    }\n    run(_accessor, _editor) {\n    }\n}\nfunction foldingArgumentsConstraint(args) {\n    if (!types.isUndefined(args)) {\n        if (!types.isObject(args)) {\n            return false;\n        }\n        const foldingArgs = args;\n        if (!types.isUndefined(foldingArgs.levels) && !types.isNumber(foldingArgs.levels)) {\n            return false;\n        }\n        if (!types.isUndefined(foldingArgs.direction) && !types.isString(foldingArgs.direction)) {\n            return false;\n        }\n        if (!types.isUndefined(foldingArgs.selectionLines) && (!types.isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(types.isNumber))) {\n            return false;\n        }\n    }\n    return true;\n}\nclass UnfoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfold',\n            label: nls.localize('unfoldAction.label', \"Unfold\"),\n            alias: 'Unfold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 89 /* BracketRight */,\n                mac: {\n                    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 89 /* BracketRight */\n                },\n                weight: 100 /* EditorContrib */\n            },\n            description: {\n                description: 'Unfold the content in the editor',\n                args: [\n                    {\n                        name: 'Unfold editor argument',\n                        description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t* 'levels': Number of levels to unfold. If not set, defaults to 1.\n\t\t\t\t\t\t* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.\n\t\t\t\t\t\t* 'selectionLines': The start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t`,\n                        constraint: foldingArgumentsConstraint,\n                        schema: {\n                            'type': 'object',\n                            'properties': {\n                                'levels': {\n                                    'type': 'number',\n                                    'default': 1\n                                },\n                                'direction': {\n                                    'type': 'string',\n                                    'enum': ['up', 'down'],\n                                    'default': 'down'\n                                },\n                                'selectionLines': {\n                                    'type': 'array',\n                                    'items': {\n                                        'type': 'number'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args) {\n        let levels = args && args.levels || 1;\n        let lineNumbers = this.getLineNumbers(args, editor);\n        if (args && args.direction === 'up') {\n            setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);\n        }\n        else {\n            setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);\n        }\n    }\n}\nclass UnFoldRecursivelyAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldRecursively',\n            label: nls.localize('unFoldRecursivelyAction.label', \"Unfold Recursively\"),\n            alias: 'Unfold Recursively',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | 89 /* BracketRight */),\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, _args) {\n        setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor));\n    }\n}\nclass FoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.fold',\n            label: nls.localize('foldAction.label', \"Fold\"),\n            alias: 'Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 87 /* BracketLeft */,\n                mac: {\n                    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 87 /* BracketLeft */\n                },\n                weight: 100 /* EditorContrib */\n            },\n            description: {\n                description: 'Fold the content in the editor',\n                args: [\n                    {\n                        name: 'Fold editor argument',\n                        description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'levels': Number of levels to fold.\n\t\t\t\t\t\t\t* 'direction': If 'up', folds given number of levels up otherwise folds down.\n\t\t\t\t\t\t\t* 'selectionLines': The start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t\tIf no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.\n\t\t\t\t\t\t`,\n                        constraint: foldingArgumentsConstraint,\n                        schema: {\n                            'type': 'object',\n                            'properties': {\n                                'levels': {\n                                    'type': 'number',\n                                },\n                                'direction': {\n                                    'type': 'string',\n                                    'enum': ['up', 'down'],\n                                },\n                                'selectionLines': {\n                                    'type': 'array',\n                                    'items': {\n                                        'type': 'number'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args) {\n        let lineNumbers = this.getLineNumbers(args, editor);\n        const levels = args && args.levels;\n        const direction = args && args.direction;\n        if (typeof levels !== 'number' && typeof direction !== 'string') {\n            // fold the region at the location or if already collapsed, the first uncollapsed parent instead.\n            setCollapseStateUp(foldingModel, true, lineNumbers);\n        }\n        else {\n            if (direction === 'up') {\n                setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);\n            }\n            else {\n                setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);\n            }\n        }\n    }\n}\nclass ToggleFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.toggleFold',\n            label: nls.localize('toggleFoldAction.label', \"Toggle Fold\"),\n            alias: 'Toggle Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | 42 /* KeyL */),\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        let selectedLines = this.getSelectedLines(editor);\n        toggleCollapseState(foldingModel, 1, selectedLines);\n    }\n}\nclass FoldRecursivelyAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldRecursively',\n            label: nls.localize('foldRecursivelyAction.label', \"Fold Recursively\"),\n            alias: 'Fold Recursively',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | 87 /* BracketLeft */),\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        let selectedLines = this.getSelectedLines(editor);\n        setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);\n    }\n}\nclass FoldAllBlockCommentsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllBlockComments',\n            label: nls.localize('foldAllBlockComments.label', \"Fold All Block Comments\"),\n            alias: 'Fold All Block Comments',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | 85 /* Slash */),\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const comments = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).comments;\n            if (comments && comments.blockCommentStartToken) {\n                let regExp = new RegExp('^\\\\s*' + escapeRegExpCharacters(comments.blockCommentStartToken));\n                setCollapseStateForMatchingLines(foldingModel, regExp, true);\n            }\n        }\n    }\n}\nclass FoldAllRegionsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllMarkerRegions',\n            label: nls.localize('foldAllMarkerRegions.label', \"Fold All Regions\"),\n            alias: 'Fold All Regions',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | 29 /* Digit8 */),\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;\n            if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n                let regExp = new RegExp(foldingRules.markers.start);\n                setCollapseStateForMatchingLines(foldingModel, regExp, true);\n            }\n        }\n    }\n}\nclass UnfoldAllRegionsAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAllMarkerRegions',\n            label: nls.localize('unfoldAllMarkerRegions.label', \"Unfold All Regions\"),\n            alias: 'Unfold All Regions',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | 30 /* Digit9 */),\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor, args, languageConfigurationService) {\n        if (foldingModel.regions.hasTypes()) {\n            setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);\n        }\n        else {\n            const editorModel = editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;\n            if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n                let regExp = new RegExp(foldingRules.markers.start);\n                setCollapseStateForMatchingLines(foldingModel, regExp, false);\n            }\n        }\n    }\n}\nclass FoldAllRegionsExceptAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAllExcept',\n            label: nls.localize('foldAllExcept.label', \"Fold All Regions Except Selected\"),\n            alias: 'Fold All Regions Except Selected',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | 83 /* Minus */),\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        let selectedLines = this.getSelectedLines(editor);\n        setCollapseStateForRest(foldingModel, true, selectedLines);\n    }\n}\nclass UnfoldAllRegionsExceptAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAllExcept',\n            label: nls.localize('unfoldAllExcept.label', \"Unfold All Regions Except Selected\"),\n            alias: 'Unfold All Regions Except Selected',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | 81 /* Equal */),\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        let selectedLines = this.getSelectedLines(editor);\n        setCollapseStateForRest(foldingModel, false, selectedLines);\n    }\n}\nclass FoldAllAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.foldAll',\n            label: nls.localize('foldAllAction.label', \"Fold All\"),\n            alias: 'Fold All',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | 21 /* Digit0 */),\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, _editor) {\n        setCollapseStateLevelsDown(foldingModel, true);\n    }\n}\nclass UnfoldAllAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.unfoldAll',\n            label: nls.localize('unfoldAllAction.label', \"Unfold All\"),\n            alias: 'Unfold All',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | 40 /* KeyJ */),\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, _editor) {\n        setCollapseStateLevelsDown(foldingModel, false);\n    }\n}\nclass FoldLevelAction extends FoldingAction {\n    getFoldingLevel() {\n        return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor));\n    }\n}\nFoldLevelAction.ID_PREFIX = 'editor.foldLevel';\nFoldLevelAction.ID = (level) => FoldLevelAction.ID_PREFIX + level;\n/** Action to go to the parent fold of current line */\nclass GotoParentFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoParentFold',\n            label: nls.localize('gotoParentFold.label', \"Go to Parent Fold\"),\n            alias: 'Go to Parent Fold',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        let selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            let startLineNumber = getParentFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\n/** Action to go to the previous fold of current line */\nclass GotoPreviousFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoPreviousFold',\n            label: nls.localize('gotoPreviousFold.label', \"Go to Previous Folding Range\"),\n            alias: 'Go to Previous Folding Range',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        let selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            let startLineNumber = getPreviousFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\n/** Action to go to the next fold of current line */\nclass GotoNextFoldAction extends FoldingAction {\n    constructor() {\n        super({\n            id: 'editor.gotoNextFold',\n            label: nls.localize('gotoNextFold.label', \"Go to Next Folding Range\"),\n            alias: 'Go to Next Folding Range',\n            precondition: CONTEXT_FOLDING_ENABLED,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    invoke(_foldingController, foldingModel, editor) {\n        let selectedLines = this.getSelectedLines(editor);\n        if (selectedLines.length > 0) {\n            let startLineNumber = getNextFoldLine(selectedLines[0], foldingModel);\n            if (startLineNumber !== null) {\n                editor.setSelection({\n                    startLineNumber: startLineNumber,\n                    startColumn: 1,\n                    endLineNumber: startLineNumber,\n                    endColumn: 1\n                });\n            }\n        }\n    }\n}\nregisterEditorContribution(FoldingController.ID, FoldingController);\nregisterEditorAction(UnfoldAction);\nregisterEditorAction(UnFoldRecursivelyAction);\nregisterEditorAction(FoldAction);\nregisterEditorAction(FoldRecursivelyAction);\nregisterEditorAction(FoldAllAction);\nregisterEditorAction(UnfoldAllAction);\nregisterEditorAction(FoldAllBlockCommentsAction);\nregisterEditorAction(FoldAllRegionsAction);\nregisterEditorAction(UnfoldAllRegionsAction);\nregisterEditorAction(FoldAllRegionsExceptAction);\nregisterEditorAction(UnfoldAllRegionsExceptAction);\nregisterEditorAction(ToggleFoldAction);\nregisterEditorAction(GotoParentFoldAction);\nregisterEditorAction(GotoPreviousFoldAction);\nregisterEditorAction(GotoNextFoldAction);\nfor (let i = 1; i <= 7; i++) {\n    registerInstantiatedEditorAction(new FoldLevelAction({\n        id: FoldLevelAction.ID(i),\n        label: nls.localize('foldLevelAction.label', \"Fold Level {0}\", i),\n        alias: `Fold Level ${i}`,\n        precondition: CONTEXT_FOLDING_ENABLED,\n        kbOpts: {\n            kbExpr: EditorContextKeys.editorTextFocus,\n            primary: KeyChord(2048 /* CtrlCmd */ | 41 /* KeyK */, 2048 /* CtrlCmd */ | (21 /* Digit0 */ + i)),\n            weight: 100 /* EditorContrib */\n        }\n    }));\n}\nexport const foldBackgroundBackground = registerColor('editor.foldBackground', { light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hc: null }, nls.localize('foldBackgroundBackground', \"Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations.\"), true);\nexport const editorFoldForeground = registerColor('editorGutter.foldingControlForeground', { dark: iconForeground, light: iconForeground, hc: iconForeground }, nls.localize('editorGutter.foldingControlForeground', 'Color of the folding control in the editor gutter.'));\nregisterThemingParticipant((theme, collector) => {\n    const foldBackground = theme.getColor(foldBackgroundBackground);\n    if (foldBackground) {\n        collector.addRule(`.monaco-editor .folded-background { background-color: ${foldBackground}; }`);\n    }\n    const editorFoldColor = theme.getColor(editorFoldForeground);\n    if (editorFoldColor) {\n        collector.addRule(`\n\t\t.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingExpandedIcon)},\n\t\t.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingCollapsedIcon)} {\n\t\t\tcolor: ${editorFoldColor} !important;\n\t\t}\n\t\t`);\n    }\n});\n"],"names":["MAX_LINE_NUMBER","MASK_INDENT","FoldingRegions","startIndexes","endIndexes","types","length","Error","this","_startIndexes","_endIndexes","_collapseStates","Uint32Array","Math","ceil","_types","_parentsComputed","parentIndexes","isInsideLast","startLineNumber","endLineNumber","index","getStartLineNumber","getEndLineNumber","i","len","pop","parentIndex","push","undefined","arrayIndex","bit","newState","value","type","hasChanged","setCollapsed","FoldingRegion","ensureParentIndices","parent","line","low","high","mid","floor","findIndex","getParentIndex","contains","res","isCollapsed","join","ranges","range","lineNumber","FoldingModel","textModel","decorationProvider","_updateEventEmitter","Emitter","onDidChange","event","_textModel","_decorationProvider","_regions","_editorDecorationIds","_isInitialized","toggledRegions","sort","r1","r2","regionIndex","processed","changeDecorations","accessor","k","dirtyRegionEndLine","lastHiddenLine","updateDecorationsUntil","changeDecorationOptions","getDecorationOption","editorDecorationId","newCollapseState","max","fire","model","collapseStateChanged","newRegions","blockedLineNumers","newEditorDecorations","isBlocked","blockedLineNumber","initRange","maxColumn","getLineMaxColumn","decorationRange","startColumn","endColumn","options","nextCollapsed","collapsedIndex","decRange","getDecorationRange","collapsedStartLineNumber","deltaDecorations","collapsedRanges","state","Array","isArray","toToogle","region","getRegionAtLine","toggleCollapseState","filter","result","findRange","level","current","toRegion","Number","MAX_VALUE","levelStack","containedBy","setCollapseStateLevelsDown","foldingModel","doCollapse","levels","lineNumbers","toToggle","regionsInside","getRegionsInside","r","setCollapseStateLevelsUp","regions","getAllRegionsAtLine","setCollapseStateForRest","blockedLineNumbers","filteredRegions","every","filteredRegion","setCollapseStateForMatchingLines","regExp","editorModel","test","getLineContent","setCollapseStateForType","getType","HiddenRangeModel","_hasLineChanges","_foldingModel","_foldingModelListener","_","updateHiddenRanges","_hiddenRanges","e","changes","some","change","countEOL","text","updateHiddenAreas","newHiddenAreas","lastCollapsedStart","lastCollapsedEnd","Range","applyHiddenRanges","hiddenRanges","map","selections","hasChanges","lastRange","adjustLine","isInside","selection","adjustedStartLine","setStartPosition","adjustedEndLine","setEndPosition","dispose","findFirstInSorted","IndentRangeProvider","languageConfigurationService","maxFoldingRegions","id","cancelationToken","notifyTooManyRegions","foldingRules","getLanguageConfiguration","getLanguageId","offSide","markers","Promise","resolve","foldingRangesLimit","tabSize","getOptions","RangesCollector","pattern","RegExp","start","source","end","previousRegions","getLineCount","indent","endAbove","lineContent","computeIndentLevel","previous","m","match","insertFirst","toIndentRanges","computeRanges","_notifyTooManyRegions","_indentOccurrences","_length","_foldingRangesLimit","entries","maxIndent","n","startIndex","foldingContext","ID_SYNTAX_PROVIDER","SyntaxRangeProvider","providers","handleFoldingRangesChange","limit","provider","disposables","DisposableStore","add","cancellationToken","rangeData","promises","provideFoldingRanges","then","isCancellationRequested","nLines","rank","kind","onUnexpectedExternalError","all","collectSyntaxRanges","sanitizeRanges","_a","_nestingLevels","_nestingLevelCounts","nestingLevel","maxLevel","sorted","d1","d2","diff","collector","top","entry","ID_INIT_PROVIDER","InitializingRangeProvider","initialRanges","onTimeout","timeoutTime","decorationIds","getLineLength","description","stickiness","timeout","setTimeout","clearTimeout","foldingRangeData","foldingExpandedIcon","registerIcon","Codicon","localize","foldingCollapsedIcon","FoldingDecorationProvider","editor","autoHideFoldingControls","showFoldingHighlights","isHidden","HIDDEN_RANGE_DECORATION","COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION","COLLAPSED_VISUAL_DECORATION","EXPANDED_AUTO_HIDE_VISUAL_DECORATION","EXPANDED_VISUAL_DECORATION","oldDecorations","newDecorations","callback","ModelDecorationOptions","afterContentClassName","isWholeLine","firstLineDecorationClassName","ThemeIcon","className","__decorate","decorators","target","key","desc","d","c","arguments","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","CONTEXT_FOLDING_ENABLED","RawContextKey","FoldingController","contextKeyService","notificationService","languageFeatureDebounceService","_tooManyRegionsNotified","localToDispose","_register","_isEnabled","get","_useFoldingProviders","_unfoldOnClickAfterEndOfLine","_restoringViewState","_currentModelHasFoldedImports","_foldingImportsByDefault","_maxFoldingRegions","updateDebounceInfo","for","FoldingRangeProviderRegistry","min","hiddenRangeModel","rangeProvider","foldingRegionPromise","foldingStateMemento","foldingModelPromise","updateScheduler","cursorChangedScheduler","mouseDownInfo","foldingDecorationProvider","foldingEnabled","bindTo","set","notify","severity","Severity","sticky","message","nls","onDidChangeModel","onModelChanged","onDidChangeConfiguration","triggerFoldingModelChanged","onFoldingStrategyChanged","getModel","isTooLargeForTokenization","collapsedRegions","isInitialized","getMemento","lineCount","foldedImports","applyMemento","getFoldingModel","onUnexpectedError","clear","hr","onHiddenRangesChanges","Delayer","RunOnceScheduler","revealCursor","onDidChangeModelLanguageConfiguration","onDidChangeModelContent","onDidChangeCursorPosition","onCursorPositionChanged","onMouseDown","onEditorMouseDown","onMouseUp","onEditorMouseUp","cancel","foldingProviders","notifyChangeModelContent","trigger","sw","StopWatch","getRangeProvider","createCancelablePromise","token","compute","foldingRanges","scrollState","setCollapsedAllOfType","FoldingRangeKind","StableEditorScrollState","getSelections","selectionLineNumbers","s","update","restore","newValue","elapsed","defaultDelay","err","adjustSelections","setSelections","setHiddenAreas","hasRanges","schedule","selectionStartLineNumber","reveal","getPosition","leftButton","middleButton","iconClicked","data","detail","offsetLeftInGutter","element","offsetLeft","offsetX","isAfterLines","altKey","toMaybeToggle","otherRegion","recursive","shiftKey","column","position","revealPositionInCenterIfOutsideViewport","getContribution","ID","Disposable","IContextKeyService","ILanguageConfigurationService","INotificationService","ILanguageFeatureDebounceService","FoldingAction","args","foldingController","reportTelemetry","invoke","getSelection","getStartPosition","selectionLines","l","getSelectedLines","_accessor","_editor","EditorAction","foldingArgumentsConstraint","foldingArgs","direction","UnfoldAction","label","alias","precondition","kbOpts","kbExpr","EditorContextKeys","primary","mac","weight","name","constraint","schema","_foldingController","getLineNumbers","UnFoldRecursivelyAction","KeyChord","_args","FoldAction","setCollapseStateUp","ToggleFoldAction","FoldRecursivelyAction","selectedLines","FoldAllBlockCommentsAction","hasTypes","comments","blockCommentStartToken","escapeRegExpCharacters","FoldAllRegionsAction","UnfoldAllRegionsAction","FoldAllRegionsExceptAction","UnfoldAllRegionsExceptAction","FoldAllAction","UnfoldAllAction","FoldLevelAction","parseInt","substr","ID_PREFIX","foldLevel","containsLine","setCollapseStateAtLevel","getFoldingLevel","GotoParentFoldAction","foldingRegion","parentFoldingIdx","getParentFoldLine","setSelection","GotoPreviousFoldAction","expectedParentIndex","minLineNumber","getPreviousFoldLine","GotoNextFoldAction","maxLineNumber","getNextFoldLine","registerEditorContribution","registerEditorAction","registerInstantiatedEditorAction","foldBackgroundBackground","registerColor","light","transparent","editorSelectionBackground","dark","hc","editorFoldForeground","iconForeground","registerThemingParticipant","theme","foldBackground","getColor","addRule","editorFoldColor"],"sourceRoot":""}